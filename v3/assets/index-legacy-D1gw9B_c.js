(function() {
    function _superPropGet(t, o, e, r) {
        var p = _get2(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t) {
            return p.apply(e, t);
        } : p;
    }
    function _get2() {
        return _get2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
            var p = _superPropBase(e, t);
            if (p) {
                var n = Object.getOwnPropertyDescriptor(p, t);
                return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
            }
        }, _get2.apply(null, arguments);
    }
    function _superPropBase(t, o) {
        for (;!{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
        return t;
    }
    function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r) {
                return Object.getOwnPropertyDescriptor(e, r).enumerable;
            })), t.push.apply(t, o);
        }
        return t;
    }
    function _objectSpread(e) {
        for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
                _defineProperty(e, r, t[r]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
                Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
            });
        }
        return e;
    }
    function _wrapNativeSuper(t) {
        var r = "function" == typeof Map ? new Map : void 0;
        return _wrapNativeSuper = function _wrapNativeSuper(t) {
            if (null === t || !_isNativeFunction(t)) return t;
            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== r) {
                if (r.has(t)) return r.get(t);
                r.set(t, Wrapper);
            }
            function Wrapper() {
                return _construct(t, arguments, _getPrototypeOf(this).constructor);
            }
            return Wrapper.prototype = Object.create(t.prototype, {
                constructor: {
                    value: Wrapper,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), _setPrototypeOf(Wrapper, t);
        }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
        if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
        var o = [ null ];
        o.push.apply(o, e);
        var p = new (t.bind.apply(t, o));
        return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeFunction(t) {
        try {
            return -1 !== Function.toString.call(t).indexOf("[native code]");
        } catch (n) {
            return "function" == typeof t;
        }
    }
    function _slicedToArray(r, e) {
        return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
            var e, n, i, u, a = [], f = !0, o = !1;
            try {
                if (i = (t = t.call(r)).next, 0 === l) {
                    if (Object(t) !== t) return;
                    f = !1;
                } else for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0) ;
            } catch (r) {
                o = !0, n = r;
            } finally {
                try {
                    if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                } finally {
                    if (o) throw n;
                }
            }
            return a;
        }
    }
    function _arrayWithHoles(r) {
        if (Array.isArray(r)) return r;
    }
    function _regenerator() {
        var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
        function i(r, n, o, i) {
            var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype);
            return _regeneratorDefine2(u, "_invoke", function(r, n, o) {
                var i, c, u, f = 0, p = o || [], y = !1, G = {
                    p: 0,
                    n: 0,
                    v: e,
                    a: d,
                    f: d.bind(e, 4),
                    d: function d(t, r) {
                        return i = t, c = 0, u = e, G.n = r, a;
                    }
                };
                function d(r, n) {
                    for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
                        var o, i = p[t], d = G.p, l = i[2];
                        r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, 
                        G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, 
                        G.n = l, c = 0));
                    }
                    if (o || r > 1) return a;
                    throw y = !0, n;
                }
                return function(o, p, l) {
                    if (f > 1) throw TypeError("Generator is already running");
                    for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y; ) {
                        i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
                        try {
                            if (f = 2, i) {
                                if (c || (o = "next"), t = i[o]) {
                                    if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                                    if (!t.done) return t;
                                    u = t.value, c < 2 && (c = 0);
                                } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), 
                                c = 1);
                                i = e;
                            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
                        } catch (t) {
                            i = e, c = 1, u = t;
                        } finally {
                            f = 1;
                        }
                    }
                    return {
                        value: t,
                        done: y
                    };
                };
            }(r, o, i), !0), u;
        }
        var a = {};
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}
        t = Object.getPrototypeOf;
        var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function() {
            return this;
        }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
        function f(e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, 
            _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), 
            e;
        }
        return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), 
        _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), 
        GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), 
        _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function() {
            return this;
        }), _regeneratorDefine2(u, "toString", function() {
            return "[object Generator]";
        }), (_regenerator = function _regenerator() {
            return {
                w: i,
                m: f
            };
        })();
    }
    function _regeneratorDefine2(e, r, n, t) {
        var i = Object.defineProperty;
        try {
            i({}, "", {});
        } catch (e) {
            i = 0;
        }
        _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) {
            function o(r, n) {
                _regeneratorDefine2(e, r, function(e) {
                    return this._invoke(r, n, e);
                });
            }
            r ? i ? i(e, r, {
                value: n,
                enumerable: !t,
                configurable: !t,
                writable: !t
            }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
        }, _regeneratorDefine2(e, r, n, t);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
        try {
            var i = n[a](c), u = i.value;
        } catch (n) {
            return void e(n);
        }
        i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
        return function() {
            var t = this, e = arguments;
            return new Promise(function(r, o) {
                var a = n.apply(t, e);
                function _next(n) {
                    asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
                }
                function _throw(n) {
                    asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
                }
                _next(void 0);
            });
        };
    }
    function _callSuper(t, o, e) {
        return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
        if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function _isNativeReflectConstruct() {
        try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t) {}
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
            return !!t;
        })();
    }
    function _getPrototypeOf(t) {
        return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t);
        }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: !0,
                configurable: !0
            }
        }), Object.defineProperty(t, "prototype", {
            writable: !1
        }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
        return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
            return t.__proto__ = e, t;
        }, _setPrototypeOf(t, e);
    }
    function _toConsumableArray(r) {
        return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArray(r) {
        if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
        if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
        for (var t = 0; t < r.length; t++) {
            var o = r[t];
            o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
            Object.defineProperty(e, _toPropertyKey(o.key), o);
        }
    }
    function _createClass(e, r, t) {
        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
            writable: !1
        }), e;
    }
    function _defineProperty(e, r, t) {
        return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
        var i = _toPrimitive(t, "string");
        return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
        if ("object" != _typeof(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
            var i = e.call(t, r || "default");
            if ("object" != _typeof(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
    }
    function _typeof(o) {
        "@babel/helpers - typeof";
        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
            return typeof o;
        } : function(o) {
            return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, _typeof(o);
    }
    function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
            if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
                t && (r = t);
                var _n = 0, F = function F() {};
                return {
                    s: F,
                    n: function n() {
                        return _n >= r.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: r[_n++]
                        };
                    },
                    e: function e(r) {
                        throw r;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = !0, u = !1;
        return {
            s: function s() {
                t = t.call(r);
            },
            n: function n() {
                var r = t.next();
                return a = r.done, r;
            },
            e: function e(r) {
                u = !0, o = r;
            },
            f: function f() {
                try {
                    a || null == t.return || t.return();
                } finally {
                    if (u) throw o;
                }
            }
        };
    }
    function _unsupportedIterableToArray(r, a) {
        if (r) {
            if ("string" == typeof r) return _arrayLikeToArray(r, a);
            var t = {}.toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
    }
    function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
    }
    System.register([], function(exports, module) {
        "use strict";
        return {
            execute: function execute() {
                var __vite_style__ = document.createElement("style");
                __vite_style__.textContent = "html,body,*{padding:0;margin:0}html,body{height:100%;overflow:hidden}video{position:absolute;top:0;left:0;z-index:2;outline:none}.center-element{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}\n/*$vite$:1*/";
                document.head.appendChild(__vite_style__);
                exports({
                    $: chainFunctions,
                    F: For,
                    G: assertTruthy,
                    H: combineStyles,
                    I: Index,
                    J: onCleanup,
                    K: Block,
                    L: LazyRow,
                    M: untrack,
                    N: createRoot,
                    O: Dynamic,
                    P: Poster,
                    Q: Button,
                    S: Show,
                    W: TileRow,
                    Y: getImageUrl,
                    Z: convertItemsToTiles,
                    a: createSignal,
                    a0: Switch,
                    a1: Match,
                    a2: LazyColumn,
                    a3: TitleRow,
                    a8: getOwner,
                    aa: Suspense,
                    b: createResource,
                    d: createComputed,
                    e: batch,
                    f: createSelector,
                    g: createEffect,
                    h: hexColor,
                    i: on,
                    j: List,
                    k: createMemo,
                    o: onMount,
                    y: useFocusStack,
                    z: children
                });
                false && function polyfill() {
                    var relList = document.createElement("link").relList;
                    if (relList && relList.supports && relList.supports("modulepreload")) return;
                    var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')), _step;
                    try {
                        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                            var link = _step.value;
                            processPreload(link);
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally {
                        _iterator.f();
                    }
                    new MutationObserver(function(mutations) {
                        var _iterator2 = _createForOfIteratorHelper(mutations), _step2;
                        try {
                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                                var mutation = _step2.value;
                                if (mutation.type !== "childList") continue;
                                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes), _step3;
                                try {
                                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                                        var node = _step3.value;
                                        if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
                                    }
                                } catch (err) {
                                    _iterator3.e(err);
                                } finally {
                                    _iterator3.f();
                                }
                            }
                        } catch (err) {
                            _iterator2.e(err);
                        } finally {
                            _iterator2.f();
                        }
                    }).observe(document, {
                        childList: true,
                        subtree: true
                    });
                    function getFetchOpts(link) {
                        var fetchOpts = {};
                        if (link.integrity) fetchOpts.integrity = link.integrity;
                        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
                        if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include"; else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit"; else fetchOpts.credentials = "same-origin";
                        return fetchOpts;
                    }
                    function processPreload(link) {
                        if (link.ep) return;
                        link.ep = true;
                        var fetchOpts = getFetchOpts(link);
                        fetch(link.href, fetchOpts);
                    }
                }();
                var scriptRel = "modulepreload";
                var assetsURL = function assetsURL(dep) {
                    return "/solid-demo-app/v2/" + dep;
                };
                var seen = {};
                var __vitePreload = function preload(baseModule, deps, importerUrl) {
                    var promise = Promise.resolve();
                    if (false && deps && deps.length > 0) {
                        var allSettled = function allSettled(promises$2) {
                            return Promise.all(promises$2.map(function(p) {
                                return Promise.resolve(p).then(function(value$1) {
                                    return {
                                        status: "fulfilled",
                                        value: value$1
                                    };
                                }, function(reason) {
                                    return {
                                        status: "rejected",
                                        reason: reason
                                    };
                                });
                            }));
                        };
                        document.getElementsByTagName("link");
                        var cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
                        var cspNonce = (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.getAttribute("nonce"));
                        promise = allSettled(deps.map(function(dep) {
                            dep = assetsURL(dep);
                            if (dep in seen) return;
                            seen[dep] = true;
                            var isCss = dep.endsWith(".css");
                            var cssSelector = isCss ? '[rel="stylesheet"]' : "";
                            if (document.querySelector('link[href="'.concat(dep, '"]').concat(cssSelector))) return;
                            var link = document.createElement("link");
                            link.rel = isCss ? "stylesheet" : scriptRel;
                            if (!isCss) link.as = "script";
                            link.crossOrigin = "";
                            link.href = dep;
                            if (cspNonce) link.setAttribute("nonce", cspNonce);
                            document.head.appendChild(link);
                            if (isCss) return new Promise(function(res, rej) {
                                link.addEventListener("load", res);
                                link.addEventListener("error", function() {
                                    return rej(new Error("Unable to preload CSS for ".concat(dep)));
                                });
                            });
                        }));
                    }
                    function handlePreloadError(err$2) {
                        var e$1 = new Event("vite:preloadError", {
                            cancelable: true
                        });
                        e$1.payload = err$2;
                        window.dispatchEvent(e$1);
                        if (!e$1.defaultPrevented) throw err$2;
                    }
                    return promise.then(function(res) {
                        var _iterator4 = _createForOfIteratorHelper(res || []), _step4;
                        try {
                            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                                var item = _step4.value;
                                if (item.status !== "rejected") continue;
                                handlePreloadError(item.reason);
                            }
                        } catch (err) {
                            _iterator4.e(err);
                        } finally {
                            _iterator4.f();
                        }
                        return baseModule().catch(handlePreloadError);
                    });
                };
                function createWebGLContext(canvas) {
                    var forceWebGL2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var contextSpy = arguments.length > 2 ? arguments[2] : undefined;
                    var config = {
                        alpha: true,
                        antialias: false,
                        depth: false,
                        stencil: true,
                        desynchronized: false,
                        powerPreference: "high-performance",
                        premultipliedAlpha: true,
                        preserveDrawingBuffer: false
                    };
                    var gl = canvas.getContext(forceWebGL2 ? "webgl2" : "webgl", config) || canvas.getContext("experimental-webgl", config);
                    if (!gl) {
                        throw new Error("Unable to create WebGL context");
                    }
                    if (contextSpy) {
                        return new Proxy(gl, {
                            get: function get(target, prop) {
                                var value = target[prop];
                                if (typeof value === "function") {
                                    contextSpy.increment(String(prop));
                                    return value.bind(target);
                                }
                                return value;
                            }
                        });
                    }
                    return gl;
                }
                var isProductionEnvironment = true;
                function assertTruthy(condition, message) {
                    return;
                }
                function mergeColorProgress(rgba1, rgba2, p) {
                    var r1 = Math.trunc(rgba1 >>> 24);
                    var g1 = Math.trunc(rgba1 >>> 16 & 255);
                    var b1 = Math.trunc(rgba1 >>> 8 & 255);
                    var a1 = Math.trunc(rgba1 & 255);
                    var r2 = Math.trunc(rgba2 >>> 24);
                    var g2 = Math.trunc(rgba2 >>> 16 & 255);
                    var b2 = Math.trunc(rgba2 >>> 8 & 255);
                    var a2 = Math.trunc(rgba2 & 255);
                    var r = Math.round(r2 * p + r1 * (1 - p));
                    var g = Math.round(g2 * p + g1 * (1 - p));
                    var b = Math.round(b2 * p + b1 * (1 - p));
                    var a = Math.round(a2 * p + a1 * (1 - p));
                    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
                }
                function mergeColorAlpha(rgba, alpha) {
                    var r = rgba >>> 24;
                    var g = rgba >>> 16 & 255;
                    var b = rgba >>> 8 & 255;
                    var a = Math.trunc((rgba & 255) * alpha);
                    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
                }
                var premultiplyRGB = true;
                function setPremultiplyMode(mode) {
                    premultiplyRGB = mode === "webgl";
                }
                function mergeColorAlphaPremultiplied(rgba, alpha) {
                    var flipEndianess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var newAlpha = (rgba & 255) / 255 * alpha;
                    var rgbAlpha = premultiplyRGB ? newAlpha : 1;
                    var r = Math.trunc((rgba >>> 24) * rgbAlpha);
                    var g = Math.trunc((rgba >>> 16 & 255) * rgbAlpha);
                    var b = Math.trunc((rgba >>> 8 & 255) * rgbAlpha);
                    var a = Math.trunc(newAlpha * 255);
                    if (flipEndianess) {
                        return (a << 24 | b << 16 | g << 8 | r) >>> 0;
                    }
                    return (r << 24 | g << 16 | b << 8 | a) >>> 0;
                }
                var nextId = 1;
                function getNewId() {
                    return nextId++;
                }
                function deepClone(obj) {
                    if (_typeof(obj) !== "object") {
                        return obj;
                    }
                    if (Array.isArray(obj)) {
                        return obj.map(function(item) {
                            return deepClone(item);
                        });
                    }
                    var copy = {};
                    for (var key in obj) {
                        copy[key] = deepClone(obj[key]);
                    }
                    return copy;
                }
                var EventEmitter = function() {
                    function EventEmitter() {
                        _classCallCheck(this, EventEmitter);
                        _defineProperty(this, "eventListeners", {});
                    }
                    return _createClass(EventEmitter, [ {
                        key: "on",
                        value: function on(event, listener) {
                            var listeners = this.eventListeners[event];
                            if (!listeners) {
                                listeners = [];
                            }
                            listeners.push(listener);
                            this.eventListeners[event] = listeners;
                        }
                    }, {
                        key: "off",
                        value: function off(event, listener) {
                            var listeners = this.eventListeners[event];
                            if (!listeners) {
                                return;
                            }
                            if (!listener) {
                                delete this.eventListeners[event];
                                return;
                            }
                            var index = listeners.indexOf(listener);
                            if (index >= 0) {
                                listeners.splice(index, 1);
                            }
                        }
                    }, {
                        key: "once",
                        value: function once(event, listener) {
                            var _this = this;
                            var _onceListener = function onceListener(target, data) {
                                _this.off(event, _onceListener);
                                listener(target, data);
                            };
                            this.on(event, _onceListener);
                        }
                    }, {
                        key: "emit",
                        value: function emit(event, data) {
                            var _this2 = this;
                            var listeners = this.eventListeners[event];
                            if (!listeners) {
                                return;
                            }
                            _toConsumableArray(listeners).forEach(function(listener) {
                                listener(_this2, data);
                            });
                        }
                    }, {
                        key: "removeAllListeners",
                        value: function removeAllListeners() {
                            this.eventListeners = {};
                        }
                    } ]);
                }();
                var TextureType;
                (function(TextureType) {
                    TextureType[TextureType["generic"] = 0] = "generic";
                    TextureType[TextureType["color"] = 1] = "color";
                    TextureType[TextureType["image"] = 2] = "image";
                    TextureType[TextureType["noise"] = 3] = "noise";
                    TextureType[TextureType["renderToTexture"] = 4] = "renderToTexture";
                    TextureType[TextureType["subTexture"] = 5] = "subTexture";
                })(TextureType || (TextureType = {}));
                var Texture = function(_EventEmitter2) {
                    function Texture(txManager) {
                        var _this3;
                        _classCallCheck(this, Texture);
                        _this3 = _callSuper(this, Texture);
                        _defineProperty(_this3, "txManager", void 0);
                        _defineProperty(_this3, "_dimensions", null);
                        _defineProperty(_this3, "_error", null);
                        _defineProperty(_this3, "state", "initial");
                        _defineProperty(_this3, "renderableOwners", []);
                        _defineProperty(_this3, "renderable", false);
                        _defineProperty(_this3, "type", TextureType.generic);
                        _defineProperty(_this3, "preventCleanup", false);
                        _defineProperty(_this3, "ctxTexture", void 0);
                        _defineProperty(_this3, "textureData", null);
                        _defineProperty(_this3, "memUsed", 0);
                        _defineProperty(_this3, "retryCount", 0);
                        _defineProperty(_this3, "maxRetryCount", void 0);
                        _defineProperty(_this3, "createdAt", Date.now());
                        _defineProperty(_this3, "gracePeriodExpired", false);
                        _defineProperty(_this3, "freeTextureDataTask", function() {
                            _this3.textureData = null;
                        });
                        _defineProperty(_this3, "releaseTask", function() {
                            _this3.release();
                        });
                        _this3.txManager = txManager;
                        _this3.maxRetryCount = _this3.txManager.maxRetryCount;
                        return _this3;
                    }
                    _inherits(Texture, _EventEmitter2);
                    return _createClass(Texture, [ {
                        key: "dimensions",
                        get: function get() {
                            return this._dimensions;
                        }
                    }, {
                        key: "error",
                        get: function get() {
                            return this._error;
                        }
                    }, {
                        key: "isWithinStartupGracePeriod",
                        value: function isWithinStartupGracePeriod() {
                            if (this.gracePeriodExpired === true) {
                                return false;
                            }
                            var hasExpired = Date.now() - this.createdAt >= Texture.STARTUP_GRACE_PERIOD;
                            if (hasExpired) {
                                this.gracePeriodExpired = true;
                                return false;
                            }
                            return true;
                        }
                    }, {
                        key: "canBeCleanedUp",
                        value: function canBeCleanedUp() {
                            if (this.preventCleanup) {
                                return false;
                            }
                            if (this.isWithinStartupGracePeriod()) {
                                return false;
                            }
                            if (this.renderable === true) {
                                return false;
                            }
                            if (this.renderableOwners.length > 0) {
                                return false;
                            }
                            return true;
                        }
                    }, {
                        key: "setRenderableOwner",
                        value: function setRenderableOwner(owner, renderable) {
                            var oldSize = this.renderableOwners.length;
                            var hasOwnerIndex = this.renderableOwners.indexOf(owner);
                            if (renderable === true) {
                                if (hasOwnerIndex === -1) {
                                    this.renderableOwners.push(owner);
                                }
                                var newSize = this.renderableOwners.length;
                                if (oldSize !== newSize && newSize === 1) {
                                    var _this$onChangeIsRende;
                                    this.renderable = true;
                                    (_this$onChangeIsRende = this.onChangeIsRenderable) === null || _this$onChangeIsRende === void 0 || _this$onChangeIsRende.call(this, true);
                                    this.load();
                                }
                            } else {
                                if (hasOwnerIndex !== -1) {
                                    this.renderableOwners.splice(hasOwnerIndex, 1);
                                }
                                var _newSize = this.renderableOwners.length;
                                if (oldSize !== _newSize && _newSize === 0) {
                                    var _this$onChangeIsRende2;
                                    this.renderable = false;
                                    (_this$onChangeIsRende2 = this.onChangeIsRenderable) === null || _this$onChangeIsRende2 === void 0 || _this$onChangeIsRende2.call(this, false);
                                }
                            }
                        }
                    }, {
                        key: "load",
                        value: function load() {
                            if (this.retryCount > this.maxRetryCount) {
                                return;
                            }
                            this.txManager.loadTexture(this);
                        }
                    }, {
                        key: "loadCtxTexture",
                        value: function loadCtxTexture() {
                            if (this.ctxTexture === undefined) {
                                this.ctxTexture = this.txManager.renderer.createCtxTexture(this);
                            }
                            return this.ctxTexture;
                        }
                    }, {
                        key: "free",
                        value: function free() {
                            var _this$ctxTexture;
                            (_this$ctxTexture = this.ctxTexture) === null || _this$ctxTexture === void 0 || _this$ctxTexture.free();
                        }
                    }, {
                        key: "release",
                        value: function release() {
                            var _this$ctxTexture2;
                            (_this$ctxTexture2 = this.ctxTexture) === null || _this$ctxTexture2 === void 0 || _this$ctxTexture2.release();
                            this.ctxTexture = undefined;
                            this.freeTextureData();
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            if (this.state === "loaded") {
                                this.free();
                            }
                            this.freeTextureData();
                        }
                    }, {
                        key: "freeTextureData",
                        value: function freeTextureData() {
                            queueMicrotask(this.freeTextureDataTask);
                        }
                    }, {
                        key: "setState",
                        value: function setState(state, errorOrDimensions) {
                            if (this.state === state) {
                                return;
                            }
                            var payload = null;
                            if (state === "loaded") {
                                if (errorOrDimensions !== undefined && "w" in errorOrDimensions === true && "h" in errorOrDimensions === true && errorOrDimensions.w !== undefined && errorOrDimensions.h !== undefined) {
                                    this._dimensions = errorOrDimensions;
                                }
                                payload = this._dimensions;
                            } else if (state === "failed") {
                                this._error = errorOrDimensions;
                                payload = this._error;
                                this.retryCount += 1;
                                queueMicrotask(this.releaseTask);
                            } else if (state === "loading") {
                                this._error = null;
                                this._dimensions = null;
                            } else {
                                this._error = null;
                            }
                            this.state = state;
                            this.emit(state, payload);
                        }
                    }, {
                        key: "getTextureData",
                        value: function() {
                            var _getTextureData = _asyncToGenerator(_regenerator().m(function _callee() {
                                return _regenerator().w(function(_context) {
                                    while (1) switch (_context.n) {
                                      case 0:
                                        if (!(this.textureData === null)) {
                                            _context.n = 2;
                                            break;
                                        }
                                        _context.n = 1;
                                        return this.getTextureSource();

                                      case 1:
                                        this.textureData = _context.v;

                                      case 2:
                                        return _context.a(2, this.textureData);
                                    }
                                }, _callee, this);
                            }));
                            function getTextureData() {
                                return _getTextureData.apply(this, arguments);
                            }
                            return getTextureData;
                        }()
                    } ], [ {
                        key: "makeCacheKey",
                        value: function makeCacheKey(props) {
                            return false;
                        }
                    }, {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            return {};
                        }
                    } ]);
                }(EventEmitter);
                _defineProperty(Texture, "STARTUP_GRACE_PERIOD", 2e3);
                var PROTOCOL_REGEX = /^(data|ftps?|https?):/;
                var getNormalizedRgbaComponents = function getNormalizedRgbaComponents(rgba) {
                    var r = rgba >>> 24;
                    var g = rgba >>> 16 & 255;
                    var b = rgba >>> 8 & 255;
                    var a = rgba & 255;
                    return [ r / 255, g / 255, b / 255, a / 255 ];
                };
                function createBound(x1, y1, x2, y2, out) {
                    if (out) {
                        out.x1 = x1;
                        out.y1 = y1;
                        out.x2 = x2;
                        out.y2 = y2;
                        return out;
                    }
                    return {
                        x1: x1,
                        y1: y1,
                        x2: x2,
                        y2: y2
                    };
                }
                function intersectRect(a, b, out) {
                    var x = Math.max(a.x, b.x);
                    var y = Math.max(a.y, b.y);
                    var width = Math.min(a.x + a.width, b.x + b.width) - x;
                    var height = Math.min(a.y + a.height, b.y + b.height) - y;
                    if (width > 0 && height > 0) {
                        if (out) {
                            out.x = x;
                            out.y = y;
                            out.width = width;
                            out.height = height;
                            return out;
                        }
                        return {
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        };
                    }
                    if (out) {
                        out.x = 0;
                        out.y = 0;
                        out.width = 0;
                        out.height = 0;
                        return out;
                    }
                    return {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                }
                function copyRect(a, out) {
                    if (out) {
                        out.x = a.x;
                        out.y = a.y;
                        out.width = a.width;
                        out.height = a.height;
                        return out;
                    }
                    return {
                        x: a.x,
                        y: a.y,
                        width: a.width,
                        height: a.height
                    };
                }
                function compareRect(a, b) {
                    if (a === b) {
                        return true;
                    }
                    if (a === null || b === null) {
                        return false;
                    }
                    return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
                }
                function boundInsideBound(bound1, bound2) {
                    return bound1.x1 <= bound2.x2 && bound1.y1 <= bound2.y2 && bound1.x2 >= bound2.x1 && bound1.y2 >= bound2.y1;
                }
                function boundLargeThanBound(bound1, bound2) {
                    return bound1.x1 < bound2.x1 && bound1.x2 > bound2.x2 && bound1.y1 < bound2.y1 && bound1.y2 > bound2.y2;
                }
                function pointInBound(x, y, bound) {
                    return !(x < bound.x1 || x > bound.x2 || y < bound.y1 || y > bound.y2);
                }
                function createPreloadBounds(strictBound, boundsMargin) {
                    return createBound(strictBound.x1 - boundsMargin[3], strictBound.y1 - boundsMargin[0], strictBound.x2 + boundsMargin[1], strictBound.y2 + boundsMargin[2]);
                }
                function convertUrlToAbsolute(url) {
                    if (self.location.protocol === "file:" && !PROTOCOL_REGEX.test(url)) {
                        var path = self.location.pathname.split("/");
                        path.pop();
                        var _basePath = path.join("/");
                        var baseUrl = self.location.protocol + "//" + _basePath;
                        if (url.charAt(0) === ".") {
                            url = url.slice(1);
                        }
                        if (url.charAt(0) === "/") {
                            url = url.slice(1);
                        }
                        return baseUrl + "/" + url;
                    }
                    var absoluteUrl = new URL(url, self.location.href);
                    return absoluteUrl.href;
                }
                function isBase64Image(src) {
                    return src.startsWith("data:") === true;
                }
                function calcFactoredRadiusArray$1(radius, width, height) {
                    var result = [ radius[0], radius[1], radius[2], radius[3] ];
                    var factor = Math.min(Math.min(Math.min(width / Math.max(width, radius[0] + radius[1]), width / Math.max(width, radius[2] + radius[3])), Math.min(height / Math.max(height, radius[0] + radius[3]), height / Math.max(height, radius[1] + radius[2]))), 1);
                    result[0] *= factor;
                    result[1] *= factor;
                    result[2] *= factor;
                    result[3] *= factor;
                    return result;
                }
                function dataURIToBlob(dataURI) {
                    var _dataURI$match;
                    dataURI = dataURI.replace(/^data:/, "");
                    var type = ((_dataURI$match = dataURI.match(/image\/[^;]+/)) === null || _dataURI$match === void 0 ? void 0 : _dataURI$match[0]) || "";
                    var base64 = dataURI.replace(/^[^,]+,/, "");
                    var sliceSize = 1024;
                    var byteCharacters = atob(base64);
                    var bytesLength = byteCharacters.length;
                    var slicesCount = Math.ceil(bytesLength / sliceSize);
                    var byteArrays = new Array(slicesCount);
                    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
                        var begin = sliceIndex * sliceSize;
                        var end = Math.min(begin + sliceSize, bytesLength);
                        var bytes = new Array(end - begin);
                        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
                            var _byteCharacters$offse;
                            bytes[i] = (_byteCharacters$offse = byteCharacters[offset]) === null || _byteCharacters$offse === void 0 ? void 0 : _byteCharacters$offse.charCodeAt(0);
                        }
                        byteArrays[sliceIndex] = new Uint8Array(bytes);
                    }
                    return new Blob(byteArrays, {
                        type: type
                    });
                }
                function fetchJson(url) {
                    var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
                    return new Promise(function(resolve, reject) {
                        var xhr = new XMLHttpRequest;
                        xhr.responseType = responseType;
                        xhr.onreadystatechange = function() {
                            if (xhr.readyState == XMLHttpRequest.DONE) {
                                if (xhr.status === 0 || xhr.status === 200) {
                                    resolve(xhr.response);
                                } else {
                                    reject(xhr.statusText);
                                }
                            }
                        };
                        xhr.open("GET", url, true);
                        xhr.send(null);
                    });
                }
                var Matrix3d = function() {
                    function Matrix3d() {
                        _classCallCheck(this, Matrix3d);
                        _defineProperty(this, "ta", void 0);
                        _defineProperty(this, "tb", void 0);
                        _defineProperty(this, "tx", void 0);
                        _defineProperty(this, "tc", void 0);
                        _defineProperty(this, "td", void 0);
                        _defineProperty(this, "ty", void 0);
                        _defineProperty(this, "_floatArr", null);
                        _defineProperty(this, "mutation", void 0);
                        this.ta = 0;
                        this.tb = 0;
                        this.tx = 0;
                        this.tc = 0;
                        this.td = 0;
                        this.ty = 0;
                        this.mutation = true;
                    }
                    return _createClass(Matrix3d, [ {
                        key: "translate",
                        value: function translate(x, y) {
                            this.tx = this.ta * x + this.tb * y + this.tx;
                            this.ty = this.tc * x + this.td * y + this.ty;
                            this.mutation = true;
                            return this;
                        }
                    }, {
                        key: "scale",
                        value: function scale(sx, sy) {
                            this.ta = this.ta * sx;
                            this.tb = this.tb * sy;
                            this.tc = this.tc * sx;
                            this.td = this.td * sy;
                            this.mutation = true;
                            return this;
                        }
                    }, {
                        key: "rotate",
                        value: function rotate(angle) {
                            if (angle === 0) {
                                return this;
                            }
                            var cos = Math.cos(angle);
                            var sin = Math.sin(angle);
                            var e0 = this.ta * cos + this.tb * sin;
                            var e1 = this.tb * cos - this.ta * sin;
                            var e3 = this.tc * cos + this.td * sin;
                            var e4 = this.td * cos - this.tc * sin;
                            this.ta = e0;
                            this.tb = e1;
                            this.tc = e3;
                            this.td = e4;
                            this.mutation = true;
                            return this;
                        }
                    }, {
                        key: "multiply",
                        value: function multiply(other) {
                            return Matrix3d.multiply(this, other, this);
                        }
                    }, {
                        key: "getFloatArr",
                        value: function getFloatArr() {
                            if (!this._floatArr) {
                                this._floatArr = new Float32Array(9);
                            }
                            if (this.mutation) {
                                this._floatArr[0] = this.ta;
                                this._floatArr[1] = this.tc;
                                this._floatArr[2] = 0;
                                this._floatArr[3] = this.tb;
                                this._floatArr[4] = this.td;
                                this._floatArr[5] = 0;
                                this._floatArr[6] = this.tx;
                                this._floatArr[7] = this.ty;
                                this._floatArr[8] = 1;
                                this.mutation = false;
                            }
                            return this._floatArr;
                        }
                    }, {
                        key: "translateOrMultiply",
                        value: function translateOrMultiply(other) {
                            if (other.ta === 1 && other.td === 1 && other.tb === 0 && other.tc === 0) {
                                return this.translate(other.tx, other.ty);
                            }
                            return this.multiply(other);
                        }
                    } ], [ {
                        key: "temp",
                        get: function get() {
                            return tempMatrix;
                        }
                    }, {
                        key: "multiply",
                        value: function multiply(a, b, out) {
                            var e0 = a.ta * b.ta + a.tb * b.tc;
                            var e1 = a.ta * b.tb + a.tb * b.td;
                            var e2 = a.ta * b.tx + a.tb * b.ty + a.tx;
                            var e3 = a.tc * b.ta + a.td * b.tc;
                            var e4 = a.tc * b.tb + a.td * b.td;
                            var e5 = a.tc * b.tx + a.td * b.ty + a.ty;
                            if (!out) {
                                out = new Matrix3d;
                            }
                            out.ta = e0;
                            out.tb = e1;
                            out.tx = e2;
                            out.tc = e3;
                            out.td = e4;
                            out.ty = e5;
                            out.mutation = true;
                            return out;
                        }
                    }, {
                        key: "identity",
                        value: function identity(out) {
                            if (!out) {
                                out = new Matrix3d;
                            }
                            out.ta = 1;
                            out.tb = 0;
                            out.tx = 0;
                            out.tc = 0;
                            out.td = 1;
                            out.ty = 0;
                            out.mutation = true;
                            return out;
                        }
                    }, {
                        key: "translate",
                        value: function translate(x, y, out) {
                            if (!out) {
                                out = new Matrix3d;
                            }
                            out.ta = 1;
                            out.tb = 0;
                            out.tx = x;
                            out.tc = 0;
                            out.td = 1;
                            out.ty = y;
                            out.mutation = true;
                            return out;
                        }
                    }, {
                        key: "scale",
                        value: function scale(sx, sy, out) {
                            if (!out) {
                                out = new Matrix3d;
                            }
                            out.ta = sx;
                            out.tb = 0;
                            out.tx = 0;
                            out.tc = 0;
                            out.td = sy;
                            out.ty = 0;
                            out.mutation = true;
                            return out;
                        }
                    }, {
                        key: "rotate",
                        value: function rotate(angle, out) {
                            var cos = Math.cos(angle);
                            var sin = Math.sin(angle);
                            if (!out) {
                                out = new Matrix3d;
                            }
                            out.ta = cos;
                            out.tb = -sin;
                            out.tx = 0;
                            out.tc = sin;
                            out.td = cos;
                            out.ty = 0;
                            out.mutation = true;
                            return out;
                        }
                    }, {
                        key: "copy",
                        value: function copy(src, dst) {
                            if (!dst) {
                                dst = new Matrix3d;
                            }
                            dst.ta = src.ta;
                            dst.tc = src.tc;
                            dst.tb = src.tb;
                            dst.td = src.td;
                            dst.tx = src.tx;
                            dst.ty = src.ty;
                            dst.mutation = true;
                            return dst;
                        }
                    } ]);
                }();
                var tempMatrix = new Matrix3d;
                var RenderCoords = function() {
                    function RenderCoords(x1, y1, x2, y2, x3, y3, x4, y4) {
                        _classCallCheck(this, RenderCoords);
                        _defineProperty(this, "x1", void 0);
                        _defineProperty(this, "y1", void 0);
                        _defineProperty(this, "x2", void 0);
                        _defineProperty(this, "y2", void 0);
                        _defineProperty(this, "x3", void 0);
                        _defineProperty(this, "y3", void 0);
                        _defineProperty(this, "x4", void 0);
                        _defineProperty(this, "y4", void 0);
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                        this.x3 = x3;
                        this.y3 = y3;
                        this.x4 = x4;
                        this.y4 = y4;
                    }
                    return _createClass(RenderCoords, null, [ {
                        key: "translate",
                        value: function translate(x1, y1, x2, y2, x3, y3, x4, y4, out) {
                            if (out === undefined) {
                                return new RenderCoords(x1, y1, x2, y2, x3, y3, x4, y4);
                            }
                            out.x1 = x1;
                            out.y1 = y1;
                            out.x2 = x2;
                            out.y2 = y2;
                            out.x3 = x3;
                            out.y3 = y3;
                            out.x4 = x4;
                            out.y4 = y4;
                            return out;
                        }
                    } ]);
                }();
                var getTimingBezier = function getTimingBezier(a, b, c, d) {
                    var xc = 3 * a;
                    var xb = 3 * (c - a) - xc;
                    var xa = 1 - xc - xb;
                    var yc = 3 * b;
                    var yb = 3 * (d - b) - yc;
                    var ya = 1 - yc - yb;
                    return function(time) {
                        if (time >= 1) {
                            return 1;
                        }
                        if (time <= 0) {
                            return 0;
                        }
                        var t = .5, cbx, cbxd, dx;
                        for (var it = 0; it < 20; it++) {
                            cbx = t * (t * (t * xa + xb) + xc);
                            dx = time - cbx;
                            if (dx > -1e-8 && dx < 1e-8) {
                                return t * (t * (t * ya + yb) + yc);
                            }
                            cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
                            if (cbxd > 1e-10 && cbxd < 1e-10) {
                                break;
                            }
                            t += dx / cbxd;
                        }
                        var minT = 0;
                        var maxT = 1;
                        for (var _it = 0; _it < 20; _it++) {
                            t = .5 * (minT + maxT);
                            cbx = t * (t * (t * xa + xb) + xc);
                            dx = time - cbx;
                            if (dx > -1e-8 && dx < 1e-8) {
                                return t * (t * (t * ya + yb) + yc);
                            }
                            if (dx < 0) {
                                maxT = t;
                            } else {
                                minT = t;
                            }
                        }
                        return time;
                    };
                };
                var timingMapping = {};
                var timingLookup = {
                    ease: [ .25, .1, .25, 1 ],
                    "ease-in": [ .42, 0, 1, 1 ],
                    "ease-out": [ 0, 0, .58, 1 ],
                    "ease-in-out": [ .42, 0, .58, 1 ],
                    "ease-in-sine": [ .12, 0, .39, 0 ],
                    "ease-out-sine": [ .12, 0, .39, 0 ],
                    "ease-in-out-sine": [ .37, 0, .63, 1 ],
                    "ease-in-cubic": [ .32, 0, .67, 0 ],
                    "ease-out-cubic": [ .33, 1, .68, 1 ],
                    "ease-in-out-cubic": [ .65, 0, .35, 1 ],
                    "ease-in-circ": [ .55, 0, 1, .45 ],
                    "ease-out-circ": [ 0, .55, .45, 1 ],
                    "ease-in-out-circ": [ .85, 0, .15, 1 ],
                    "ease-in-back": [ .36, 0, .66, -.56 ],
                    "ease-out-back": [ .34, 1.56, .64, 1 ],
                    "ease-in-out-back": [ .68, -.6, .32, 1.6 ]
                };
                var defaultTiming = function defaultTiming(t) {
                    return t;
                };
                var parseCubicBezier = function parseCubicBezier(str) {
                    var regex = /-?\d*\.?\d+/g;
                    var match = str.match(regex);
                    if (match) {
                        var _match = _slicedToArray(match, 4), num1 = _match[0], num2 = _match[1], num3 = _match[2], num4 = _match[3];
                        var a = parseFloat(num1 || "0.42");
                        var b = parseFloat(num2 || "0");
                        var c = parseFloat(num3 || "1");
                        var d = parseFloat(num4 || "1");
                        var timing = getTimingBezier(a, b, c, d);
                        timingMapping[str] = timing;
                        return timing;
                    }
                    console.warn("Unknown cubic-bezier timing: " + str);
                    return defaultTiming;
                };
                var getTimingFunction = function getTimingFunction(str) {
                    if (str === "linear") {
                        return defaultTiming;
                    }
                    if (timingMapping[str] !== undefined) {
                        return timingMapping[str] || defaultTiming;
                    }
                    if (str === "step-start") {
                        return function() {
                            return 1;
                        };
                    }
                    if (str === "step-end") {
                        return function(time) {
                            return time === 1 ? 1 : 0;
                        };
                    }
                    var lookup = timingLookup[str];
                    if (lookup !== undefined) {
                        var _lookup = _slicedToArray(lookup, 4), a = _lookup[0], b = _lookup[1], c = _lookup[2], d = _lookup[3];
                        var timing = getTimingBezier(a, b, c, d);
                        timingMapping[str] = timing;
                        return timing;
                    }
                    if (str.startsWith("cubic-bezier")) {
                        return parseCubicBezier(str);
                    }
                    console.warn("Unknown timing function: " + str);
                    return defaultTiming;
                };
                function bytesToMb$1(bytes) {
                    return (bytes / 1024 / 1024).toFixed(2);
                }
                var CoreAnimation = function(_EventEmitter3) {
                    function CoreAnimation(node, props, settings) {
                        var _settings$delay, _settings$duration, _settings$loop, _settings$repeat, _settings$stopMethod;
                        var _this4;
                        _classCallCheck(this, CoreAnimation);
                        _this4 = _callSuper(this, CoreAnimation);
                        _defineProperty(_this4, "node", void 0);
                        _defineProperty(_this4, "props", void 0);
                        _defineProperty(_this4, "settings", void 0);
                        _defineProperty(_this4, "progress", 0);
                        _defineProperty(_this4, "delayFor", 0);
                        _defineProperty(_this4, "delay", 0);
                        _defineProperty(_this4, "timingFunction", void 0);
                        _defineProperty(_this4, "propValuesMap", {});
                        _this4.node = node;
                        _this4.props = props;
                        for (var key in props) {
                            if (key !== "shaderProps") {
                                if (_this4.propValuesMap["props"] === undefined) {
                                    _this4.propValuesMap["props"] = {};
                                }
                                _this4.propValuesMap["props"][key] = {
                                    start: node[key] || 0,
                                    target: props[key]
                                };
                            } else if (key === "shaderProps" && node.shader !== null) {
                                _this4.propValuesMap["shaderProps"] = {};
                                for (var _key2 in props.shaderProps) {
                                    var start = node.shader.props[_key2];
                                    if (Array.isArray(start) === true) {
                                        start = start[0];
                                    }
                                    _this4.propValuesMap["shaderProps"][_key2] = {
                                        start: start,
                                        target: props.shaderProps[_key2]
                                    };
                                }
                            }
                        }
                        var easing = settings.easing || "linear";
                        var delay = (_settings$delay = settings.delay) !== null && _settings$delay !== void 0 ? _settings$delay : 0;
                        _this4.settings = {
                            duration: (_settings$duration = settings.duration) !== null && _settings$duration !== void 0 ? _settings$duration : 0,
                            delay: delay,
                            easing: easing,
                            loop: (_settings$loop = settings.loop) !== null && _settings$loop !== void 0 ? _settings$loop : false,
                            repeat: (_settings$repeat = settings.repeat) !== null && _settings$repeat !== void 0 ? _settings$repeat : 0,
                            stopMethod: (_settings$stopMethod = settings.stopMethod) !== null && _settings$stopMethod !== void 0 ? _settings$stopMethod : false
                        };
                        _this4.timingFunction = typeof easing === "string" ? getTimingFunction(easing) : easing;
                        _this4.delayFor = delay;
                        _this4.delay = delay;
                        return _this4;
                    }
                    _inherits(CoreAnimation, _EventEmitter3);
                    return _createClass(CoreAnimation, [ {
                        key: "reset",
                        value: function reset() {
                            this.progress = 0;
                            this.delayFor = this.settings.delay || 0;
                            this.update(0);
                        }
                    }, {
                        key: "restoreValues",
                        value: function restoreValues(target, valueMap) {
                            var entries = Object.entries(valueMap);
                            var eLength = entries.length;
                            for (var i = 0; i < eLength; i++) {
                                var _entries$i = _slicedToArray(entries[i], 2), key = _entries$i[0], value = _entries$i[1];
                                target[key] = value.start;
                            }
                        }
                    }, {
                        key: "restore",
                        value: function restore() {
                            this.reset();
                            if (this.propValuesMap["props"] !== undefined) {
                                this.restoreValues(this.node, this.propValuesMap["props"]);
                            }
                            if (this.propValuesMap["shaderProps"] !== undefined) {
                                this.restoreValues(this.node.shader.props, this.propValuesMap["shaderProps"]);
                            }
                        }
                    }, {
                        key: "reverseValues",
                        value: function reverseValues(valueMap) {
                            var entries = Object.entries(valueMap);
                            var eLength = entries.length;
                            for (var i = 0; i < eLength; i++) {
                                var _entries$i2 = _slicedToArray(entries[i], 2), key = _entries$i2[0], value = _entries$i2[1];
                                valueMap[key] = {
                                    start: value.target,
                                    target: value.start
                                };
                            }
                        }
                    }, {
                        key: "reverse",
                        value: function reverse() {
                            this.progress = 0;
                            if (this.propValuesMap["props"] !== undefined) {
                                this.reverseValues(this.propValuesMap["props"]);
                            }
                            if (this.propValuesMap["shaderProps"] !== undefined) {
                                this.reverseValues(this.propValuesMap["shaderProps"]);
                            }
                            if (!this.settings.loop) {
                                this.settings.stopMethod = false;
                            }
                        }
                    }, {
                        key: "applyEasing",
                        value: function applyEasing(p, s, e) {
                            return this.timingFunction(p) * (e - s) + s;
                        }
                    }, {
                        key: "updateValue",
                        value: function updateValue(propName, propValue, startValue, easing) {
                            if (this.progress === 1) {
                                return propValue;
                            }
                            if (this.progress === 0) {
                                return startValue;
                            }
                            var endValue = propValue;
                            if (propName.indexOf("color") !== -1) {
                                if (startValue === endValue) {
                                    return startValue;
                                }
                                if (easing) {
                                    var easingProgressValue = this.timingFunction(this.progress) || this.progress;
                                    return mergeColorProgress(startValue, endValue, easingProgressValue);
                                }
                                return mergeColorProgress(startValue, endValue, this.progress);
                            }
                            if (easing) {
                                return this.applyEasing(this.progress, startValue, endValue);
                            }
                            return startValue + (endValue - startValue) * this.progress;
                        }
                    }, {
                        key: "updateValues",
                        value: function updateValues(target, valueMap, easing) {
                            var entries = Object.entries(valueMap);
                            var eLength = entries.length;
                            for (var i = 0; i < eLength; i++) {
                                var _entries$i3 = _slicedToArray(entries[i], 2), key = _entries$i3[0], value = _entries$i3[1];
                                target[key] = this.updateValue(key, value.target, value.start, easing);
                            }
                        }
                    }, {
                        key: "update",
                        value: function update(dt) {
                            var _this$settings = this.settings, duration = _this$settings.duration, loop = _this$settings.loop, easing = _this$settings.easing, stopMethod = _this$settings.stopMethod;
                            var delayFor = this.delayFor;
                            if (this.node.destroyed) {
                                this.emit("destroyed", {});
                                return;
                            }
                            if (duration === 0 && delayFor === 0) {
                                this.emit("finished", {});
                                return;
                            }
                            if (this.delayFor > 0) {
                                this.delayFor -= dt;
                                if (this.delayFor >= 0) {
                                    return;
                                } else {
                                    dt = -this.delayFor;
                                    this.delayFor = 0;
                                }
                            }
                            if (duration === 0) {
                                this.emit("finished", {});
                                return;
                            }
                            if (this.progress === 0) {
                                this.emit("animating", {});
                            }
                            this.progress += dt / duration;
                            if (this.progress > 1) {
                                this.progress = loop ? 0 : 1;
                                this.delayFor = this.delay;
                                if (stopMethod) {
                                    this.emit("finished", {});
                                    return;
                                }
                            }
                            if (this.propValuesMap["props"] !== undefined) {
                                this.updateValues(this.node, this.propValuesMap["props"], easing);
                            }
                            if (this.propValuesMap["shaderProps"] !== undefined) {
                                this.updateValues(this.node.shader.props, this.propValuesMap["shaderProps"], easing);
                            }
                            if (this.progress < 1) {
                                this.emit("tick", {
                                    progress: this.progress
                                });
                            }
                            if (this.progress === 1) {
                                this.emit("finished", {});
                            }
                        }
                    } ]);
                }(EventEmitter);
                var CoreAnimationController = function(_EventEmitter4) {
                    function CoreAnimationController(manager, animation) {
                        var _this5;
                        _classCallCheck(this, CoreAnimationController);
                        _this5 = _callSuper(this, CoreAnimationController);
                        _defineProperty(_this5, "manager", void 0);
                        _defineProperty(_this5, "animation", void 0);
                        _defineProperty(_this5, "stoppedPromise", void 0);
                        _defineProperty(_this5, "stoppedResolve", null);
                        _defineProperty(_this5, "state", void 0);
                        _this5.manager = manager;
                        _this5.animation = animation;
                        _this5.state = "stopped";
                        _this5.stoppedPromise = Promise.resolve();
                        _this5.onAnimating = _this5.onAnimating.bind(_this5);
                        _this5.onFinished = _this5.onFinished.bind(_this5);
                        _this5.onTick = _this5.onTick.bind(_this5);
                        _this5.onDestroy = _this5.onDestroy.bind(_this5);
                        return _this5;
                    }
                    _inherits(CoreAnimationController, _EventEmitter4);
                    return _createClass(CoreAnimationController, [ {
                        key: "start",
                        value: function start() {
                            if (this.state !== "running" && this.state !== "scheduled") {
                                this.makeStoppedPromise();
                                this.registerAnimation();
                                this.state = "scheduled";
                            }
                            return this;
                        }
                    }, {
                        key: "stop",
                        value: function stop() {
                            this.unregisterAnimation();
                            if (this.stoppedResolve !== null) {
                                this.stoppedResolve();
                                this.stoppedResolve = null;
                                this.emit("stopped", this);
                            }
                            this.animation.reset();
                            this.state = "stopped";
                            return this;
                        }
                    }, {
                        key: "pause",
                        value: function pause() {
                            this.unregisterAnimation();
                            this.state = "paused";
                            return this;
                        }
                    }, {
                        key: "restore",
                        value: function restore() {
                            this.stoppedResolve = null;
                            this.animation.restore();
                            return this;
                        }
                    }, {
                        key: "waitUntilStopped",
                        value: function waitUntilStopped() {
                            return this.stoppedPromise;
                        }
                    }, {
                        key: "registerAnimation",
                        value: function registerAnimation() {
                            this.animation.once("finished", this.onFinished);
                            this.animation.on("animating", this.onAnimating);
                            this.animation.on("tick", this.onTick);
                            this.animation.on("destroyed", this.onDestroy);
                            this.manager.registerAnimation(this.animation);
                        }
                    }, {
                        key: "unregisterAnimation",
                        value: function unregisterAnimation() {
                            this.manager.unregisterAnimation(this.animation);
                            this.animation.off("finished", this.onFinished);
                            this.animation.off("animating", this.onAnimating);
                            this.animation.off("tick", this.onTick);
                            this.animation.off("destroy", this.onDestroy);
                        }
                    }, {
                        key: "makeStoppedPromise",
                        value: function makeStoppedPromise() {
                            var _this6 = this;
                            if (this.stoppedResolve === null) {
                                this.stoppedPromise = new Promise(function(resolve) {
                                    _this6.stoppedResolve = resolve;
                                });
                            }
                        }
                    }, {
                        key: "onDestroy",
                        value: function onDestroy() {
                            this.unregisterAnimation();
                            this.state = "stopped";
                        }
                    }, {
                        key: "onFinished",
                        value: function onFinished() {
                            var _this$animation$setti = this.animation.settings, loop = _this$animation$setti.loop, stopMethod = _this$animation$setti.stopMethod;
                            if (stopMethod === "reverse") {
                                this.animation.once("finished", this.onFinished);
                                this.animation.reverse();
                                return;
                            }
                            if (loop) {
                                return;
                            }
                            this.unregisterAnimation();
                            if (this.stoppedResolve !== null) {
                                this.stoppedResolve();
                                this.stoppedResolve = null;
                            }
                            this.emit("stopped", this);
                            this.state = "stopped";
                        }
                    }, {
                        key: "onAnimating",
                        value: function onAnimating() {
                            this.state = "running";
                            this.emit("animating", this);
                        }
                    }, {
                        key: "onTick",
                        value: function onTick(_animation, data) {
                            this.emit("tick", data);
                        }
                    } ]);
                }(EventEmitter);
                var AutosizeMode;
                (function(AutosizeMode) {
                    AutosizeMode[AutosizeMode["Children"] = 0] = "Children";
                    AutosizeMode[AutosizeMode["Texture"] = 1] = "Texture";
                })(AutosizeMode || (AutosizeMode = {}));
                var AutosizeUpdateType;
                (function(AutosizeUpdateType) {
                    AutosizeUpdateType[AutosizeUpdateType["None"] = 0] = "None";
                    AutosizeUpdateType[AutosizeUpdateType["Filtered"] = 1] = "Filtered";
                    AutosizeUpdateType[AutosizeUpdateType["All"] = 2] = "All";
                })(AutosizeUpdateType || (AutosizeUpdateType = {}));
                var applyDimensions = function applyDimensions(node, w, h) {
                    node.props.w = w;
                    node.props.h = h;
                    node.setUpdateType(UpdateType.Local);
                };
                var getFilteredChildren = function getFilteredChildren(children, childMap) {
                    var filtered = [];
                    while (children.length > 0) {
                        var id = children.pop();
                        var child = childMap.get(id);
                        filtered.push(child);
                    }
                    return filtered;
                };
                var autosizerId = 0;
                var Autosizer = function() {
                    function Autosizer(node) {
                        _classCallCheck(this, Autosizer);
                        _defineProperty(this, "node", void 0);
                        _defineProperty(this, "id", autosizerId++);
                        _defineProperty(this, "mode", AutosizeMode.Children);
                        _defineProperty(this, "updateType", AutosizeUpdateType.All);
                        _defineProperty(this, "lastWidth", 0);
                        _defineProperty(this, "lastHeight", 0);
                        _defineProperty(this, "lastHasChanged", false);
                        _defineProperty(this, "flaggedChildren", []);
                        _defineProperty(this, "childMap", new Map);
                        _defineProperty(this, "minX", Infinity);
                        _defineProperty(this, "minY", Infinity);
                        _defineProperty(this, "maxX", -Infinity);
                        _defineProperty(this, "maxY", -Infinity);
                        _defineProperty(this, "corners", [ {
                            x: 0,
                            y: 0
                        }, {
                            x: 0,
                            y: 0
                        }, {
                            x: 0,
                            y: 0
                        }, {
                            x: 0,
                            y: 0
                        } ]);
                        this.node = node;
                        if (node.texture !== null) {
                            this.mode = AutosizeMode.Texture;
                        }
                    }
                    return _createClass(Autosizer, [ {
                        key: "attach",
                        value: function attach(node) {
                            this.childMap.set(node.id, node);
                            node.parentAutosizer = this;
                            if (node.children.length > 0 && node.autosizer === null) {
                                var _children = node.children;
                                for (var i = 0; i < _children.length; i++) {
                                    this.attach(_children[i]);
                                }
                            }
                        }
                    }, {
                        key: "detach",
                        value: function detach(node) {
                            if (this.childMap.delete(node.id) === true) {
                                node.parentAutosizer = null;
                                if (node.children.length > 0 && node.autosizer === null) {
                                    var _children2 = node.children;
                                    for (var i = 0; i < _children2.length; i++) {
                                        this.detach(_children2[i]);
                                    }
                                }
                                this.setUpdateType(AutosizeUpdateType.All);
                            }
                        }
                    }, {
                        key: "patch",
                        value: function patch(id) {
                            var entry = this.childMap.get(id);
                            if (entry === undefined) {
                                return;
                            }
                            this.flaggedChildren.push(id);
                            this.setUpdateType(AutosizeUpdateType.Filtered);
                        }
                    }, {
                        key: "setUpdateType",
                        value: function setUpdateType(updateType) {
                            this.updateType |= updateType;
                            this.node.setUpdateType(UpdateType.Autosize);
                        }
                    }, {
                        key: "setMode",
                        value: function setMode(mode) {
                            this.mode = mode;
                            this.setUpdateType(AutosizeUpdateType.All);
                        }
                    }, {
                        key: "update",
                        value: function update() {
                            var node = this.node;
                            if (this.mode === AutosizeMode.Texture && node.texture !== null && node.texture.dimensions !== null) {
                                var _node$texture$dimensi = node.texture.dimensions, w = _node$texture$dimensi.w, h = _node$texture$dimensi.h;
                                if (w !== node.w || h !== node.h) {
                                    applyDimensions(node, w, h);
                                }
                                this.lastWidth = w;
                                this.lastHeight = h;
                                this.updateType = AutosizeUpdateType.None;
                                return;
                            }
                            var filtered = this.updateType === AutosizeUpdateType.Filtered ? getFilteredChildren(this.flaggedChildren, this.childMap) : Array.from(this.childMap.values());
                            if (filtered.length === 0) {
                                return;
                            }
                            var corners = this.corners;
                            var minX = this.minX;
                            var minY = this.minY;
                            var maxX = this.maxX;
                            var maxY = this.maxY;
                            for (var i = 0; i < filtered.length; i++) {
                                var child = filtered[i];
                                if (child.isRenderable === false || child.localTransform === undefined) {
                                    continue;
                                }
                                var _child$localTransform = child.localTransform, tx = _child$localTransform.tx, ty = _child$localTransform.ty, ta = _child$localTransform.ta, tb = _child$localTransform.tb, tc = _child$localTransform.tc, td = _child$localTransform.td;
                                var _w = child.props.w;
                                var _h = child.props.h;
                                var childMinX = tx;
                                var childMaxX = tx + _w * ta;
                                var childMinY = ty;
                                var childMaxY = ty + _h * td;
                                corners[0].x = childMinX;
                                corners[0].y = childMinY;
                                corners[1].x = childMaxX;
                                if (tb === 0 && tc === 0) {
                                    corners[1].y = childMinY;
                                    corners[2].x = childMaxX;
                                    corners[2].y = childMaxY;
                                    corners[3].x = childMinX;
                                    corners[3].y = childMaxY;
                                } else {
                                    corners[1].y = tx + _w * tc;
                                    corners[2].x = tx + _w * ta + _h * tb;
                                    corners[2].y = ty + _w * tc + _h * td;
                                    corners[3].x = tx + _h * tb;
                                    corners[3].y = ty + _h * td;
                                }
                                for (var j = 0; j < 4; j++) {
                                    var corner = corners[j];
                                    if (corner.x < minX) minX = corner.x;
                                    if (corner.y < minY) minY = corner.y;
                                    if (corner.x > maxX) maxX = corner.x;
                                    if (corner.y > maxY) maxY = corner.y;
                                }
                            }
                            this.updateType = AutosizeUpdateType.None;
                            var newWidth = maxX > 0 ? maxX : 0;
                            var newHeight = maxY > 0 ? maxY : 0;
                            applyDimensions(node, newWidth, newHeight);
                            this.lastWidth = newWidth;
                            this.lastHeight = newHeight;
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            if (this.childMap.size > 0) {
                                var _iterator5 = _createForOfIteratorHelper(this.childMap.values()), _step5;
                                try {
                                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                                        var child = _step5.value;
                                        child.parentAutosizer = null;
                                    }
                                } catch (err) {
                                    _iterator5.e(err);
                                } finally {
                                    _iterator5.f();
                                }
                            }
                            this.childMap.clear();
                            this.flaggedChildren.length = 0;
                        }
                    } ]);
                }();
                var bucketSortByZIndex = function bucketSortByZIndex(nodes, min) {
                    var buckets = [];
                    var bucketIndices = [];
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        var index = node.props.zIndex - min;
                        if (buckets[index] === undefined) {
                            buckets[index] = [];
                            bucketIndices.push(index);
                        }
                        buckets[index].push(node);
                    }
                    for (var _i = 1; _i < bucketIndices.length; _i++) {
                        var key = bucketIndices[_i];
                        var j = _i - 1;
                        while (j >= 0 && bucketIndices[j] > key) {
                            bucketIndices[j + 1] = bucketIndices[j];
                            j--;
                        }
                        bucketIndices[j + 1] = key;
                    }
                    var idx = 0;
                    for (var _i2 = 0; _i2 < bucketIndices.length; _i2++) {
                        var bucket = buckets[bucketIndices[_i2]];
                        for (var _j = 0; _j < bucket.length; _j++) {
                            nodes[idx++] = bucket[_j];
                        }
                    }
                    buckets.length = 0;
                    bucketIndices.length = 0;
                };
                var incrementalRepositionByZIndex = function incrementalRepositionByZIndex(changedNodes, nodes) {
                    for (var i = 0; i < changedNodes.length; i++) {
                        var node = changedNodes[i];
                        var currentIndex = findChildIndexById(node, nodes);
                        if (currentIndex === -1) continue;
                        var targetZIndex = node.props.zIndex;
                        var left = 0;
                        var right = nodes.length;
                        while (left < right) {
                            var mid = left + right >>> 1;
                            if (nodes[mid].props.zIndex <= targetZIndex) {
                                left = mid + 1;
                            } else {
                                right = mid;
                            }
                        }
                        var targetIndex = left > currentIndex ? left - 1 : left;
                        if (targetIndex !== currentIndex) {
                            nodes.splice(currentIndex, 1);
                            nodes.splice(targetIndex, 0, node);
                        }
                    }
                };
                var findChildIndexById = function findChildIndexById(node, children) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child._id === node._id) {
                            return i;
                        }
                    }
                    return -1;
                };
                var _removeChild = function removeChild(node, children) {
                    var index = findChildIndexById(node, children);
                    if (index !== -1) {
                        children.splice(index, 1);
                    }
                };
                var CoreNodeRenderState;
                (function(CoreNodeRenderState) {
                    CoreNodeRenderState[CoreNodeRenderState["Init"] = 0] = "Init";
                    CoreNodeRenderState[CoreNodeRenderState["OutOfBounds"] = 2] = "OutOfBounds";
                    CoreNodeRenderState[CoreNodeRenderState["InBounds"] = 4] = "InBounds";
                    CoreNodeRenderState[CoreNodeRenderState["InViewport"] = 8] = "InViewport";
                })(CoreNodeRenderState || (CoreNodeRenderState = {}));
                var NO_CLIPPING_RECT = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                    valid: false
                };
                var CoreNodeRenderStateMap = new Map;
                CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, "init");
                CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, "outOfBounds");
                CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, "inBounds");
                CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, "inViewport");
                var UpdateType;
                (function(UpdateType) {
                    UpdateType[UpdateType["Children"] = 1] = "Children";
                    UpdateType[UpdateType["Local"] = 2] = "Local";
                    UpdateType[UpdateType["Global"] = 4] = "Global";
                    UpdateType[UpdateType["Clipping"] = 8] = "Clipping";
                    UpdateType[UpdateType["SortZIndexChildren"] = 16] = "SortZIndexChildren";
                    UpdateType[UpdateType["PremultipliedColors"] = 32] = "PremultipliedColors";
                    UpdateType[UpdateType["WorldAlpha"] = 64] = "WorldAlpha";
                    UpdateType[UpdateType["RenderState"] = 128] = "RenderState";
                    UpdateType[UpdateType["IsRenderable"] = 256] = "IsRenderable";
                    UpdateType[UpdateType["RenderTexture"] = 512] = "RenderTexture";
                    UpdateType[UpdateType["ParentRenderTexture"] = 1024] = "ParentRenderTexture";
                    UpdateType[UpdateType["RenderBounds"] = 2048] = "RenderBounds";
                    UpdateType[UpdateType["RecalcUniforms"] = 4096] = "RecalcUniforms";
                    UpdateType[UpdateType["Autosize"] = 8192] = "Autosize";
                    UpdateType[UpdateType["None"] = 0] = "None";
                    UpdateType[UpdateType["All"] = 16383] = "All";
                })(UpdateType || (UpdateType = {}));
                var CoreNode = function(_EventEmitter5) {
                    function CoreNode(stage, props) {
                        var _this7;
                        _classCallCheck(this, CoreNode);
                        _this7 = _callSuper(this, CoreNode);
                        _defineProperty(_this7, "stage", void 0);
                        _defineProperty(_this7, "children", []);
                        _defineProperty(_this7, "_id", getNewId());
                        _defineProperty(_this7, "props", void 0);
                        _defineProperty(_this7, "isCoreNode", true);
                        _defineProperty(_this7, "renderOpBufferIdx", 0);
                        _defineProperty(_this7, "numQuads", 0);
                        _defineProperty(_this7, "renderOpTextures", []);
                        _defineProperty(_this7, "hasShaderUpdater", false);
                        _defineProperty(_this7, "hasShaderTimeFn", false);
                        _defineProperty(_this7, "hasColorProps", false);
                        _defineProperty(_this7, "zIndexMin", 0);
                        _defineProperty(_this7, "zIndexMax", 0);
                        _defineProperty(_this7, "previousZIndex", -1);
                        _defineProperty(_this7, "zIndexSortList", []);
                        _defineProperty(_this7, "updateType", UpdateType.All);
                        _defineProperty(_this7, "childUpdateType", UpdateType.None);
                        _defineProperty(_this7, "globalTransform", void 0);
                        _defineProperty(_this7, "localTransform", void 0);
                        _defineProperty(_this7, "sceneGlobalTransform", void 0);
                        _defineProperty(_this7, "renderCoords", void 0);
                        _defineProperty(_this7, "sceneRenderCoords", void 0);
                        _defineProperty(_this7, "renderBound", void 0);
                        _defineProperty(_this7, "strictBound", void 0);
                        _defineProperty(_this7, "preloadBound", void 0);
                        _defineProperty(_this7, "clippingRect", {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            valid: false
                        });
                        _defineProperty(_this7, "textureCoords", void 0);
                        _defineProperty(_this7, "updateShaderUniforms", false);
                        _defineProperty(_this7, "isRenderable", false);
                        _defineProperty(_this7, "renderState", CoreNodeRenderState.Init);
                        _defineProperty(_this7, "worldAlpha", 1);
                        _defineProperty(_this7, "premultipliedColorTl", 0);
                        _defineProperty(_this7, "premultipliedColorTr", 0);
                        _defineProperty(_this7, "premultipliedColorBl", 0);
                        _defineProperty(_this7, "premultipliedColorBr", 0);
                        _defineProperty(_this7, "calcZIndex", 0);
                        _defineProperty(_this7, "hasRTTupdates", false);
                        _defineProperty(_this7, "parentHasRenderTexture", false);
                        _defineProperty(_this7, "rttParent", null);
                        _defineProperty(_this7, "framebufferDimensions", null);
                        _defineProperty(_this7, "autosizer", null);
                        _defineProperty(_this7, "parentAutosizer", null);
                        _defineProperty(_this7, "destroyed", false);
                        _defineProperty(_this7, "loadTextureTask", function() {
                            var _this7$props$textureO, _this7$props$textureO2;
                            var texture = _this7.props.texture;
                            if (texture === null) {
                                return;
                            }
                            if (_this7.textureOptions.preload === true) {
                                _this7.stage.txManager.loadTexture(texture);
                            }
                            texture.preventCleanup = (_this7$props$textureO = (_this7$props$textureO2 = _this7.props.textureOptions) === null || _this7$props$textureO2 === void 0 ? void 0 : _this7$props$textureO2.preventCleanup) !== null && _this7$props$textureO !== void 0 ? _this7$props$textureO : false;
                            texture.on("loaded", _this7.onTextureLoaded);
                            texture.on("failed", _this7.onTextureFailed);
                            texture.on("freed", _this7.onTextureFreed);
                            if (_this7.parentHasRenderTexture) {
                                _this7.notifyParentRTTOfUpdate();
                                return;
                            }
                            if (texture.state === "loaded") {
                                _this7.onTextureLoaded(texture, texture.dimensions);
                            } else if (texture.state === "failed") {
                                _this7.onTextureFailed(texture, texture.error);
                            } else if (texture.state === "freed") {
                                _this7.onTextureFreed(texture);
                            }
                        });
                        _defineProperty(_this7, "onTextureLoaded", function(_, dimensions) {
                            var _this7$props$textureO3;
                            if (_this7.autosizer !== null) {
                                _this7.autosizer.update();
                            }
                            _this7.setUpdateType(UpdateType.IsRenderable);
                            _this7.stage.requestRender();
                            if (_this7.parentHasRenderTexture) {
                                _this7.notifyParentRTTOfUpdate();
                            }
                            if (dimensions.w > 1 && dimensions.h > 1) {
                                _this7.emit("loaded", {
                                    type: "texture",
                                    dimensions: dimensions
                                });
                            }
                            if (_this7.stage.calculateTextureCoord === true && _this7.props.textureOptions !== null) {
                                _this7.textureCoords = _this7.stage.renderer.getTextureCoords(_this7);
                            }
                            if (((_this7$props$textureO3 = _this7.props.textureOptions) === null || _this7$props$textureO3 === void 0 || (_this7$props$textureO3 = _this7$props$textureO3.resizeMode) === null || _this7$props$textureO3 === void 0 ? void 0 : _this7$props$textureO3.type) === "contain") {
                                _this7.setUpdateType(UpdateType.Local);
                            }
                        });
                        _defineProperty(_this7, "onTextureFailed", function(_, error) {
                            _this7.isRenderable = false;
                            _this7.updateTextureOwnership(false);
                            _this7.setUpdateType(UpdateType.IsRenderable);
                            if (_this7.parentHasRenderTexture) {
                                _this7.notifyParentRTTOfUpdate();
                            }
                            if (_this7.texture !== null && _this7.texture.retryCount > _this7.texture.maxRetryCount) {
                                _this7.emit("failed", {
                                    type: "texture",
                                    error: error
                                });
                            }
                        });
                        _defineProperty(_this7, "onTextureFreed", function() {
                            _this7.isRenderable = false;
                            _this7.updateTextureOwnership(false);
                            _this7.setUpdateType(UpdateType.IsRenderable);
                            if (_this7.parentHasRenderTexture) {
                                _this7.notifyParentRTTOfUpdate();
                            }
                            _this7.emit("freed", {
                                type: "texture"
                            });
                        });
                        _this7.stage = stage;
                        var p = _this7.props = {};
                        _this7.renderOpTextures = [];
                        var initialUpdateType = UpdateType.Local | UpdateType.RenderBounds | UpdateType.RenderState;
                        p.x = props.x;
                        p.y = props.y;
                        p.w = props.w;
                        p.h = props.h;
                        p.alpha = props.alpha;
                        p.autosize = props.autosize;
                        p.clipping = props.clipping;
                        p.color = props.color;
                        p.colorTop = props.colorTop;
                        p.colorBottom = props.colorBottom;
                        p.colorLeft = props.colorLeft;
                        p.colorRight = props.colorRight;
                        p.colorTl = props.colorTl;
                        p.colorTr = props.colorTr;
                        p.colorBl = props.colorBl;
                        p.colorBr = props.colorBr;
                        if (props.color > 0 || props.colorTop > 0 || props.colorBottom > 0 || props.colorLeft > 0 || props.colorRight > 0 || props.colorTl > 0 || props.colorTr > 0 || props.colorBl > 0 || props.colorBr > 0) {
                            _this7.hasColorProps = true;
                            initialUpdateType |= UpdateType.PremultipliedColors;
                        }
                        p.scaleX = props.scaleX;
                        p.scaleY = props.scaleY;
                        p.rotation = props.rotation;
                        p.pivotX = props.pivotX;
                        p.pivotY = props.pivotY;
                        p.mountX = props.mountX;
                        p.mountY = props.mountY;
                        p.mount = props.mount;
                        p.pivot = props.pivot;
                        p.zIndex = props.zIndex;
                        p.textureOptions = props.textureOptions;
                        p.data = props.data;
                        p.imageType = props.imageType;
                        p.srcX = props.srcX;
                        p.srcY = props.srcY;
                        p.srcWidth = props.srcWidth;
                        p.srcHeight = props.srcHeight;
                        p.autosize = props.autosize;
                        p.parent = props.parent;
                        p.texture = null;
                        p.shader = null;
                        p.src = null;
                        p.rtt = false;
                        p.boundsMargin = null;
                        if (props.zIndex !== 0) {
                            _this7.zIndex = props.zIndex;
                        }
                        if (props.parent !== null) {
                            props.parent.addChild(_this7);
                        }
                        _this7.texture = props.texture;
                        _this7.shader = props.shader;
                        _this7.src = props.src;
                        _this7.rtt = props.rtt;
                        _this7.boundsMargin = props.boundsMargin;
                        _this7.interactive = props.interactive;
                        if (p.autosize === true) {
                            _this7.autosizer = new Autosizer(_this7);
                        }
                        _this7.setUpdateType(initialUpdateType);
                        var dt = _this7.stage.defaultTexture;
                        if (dt !== null && dt.state !== "loaded") {
                            dt.once("loaded", function() {
                                return _this7.setUpdateType(UpdateType.IsRenderable);
                            });
                        }
                        return _this7;
                    }
                    _inherits(CoreNode, _EventEmitter5);
                    return _createClass(CoreNode, [ {
                        key: "loadTexture",
                        value: function loadTexture() {
                            if (this.props.texture === null) {
                                return;
                            }
                            queueMicrotask(this.loadTextureTask);
                        }
                    }, {
                        key: "unloadTexture",
                        value: function unloadTexture() {
                            if (this.texture === null) {
                                return;
                            }
                            var texture = this.texture;
                            texture.off("loaded", this.onTextureLoaded);
                            texture.off("failed", this.onTextureFailed);
                            texture.off("freed", this.onTextureFreed);
                            texture.setRenderableOwner(this._id, false);
                        }
                    }, {
                        key: "setUpdateType",
                        value: function setUpdateType(type) {
                            this.updateType |= type;
                            var parent = this.props.parent;
                            if (!parent || parent.updateType & UpdateType.Children) return;
                            parent.setUpdateType(UpdateType.Children);
                        }
                    }, {
                        key: "updateLocalTransform",
                        value: function updateLocalTransform() {
                            var _p$textureOptions$res;
                            var p = this.props;
                            var x = p.x, y = p.y, w = p.w, h = p.h;
                            var mountTranslateX = p.mountX * w;
                            var mountTranslateY = p.mountY * h;
                            if (p.rotation !== 0 || p.scaleX !== 1 || p.scaleY !== 1) {
                                var scaleRotate = Matrix3d.rotate(p.rotation, Matrix3d.temp).scale(p.scaleX, p.scaleY);
                                var pivotTranslateX = p.pivotX * w;
                                var pivotTranslateY = p.pivotY * h;
                                this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(scaleRotate).translate(-pivotTranslateX, -pivotTranslateY);
                            } else {
                                this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
                            }
                            var texture = p.texture;
                            if (texture && texture.dimensions && ((_p$textureOptions$res = p.textureOptions.resizeMode) === null || _p$textureOptions$res === void 0 ? void 0 : _p$textureOptions$res.type) === "contain") {
                                var resizeModeScaleX = 1;
                                var resizeModeScaleY = 1;
                                var extraX = 0;
                                var extraY = 0;
                                var _texture$dimensions = texture.dimensions, tw = _texture$dimensions.w, th = _texture$dimensions.h;
                                var txAspectRatio = tw / th;
                                var nodeAspectRatio = w / h;
                                if (txAspectRatio > nodeAspectRatio) {
                                    var scaleX = w / tw;
                                    var scaledTxHeight = th * scaleX;
                                    extraY = (h - scaledTxHeight) / 2;
                                    resizeModeScaleY = scaledTxHeight / h;
                                } else {
                                    var scaleY = h / th;
                                    var scaledTxWidth = tw * scaleY;
                                    extraX = (w - scaledTxWidth) / 2;
                                    resizeModeScaleX = scaledTxWidth / w;
                                }
                                this.localTransform.translate(extraX, extraY).scale(resizeModeScaleX, resizeModeScaleY);
                            }
                        }
                    }, {
                        key: "update",
                        value: function update(delta, parentClippingRect) {
                            var props = this.props;
                            var parent = props.parent;
                            var parentHasRenderTexture = this.parentHasRenderTexture;
                            var newRenderState = null;
                            var updateType = this.updateType;
                            var childUpdateType = this.childUpdateType;
                            if (updateType & UpdateType.Autosize && this.autosizer !== null) {
                                this.autosizer.update();
                            }
                            this.updateType = 0;
                            this.childUpdateType = 0;
                            if (updateType & UpdateType.Local) {
                                this.updateLocalTransform();
                                updateType |= UpdateType.Global;
                            }
                            if (updateType & UpdateType.RenderTexture && this.rtt === true) {
                                this.hasRTTupdates = true;
                            }
                            if (updateType & UpdateType.Global) {
                                if (this.parentHasRenderTexture === true && parent.rtt === true) {
                                    this.globalTransform = Matrix3d.identity(this.globalTransform);
                                    var parentTransform = parent.globalTransform || Matrix3d.identity(Matrix3d.temp);
                                    this.sceneGlobalTransform = Matrix3d.copy(parentTransform, this.sceneGlobalTransform).translateOrMultiply(this.localTransform);
                                } else if (this.parentHasRenderTexture === true && parent.rtt === false) {
                                    var parentSceneTransform = parent.sceneGlobalTransform || this.localTransform;
                                    this.sceneGlobalTransform = Matrix3d.copy(parentSceneTransform, this.sceneGlobalTransform).translateOrMultiply(this.localTransform);
                                    this.globalTransform = Matrix3d.copy(parent.globalTransform || this.localTransform, this.globalTransform);
                                } else {
                                    this.globalTransform = Matrix3d.copy(parent.globalTransform || this.localTransform, this.globalTransform);
                                }
                                this.globalTransform.translateOrMultiply(this.localTransform);
                                this.calculateRenderCoords();
                                this.updateBoundingRect();
                                updateType |= UpdateType.RenderState | UpdateType.RecalcUniforms;
                                if ((updateType & UpdateType.Autosize) === 0) {
                                    updateType |= UpdateType.Children;
                                    childUpdateType |= UpdateType.Global;
                                }
                                if (this.clipping === true) {
                                    updateType |= UpdateType.Clipping | UpdateType.RenderBounds;
                                    childUpdateType |= UpdateType.RenderBounds;
                                }
                            }
                            if (updateType & UpdateType.RenderBounds) {
                                this.createRenderBounds();
                                updateType |= UpdateType.RenderState | UpdateType.Children;
                                childUpdateType |= UpdateType.RenderBounds;
                            }
                            if (updateType & UpdateType.RenderState) {
                                newRenderState = this.checkRenderBounds();
                                updateType |= UpdateType.IsRenderable;
                                if (newRenderState !== CoreNodeRenderState.OutOfBounds) {
                                    this.updateRenderState(newRenderState);
                                }
                            }
                            if (updateType & UpdateType.WorldAlpha) {
                                this.worldAlpha = parent.worldAlpha * this.props.alpha;
                                updateType |= UpdateType.PremultipliedColors | UpdateType.Children | UpdateType.IsRenderable;
                                childUpdateType |= UpdateType.WorldAlpha;
                            }
                            if (updateType & UpdateType.IsRenderable) {
                                this.updateIsRenderable();
                            }
                            if (updateType & UpdateType.Global && this.isRenderable === true && this.parentAutosizer !== null) {
                                this.parentAutosizer.patch(this.id);
                            }
                            if (updateType & UpdateType.Clipping) {
                                this.calculateClippingRect(parentClippingRect);
                                updateType |= UpdateType.Children;
                                childUpdateType |= UpdateType.Clipping | UpdateType.RenderBounds;
                            }
                            if (updateType & UpdateType.PremultipliedColors) {
                                var alpha = this.worldAlpha;
                                var tl = props.colorTl;
                                var tr = props.colorTr;
                                var bl = props.colorBl;
                                var br = props.colorBr;
                                var same = tl === tr && tl === bl && tl === br;
                                var merged = mergeColorAlphaPremultiplied(tl, alpha, true);
                                this.premultipliedColorTl = merged;
                                if (same === true) {
                                    this.premultipliedColorTr = this.premultipliedColorBl = this.premultipliedColorBr = merged;
                                } else {
                                    this.premultipliedColorTr = mergeColorAlphaPremultiplied(tr, alpha, true);
                                    this.premultipliedColorBl = mergeColorAlphaPremultiplied(bl, alpha, true);
                                    this.premultipliedColorBr = mergeColorAlphaPremultiplied(br, alpha, true);
                                }
                            }
                            if (this.renderState === CoreNodeRenderState.OutOfBounds) {
                                this.updateType = updateType;
                                this.childUpdateType = childUpdateType;
                                return;
                            }
                            if (updateType & UpdateType.RecalcUniforms && this.hasShaderUpdater === true) {
                                this.updateShaderUniforms = true;
                            }
                            if (this.isRenderable === true && this.updateShaderUniforms === true) {
                                this.updateShaderUniforms = false;
                                this.shader.update();
                            }
                            if (updateType & UpdateType.Children && this.children.length > 0) {
                                var childClippingRect = this.clippingRect;
                                if (this.rtt === true) {
                                    childClippingRect = NO_CLIPPING_RECT;
                                }
                                for (var i = 0, length = this.children.length; i < length; i++) {
                                    var child = this.children[i];
                                    if (childUpdateType !== 0) {
                                        child.setUpdateType(childUpdateType);
                                    }
                                    if (child.updateType === 0) {
                                        continue;
                                    }
                                    child.update(delta, childClippingRect);
                                }
                            }
                            if (parentHasRenderTexture === true) {
                                this.notifyParentRTTOfUpdate();
                            }
                            if (updateType & UpdateType.SortZIndexChildren) {
                                this.sortChildren();
                            }
                            if (newRenderState === CoreNodeRenderState.OutOfBounds) {
                                this.updateRenderState(newRenderState);
                                this.updateIsRenderable();
                                if (this.rtt === true && newRenderState === CoreNodeRenderState.OutOfBounds) {
                                    this.notifyChildrenRTTOfUpdate(newRenderState);
                                }
                            }
                        }
                    }, {
                        key: "findParentRTTNode",
                        value: function findParentRTTNode() {
                            var rttNode = this.parent;
                            while (rttNode && !rttNode.rtt) {
                                rttNode = rttNode.parent;
                            }
                            return rttNode;
                        }
                    }, {
                        key: "notifyChildrenRTTOfUpdate",
                        value: function notifyChildrenRTTOfUpdate(renderState) {
                            var _iterator6 = _createForOfIteratorHelper(this.children), _step6;
                            try {
                                for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                                    var child = _step6.value;
                                    child.updateRenderState(renderState);
                                    child.updateIsRenderable();
                                    child.notifyChildrenRTTOfUpdate(renderState);
                                }
                            } catch (err) {
                                _iterator6.e(err);
                            } finally {
                                _iterator6.f();
                            }
                        }
                    }, {
                        key: "notifyParentRTTOfUpdate",
                        value: function notifyParentRTTOfUpdate() {
                            if (this.parent === null) {
                                return;
                            }
                            var rttNode = this.rttParent || this.findParentRTTNode();
                            if (!rttNode) {
                                return;
                            }
                            rttNode.hasRTTupdates = true;
                            rttNode.setUpdateType(UpdateType.RenderTexture);
                            if (rttNode.parentHasRenderTexture === true) {
                                rttNode.notifyParentRTTOfUpdate();
                            }
                        }
                    }, {
                        key: "checkRenderBounds",
                        value: function checkRenderBounds() {
                            if (boundInsideBound(this.renderBound, this.strictBound)) {
                                return CoreNodeRenderState.InViewport;
                            }
                            if (boundInsideBound(this.renderBound, this.preloadBound)) {
                                return CoreNodeRenderState.InBounds;
                            }
                            if (boundLargeThanBound(this.renderBound, this.strictBound)) {
                                return CoreNodeRenderState.InViewport;
                            }
                            if (this.parent !== null && (this.props.w === 0 || this.props.h === 0)) {
                                return this.parent.renderState;
                            }
                            return CoreNodeRenderState.OutOfBounds;
                        }
                    }, {
                        key: "updateBoundingRect",
                        value: function updateBoundingRect() {
                            var transform = this.sceneGlobalTransform || this.globalTransform;
                            var renderCoords = this.sceneRenderCoords || this.renderCoords;
                            if (transform.tb === 0 || transform.tc === 0) {
                                this.renderBound = createBound(renderCoords.x1, renderCoords.y1, renderCoords.x3, renderCoords.y3, this.renderBound);
                            } else {
                                var x1 = renderCoords.x1, y1 = renderCoords.y1, x2 = renderCoords.x2, y2 = renderCoords.y2, x3 = renderCoords.x3, y3 = renderCoords.y3, x4 = renderCoords.x4, y4 = renderCoords.y4;
                                this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
                            }
                        }
                    }, {
                        key: "createRenderBounds",
                        value: function createRenderBounds() {
                            if (this.parent !== null && this.parent.strictBound !== undefined) {
                                var parentBound = this.parent.strictBound;
                                this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
                                this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
                            } else {
                                this.strictBound = this.stage.strictBound;
                                this.preloadBound = this.stage.preloadBound;
                            }
                            if (this.props.clipping === false) {
                                return;
                            }
                            if (this.renderBound === undefined) {
                                return;
                            }
                            if (boundInsideBound(this.renderBound, this.strictBound) === false) {
                                return;
                            }
                            var _this$props = this.props, x = _this$props.x, y = _this$props.y, w = _this$props.w, h = _this$props.h;
                            var _ref = this.sceneGlobalTransform || this.globalTransform || {}, tx = _ref.tx, ty = _ref.ty;
                            var _x = tx !== null && tx !== void 0 ? tx : x;
                            var _y = ty !== null && ty !== void 0 ? ty : y;
                            this.strictBound = createBound(_x, _y, _x + w, _y + h, this.strictBound);
                            this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
                        }
                    }, {
                        key: "updateRenderState",
                        value: function updateRenderState(renderState) {
                            if (renderState === this.renderState) {
                                return;
                            }
                            var previous = this.renderState;
                            this.renderState = renderState;
                            var event = CoreNodeRenderStateMap.get(renderState);
                            this.emit(event, {
                                previous: previous,
                                current: renderState
                            });
                        }
                    }, {
                        key: "checkBasicRenderability",
                        value: function checkBasicRenderability() {
                            if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
                                return false;
                            } else {
                                return true;
                            }
                        }
                    }, {
                        key: "updateIsRenderable",
                        value: function updateIsRenderable() {
                            var newIsRenderable = false;
                            var needsTextureOwnership = false;
                            if (this.checkBasicRenderability() === false) {
                                this.updateTextureOwnership(false);
                                this.setRenderable(false);
                                return;
                            }
                            if (this.texture !== null) {
                                if (this.texture.retryCount > this.texture.maxRetryCount) {
                                    this.updateTextureOwnership(false);
                                    this.setRenderable(false);
                                    return;
                                }
                                needsTextureOwnership = true;
                                newIsRenderable = this.texture.state === "loaded";
                            } else if ((this.props.shader !== this.stage.renderer.getDefaultShaderNode() || this.hasColorProps === true) && this.hasDimensions() === true) {
                                if (this.stage.defaultTexture && this.stage.defaultTexture.state === "loaded") {
                                    newIsRenderable = true;
                                }
                            }
                            this.updateTextureOwnership(needsTextureOwnership);
                            this.setRenderable(newIsRenderable);
                        }
                    }, {
                        key: "setRenderable",
                        value: function setRenderable(isRenderable) {
                            var previousIsRenderable = this.isRenderable;
                            this.isRenderable = isRenderable;
                            if (previousIsRenderable !== isRenderable) {
                                this.emit("renderable", {
                                    type: "renderable",
                                    isRenderable: isRenderable
                                });
                            }
                        }
                    }, {
                        key: "updateTextureOwnership",
                        value: function updateTextureOwnership(isRenderable) {
                            var _this$texture;
                            (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.setRenderableOwner(this._id, isRenderable);
                        }
                    }, {
                        key: "isOutOfBounds",
                        value: function isOutOfBounds() {
                            return this.renderState <= CoreNodeRenderState.OutOfBounds;
                        }
                    }, {
                        key: "hasDimensions",
                        value: function hasDimensions() {
                            return this.props.w !== 0 && this.props.h !== 0;
                        }
                    }, {
                        key: "calculateRenderCoords",
                        value: function calculateRenderCoords() {
                            var _this$props2 = this.props, w = _this$props2.w, h = _this$props2.h;
                            var g = this.globalTransform;
                            var tx = g.tx, ty = g.ty, ta = g.ta, tb = g.tb, tc = g.tc, td = g.td;
                            if (tb === 0 && tc === 0) {
                                var minX = tx;
                                var maxX = tx + w * ta;
                                var minY = ty;
                                var maxY = ty + h * td;
                                this.renderCoords = RenderCoords.translate(minX, minY, maxX, minY, maxX, maxY, minX, maxY, this.renderCoords);
                            } else {
                                this.renderCoords = RenderCoords.translate(tx, ty, tx + w * ta, ty + w * tc, tx + w * ta + h * tb, ty + w * tc + h * td, tx + h * tb, ty + h * td, this.renderCoords);
                            }
                            if (this.sceneGlobalTransform === undefined) {
                                return;
                            }
                            var _this$sceneGlobalTran = this.sceneGlobalTransform, stx = _this$sceneGlobalTran.tx, sty = _this$sceneGlobalTran.ty, sta = _this$sceneGlobalTran.ta, stb = _this$sceneGlobalTran.tb, stc = _this$sceneGlobalTran.tc, std = _this$sceneGlobalTran.td;
                            if (stb === 0 && stc === 0) {
                                var _minX = stx;
                                var _maxX = stx + w * sta;
                                var _minY = sty;
                                var _maxY = sty + h * std;
                                this.sceneRenderCoords = RenderCoords.translate(_minX, _minY, _maxX, _minY, _maxX, _maxY, _minX, _maxY, this.sceneRenderCoords);
                            } else {
                                this.sceneRenderCoords = RenderCoords.translate(stx, sty, stx + w * sta, sty + w * stc, stx + w * sta + h * stb, sty + w * stc + h * std, stx + h * stb, sty + h * std, this.sceneRenderCoords);
                            }
                        }
                    }, {
                        key: "calculateClippingRect",
                        value: function calculateClippingRect(parentClippingRect) {
                            var clippingRect = this.clippingRect, props = this.props, gt = this.globalTransform;
                            var clipping = props.clipping;
                            var isRotated = gt.tb !== 0 || gt.tc !== 0;
                            if (clipping === true && isRotated === false) {
                                clippingRect.x = gt.tx;
                                clippingRect.y = gt.ty;
                                clippingRect.width = this.props.w * gt.ta;
                                clippingRect.height = this.props.h * gt.td;
                                clippingRect.valid = true;
                            } else {
                                clippingRect.valid = false;
                            }
                            if (parentClippingRect.valid === true && clippingRect.valid === true) {
                                intersectRect(parentClippingRect, clippingRect, clippingRect);
                            } else if (parentClippingRect.valid === true) {
                                copyRect(parentClippingRect, clippingRect);
                                clippingRect.valid = true;
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            if (this.destroyed === true) {
                                return;
                            }
                            this.removeAllListeners();
                            this.destroyed = true;
                            this.unloadTexture();
                            this.isRenderable = false;
                            if (this.hasShaderTimeFn === true) {
                                this.stage.untrackTimedNode(this);
                            }
                            while (this.children.length > 0) {
                                this.children[0].destroy();
                            }
                            var parent = this.parent;
                            if (parent !== null) {
                                parent.removeChild(this);
                            }
                            this.props.parent = null;
                            this.props.texture = null;
                            if (this.rtt === true) {
                                this.stage.renderer.removeRTTNode(this);
                            }
                            this.stage.requestRender();
                        }
                    }, {
                        key: "renderQuads",
                        value: function renderQuads(renderer) {
                            if (this.parentHasRenderTexture === true) {
                                var rtt = renderer.renderToTextureActive;
                                if (rtt === false || this.parentRenderTexture !== renderer.activeRttNode) return;
                            }
                            if (this.renderTexture.state !== "loaded") {
                                return;
                            }
                            renderer.addQuad(this);
                        }
                    }, {
                        key: "renderTexture",
                        get: function get() {
                            return this.props.texture || this.stage.defaultTexture;
                        }
                    }, {
                        key: "renderTextureCoords",
                        get: function get() {
                            return this.textureCoords || this.stage.renderer.defaultTextureCoords;
                        }
                    }, {
                        key: "quadBufferCollection",
                        get: function get() {
                            return this.stage.renderer.quadBufferCollection;
                        }
                    }, {
                        key: "width",
                        get: function get() {
                            return this.props.w;
                        }
                    }, {
                        key: "height",
                        get: function get() {
                            return this.props.h;
                        }
                    }, {
                        key: "time",
                        get: function get() {
                            if (this.hasShaderTimeFn === true) {
                                return this.getTimerValue();
                            }
                            return 0;
                        }
                    }, {
                        key: "getTimerValue",
                        value: function getTimerValue() {
                            if (typeof this.shader.time === "function") {
                                return this.shader.time(this.stage);
                            }
                            return this.stage.elapsedTime;
                        }
                    }, {
                        key: "sortChildren",
                        value: function sortChildren() {
                            var changedCount = this.zIndexSortList.length;
                            if (changedCount === 0) {
                                return;
                            }
                            var children = this.children;
                            var min = Infinity;
                            var max = -Infinity;
                            for (var i = 0; i < children.length; i++) {
                                var zIndex = children[i].props.zIndex;
                                if (zIndex < min) {
                                    min = zIndex;
                                }
                                if (zIndex > max) {
                                    max = zIndex;
                                }
                            }
                            this.zIndexMin = min;
                            this.zIndexMax = max;
                            if (min === max) {
                                return;
                            }
                            var n = children.length;
                            var useIncremental = changedCount <= 2 || changedCount < n * .05;
                            if (useIncremental === true) {
                                incrementalRepositionByZIndex(this.zIndexSortList, children);
                            } else {
                                bucketSortByZIndex(children, min);
                            }
                            this.zIndexSortList.length = 0;
                            this.zIndexSortList = [];
                        }
                    }, {
                        key: "removeChild",
                        value: function removeChild(node) {
                            var targetParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                            if (targetParent === null) {
                                if (this.props.rtt === true && this.parentHasRenderTexture === true) {
                                    node.clearRTTInheritance();
                                }
                                var autosizeTarget = this.autosizer || this.parentAutosizer;
                                if (autosizeTarget !== null) {
                                    autosizeTarget.detach(node);
                                }
                            }
                            _removeChild(node, this.children);
                        }
                    }, {
                        key: "addChild",
                        value: function addChild(node) {
                            var previousParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                            var inRttCluster = this.props.rtt === true || this.parentHasRenderTexture === true;
                            var children = this.children;
                            var min = this.zIndexMin;
                            var max = this.zIndexMax;
                            var zIndex = node.zIndex;
                            var autosizeTarget = this.autosizer || this.parentAutosizer;
                            var attachToAutosizer = autosizeTarget !== null;
                            node.parentHasRenderTexture = inRttCluster;
                            if (previousParent !== null) {
                                var previousParentInRttCluster = previousParent.props.rtt === true || previousParent.parentHasRenderTexture === true;
                                if (inRttCluster === false && previousParentInRttCluster === true) {
                                    node.clearRTTInheritance();
                                }
                                var previousAutosizer = node.autosizer || node.parentAutosizer;
                                if (previousAutosizer !== null) {
                                    if (autosizeTarget === null || previousAutosizer.id !== autosizeTarget.id) {
                                        previousAutosizer.detach(node);
                                    }
                                    attachToAutosizer = false;
                                }
                            }
                            if (attachToAutosizer === true) {
                                autosizeTarget.attach(node);
                            }
                            if (inRttCluster === true) {
                                node.markChildrenWithRTT(this);
                            }
                            children.push(node);
                            if (min !== max || zIndex !== min && zIndex !== max) {
                                this.zIndexSortList.push(node);
                                this.setUpdateType(UpdateType.SortZIndexChildren);
                            }
                            this.setUpdateType(UpdateType.Children);
                        }
                    }, {
                        key: "id",
                        get: function get() {
                            return this._id;
                        }
                    }, {
                        key: "data",
                        get: function get() {
                            return this.props.data;
                        },
                        set: function set(d) {
                            this.props.data = d;
                        }
                    }, {
                        key: "x",
                        get: function get() {
                            return this.props.x;
                        },
                        set: function set(value) {
                            if (this.props.x !== value) {
                                this.props.x = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "absX",
                        get: function get() {
                            var _this$props$parent, _this$props$parent2;
                            return this.props.x + -this.props.w * this.props.mountX + (((_this$props$parent = this.props.parent) === null || _this$props$parent === void 0 ? void 0 : _this$props$parent.absX) || ((_this$props$parent2 = this.props.parent) === null || _this$props$parent2 === void 0 || (_this$props$parent2 = _this$props$parent2.globalTransform) === null || _this$props$parent2 === void 0 ? void 0 : _this$props$parent2.tx) || 0);
                        }
                    }, {
                        key: "absY",
                        get: function get() {
                            var _this$props$parent$ab, _this$props$parent3;
                            return this.props.y + -this.props.h * this.props.mountY + ((_this$props$parent$ab = (_this$props$parent3 = this.props.parent) === null || _this$props$parent3 === void 0 ? void 0 : _this$props$parent3.absY) !== null && _this$props$parent$ab !== void 0 ? _this$props$parent$ab : 0);
                        }
                    }, {
                        key: "y",
                        get: function get() {
                            return this.props.y;
                        },
                        set: function set(value) {
                            if (this.props.y !== value) {
                                this.props.y = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "w",
                        get: function get() {
                            return this.props.w;
                        },
                        set: function set(value) {
                            var props = this.props;
                            if (props.w !== value) {
                                props.w = value;
                                var updateType = UpdateType.Local;
                                if (props.texture !== null && this.stage.calculateTextureCoord === true && props.textureOptions !== null) {
                                    this.textureCoords = this.stage.renderer.getTextureCoords(this);
                                }
                                if (props.rtt === true) {
                                    this.framebufferDimensions.w = value;
                                    this.texture = this.stage.txManager.createTexture("RenderTexture", this.framebufferDimensions);
                                    updateType |= UpdateType.RenderTexture;
                                }
                                this.setUpdateType(updateType);
                            }
                        }
                    }, {
                        key: "h",
                        get: function get() {
                            return this.props.h;
                        },
                        set: function set(value) {
                            var props = this.props;
                            if (props.h !== value) {
                                props.h = value;
                                var updateType = UpdateType.Local;
                                if (props.texture !== null && this.stage.calculateTextureCoord === true && props.textureOptions !== null) {
                                    this.textureCoords = this.stage.renderer.getTextureCoords(this);
                                }
                                if (props.rtt === true) {
                                    this.framebufferDimensions.h = value;
                                    this.texture = this.stage.txManager.createTexture("RenderTexture", this.framebufferDimensions);
                                    updateType |= UpdateType.RenderTexture;
                                }
                                this.setUpdateType(updateType);
                            }
                        }
                    }, {
                        key: "scale",
                        get: function get() {
                            return this.scaleX;
                        },
                        set: function set(value) {
                            this.scaleX = value;
                            this.scaleY = value;
                        }
                    }, {
                        key: "scaleX",
                        get: function get() {
                            return this.props.scaleX;
                        },
                        set: function set(value) {
                            if (this.props.scaleX !== value) {
                                this.props.scaleX = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "scaleY",
                        get: function get() {
                            return this.props.scaleY;
                        },
                        set: function set(value) {
                            if (this.props.scaleY !== value) {
                                this.props.scaleY = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "mount",
                        get: function get() {
                            return this.props.mount;
                        },
                        set: function set(value) {
                            if (this.props.mountX !== value || this.props.mountY !== value) {
                                this.props.mountX = value;
                                this.props.mountY = value;
                                this.props.mount = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "mountX",
                        get: function get() {
                            return this.props.mountX;
                        },
                        set: function set(value) {
                            if (this.props.mountX !== value) {
                                this.props.mountX = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "mountY",
                        get: function get() {
                            return this.props.mountY;
                        },
                        set: function set(value) {
                            if (this.props.mountY !== value) {
                                this.props.mountY = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "pivot",
                        get: function get() {
                            return this.props.pivot;
                        },
                        set: function set(value) {
                            if (this.props.pivotX !== value || this.props.pivotY !== value) {
                                this.props.pivotX = value;
                                this.props.pivotY = value;
                                this.props.pivot = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "pivotX",
                        get: function get() {
                            return this.props.pivotX;
                        },
                        set: function set(value) {
                            if (this.props.pivotX !== value) {
                                this.props.pivotX = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "pivotY",
                        get: function get() {
                            return this.props.pivotY;
                        },
                        set: function set(value) {
                            if (this.props.pivotY !== value) {
                                this.props.pivotY = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "rotation",
                        get: function get() {
                            return this.props.rotation;
                        },
                        set: function set(value) {
                            if (this.props.rotation !== value) {
                                this.props.rotation = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "alpha",
                        get: function get() {
                            return this.props.alpha;
                        },
                        set: function set(value) {
                            this.props.alpha = value;
                            this.setUpdateType(UpdateType.PremultipliedColors | UpdateType.WorldAlpha | UpdateType.Children | UpdateType.IsRenderable);
                            this.childUpdateType |= UpdateType.WorldAlpha;
                        }
                    }, {
                        key: "autosize",
                        get: function get() {
                            return this.props.autosize;
                        },
                        set: function set(value) {
                            if (this.props.autosize === value) {
                                return;
                            }
                            this.props.autosize = value;
                            if (value === true && this.autosizer === null) {
                                this.autosizer = new Autosizer(this);
                            } else {
                                this.autosizer = null;
                            }
                        }
                    }, {
                        key: "boundsMargin",
                        get: function get() {
                            var props = this.props;
                            if (props.boundsMargin !== null) {
                                return props.boundsMargin;
                            }
                            var parent = this.parent;
                            if (parent !== null) {
                                var margin = parent.boundsMargin;
                                if (margin !== undefined) {
                                    return margin;
                                }
                            }
                            return this.stage.boundsMargin;
                        },
                        set: function set(value) {
                            if (value === this.props.boundsMargin) {
                                return;
                            }
                            if (value === null) {
                                this.props.boundsMargin = value;
                            } else {
                                var bm = Array.isArray(value) ? value : [ value, value, value, value ];
                                this.props.boundsMargin = bm;
                            }
                            this.setUpdateType(UpdateType.RenderBounds);
                        }
                    }, {
                        key: "clipping",
                        get: function get() {
                            return this.props.clipping;
                        },
                        set: function set(value) {
                            this.props.clipping = value;
                            this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
                            this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
                        }
                    }, {
                        key: "color",
                        get: function get() {
                            return this.props.color;
                        },
                        set: function set(value) {
                            var p = this.props;
                            if (p.color === value) return;
                            p.color = value;
                            var has = value > 0;
                            this.hasColorProps = has;
                            if (p.colorTop !== value) this.colorTop = value;
                            if (p.colorBottom !== value) this.colorBottom = value;
                            if (p.colorLeft !== value) this.colorLeft = value;
                            if (p.colorRight !== value) this.colorRight = value;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorTop",
                        get: function get() {
                            return this.props.colorTop;
                        },
                        set: function set(value) {
                            if (this.props.colorTl !== value || this.props.colorTr !== value) {
                                this.colorTl = value;
                                this.colorTr = value;
                            }
                            this.props.colorTop = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorBottom",
                        get: function get() {
                            return this.props.colorBottom;
                        },
                        set: function set(value) {
                            if (this.props.colorBl !== value || this.props.colorBr !== value) {
                                this.colorBl = value;
                                this.colorBr = value;
                            }
                            this.props.colorBottom = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorLeft",
                        get: function get() {
                            return this.props.colorLeft;
                        },
                        set: function set(value) {
                            if (this.props.colorTl !== value || this.props.colorBl !== value) {
                                this.colorTl = value;
                                this.colorBl = value;
                            }
                            this.props.colorLeft = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorRight",
                        get: function get() {
                            return this.props.colorRight;
                        },
                        set: function set(value) {
                            if (this.props.colorTr !== value || this.props.colorBr !== value) {
                                this.colorTr = value;
                                this.colorBr = value;
                            }
                            this.props.colorRight = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorTl",
                        get: function get() {
                            return this.props.colorTl;
                        },
                        set: function set(value) {
                            this.props.colorTl = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorTr",
                        get: function get() {
                            return this.props.colorTr;
                        },
                        set: function set(value) {
                            this.props.colorTr = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorBl",
                        get: function get() {
                            return this.props.colorBl;
                        },
                        set: function set(value) {
                            this.props.colorBl = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "colorBr",
                        get: function get() {
                            return this.props.colorBr;
                        },
                        set: function set(value) {
                            this.props.colorBr = value;
                            this.hasColorProps = value > 0;
                            this.setUpdateType(UpdateType.PremultipliedColors);
                        }
                    }, {
                        key: "zIndex",
                        get: function get() {
                            return this.props.zIndex;
                        },
                        set: function set(value) {
                            var sanitizedValue = value;
                            if (isNaN(sanitizedValue) || Number.isFinite(sanitizedValue) === false) {
                                console.warn("zIndex was set to an invalid value: ".concat(value, ", defaulting to 0"));
                                sanitizedValue = 0;
                            }
                            if (sanitizedValue > Number.MAX_SAFE_INTEGER) {
                                sanitizedValue = 1e3;
                            } else if (sanitizedValue < Number.MIN_SAFE_INTEGER) {
                                sanitizedValue = -1e3;
                            }
                            if (this.props.zIndex === sanitizedValue) {
                                return;
                            }
                            this.previousZIndex = this.props.zIndex;
                            this.props.zIndex = sanitizedValue;
                            var parent = this.parent;
                            if (parent !== null) {
                                var min = parent.zIndexMin;
                                var max = parent.zIndexMax;
                                if (min !== max || sanitizedValue < min || sanitizedValue > max) {
                                    parent.zIndexSortList.push(this);
                                    parent.setUpdateType(UpdateType.SortZIndexChildren);
                                }
                            }
                        }
                    }, {
                        key: "parent",
                        get: function get() {
                            return this.props.parent;
                        },
                        set: function set(newParent) {
                            var oldParent = this.props.parent;
                            if (oldParent === newParent) {
                                return;
                            }
                            this.props.parent = newParent;
                            if (oldParent) {
                                oldParent.removeChild(this, newParent);
                            }
                            if (newParent !== null) {
                                newParent.addChild(this, oldParent);
                            }
                            this.setUpdateType(UpdateType.Global | UpdateType.RenderBounds);
                        }
                    }, {
                        key: "rtt",
                        get: function get() {
                            return this.props.rtt;
                        },
                        set: function set(value) {
                            if (this.props.rtt === value) {
                                return;
                            }
                            this.props.rtt = value;
                            if (value === true) {
                                this.initRenderTexture();
                                this.markChildrenWithRTT();
                            } else {
                                this.cleanupRenderTexture();
                            }
                            this.setUpdateType(UpdateType.RenderTexture);
                            if (this.parentHasRenderTexture === true) {
                                this.notifyParentRTTOfUpdate();
                            }
                        }
                    }, {
                        key: "initRenderTexture",
                        value: function initRenderTexture() {
                            this.framebufferDimensions = {
                                w: this.props.w,
                                h: this.props.h
                            };
                            this.texture = this.stage.txManager.createTexture("RenderTexture", this.framebufferDimensions);
                            this.stage.renderer.renderToTexture(this);
                        }
                    }, {
                        key: "cleanupRenderTexture",
                        value: function cleanupRenderTexture() {
                            this.unloadTexture();
                            this.clearRTTInheritance();
                            this.hasRTTupdates = false;
                            this.texture = null;
                            this.framebufferDimensions = null;
                        }
                    }, {
                        key: "markChildrenWithRTT",
                        value: function markChildrenWithRTT() {
                            var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                            var parent = node || this;
                            var _iterator7 = _createForOfIteratorHelper(parent.children), _step7;
                            try {
                                for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                                    var child = _step7.value;
                                    child.setUpdateType(UpdateType.All);
                                    child.parentHasRenderTexture = true;
                                    child.markChildrenWithRTT();
                                }
                            } catch (err) {
                                _iterator7.e(err);
                            } finally {
                                _iterator7.f();
                            }
                        }
                    }, {
                        key: "applyRTTInheritance",
                        value: function applyRTTInheritance(parent) {
                            if (parent.rtt) {
                                parent.setUpdateType(UpdateType.RenderTexture);
                            }
                            this.markChildrenWithRTT(parent);
                        }
                    }, {
                        key: "clearRTTInheritance",
                        value: function clearRTTInheritance() {
                            if (this.rtt) {
                                return;
                            }
                            var _iterator8 = _createForOfIteratorHelper(this.children), _step8;
                            try {
                                for (_iterator8.s(); !(_step8 = _iterator8.n()).done; ) {
                                    var child = _step8.value;
                                    child.parentHasRenderTexture = false;
                                    child.rttParent = null;
                                    child.setUpdateType(UpdateType.All);
                                    child.clearRTTInheritance();
                                }
                            } catch (err) {
                                _iterator8.e(err);
                            } finally {
                                _iterator8.f();
                            }
                        }
                    }, {
                        key: "shader",
                        get: function get() {
                            return this.props.shader;
                        },
                        set: function set(shader) {
                            if (this.props.shader === shader) {
                                return;
                            }
                            if (shader === null) {
                                this.hasShaderUpdater = false;
                                this.props.shader = this.stage.defShaderNode;
                                this.setUpdateType(UpdateType.IsRenderable);
                                return;
                            }
                            if (shader.shaderKey !== "default") {
                                this.hasShaderUpdater = shader.update !== undefined;
                                this.hasShaderTimeFn = shader.time !== undefined;
                                shader.attachNode(this);
                            }
                            if (this.hasShaderTimeFn === true) {
                                this.stage.trackTimedNode(this);
                            } else {
                                this.stage.untrackTimedNode(this);
                            }
                            this.props.shader = shader;
                            this.setUpdateType(UpdateType.IsRenderable | UpdateType.RecalcUniforms);
                        }
                    }, {
                        key: "src",
                        get: function get() {
                            return this.props.src;
                        },
                        set: function set(imageUrl) {
                            var _this$props$textureOp, _this$props$textureOp2;
                            if (this.props.src === imageUrl) {
                                return;
                            }
                            this.props.src = imageUrl;
                            if (!imageUrl) {
                                this.texture = null;
                                return;
                            }
                            this.texture = this.stage.txManager.createTexture("ImageTexture", {
                                src: imageUrl,
                                w: this.props.w,
                                h: this.props.h,
                                type: this.props.imageType,
                                sx: this.props.srcX,
                                sy: this.props.srcY,
                                sw: this.props.srcWidth,
                                sh: this.props.srcHeight,
                                enableAlphaChannel: (_this$props$textureOp = this.props.textureOptions) === null || _this$props$textureOp === void 0 ? void 0 : _this$props$textureOp.enableAlphaChannel,
                                loadOnMainThread: (_this$props$textureOp2 = this.props.textureOptions) === null || _this$props$textureOp2 === void 0 ? void 0 : _this$props$textureOp2.loadOnMainThread
                            });
                        }
                    }, {
                        key: "imageType",
                        get: function get() {
                            return this.props.imageType || null;
                        },
                        set: function set(type) {
                            if (this.props.imageType === type) {
                                return;
                            }
                            this.props.imageType = type;
                        }
                    }, {
                        key: "srcHeight",
                        get: function get() {
                            return this.props.srcHeight;
                        },
                        set: function set(value) {
                            this.props.srcHeight = value;
                        }
                    }, {
                        key: "srcWidth",
                        get: function get() {
                            return this.props.srcWidth;
                        },
                        set: function set(value) {
                            this.props.srcWidth = value;
                        }
                    }, {
                        key: "srcX",
                        get: function get() {
                            return this.props.srcX;
                        },
                        set: function set(value) {
                            this.props.srcX = value;
                        }
                    }, {
                        key: "srcY",
                        get: function get() {
                            return this.props.srcY;
                        },
                        set: function set(value) {
                            this.props.srcY = value;
                        }
                    }, {
                        key: "parentFramebufferDimensions",
                        get: function get() {
                            if (this.rttParent !== null) {
                                return this.rttParent.framebufferDimensions;
                            }
                            this.rttParent = this.findParentRTTNode();
                            return this.rttParent ? this.rttParent.framebufferDimensions : null;
                        }
                    }, {
                        key: "parentRenderTexture",
                        get: function get() {
                            var parent = this.parent;
                            while (parent) {
                                if (parent.rtt) {
                                    return parent;
                                }
                                parent = parent.parent;
                            }
                            return null;
                        }
                    }, {
                        key: "texture",
                        get: function get() {
                            return this.props.texture;
                        },
                        set: function set(value) {
                            if (this.props.texture === value) {
                                return;
                            }
                            var oldTexture = this.props.texture;
                            if (oldTexture) {
                                this.unloadTexture();
                                if (this.autosizer !== null && value === null) {
                                    this.autosizer.setMode(AutosizeMode.Children);
                                }
                            }
                            this.textureCoords = undefined;
                            this.props.texture = value;
                            if (value !== null) {
                                if (this.autosizer !== null) {
                                    this.autosizer.setMode(AutosizeMode.Texture);
                                }
                                value.setRenderableOwner(this._id, this.isRenderable);
                                this.loadTexture();
                            }
                            this.setUpdateType(UpdateType.IsRenderable);
                        }
                    }, {
                        key: "textureOptions",
                        get: function get() {
                            return this.props.textureOptions;
                        },
                        set: function set(value) {
                            this.props.textureOptions = value;
                            if (this.stage.calculateTextureCoord === true && value !== null) {
                                this.textureCoords = this.stage.renderer.getTextureCoords(this);
                            }
                        }
                    }, {
                        key: "interactive",
                        get: function get() {
                            return this.props.interactive;
                        },
                        set: function set(value) {
                            this.props.interactive = value;
                            if (value === true) {
                                this.stage.interactiveNodes.add(this);
                            }
                        }
                    }, {
                        key: "setRTTUpdates",
                        value: function setRTTUpdates(type) {
                            var _this$parent;
                            this.hasRTTupdates = true;
                            (_this$parent = this.parent) === null || _this$parent === void 0 || _this$parent.setRTTUpdates(type);
                        }
                    }, {
                        key: "animate",
                        value: function animate(props, settings) {
                            var animation = new CoreAnimation(this, props, settings);
                            var controller = new CoreAnimationController(this.stage.animationManager, animation);
                            return controller;
                        }
                    }, {
                        key: "flush",
                        value: function flush() {}
                    }, {
                        key: "addTexture",
                        value: function addTexture(texture) {
                            var textures = this.renderOpTextures;
                            var length = textures.length;
                            for (var i = 0; i < length; i++) {
                                if (textures[i] === texture) {
                                    return i;
                                }
                            }
                            if (length >= 1) {
                                return 4294967295;
                            }
                            textures.push(texture);
                            return length;
                        }
                    }, {
                        key: "draw",
                        value: function draw(renderer) {
                            var glw = renderer.glw, options = renderer.options, stage = renderer.stage;
                            var shader = this.props.shader;
                            stage.shManager.useShader(shader.program);
                            shader.program.bindRenderOp(this);
                            if (this.clippingRect.valid === true) {
                                var pixelRatio = this.parentHasRenderTexture ? 1 : stage.pixelRatio;
                                var clipX = Math.round(this.clippingRect.x * pixelRatio);
                                var clipWidth = Math.round(this.clippingRect.width * pixelRatio);
                                var clipHeight = Math.round(this.clippingRect.height * pixelRatio);
                                var clipY = Math.round(options.canvas.height - clipHeight - this.clippingRect.y * pixelRatio);
                                if (this.parentHasRenderTexture) {
                                    clipY = this.parentFramebufferDimensions ? this.parentFramebufferDimensions.h - this.props.h : 0;
                                }
                                glw.setScissorTest(true);
                                glw.scissor(clipX, clipY, clipWidth, clipHeight);
                            } else {
                                glw.setScissorTest(false);
                            }
                            var quadIdx = this.renderOpBufferIdx / 32 * 6 * 2;
                            glw.drawElements(glw.TRIANGLES, 6 * this.numQuads, glw.UNSIGNED_SHORT, quadIdx);
                        }
                    } ]);
                }(EventEmitter);
                var AnimationManager = function() {
                    function AnimationManager() {
                        _classCallCheck(this, AnimationManager);
                        _defineProperty(this, "activeAnimations", new Set);
                    }
                    return _createClass(AnimationManager, [ {
                        key: "registerAnimation",
                        value: function registerAnimation(animation) {
                            this.activeAnimations.add(animation);
                        }
                    }, {
                        key: "unregisterAnimation",
                        value: function unregisterAnimation(animation) {
                            this.activeAnimations.delete(animation);
                        }
                    }, {
                        key: "update",
                        value: function update(dt) {
                            this.activeAnimations.forEach(function(animation) {
                                animation.update(dt);
                            });
                        }
                    } ]);
                }();
                function createImageWorker() {
                    function hasAlphaChannel(mimeType) {
                        return mimeType.indexOf("image/png") !== -1;
                    }
                    function getImage(src, premultiplyAlpha, x, y, width, height, options) {
                        return new Promise(function(resolve, reject) {
                            var xhr = new XMLHttpRequest;
                            xhr.open("GET", src, true);
                            xhr.responseType = "blob";
                            xhr.onload = function() {
                                if (xhr.status !== 200 && xhr.status !== 0) {
                                    return reject(new Error("Image loading failed. HTTP status code: ".concat(xhr.status || "N/A", ". URL: ").concat(src)));
                                }
                                var blob = xhr.response;
                                premultiplyAlpha !== undefined ? premultiplyAlpha : hasAlphaChannel(blob.type);
                                {
                                    createImageBitmap(blob).then(function(data) {
                                        resolve({
                                            data: data,
                                            premultiplyAlpha: premultiplyAlpha
                                        });
                                    }).catch(function(error) {
                                        reject(error);
                                    });
                                }
                            };
                            xhr.onerror = function() {
                                reject(new Error("Network error occurred while trying to fetch the image."));
                            };
                            xhr.send();
                        });
                    }
                    self.onmessage = function(event) {
                        var src = event.data.src;
                        var id = event.data.id;
                        var premultiplyAlpha = event.data.premultiplyAlpha;
                        event.data.sx;
                        event.data.sy;
                        event.data.sw;
                        event.data.sh;
                        getImage(src, premultiplyAlpha).then(function(data) {
                            self.postMessage({
                                id: id,
                                src: src,
                                data: data
                            }, [ data.data ]);
                        }).catch(function(error) {
                            self.postMessage({
                                id: id,
                                src: src,
                                error: error.message
                            });
                        });
                    };
                }
                var ImageWorkerManager = function() {
                    function ImageWorkerManager(numImageWorkers, createImageBitmapSupport) {
                        var _this8 = this;
                        _classCallCheck(this, ImageWorkerManager);
                        _defineProperty(this, "imageWorkersEnabled", true);
                        _defineProperty(this, "messageManager", {});
                        _defineProperty(this, "workers", []);
                        _defineProperty(this, "workerLoad", []);
                        _defineProperty(this, "nextId", 0);
                        this.workers = this.createWorkers(numImageWorkers, createImageBitmapSupport);
                        this.workers.forEach(function(worker, index) {
                            worker.onmessage = function(event) {
                                return _this8.handleMessage(event, index);
                            };
                        });
                    }
                    return _createClass(ImageWorkerManager, [ {
                        key: "handleMessage",
                        value: function handleMessage(event, workerIndex) {
                            var _event$data = event.data, id = _event$data.id, data = _event$data.data, error = _event$data.error;
                            var msg = this.messageManager[id];
                            if (this.workerLoad[workerIndex]) {
                                this.workerLoad[workerIndex]--;
                            }
                            if (msg) {
                                var _msg = _slicedToArray(msg, 2), resolve = _msg[0], reject = _msg[1];
                                delete this.messageManager[id];
                                if (error) {
                                    reject(new Error(error));
                                } else {
                                    resolve(data);
                                }
                            }
                        }
                    }, {
                        key: "createWorkers",
                        value: function createWorkers() {
                            var numWorkers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                            var createImageBitmapSupport = arguments.length > 1 ? arguments[1] : undefined;
                            var workerCode = "(".concat(createImageWorker.toString(), ")()");
                            if (createImageBitmapSupport.options === true) {
                                workerCode = workerCode.replace("var supportsOptionsCreateImageBitmap = false;", "var supportsOptionsCreateImageBitmap = true;");
                            }
                            if (createImageBitmapSupport.full === true) {
                                workerCode = workerCode.replace("var supportsOptionsCreateImageBitmap = false;", "var supportsOptionsCreateImageBitmap = true;");
                                workerCode = workerCode.replace("var supportsFullCreateImageBitmap = false;", "var supportsFullCreateImageBitmap = true;");
                            }
                            workerCode = workerCode.replace('"use strict";', "");
                            var blob = new Blob([ workerCode ], {
                                type: "application/javascript"
                            });
                            var blobURL = (self.URL ? URL : webkitURL).createObjectURL(blob);
                            var workers = [];
                            for (var i = 0; i < numWorkers; i++) {
                                workers.push(new Worker(blobURL));
                                this.workerLoad.push(0);
                            }
                            return workers;
                        }
                    }, {
                        key: "getNextWorkerIndex",
                        value: function getNextWorkerIndex() {
                            if (this.workers.length === 0) return -1;
                            var minLoad = 99;
                            var workerIndex = 0;
                            for (var i = 0; i < this.workers.length; i++) {
                                var load = this.workerLoad[i] || 0;
                                if (load === 0) {
                                    return i;
                                }
                                if (load < minLoad) {
                                    minLoad = load;
                                    workerIndex = i;
                                }
                            }
                            return workerIndex;
                        }
                    }, {
                        key: "getImage",
                        value: function getImage(src, premultiplyAlpha, sx, sy, sw, sh) {
                            var _this9 = this;
                            return new Promise(function(resolve, reject) {
                                try {
                                    if (_this9.workers) {
                                        var id = _this9.nextId++;
                                        _this9.messageManager[id] = [ resolve, reject ];
                                        var nextWorkerIndex = _this9.getNextWorkerIndex();
                                        if (nextWorkerIndex !== -1) {
                                            var worker = _this9.workers[nextWorkerIndex];
                                            _this9.workerLoad[nextWorkerIndex]++;
                                            worker.postMessage({
                                                id: id,
                                                src: src,
                                                premultiplyAlpha: premultiplyAlpha,
                                                sx: sx,
                                                sy: sy,
                                                sw: sw,
                                                sh: sh
                                            });
                                        }
                                    }
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        }
                    } ]);
                }();
                var ColorTexture = function(_Texture2) {
                    function ColorTexture(txManager, props) {
                        var _this0;
                        _classCallCheck(this, ColorTexture);
                        _this0 = _callSuper(this, ColorTexture, [ txManager ]);
                        _defineProperty(_this0, "type", TextureType.color);
                        _defineProperty(_this0, "props", void 0);
                        _this0.props = props;
                        return _this0;
                    }
                    _inherits(ColorTexture, _Texture2);
                    return _createClass(ColorTexture, [ {
                        key: "color",
                        get: function get() {
                            return this.props.color;
                        },
                        set: function set(color) {
                            this.props.color = color;
                        }
                    }, {
                        key: "getTextureSource",
                        value: function() {
                            var _getTextureSource = _asyncToGenerator(_regenerator().m(function _callee2() {
                                var pixelData;
                                return _regenerator().w(function(_context2) {
                                    while (1) switch (_context2.n) {
                                      case 0:
                                        pixelData = new Uint8Array(4);
                                        if (this.color === 4294967295) {
                                            pixelData[0] = 255;
                                            pixelData[1] = 255;
                                            pixelData[2] = 255;
                                            pixelData[3] = 255;
                                        } else {
                                            pixelData[0] = this.color >> 16 & 255;
                                            pixelData[1] = this.color >> 8 & 255;
                                            pixelData[2] = this.color & 255;
                                            pixelData[3] = this.color >>> 24 & 255;
                                        }
                                        this.setState("fetched", {
                                            w: 1,
                                            h: 1
                                        });
                                        return _context2.a(2, {
                                            data: pixelData,
                                            premultiplyAlpha: true
                                        });
                                    }
                                }, _callee2, this);
                            }));
                            function getTextureSource() {
                                return _getTextureSource.apply(this, arguments);
                            }
                            return getTextureSource;
                        }()
                    } ], [ {
                        key: "makeCacheKey",
                        value: function makeCacheKey(props) {
                            return "ColorTexture,".concat(props.color);
                        }
                    }, {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            return {
                                color: props.color || 4294967295
                            };
                        }
                    } ]);
                }(Texture);
                _defineProperty(ColorTexture, "z$__type__Props", void 0);
                function isCompressedTextureContainer(src) {
                    return /\.(ktx|pvr)$/.test(src);
                }
                var PVR_MAGIC = 55727696;
                var PVR_TO_GL_INTERNAL_FORMAT = {
                    0: 35841,
                    1: 35843,
                    2: 35840,
                    3: 35842,
                    6: 36196,
                    7: 33776,
                    8: 33778,
                    9: 33778,
                    10: 33779,
                    11: 33779
                };
                var ASTC_MAGIC = 1554098963;
                var ASTC_TO_GL_INTERNAL_FORMAT = {
                    "4x4": 37808,
                    "5x5": 37809,
                    "6x6": 37810,
                    "8x8": 37811,
                    "10x10": 37812,
                    "12x12": 37813
                };
                var KTX_IDENTIFIER = [ 171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10 ];
                var loadCompressedTexture = function() {
                    var _ref2 = _asyncToGenerator(_regenerator().m(function _callee3(url) {
                        var response, arrayBuffer, view, magic, isKTX, i, _t;
                        return _regenerator().w(function(_context3) {
                            while (1) switch (_context3.p = _context3.n) {
                              case 0:
                                _context3.p = 0;
                                _context3.n = 1;
                                return fetch(url);

                              case 1:
                                response = _context3.v;
                                if (response.ok) {
                                    _context3.n = 2;
                                    break;
                                }
                                throw new Error("Failed to fetch compressed texture: ".concat(response.status, " ").concat(response.statusText));

                              case 2:
                                _context3.n = 3;
                                return response.arrayBuffer();

                              case 3:
                                arrayBuffer = _context3.v;
                                if (!(arrayBuffer.byteLength < 16)) {
                                    _context3.n = 4;
                                    break;
                                }
                                throw new Error("File too small to be a valid compressed texture (".concat(arrayBuffer.byteLength, " bytes). Expected at least 16 bytes for header inspection."));

                              case 4:
                                view = new DataView(arrayBuffer);
                                magic = view.getUint32(0, true);
                                if (!(magic === PVR_MAGIC)) {
                                    _context3.n = 5;
                                    break;
                                }
                                return _context3.a(2, loadPVR(view));

                              case 5:
                                if (!(magic === ASTC_MAGIC)) {
                                    _context3.n = 6;
                                    break;
                                }
                                return _context3.a(2, loadASTC(view));

                              case 6:
                                isKTX = true;
                                i = 0;

                              case 7:
                                if (!(i < KTX_IDENTIFIER.length)) {
                                    _context3.n = 9;
                                    break;
                                }
                                if (!(view.getUint8(i) !== KTX_IDENTIFIER[i])) {
                                    _context3.n = 8;
                                    break;
                                }
                                isKTX = false;
                                return _context3.a(3, 9);

                              case 8:
                                i++;
                                _context3.n = 7;
                                break;

                              case 9:
                                if (!(isKTX === true)) {
                                    _context3.n = 10;
                                    break;
                                }
                                return _context3.a(2, loadKTX(view));

                              case 10:
                                throw new Error("Unrecognized compressed texture format");

                              case 11:
                                _context3.n = 13;
                                break;

                              case 12:
                                _context3.p = 12;
                                _t = _context3.v;
                                throw new Error("Failed to load compressed texture from ".concat(url, ": ").concat(_t));

                              case 13:
                                return _context3.a(2);
                            }
                        }, _callee3, null, [ [ 0, 12 ] ]);
                    }));
                    return function loadCompressedTexture(_x2) {
                        return _ref2.apply(this, arguments);
                    };
                }();
                function readUint24(view, offset) {
                    return view.getUint8(offset) + (view.getUint8(offset + 1) << 8) + (view.getUint8(offset + 2) << 16);
                }
                var loadASTC = function() {
                    var _ref3 = _asyncToGenerator(_regenerator().m(function _callee4(view) {
                        var blockX, blockY, sizeX, sizeY, expected, dataSize, internalFormat, buffer, mipmaps;
                        return _regenerator().w(function(_context4) {
                            while (1) switch (_context4.n) {
                              case 0:
                                blockX = view.getUint8(4);
                                blockY = view.getUint8(5);
                                sizeX = readUint24(view, 7);
                                sizeY = readUint24(view, 10);
                                if (!(sizeX === 0 || sizeY === 0)) {
                                    _context4.n = 1;
                                    break;
                                }
                                throw new Error("Invalid ASTC texture dimensions: ".concat(sizeX, "x").concat(sizeY));

                              case 1:
                                expected = Math.ceil(sizeX / blockX) * Math.ceil(sizeY / blockY) * 16;
                                dataSize = view.byteLength - 16;
                                if (!(expected !== dataSize)) {
                                    _context4.n = 2;
                                    break;
                                }
                                throw new Error("Invalid ASTC texture data size: expected ".concat(expected, ", got ").concat(dataSize));

                              case 2:
                                internalFormat = ASTC_TO_GL_INTERNAL_FORMAT["".concat(blockX, "x").concat(blockY)];
                                if (!(internalFormat === undefined)) {
                                    _context4.n = 3;
                                    break;
                                }
                                throw new Error("Unsupported ASTC block size: ".concat(blockX, "x").concat(blockY));

                              case 3:
                                buffer = view.buffer;
                                mipmaps = [];
                                mipmaps.push(buffer.slice(16));
                                return _context4.a(2, {
                                    data: {
                                        blockInfo: blockInfoMap[internalFormat],
                                        glInternalFormat: internalFormat,
                                        mipmaps: mipmaps,
                                        w: sizeX,
                                        h: sizeY,
                                        type: "astc"
                                    },
                                    premultiplyAlpha: false
                                });
                            }
                        }, _callee4);
                    }));
                    return function loadASTC(_x3) {
                        return _ref3.apply(this, arguments);
                    };
                }();
                var uploadASTC = function uploadASTC(glw, texture, data) {
                    if (glw.getExtension("WEBGL_compressed_texture_astc") === null) {
                        throw new Error("ASTC compressed textures not supported by this device");
                    }
                    glw.bindTexture(texture);
                    var glInternalFormat = data.glInternalFormat, mipmaps = data.mipmaps, w = data.w, h = data.h;
                    if (mipmaps === undefined) {
                        return;
                    }
                    var view = new Uint8Array(mipmaps[0]);
                    glw.compressedTexImage2D(0, glInternalFormat, w, h, 0, view);
                    glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                    glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
                };
                var loadKTX = function() {
                    var _ref4 = _asyncToGenerator(_regenerator().m(function _callee5(view) {
                        var endianness, littleEndian, glType, glFormat, glInternalFormat, width, height, mipmapLevels, bytesOfKeyValueData, mipmaps, buffer, offset, i, imageSize, end;
                        return _regenerator().w(function(_context5) {
                            while (1) switch (_context5.n) {
                              case 0:
                                endianness = view.getUint32(12, true);
                                littleEndian = endianness === 67305985;
                                if (!(littleEndian === false && endianness !== 16909060)) {
                                    _context5.n = 1;
                                    break;
                                }
                                throw new Error("Invalid KTX endianness value");

                              case 1:
                                glType = view.getUint32(16, littleEndian);
                                glFormat = view.getUint32(24, littleEndian);
                                if (!(glType !== 0 || glFormat !== 0)) {
                                    _context5.n = 2;
                                    break;
                                }
                                throw new Error("KTX texture is not compressed (glType: ".concat(glType, ", glFormat: ").concat(glFormat, ")"));

                              case 2:
                                glInternalFormat = view.getUint32(28, littleEndian);
                                if (!(blockInfoMap[glInternalFormat] === undefined)) {
                                    _context5.n = 3;
                                    break;
                                }
                                throw new Error("Unsupported KTX compressed texture format: 0x".concat(glInternalFormat.toString(16)));

                              case 3:
                                width = view.getUint32(36, littleEndian);
                                height = view.getUint32(40, littleEndian);
                                if (!(width === 0 || height === 0)) {
                                    _context5.n = 4;
                                    break;
                                }
                                throw new Error("Invalid KTX texture dimensions: ".concat(width, "x").concat(height));

                              case 4:
                                mipmapLevels = view.getUint32(56, littleEndian);
                                if (!(mipmapLevels === 0)) {
                                    _context5.n = 5;
                                    break;
                                }
                                throw new Error("KTX texture has no mipmap levels");

                              case 5:
                                bytesOfKeyValueData = view.getUint32(60, littleEndian);
                                mipmaps = [];
                                buffer = view.buffer;
                                offset = 64 + bytesOfKeyValueData;
                                if (!(offset > view.byteLength)) {
                                    _context5.n = 6;
                                    break;
                                }
                                throw new Error("Invalid KTX file: key/value data exceeds file size");

                              case 6:
                                for (i = 0; i < mipmapLevels; i++) {
                                    imageSize = view.getUint32(offset, littleEndian);
                                    offset += 4;
                                    end = offset + imageSize;
                                    mipmaps.push(buffer.slice(offset, end));
                                    offset = end;
                                    if (offset % 4 !== 0) {
                                        offset += 4 - offset % 4;
                                    }
                                }
                                return _context5.a(2, {
                                    data: {
                                        blockInfo: blockInfoMap[glInternalFormat],
                                        glInternalFormat: glInternalFormat,
                                        mipmaps: mipmaps,
                                        w: width,
                                        h: height,
                                        type: "ktx"
                                    },
                                    premultiplyAlpha: false
                                });
                            }
                        }, _callee5);
                    }));
                    return function loadKTX(_x4) {
                        return _ref4.apply(this, arguments);
                    };
                }();
                var uploadKTX = function uploadKTX(glw, texture, data) {
                    var glInternalFormat = data.glInternalFormat, mipmaps = data.mipmaps, width = data.w, height = data.h, blockInfo = data.blockInfo;
                    if (mipmaps === undefined) {
                        return;
                    }
                    glw.bindTexture(texture);
                    var blockWidth = blockInfo.width;
                    var blockHeight = blockInfo.height;
                    var w = width;
                    var h = height;
                    for (var i = 0; i < mipmaps.length; i++) {
                        var view = new Uint8Array(mipmaps[i]);
                        var uploadW = Math.ceil(w / blockWidth) * blockWidth;
                        var uploadH = Math.ceil(h / blockHeight) * blockHeight;
                        var expectedBytes = Math.ceil(w / blockWidth) * Math.ceil(h / blockHeight) * blockInfo.bytes;
                        if (view.byteLength < expectedBytes) {
                            var padded = new Uint8Array(expectedBytes);
                            padded.set(view);
                            view = padded;
                        }
                        glw.compressedTexImage2D(i, glInternalFormat, uploadW, uploadH, 0, view);
                        w = Math.max(1, w >> 1);
                        h = Math.max(1, h >> 1);
                    }
                    glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                    glw.texParameteri(glw.TEXTURE_MIN_FILTER, mipmaps.length > 1 ? glw.LINEAR_MIPMAP_LINEAR : glw.LINEAR);
                };
                function pvrtcMipSize(width, height, bpp) {
                    var minW = bpp === 2 ? 16 : 8;
                    var minH = 8;
                    var w = Math.max(width, minW);
                    var h = Math.max(height, minH);
                    return w * h * bpp / 8;
                }
                var loadPVR = function() {
                    var _ref5 = _asyncToGenerator(_regenerator().m(function _callee6(view) {
                        var pixelFormatLow, internalFormat, height, width, mipmapLevels, metadataSize, buffer, offset, mipmaps, block, i, declaredSize, max, start, end, bpp, computed, blockW, blockH, _computed;
                        return _regenerator().w(function(_context6) {
                            while (1) switch (_context6.n) {
                              case 0:
                                pixelFormatLow = view.getUint32(8, true);
                                internalFormat = PVR_TO_GL_INTERNAL_FORMAT[pixelFormatLow];
                                if (!(internalFormat === undefined)) {
                                    _context6.n = 1;
                                    break;
                                }
                                throw new Error("Unsupported PVR pixel format: 0x".concat(pixelFormatLow.toString(16)));

                              case 1:
                                height = view.getInt32(24, true);
                                width = view.getInt32(28, true);
                                if (!(width === 0 || height === 0)) {
                                    _context6.n = 2;
                                    break;
                                }
                                throw new Error("Invalid PVR texture dimensions: ".concat(width, "x").concat(height));

                              case 2:
                                mipmapLevels = view.getInt32(44, true);
                                metadataSize = view.getUint32(48, true);
                                buffer = view.buffer;
                                offset = 52 + metadataSize;
                                if (!(offset > buffer.byteLength)) {
                                    _context6.n = 3;
                                    break;
                                }
                                throw new Error("Invalid PVR file: metadata exceeds file size");

                              case 3:
                                mipmaps = [];
                                block = blockInfoMap[internalFormat];
                                i = 0;

                              case 4:
                                if (!(i < mipmapLevels)) {
                                    _context6.n = 8;
                                    break;
                                }
                                declaredSize = view.getUint32(offset, true);
                                max = buffer.byteLength - (offset + 4);
                                if (!(declaredSize > 0 && declaredSize <= max)) {
                                    _context6.n = 5;
                                    break;
                                }
                                offset += 4;
                                start = offset;
                                end = offset + declaredSize;
                                mipmaps.push(buffer.slice(start, end));
                                offset = end;
                                offset = offset + 3 & -4;
                                return _context6.a(3, 7);

                              case 5:
                                if (!(pixelFormatLow === 0 || pixelFormatLow === 1 || pixelFormatLow === 2 || pixelFormatLow === 3)) {
                                    _context6.n = 6;
                                    break;
                                }
                                bpp = pixelFormatLow === 0 || pixelFormatLow === 1 ? 2 : 4;
                                computed = pvrtcMipSize(width >> i, height >> i, bpp);
                                mipmaps.push(buffer.slice(offset, offset + computed));
                                offset += computed;
                                offset = offset + 3 & -4;
                                return _context6.a(3, 7);

                              case 6:
                                if (block !== undefined) {
                                    blockW = Math.ceil((width >> i) / block.width);
                                    blockH = Math.ceil((height >> i) / block.height);
                                    _computed = blockW * blockH * block.bytes;
                                    mipmaps.push(buffer.slice(offset, offset + _computed));
                                    offset += _computed;
                                    offset = offset + 3 & -4;
                                }

                              case 7:
                                i++;
                                _context6.n = 4;
                                break;

                              case 8:
                                return _context6.a(2, {
                                    data: {
                                        blockInfo: blockInfoMap[internalFormat],
                                        glInternalFormat: internalFormat,
                                        mipmaps: mipmaps,
                                        w: width,
                                        h: height,
                                        type: "pvr"
                                    },
                                    premultiplyAlpha: false
                                });
                            }
                        }, _callee6);
                    }));
                    return function loadPVR(_x5) {
                        return _ref5.apply(this, arguments);
                    };
                }();
                var uploadPVR = function uploadPVR(glw, texture, data) {
                    var glInternalFormat = data.glInternalFormat, mipmaps = data.mipmaps, width = data.w, height = data.h;
                    if (mipmaps === undefined) {
                        return;
                    }
                    glw.bindTexture(texture);
                    var w = width;
                    var h = height;
                    for (var i = 0; i < mipmaps.length; i++) {
                        glw.compressedTexImage2D(i, glInternalFormat, w, h, 0, new Uint8Array(mipmaps[i]));
                        w = Math.max(1, w >> 1);
                        h = Math.max(1, h >> 1);
                    }
                    glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                    glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                    glw.texParameteri(glw.TEXTURE_MIN_FILTER, mipmaps.length > 1 ? glw.LINEAR_MIPMAP_LINEAR : glw.LINEAR);
                };
                var BLOCK_4x4x8 = {
                    width: 4,
                    height: 4,
                    bytes: 8
                };
                var BLOCK_4x4x16 = {
                    width: 4,
                    height: 4,
                    bytes: 16
                };
                var BLOCK_5x5x16 = {
                    width: 5,
                    height: 5,
                    bytes: 16
                };
                var BLOCK_6x6x16 = {
                    width: 6,
                    height: 6,
                    bytes: 16
                };
                var BLOCK_8x4x8 = {
                    width: 8,
                    height: 4,
                    bytes: 8
                };
                var BLOCK_8x8x16 = {
                    width: 8,
                    height: 8,
                    bytes: 16
                };
                var BLOCK_10x10x16 = {
                    width: 10,
                    height: 10,
                    bytes: 16
                };
                var BLOCK_12x12x16 = {
                    width: 12,
                    height: 12,
                    bytes: 16
                };
                var blockInfoMap = {
                    33776: BLOCK_4x4x8,
                    33777: BLOCK_4x4x8,
                    33778: BLOCK_4x4x16,
                    33779: BLOCK_4x4x16,
                    36196: BLOCK_4x4x8,
                    37492: BLOCK_4x4x8,
                    37493: BLOCK_4x4x8,
                    37496: BLOCK_4x4x16,
                    37497: BLOCK_4x4x16,
                    35840: BLOCK_4x4x8,
                    35842: BLOCK_4x4x8,
                    35841: BLOCK_8x4x8,
                    35843: BLOCK_8x4x8,
                    37808: BLOCK_4x4x16,
                    37840: BLOCK_4x4x16,
                    37809: BLOCK_5x5x16,
                    37841: BLOCK_5x5x16,
                    37810: BLOCK_6x6x16,
                    37842: BLOCK_6x6x16,
                    37811: BLOCK_8x8x16,
                    37843: BLOCK_8x8x16,
                    37812: BLOCK_10x10x16,
                    37844: BLOCK_10x10x16,
                    37813: BLOCK_12x12x16,
                    37845: BLOCK_12x12x16
                };
                var uploadCompressedTexture = {
                    ktx: uploadKTX,
                    pvr: uploadPVR,
                    astc: uploadASTC
                };
                function isSvgImage(url) {
                    return /\.(svg)(\?.*)?$/.test(url);
                }
                var loadSvg = function loadSvg(url, width, height, sx, sy, sw, sh) {
                    return new Promise(function(resolve, reject) {
                        var canvas = document.createElement("canvas");
                        var ctx = canvas.getContext("2d");
                        ctx.imageSmoothingEnabled = true;
                        var img = new Image;
                        img.onload = function() {
                            var x = sx !== null && sx !== void 0 ? sx : 0;
                            var y = sy !== null && sy !== void 0 ? sy : 0;
                            var w = width || img.width;
                            var h = height || img.height;
                            canvas.width = w;
                            canvas.height = h;
                            ctx.drawImage(img, 0, 0, w, h);
                            resolve({
                                data: ctx.getImageData(x, y, sw !== null && sw !== void 0 ? sw : w, sh !== null && sh !== void 0 ? sh : h),
                                premultiplyAlpha: false
                            });
                        };
                        img.onerror = function(err) {
                            reject(err);
                        };
                        img.src = url;
                    });
                };
                var ImageTexture = function(_Texture3) {
                    function ImageTexture(txManager, props) {
                        var _this1;
                        _classCallCheck(this, ImageTexture);
                        _this1 = _callSuper(this, ImageTexture, [ txManager ]);
                        _defineProperty(_this1, "platform", void 0);
                        _defineProperty(_this1, "props", void 0);
                        _defineProperty(_this1, "type", TextureType.image);
                        _this1.platform = txManager.platform;
                        _this1.props = props;
                        _this1.maxRetryCount = props.maxRetryCount;
                        return _this1;
                    }
                    _inherits(ImageTexture, _Texture3);
                    return _createClass(ImageTexture, [ {
                        key: "hasAlphaChannel",
                        value: function hasAlphaChannel(mimeType) {
                            return mimeType.indexOf("image/png") !== -1;
                        }
                    }, {
                        key: "loadImageFallback",
                        value: function() {
                            var _loadImageFallback = _asyncToGenerator(_regenerator().m(function _callee7(src, hasAlpha) {
                                var img;
                                return _regenerator().w(function(_context7) {
                                    while (1) switch (_context7.n) {
                                      case 0:
                                        img = new Image;
                                        if (typeof src === "string" && isBase64Image(src) === false) {
                                            img.crossOrigin = "anonymous";
                                        }
                                        return _context7.a(2, new Promise(function(resolve, reject) {
                                            img.onload = function() {
                                                resolve({
                                                    data: img,
                                                    premultiplyAlpha: hasAlpha
                                                });
                                            };
                                            img.onerror = function(err) {
                                                var errorMessage = err instanceof Error ? err.message : err instanceof Event ? "Image loading failed for ".concat(img.src) : "Unknown image loading error";
                                                reject(new Error("Image loading failed: ".concat(errorMessage)));
                                            };
                                            if (src instanceof Blob) {
                                                img.src = URL.createObjectURL(src);
                                            } else {
                                                img.src = src;
                                            }
                                        }));
                                    }
                                }, _callee7);
                            }));
                            function loadImageFallback(_x6, _x7) {
                                return _loadImageFallback.apply(this, arguments);
                            }
                            return loadImageFallback;
                        }()
                    }, {
                        key: "createImageBitmap",
                        value: function() {
                            var _createImageBitmap = _asyncToGenerator(_regenerator().m(function _callee8(blob, premultiplyAlpha, sx, sy, sw, sh) {
                                var hasAlphaChannel, imageBitmapSupported, _bitmap, bitmap, _t2, _t3;
                                return _regenerator().w(function(_context8) {
                                    while (1) switch (_context8.n) {
                                      case 0:
                                        hasAlphaChannel = premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : blob.type.includes("image/png");
                                        imageBitmapSupported = this.txManager.imageBitmapSupported;
                                        if (!(imageBitmapSupported.full === true && sw !== null && sh !== null)) {
                                            _context8.n = 2;
                                            break;
                                        }
                                        _context8.n = 1;
                                        return this.platform.createImageBitmap(blob, sx || 0, sy || 0, sw, sh, {
                                            premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
                                            colorSpaceConversion: "none",
                                            imageOrientation: "none"
                                        });

                                      case 1:
                                        _bitmap = _context8.v;
                                        return _context8.a(2, {
                                            data: _bitmap,
                                            premultiplyAlpha: hasAlphaChannel
                                        });

                                      case 2:
                                        if (!(imageBitmapSupported.basic === true)) {
                                            _context8.n = 4;
                                            break;
                                        }
                                        _context8.n = 3;
                                        return this.platform.createImageBitmap(blob);

                                      case 3:
                                        _t2 = _context8.v;
                                        _t3 = hasAlphaChannel;
                                        return _context8.a(2, {
                                            data: _t2,
                                            premultiplyAlpha: _t3
                                        });

                                      case 4:
                                        _context8.n = 5;
                                        return this.platform.createImageBitmap(blob, {
                                            premultiplyAlpha: hasAlphaChannel ? "premultiply" : "none",
                                            colorSpaceConversion: "none",
                                            imageOrientation: "none"
                                        });

                                      case 5:
                                        bitmap = _context8.v;
                                        return _context8.a(2, {
                                            data: bitmap,
                                            premultiplyAlpha: hasAlphaChannel
                                        });
                                    }
                                }, _callee8, this);
                            }));
                            function createImageBitmap(_x8, _x9, _x0, _x1, _x10, _x11) {
                                return _createImageBitmap.apply(this, arguments);
                            }
                            return createImageBitmap;
                        }()
                    }, {
                        key: "loadImage",
                        value: function() {
                            var _loadImage = _asyncToGenerator(_regenerator().m(function _callee9(src) {
                                var _this$props3, premultiplyAlpha, sx, sy, sw, sh, loadOnMainThread, startTime, blob;
                                return _regenerator().w(function(_context9) {
                                    while (1) switch (_context9.n) {
                                      case 0:
                                        _this$props3 = this.props, premultiplyAlpha = _this$props3.premultiplyAlpha, sx = _this$props3.sx, 
                                        sy = _this$props3.sy, sw = _this$props3.sw, sh = _this$props3.sh, loadOnMainThread = _this$props3.loadOnMainThread;
                                        startTime = performance.now();
                                        if (!(this.txManager.hasCreateImageBitmap === true)) {
                                            _context9.n = 5;
                                            break;
                                        }
                                        if (!(loadOnMainThread !== true && isBase64Image(src) === false && this.txManager.hasWorker === true && this.txManager.imageWorkerManager !== null)) {
                                            _context9.n = 1;
                                            break;
                                        }
                                        return _context9.a(2, this.txManager.imageWorkerManager.getImage(src, premultiplyAlpha, sx, sy, sw, sh).then(function(result) {
                                            ImageTexture.recordMetric(src, "worker", startTime);
                                            return result;
                                        }));

                                      case 1:
                                        if (!(isBase64Image(src) === true)) {
                                            _context9.n = 2;
                                            break;
                                        }
                                        blob = dataURIToBlob(src);
                                        _context9.n = 4;
                                        break;

                                      case 2:
                                        _context9.n = 3;
                                        return fetchJson(src, "blob").then(function(response) {
                                            return response;
                                        });

                                      case 3:
                                        blob = _context9.v;

                                      case 4:
                                        return _context9.a(2, this.createImageBitmap(blob, premultiplyAlpha, sx, sy, sw, sh).then(function(result) {
                                            ImageTexture.recordMetric(src, "main", startTime);
                                            return result;
                                        }));

                                      case 5:
                                        return _context9.a(2, this.loadImageFallback(src, premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : true).then(function(result) {
                                            ImageTexture.recordMetric(src, "main", startTime);
                                            return result;
                                        }));
                                    }
                                }, _callee9, this);
                            }));
                            function loadImage(_x12) {
                                return _loadImage.apply(this, arguments);
                            }
                            return loadImage;
                        }()
                    }, {
                        key: "getTextureSource",
                        value: function() {
                            var _getTextureSource2 = _asyncToGenerator(_regenerator().m(function _callee0() {
                                var _this$props$premultip, _this$props$enableAlp;
                                var resp, _t4;
                                return _regenerator().w(function(_context0) {
                                    while (1) switch (_context0.p = _context0.n) {
                                      case 0:
                                        _context0.p = 0;
                                        _context0.n = 1;
                                        return this.determineImageTypeAndLoadImage();

                                      case 1:
                                        resp = _context0.v;
                                        _context0.n = 3;
                                        break;

                                      case 2:
                                        _context0.p = 2;
                                        _t4 = _context0.v;
                                        this.setState("failed", _t4);
                                        return _context0.a(2, {
                                            data: null
                                        });

                                      case 3:
                                        if (!(resp.data === null)) {
                                            _context0.n = 4;
                                            break;
                                        }
                                        this.setState("failed", Error("ImageTexture: No image data"));
                                        return _context0.a(2, {
                                            data: null
                                        });

                                      case 4:
                                        return _context0.a(2, {
                                            data: resp.data,
                                            premultiplyAlpha: (_this$props$premultip = this.props.premultiplyAlpha) !== null && _this$props$premultip !== void 0 ? _this$props$premultip : true,
                                            enableAlphaChannel: (_this$props$enableAlp = this.props.enableAlphaChannel) !== null && _this$props$enableAlp !== void 0 ? _this$props$enableAlp : false
                                        });
                                    }
                                }, _callee0, this, [ [ 0, 2 ] ]);
                            }));
                            function getTextureSource() {
                                return _getTextureSource2.apply(this, arguments);
                            }
                            return getTextureSource;
                        }()
                    }, {
                        key: "determineImageTypeAndLoadImage",
                        value: function determineImageTypeAndLoadImage() {
                            var _this$props4 = this.props, src = _this$props4.src, premultiplyAlpha = _this$props4.premultiplyAlpha, type = _this$props4.type;
                            if (src === null) {
                                return {
                                    data: null
                                };
                            }
                            if (typeof src !== "string") {
                                if (src instanceof Blob) {
                                    if (this.txManager.hasCreateImageBitmap === true) {
                                        var _this$props5 = this.props, sx = _this$props5.sx, sy = _this$props5.sy, sw = _this$props5.sw, sh = _this$props5.sh;
                                        return this.createImageBitmap(src, premultiplyAlpha, sx, sy, sw, sh);
                                    } else {
                                        return this.loadImageFallback(src, premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : true);
                                    }
                                }
                                if (src instanceof ImageData) {
                                    return {
                                        data: src,
                                        premultiplyAlpha: premultiplyAlpha
                                    };
                                }
                                return {
                                    data: src(),
                                    premultiplyAlpha: premultiplyAlpha
                                };
                            }
                            var absoluteSrc = convertUrlToAbsolute(src);
                            if (type === "regular") {
                                return this.loadImage(absoluteSrc);
                            }
                            if (type === "svg") {
                                return loadSvg(absoluteSrc, this.props.w, this.props.h, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
                            }
                            if (isSvgImage(src) === true) {
                                return loadSvg(absoluteSrc, this.props.w, this.props.h, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
                            }
                            if (type === "compressed") {
                                return loadCompressedTexture(absoluteSrc);
                            }
                            if (isCompressedTextureContainer(src) === true) {
                                return loadCompressedTexture(absoluteSrc);
                            }
                            return this.loadImage(absoluteSrc);
                        }
                    } ], [ {
                        key: "recordMetric",
                        value: function recordMetric(src, method, startTime) {
                            var duration = performance.now() - startTime;
                            ImageTexture.loadMetrics.push({
                                src: src,
                                loadTime: duration,
                                method: method,
                                timestamp: Date.now()
                            });
                        }
                    }, {
                        key: "makeCacheKey",
                        value: function makeCacheKey(props) {
                            var _props$premultiplyAlp;
                            var key = props.key || props.src;
                            if (typeof key !== "string") {
                                return false;
                            }
                            var cacheKey = "ImageTexture,".concat(key, ",").concat((_props$premultiplyAlp = props.premultiplyAlpha) !== null && _props$premultiplyAlp !== void 0 ? _props$premultiplyAlp : "true", ",").concat(props.maxRetryCount);
                            if (props.sh !== null && props.sw !== null) {
                                var _props$sx, _props$sy;
                                cacheKey += ",";
                                cacheKey += (_props$sx = props.sx) !== null && _props$sx !== void 0 ? _props$sx : "";
                                cacheKey += (_props$sy = props.sy) !== null && _props$sy !== void 0 ? _props$sy : "";
                                cacheKey += props.sw || "";
                                cacheKey += props.sh || "";
                            }
                            return cacheKey;
                        }
                    }, {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            var _props$src, _props$premultiplyAlp2, _props$key, _props$type, _props$w, _props$h, _props$sx2, _props$sy2, _props$sw, _props$sh, _props$maxRetryCount, _props$enableAlphaCha, _props$loadOnMainThre;
                            return {
                                src: (_props$src = props.src) !== null && _props$src !== void 0 ? _props$src : "",
                                premultiplyAlpha: (_props$premultiplyAlp2 = props.premultiplyAlpha) !== null && _props$premultiplyAlp2 !== void 0 ? _props$premultiplyAlp2 : true,
                                key: (_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : null,
                                type: (_props$type = props.type) !== null && _props$type !== void 0 ? _props$type : null,
                                w: (_props$w = props.w) !== null && _props$w !== void 0 ? _props$w : null,
                                h: (_props$h = props.h) !== null && _props$h !== void 0 ? _props$h : null,
                                sx: (_props$sx2 = props.sx) !== null && _props$sx2 !== void 0 ? _props$sx2 : null,
                                sy: (_props$sy2 = props.sy) !== null && _props$sy2 !== void 0 ? _props$sy2 : null,
                                sw: (_props$sw = props.sw) !== null && _props$sw !== void 0 ? _props$sw : null,
                                sh: (_props$sh = props.sh) !== null && _props$sh !== void 0 ? _props$sh : null,
                                maxRetryCount: (_props$maxRetryCount = props.maxRetryCount) !== null && _props$maxRetryCount !== void 0 ? _props$maxRetryCount : 5,
                                enableAlphaChannel: (_props$enableAlphaCha = props.enableAlphaChannel) !== null && _props$enableAlphaCha !== void 0 ? _props$enableAlphaCha : null,
                                loadOnMainThread: (_props$loadOnMainThre = props.loadOnMainThread) !== null && _props$loadOnMainThre !== void 0 ? _props$loadOnMainThre : false
                            };
                        }
                    } ]);
                }(Texture);
                _defineProperty(ImageTexture, "loadMetrics", []);
                _defineProperty(ImageTexture, "z$__type__Props", void 0);
                var NoiseTexture = function(_Texture4) {
                    function NoiseTexture(txManager, props) {
                        var _this10;
                        _classCallCheck(this, NoiseTexture);
                        _this10 = _callSuper(this, NoiseTexture, [ txManager ]);
                        _defineProperty(_this10, "props", void 0);
                        _defineProperty(_this10, "type", TextureType.noise);
                        _this10.props = props;
                        return _this10;
                    }
                    _inherits(NoiseTexture, _Texture4);
                    return _createClass(NoiseTexture, [ {
                        key: "getTextureSource",
                        value: function() {
                            var _getTextureSource3 = _asyncToGenerator(_regenerator().m(function _callee1() {
                                var _this$props6, w, h, size, pixelData8, i, v;
                                return _regenerator().w(function(_context1) {
                                    while (1) switch (_context1.n) {
                                      case 0:
                                        _this$props6 = this.props, w = _this$props6.w, h = _this$props6.h;
                                        size = w * h * 4;
                                        pixelData8 = new Uint8ClampedArray(size);
                                        for (i = 0; i < size; i += 4) {
                                            v = Math.floor(Math.random() * 256);
                                            pixelData8[i] = v;
                                            pixelData8[i + 1] = v;
                                            pixelData8[i + 2] = v;
                                            pixelData8[i + 3] = 255;
                                        }
                                        return _context1.a(2, {
                                            data: new ImageData(pixelData8, w, h)
                                        });
                                    }
                                }, _callee1, this);
                            }));
                            function getTextureSource() {
                                return _getTextureSource3.apply(this, arguments);
                            }
                            return getTextureSource;
                        }()
                    } ], [ {
                        key: "makeCacheKey",
                        value: function makeCacheKey(props) {
                            if (props.cacheId === undefined) {
                                return false;
                            }
                            var resolvedProps = NoiseTexture.resolveDefaults(props);
                            return "NoiseTexture,".concat(resolvedProps.w, ",").concat(resolvedProps.h, ",").concat(resolvedProps.cacheId);
                        }
                    }, {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            var _props$w2, _props$h2, _props$cacheId;
                            return {
                                w: (_props$w2 = props.w) !== null && _props$w2 !== void 0 ? _props$w2 : 128,
                                h: (_props$h2 = props.h) !== null && _props$h2 !== void 0 ? _props$h2 : 128,
                                cacheId: (_props$cacheId = props.cacheId) !== null && _props$cacheId !== void 0 ? _props$cacheId : 0
                            };
                        }
                    } ]);
                }(Texture);
                _defineProperty(NoiseTexture, "z$__type__Props", void 0);
                var subTextureId = 0;
                var SubTexture = function(_Texture5) {
                    function SubTexture(txManager, props) {
                        var _this11;
                        _classCallCheck(this, SubTexture);
                        _this11 = _callSuper(this, SubTexture, [ txManager ]);
                        _defineProperty(_this11, "props", void 0);
                        _defineProperty(_this11, "parentTexture", void 0);
                        _defineProperty(_this11, "type", TextureType.subTexture);
                        _defineProperty(_this11, "subtextureId", "subtexture-".concat(subTextureId++));
                        _defineProperty(_this11, "onParentTxLoaded", function() {
                            _this11.setState("loaded", {
                                w: _this11.props.w,
                                h: _this11.props.h
                            });
                        });
                        _defineProperty(_this11, "onParentTxFailed", function(target, error) {
                            _this11.retryCount = _this11.parentTexture.retryCount - 1;
                            _this11.setState("failed", error);
                        });
                        _defineProperty(_this11, "onParentTxLoading", function() {
                            _this11.setState("loading");
                        });
                        _defineProperty(_this11, "onParentTxFreed", function() {
                            _this11.setState("freed");
                        });
                        _this11.props = props;
                        assertTruthy(_this11.props.texture);
                        assertTruthy(_this11.props.texture instanceof ImageTexture);
                        _this11.parentTexture = txManager.resolveParentTexture(_this11.props.texture);
                        if (_this11.renderableOwners.length > 0) {
                            _this11.parentTexture.setRenderableOwner(_this11.subtextureId, true);
                        }
                        queueMicrotask(function() {
                            var parentTx = _this11.parentTexture;
                            if (parentTx.state === "loaded" && parentTx.dimensions !== null) {
                                _this11.onParentTxLoaded(parentTx, parentTx.dimensions);
                            } else if (parentTx.state === "loading") {
                                _this11.onParentTxLoading();
                            } else if (parentTx.state === "failed" && parentTx.error !== null) {
                                _this11.onParentTxFailed(parentTx, parentTx.error);
                            } else if (parentTx.state === "freed") {
                                _this11.onParentTxFreed();
                            }
                            parentTx.on("loading", _this11.onParentTxLoading);
                            parentTx.on("loaded", _this11.onParentTxLoaded);
                            parentTx.on("failed", _this11.onParentTxFailed);
                            parentTx.on("freed", _this11.onParentTxFreed);
                        });
                        return _this11;
                    }
                    _inherits(SubTexture, _Texture5);
                    return _createClass(SubTexture, [ {
                        key: "onChangeIsRenderable",
                        value: function onChangeIsRenderable(isRenderable) {
                            this.parentTexture.setRenderableOwner(this.subtextureId, isRenderable);
                        }
                    }, {
                        key: "getTextureSource",
                        value: function() {
                            var _getTextureSource4 = _asyncToGenerator(_regenerator().m(function _callee10() {
                                var _this12 = this;
                                return _regenerator().w(function(_context10) {
                                    while (1) switch (_context10.n) {
                                      case 0:
                                        return _context10.a(2, new Promise(function(resolve, reject) {
                                            resolve({
                                                data: _this12.props
                                            });
                                        }));
                                    }
                                }, _callee10);
                            }));
                            function getTextureSource() {
                                return _getTextureSource4.apply(this, arguments);
                            }
                            return getTextureSource;
                        }()
                    } ], [ {
                        key: "makeCacheKey",
                        value: function makeCacheKey(props) {
                            return false;
                        }
                    }, {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            return {
                                texture: props.texture,
                                x: props.x || 0,
                                y: props.y || 0,
                                w: props.w || 0,
                                h: props.h || 0
                            };
                        }
                    } ]);
                }(Texture);
                _defineProperty(SubTexture, "z$__type__Props", void 0);
                var RenderTexture = function(_Texture6) {
                    function RenderTexture(txManager, props) {
                        var _this13;
                        _classCallCheck(this, RenderTexture);
                        _this13 = _callSuper(this, RenderTexture, [ txManager ]);
                        _defineProperty(_this13, "props", void 0);
                        _defineProperty(_this13, "type", TextureType.renderToTexture);
                        _this13.props = props;
                        return _this13;
                    }
                    _inherits(RenderTexture, _Texture6);
                    return _createClass(RenderTexture, [ {
                        key: "w",
                        get: function get() {
                            return this.props.w;
                        },
                        set: function set(value) {
                            this.props.w = value;
                        }
                    }, {
                        key: "h",
                        get: function get() {
                            return this.props.h;
                        },
                        set: function set(value) {
                            this.props.h = value;
                        }
                    }, {
                        key: "getTextureSource",
                        value: function() {
                            var _getTextureSource5 = _asyncToGenerator(_regenerator().m(function _callee11() {
                                return _regenerator().w(function(_context11) {
                                    while (1) switch (_context11.n) {
                                      case 0:
                                        return _context11.a(2, {
                                            data: null,
                                            premultiplyAlpha: null
                                        });
                                    }
                                }, _callee11);
                            }));
                            function getTextureSource() {
                                return _getTextureSource5.apply(this, arguments);
                            }
                            return getTextureSource;
                        }()
                    } ], [ {
                        key: "resolveDefaults",
                        value: function resolveDefaults(props) {
                            return {
                                w: props.w || 256,
                                h: props.h || 256
                            };
                        }
                    } ]);
                }(Texture);
                _defineProperty(RenderTexture, "z$__type__Props", void 0);
                function validateCreateImageBitmap(_x13) {
                    return _validateCreateImageBitmap.apply(this, arguments);
                }
                function _validateCreateImageBitmap() {
                    _validateCreateImageBitmap = _asyncToGenerator(_regenerator().m(function _callee28(platform) {
                        var _bitmap$close;
                        var pngBinaryData, support, blob, bitmap, _bitmapWithOptions$cl, options, bitmapWithOptions, _bitmapWithFullOption, bitmapWithFullOptions, _t1, _t10;
                        return _regenerator().w(function(_context28) {
                            while (1) switch (_context28.p = _context28.n) {
                              case 0:
                                pngBinaryData = new Uint8Array([ 137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, 0, 0, 0, 1, 0, 0, 0, 1, 1, 3, 0, 0, 0, 37, 219, 86, 202, 0, 0, 0, 3, 80, 76, 84, 69, 0, 0, 0, 167, 122, 61, 218, 0, 0, 0, 1, 116, 82, 78, 83, 0, 64, 230, 216, 102, 0, 0, 0, 10, 73, 68, 65, 84, 8, 215, 99, 96, 0, 0, 0, 2, 0, 1, 226, 33, 188, 51, 0, 0, 0, 0, 73, 69, 78, 68, 174, 66, 96, 130 ]);
                                support = {
                                    basic: false,
                                    options: false,
                                    full: false
                                };
                                blob = new Blob([ pngBinaryData ], {
                                    type: "image/png"
                                });
                                _context28.n = 1;
                                return platform.createImageBitmap(blob);

                              case 1:
                                bitmap = _context28.v;
                                (_bitmap$close = bitmap.close) === null || _bitmap$close === void 0 || _bitmap$close.call(bitmap);
                                support.basic = true;
                                _context28.p = 2;
                                options = {
                                    premultiplyAlpha: "none"
                                };
                                _context28.n = 3;
                                return platform.createImageBitmap(blob, options);

                              case 3:
                                bitmapWithOptions = _context28.v;
                                (_bitmapWithOptions$cl = bitmapWithOptions.close) === null || _bitmapWithOptions$cl === void 0 || _bitmapWithOptions$cl.call(bitmapWithOptions);
                                support.options = true;
                                _context28.n = 5;
                                break;

                              case 4:
                                _context28.p = 4;
                                _t1 = _context28.v;

                              case 5:
                                _context28.p = 5;
                                _context28.n = 6;
                                return platform.createImageBitmap(blob, 0, 0, 1, 1, {
                                    premultiplyAlpha: "none"
                                });

                              case 6:
                                bitmapWithFullOptions = _context28.v;
                                (_bitmapWithFullOption = bitmapWithFullOptions.close) === null || _bitmapWithFullOption === void 0 || _bitmapWithFullOption.call(bitmapWithFullOptions);
                                support.full = true;
                                _context28.n = 8;
                                break;

                              case 7:
                                _context28.p = 7;
                                _t10 = _context28.v;

                              case 8:
                                return _context28.a(2, support);
                            }
                        }, _callee28, null, [ [ 5, 7 ], [ 2, 4 ] ]);
                    }));
                    return _validateCreateImageBitmap.apply(this, arguments);
                }
                var TextureErrorCode;
                (function(TextureErrorCode) {
                    TextureErrorCode["MEMORY_THRESHOLD_EXCEEDED"] = "MEMORY_THRESHOLD_EXCEEDED";
                    TextureErrorCode["TEXTURE_DATA_NULL"] = "TEXTURE_DATA_NULL";
                    TextureErrorCode["TEXTURE_TYPE_NOT_REGISTERED"] = "TEXTURE_TYPE_NOT_REGISTERED";
                })(TextureErrorCode || (TextureErrorCode = {}));
                var defaultMessages = _defineProperty(_defineProperty(_defineProperty({}, TextureErrorCode.MEMORY_THRESHOLD_EXCEEDED, "Memory threshold exceeded"), TextureErrorCode.TEXTURE_DATA_NULL, "Texture data is null"), TextureErrorCode.TEXTURE_TYPE_NOT_REGISTERED, "Texture type is not registered");
                var TextureError = function(_Error) {
                    function TextureError(codeOrMessage, maybeMessage) {
                        var _this14;
                        _classCallCheck(this, TextureError);
                        var isCode = Object.values(TextureErrorCode).includes(codeOrMessage);
                        var code = isCode ? codeOrMessage : undefined;
                        var message;
                        if (isCode && code) {
                            message = maybeMessage !== null && maybeMessage !== void 0 ? maybeMessage : defaultMessages[code];
                        } else {
                            message = String(codeOrMessage);
                        }
                        _this14 = _callSuper(this, TextureError, [ message ]);
                        _defineProperty(_this14, "code", void 0);
                        _this14.name = (this instanceof TextureError ? this.constructor : void 0).name;
                        if (code) _this14.code = code;
                        return _this14;
                    }
                    _inherits(TextureError, _Error);
                    return _createClass(TextureError);
                }(_wrapNativeSuper(Error));
                var CoreTextureManager = function(_EventEmitter6) {
                    function CoreTextureManager(stage, settings) {
                        var _this15;
                        _classCallCheck(this, CoreTextureManager);
                        _this15 = _callSuper(this, CoreTextureManager);
                        _defineProperty(_this15, "keyCache", new Map);
                        _defineProperty(_this15, "inverseKeyCache", new WeakMap);
                        _defineProperty(_this15, "txConstructors", {});
                        _defineProperty(_this15, "maxRetryCount", void 0);
                        _defineProperty(_this15, "priorityQueue", []);
                        _defineProperty(_this15, "uploadTextureQueue", []);
                        _defineProperty(_this15, "initialized", false);
                        _defineProperty(_this15, "stage", void 0);
                        _defineProperty(_this15, "numImageWorkers", void 0);
                        _defineProperty(_this15, "enableAlphaChannel", void 0);
                        _defineProperty(_this15, "textureEnableAlphaFormats", void 0);
                        _defineProperty(_this15, "platform", void 0);
                        _defineProperty(_this15, "imageWorkerManager", null);
                        _defineProperty(_this15, "hasCreateImageBitmap", false);
                        _defineProperty(_this15, "imageBitmapSupported", {
                            basic: false,
                            options: false,
                            full: false
                        });
                        _defineProperty(_this15, "hasWorker", !!self.Worker);
                        _defineProperty(_this15, "renderer", void 0);
                        _defineProperty(_this15, "frameTime", 0);
                        var numImageWorkers = settings.numImageWorkers, createImageBitmapSupport = settings.createImageBitmapSupport, maxRetryCount = settings.maxRetryCount, enableAlphaChannel = settings.enableAlphaChannel, textureEnableAlphaFormats = settings.textureEnableAlphaFormats;
                        _this15.stage = stage;
                        _this15.platform = stage.platform;
                        _this15.numImageWorkers = numImageWorkers;
                        _this15.maxRetryCount = maxRetryCount;
                        _this15.enableAlphaChannel = enableAlphaChannel;
                        _this15.textureEnableAlphaFormats = textureEnableAlphaFormats;
                        if (createImageBitmapSupport === "auto") {
                            validateCreateImageBitmap(_this15.platform).then(function(result) {
                                _this15.initialize(result);
                            }).catch(function() {
                                console.warn("[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.");
                                _this15.initialized = true;
                                _this15.emit("initialized");
                            });
                        } else {
                            _this15.initialize({
                                basic: createImageBitmapSupport === "basic",
                                options: createImageBitmapSupport === "options",
                                full: createImageBitmapSupport === "full"
                            });
                        }
                        _this15.registerTextureType("ImageTexture", ImageTexture);
                        _this15.registerTextureType("ColorTexture", ColorTexture);
                        _this15.registerTextureType("NoiseTexture", NoiseTexture);
                        _this15.registerTextureType("SubTexture", SubTexture);
                        _this15.registerTextureType("RenderTexture", RenderTexture);
                        return _this15;
                    }
                    _inherits(CoreTextureManager, _EventEmitter6);
                    return _createClass(CoreTextureManager, [ {
                        key: "registerTextureType",
                        value: function registerTextureType(textureType, textureClass) {
                            this.txConstructors[textureType] = textureClass;
                        }
                    }, {
                        key: "initialize",
                        value: function initialize(support) {
                            this.hasCreateImageBitmap = support.basic || support.options || support.full;
                            this.imageBitmapSupported = support;
                            if (this.hasCreateImageBitmap === false) {
                                console.warn("[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.");
                            }
                            if (this.hasCreateImageBitmap === true && this.hasWorker === true && this.numImageWorkers > 0) {
                                this.imageWorkerManager = new ImageWorkerManager(this.numImageWorkers, support);
                            } else {
                                console.warn("[Lightning] Imageworker is 0 or not supported on this browser. Image loading will be slower.");
                            }
                            this.initialized = true;
                            this.emit("initialized");
                        }
                    }, {
                        key: "enqueueUploadTexture",
                        value: function enqueueUploadTexture(texture) {
                            if (this.uploadTextureQueue.includes(texture) === false) {
                                this.uploadTextureQueue.push(texture);
                            }
                        }
                    }, {
                        key: "createTexture",
                        value: function createTexture(textureType, props) {
                            var texture;
                            var TextureClass = this.txConstructors[textureType];
                            if (!TextureClass) {
                                throw new Error('Texture type "'.concat(textureType, '" is not registered'));
                            }
                            if (textureType === "ImageTexture" && props) {
                                var p = props;
                                if (p.enableAlphaChannel === undefined || p.enableAlphaChannel === null) {
                                    var useTransparency = this.enableAlphaChannel;
                                    if (this.textureEnableAlphaFormats && typeof p.src === "string") {
                                        var _p$src$split$pop;
                                        var ext = (_p$src$split$pop = p.src.split(".").pop()) === null || _p$src$split$pop === void 0 ? void 0 : _p$src$split$pop.toLowerCase();
                                        if (ext && this.textureEnableAlphaFormats.includes(ext)) {
                                            useTransparency = true;
                                        }
                                    }
                                    if (useTransparency === true) {
                                        p.enableAlphaChannel = true;
                                    }
                                }
                            }
                            var resolvedProps = TextureClass.resolveDefaults(props);
                            var cacheKey = TextureClass.makeCacheKey(resolvedProps);
                            if (cacheKey && this.keyCache.has(cacheKey)) {
                                texture = this.keyCache.get(cacheKey);
                            } else {
                                texture = new TextureClass(this, resolvedProps);
                                if (cacheKey) {
                                    this.initTextureToCache(texture, cacheKey);
                                }
                            }
                            return texture;
                        }
                    }, {
                        key: "loadTexture",
                        value: function() {
                            var _loadTexture = _asyncToGenerator(_regenerator().m(function _callee12(texture, priority) {
                                var textureDataResult, shouldUploadImmediately;
                                return _regenerator().w(function(_context12) {
                                    while (1) switch (_context12.n) {
                                      case 0:
                                        this.stage.txMemManager.removeFromOrphanedTextures(texture);
                                        if (!(texture.type === TextureType.subTexture)) {
                                            _context12.n = 1;
                                            break;
                                        }
                                        return _context12.a(2);

                                      case 1:
                                        if (!(texture.state === "loaded")) {
                                            _context12.n = 2;
                                            break;
                                        }
                                        return _context12.a(2);

                                      case 2:
                                        if (!(this.initialized === false)) {
                                            _context12.n = 3;
                                            break;
                                        }
                                        this.priorityQueue.push(texture);
                                        return _context12.a(2);

                                      case 3:
                                        texture.setState("loading");
                                        _context12.n = 4;
                                        return texture.getTextureData().catch(function(err) {
                                            console.error(err);
                                            texture.setState("failed");
                                            return null;
                                        });

                                      case 4:
                                        textureDataResult = _context12.v;
                                        if (!(textureDataResult === null || texture.state === "failed")) {
                                            _context12.n = 5;
                                            break;
                                        }
                                        return _context12.a(2);

                                      case 5:
                                        shouldUploadImmediately = texture.type !== TextureType.image || priority === true;
                                        if (!(shouldUploadImmediately === true)) {
                                            _context12.n = 7;
                                            break;
                                        }
                                        _context12.n = 6;
                                        return this.uploadTexture(texture).catch(function(err) {
                                            console.error("Failed to upload texture:", err);
                                            texture.setState("failed");
                                        });

                                      case 6:
                                        return _context12.a(2);

                                      case 7:
                                        this.enqueueUploadTexture(texture);

                                      case 8:
                                        return _context12.a(2);
                                    }
                                }, _callee12, this);
                            }));
                            function loadTexture(_x14, _x15) {
                                return _loadTexture.apply(this, arguments);
                            }
                            return loadTexture;
                        }()
                    }, {
                        key: "uploadTexture",
                        value: function() {
                            var _uploadTexture = _asyncToGenerator(_regenerator().m(function _callee13(texture) {
                                var coreContext;
                                return _regenerator().w(function(_context13) {
                                    while (1) switch (_context13.n) {
                                      case 0:
                                        if (!(this.stage.txMemManager.doNotExceedCriticalThreshold === true && this.stage.txMemManager.criticalCleanupRequested === true)) {
                                            _context13.n = 1;
                                            break;
                                        }
                                        texture.setState("failed");
                                        return _context13.a(2);

                                      case 1:
                                        if (!(texture.state === "failed" || texture.state === "freed")) {
                                            _context13.n = 2;
                                            break;
                                        }
                                        return _context13.a(2);

                                      case 2:
                                        if (!(texture.state === "loaded")) {
                                            _context13.n = 3;
                                            break;
                                        }
                                        return _context13.a(2);

                                      case 3:
                                        if (!(texture.textureData === null)) {
                                            _context13.n = 4;
                                            break;
                                        }
                                        texture.setState("failed", new TextureError(TextureErrorCode.TEXTURE_DATA_NULL, "Texture data is null, cannot upload texture"));
                                        return _context13.a(2);

                                      case 4:
                                        coreContext = texture.loadCtxTexture();
                                        if (!(coreContext !== null && coreContext.state === "loaded")) {
                                            _context13.n = 5;
                                            break;
                                        }
                                        texture.setState("loaded");
                                        return _context13.a(2);

                                      case 5:
                                        _context13.n = 6;
                                        return coreContext.load();

                                      case 6:
                                        return _context13.a(2);
                                    }
                                }, _callee13, this);
                            }));
                            function uploadTexture(_x16) {
                                return _uploadTexture.apply(this, arguments);
                            }
                            return uploadTexture;
                        }()
                    }, {
                        key: "isProcessingTexture",
                        value: function isProcessingTexture(texture) {
                            return this.uploadTextureQueue.includes(texture) === true;
                        }
                    }, {
                        key: "processSome",
                        value: function() {
                            var _processSome = _asyncToGenerator(_regenerator().m(function _callee14(maxProcessingTime) {
                                var platform, startTime, texture, _texture, _t5, _t6;
                                return _regenerator().w(function(_context14) {
                                    while (1) switch (_context14.p = _context14.n) {
                                      case 0:
                                        if (!(this.initialized === false)) {
                                            _context14.n = 1;
                                            break;
                                        }
                                        return _context14.a(2);

                                      case 1:
                                        platform = this.platform;
                                        startTime = platform.getTimeStamp();

                                      case 2:
                                        if (!(this.priorityQueue.length > 0 && platform.getTimeStamp() - startTime < maxProcessingTime)) {
                                            _context14.n = 8;
                                            break;
                                        }
                                        texture = this.priorityQueue.pop();
                                        _context14.p = 3;
                                        _context14.n = 4;
                                        return texture.getTextureData();

                                      case 4:
                                        _context14.n = 5;
                                        return this.uploadTexture(texture);

                                      case 5:
                                        _context14.n = 7;
                                        break;

                                      case 6:
                                        _context14.p = 6;
                                        _t5 = _context14.v;
                                        console.error("Failed to process priority texture:", _t5);

                                      case 7:
                                        _context14.n = 2;
                                        break;

                                      case 8:
                                        if (!(this.uploadTextureQueue.length > 0 && platform.getTimeStamp() - startTime < maxProcessingTime)) {
                                            _context14.n = 13;
                                            break;
                                        }
                                        _texture = this.uploadTextureQueue.shift();
                                        _context14.p = 9;
                                        _context14.n = 10;
                                        return this.uploadTexture(_texture);

                                      case 10:
                                        _context14.n = 12;
                                        break;

                                      case 11:
                                        _context14.p = 11;
                                        _t6 = _context14.v;
                                        console.error("Failed to upload texture:", _t6);

                                      case 12:
                                        _context14.n = 8;
                                        break;

                                      case 13:
                                        return _context14.a(2);
                                    }
                                }, _callee14, this, [ [ 9, 11 ], [ 3, 6 ] ]);
                            }));
                            function processSome(_x17) {
                                return _processSome.apply(this, arguments);
                            }
                            return processSome;
                        }()
                    }, {
                        key: "hasUpdates",
                        value: function hasUpdates() {
                            return this.uploadTextureQueue.length > 0 || this.priorityQueue.length > 0;
                        }
                    }, {
                        key: "initTextureToCache",
                        value: function initTextureToCache(texture, cacheKey) {
                            var keyCache = this.keyCache, inverseKeyCache = this.inverseKeyCache;
                            keyCache.set(cacheKey, texture);
                            inverseKeyCache.set(texture, cacheKey);
                        }
                    }, {
                        key: "getTextureFromCache",
                        value: function getTextureFromCache(cacheKey) {
                            return this.keyCache.get(cacheKey);
                        }
                    }, {
                        key: "removeTextureFromCache",
                        value: function removeTextureFromCache(texture) {
                            var inverseKeyCache = this.inverseKeyCache, keyCache = this.keyCache;
                            var cacheKey = inverseKeyCache.get(texture);
                            if (cacheKey) {
                                keyCache.delete(cacheKey);
                            }
                        }
                    }, {
                        key: "removeTextureFromQueue",
                        value: function removeTextureFromQueue(texture) {
                            var uploadIndex = this.uploadTextureQueue.indexOf(texture);
                            if (uploadIndex !== -1) {
                                this.uploadTextureQueue.splice(uploadIndex, 1);
                            }
                        }
                    }, {
                        key: "resolveParentTexture",
                        value: function resolveParentTexture(texture) {
                            if (!(texture !== null && texture !== void 0 && texture.props)) {
                                return texture;
                            }
                            var cacheKey = ImageTexture.makeCacheKey(texture.props);
                            var cachedTexture = cacheKey ? this.getTextureFromCache(cacheKey) : undefined;
                            return cachedTexture !== null && cachedTexture !== void 0 ? cachedTexture : texture;
                        }
                    } ]);
                }(EventEmitter);
                function isAdvancedShaderProp(obj) {
                    return obj !== null && _typeof(obj) === "object" && obj.default !== undefined;
                }
                function resolveShaderProps(props, propsConfig) {
                    for (var key in propsConfig) {
                        if (!isAdvancedShaderProp(propsConfig[key]) && props[key] === undefined) {
                            props[key] = propsConfig[key];
                            continue;
                        }
                        var pConfig = propsConfig[key];
                        var hasValue = props[key] !== undefined;
                        if (pConfig.resolve !== undefined) {
                            props[key] = pConfig.resolve(props[key], props);
                            continue;
                        }
                        if (hasValue && pConfig.set !== undefined) {
                            pConfig.set(props[key], props);
                            continue;
                        }
                        if (hasValue) {
                            continue;
                        }
                        if (props[key] === undefined && pConfig.get === undefined) {
                            props[key] = deepClone(pConfig.default);
                            continue;
                        }
                        props[key] = pConfig.get(props);
                    }
                }
                var CoreShaderNode = function() {
                    function CoreShaderNode(shaderKey, type, stage, props) {
                        _classCallCheck(this, CoreShaderNode);
                        _defineProperty(this, "shaderKey", void 0);
                        _defineProperty(this, "stage", void 0);
                        _defineProperty(this, "shaderType", void 0);
                        _defineProperty(this, "propsConfig", void 0);
                        _defineProperty(this, "resolvedProps", undefined);
                        _defineProperty(this, "definedProps", undefined);
                        _defineProperty(this, "node", null);
                        _defineProperty(this, "time", undefined);
                        _defineProperty(this, "update", undefined);
                        _defineProperty(this, "_valueKeyCache", "");
                        _defineProperty(this, "_valueKeyDirty", true);
                        _defineProperty(this, "_lastW", 0);
                        _defineProperty(this, "_lastH", 0);
                        this.shaderKey = shaderKey;
                        this.stage = stage;
                        this.shaderType = type;
                        this.time = type.time;
                        if (props !== undefined) {
                            this.resolvedProps = props;
                            this.defineProps(props);
                        }
                    }
                    return _createClass(CoreShaderNode, [ {
                        key: "defineProps",
                        value: function defineProps(props) {
                            var _this16 = this;
                            var definedProps = {};
                            var _loop = function _loop(key) {
                                var propConfig = _this16.shaderType.props[key];
                                var isAdvancedProp = isAdvancedShaderProp(propConfig);
                                Object.defineProperty(definedProps, key, {
                                    get: function get() {
                                        return _this16.resolvedProps[key];
                                    },
                                    set: function set(value) {
                                        if (isAdvancedProp === true && propConfig.resolve !== undefined) {
                                            _this16.resolvedProps[key] = propConfig.resolve(value, _this16.resolvedProps);
                                        } else if (isAdvancedProp === true && propConfig.set !== undefined) {
                                            propConfig.set(value, _this16.resolvedProps);
                                        } else {
                                            _this16.resolvedProps[key] = value;
                                        }
                                        _this16._valueKeyDirty = true;
                                        if (_this16.update !== undefined && _this16.node !== null) {
                                            _this16.node.setUpdateType(UpdateType.RecalcUniforms);
                                        } else {
                                            _this16.stage.requestRender();
                                        }
                                    }
                                });
                            };
                            for (var key in props) {
                                _loop(key);
                            }
                            this.definedProps = definedProps;
                        }
                    }, {
                        key: "attachNode",
                        value: function attachNode(node) {
                            this.node = node;
                        }
                    }, {
                        key: "createValueKey",
                        value: function createValueKey() {
                            if (this._valueKeyDirty === false && this.node !== null && this.node.w === this._lastW && this.node.h === this._lastH) {
                                return this._valueKeyCache;
                            }
                            var valueKey = "";
                            for (var key in this.resolvedProps) {
                                valueKey += "".concat(key, ":").concat(this.resolvedProps[key], ";");
                            }
                            valueKey += "node-width:".concat(this.node.w);
                            valueKey += "node-height:".concat(this.node.h);
                            this._valueKeyCache = valueKey;
                            this._valueKeyDirty = false;
                            this._lastW = this.node.w;
                            this._lastH = this.node.h;
                            return valueKey;
                        }
                    }, {
                        key: "props",
                        get: function get() {
                            return this.definedProps;
                        },
                        set: function set(props) {
                            if (props === undefined) {
                                return;
                            }
                            for (var key in props) {
                                this.props[key] = props[key];
                            }
                        }
                    } ]);
                }();
                var CoreShaderManager = function() {
                    function CoreShaderManager(stage) {
                        _classCallCheck(this, CoreShaderManager);
                        _defineProperty(this, "stage", void 0);
                        _defineProperty(this, "shTypes", {});
                        _defineProperty(this, "shCache", new Map);
                        _defineProperty(this, "valuesCache", new Map);
                        _defineProperty(this, "valuesCacheUsage", new Map);
                        _defineProperty(this, "attachedShader", null);
                        this.stage = stage;
                    }
                    return _createClass(CoreShaderManager, [ {
                        key: "registerShaderType",
                        value: function registerShaderType(name, shType) {
                            if (this.shTypes[name] !== undefined) {
                                console.warn("ShaderType already exists with the name: ".concat(name, ". Breaking off registration."));
                                return;
                            }
                            if (this.stage.renderer.supportsShaderType(shType) === false) {
                                console.warn("The renderer being used does not support this shader type. Breaking off registration.");
                                return;
                            }
                            this.shTypes[name] = deepClone(shType);
                        }
                    }, {
                        key: "createShader",
                        value: function createShader(name, props) {
                            var shType = this.shTypes[name];
                            if (shType === undefined) {
                                console.warn("ShaderType not found falling back on renderer default shader");
                                return this.stage.defShaderNode;
                            }
                            var shaderKey = name;
                            if (shType.props !== undefined) {
                                props = props || {};
                                resolveShaderProps(props, shType.props);
                                if (shType.getCacheMarkers !== undefined) {
                                    shaderKey += "-".concat(shType.getCacheMarkers(props));
                                }
                            }
                            if (this.stage.renderer.mode === "canvas") {
                                return this.stage.renderer.createShaderNode(shaderKey, shType, props);
                            }
                            var shProgram = this.shCache.get(shaderKey);
                            if (shProgram === undefined) {
                                shProgram = this.stage.renderer.createShaderProgram(shType, props);
                                this.shCache.set(shaderKey, shProgram);
                            }
                            return this.stage.renderer.createShaderNode(shaderKey, shType, props, shProgram);
                        }
                    }, {
                        key: "mutateShaderValueUsage",
                        value: function mutateShaderValueUsage(key, mutation) {
                            var usage = this.valuesCacheUsage.get(key) || 0;
                            this.valuesCacheUsage.set(key, usage + mutation);
                        }
                    }, {
                        key: "getShaderValues",
                        value: function getShaderValues(key) {
                            var values = this.valuesCache.get(key);
                            if (values === undefined) {
                                return undefined;
                            }
                            this.mutateShaderValueUsage(key, 1);
                            return values;
                        }
                    }, {
                        key: "setShaderValues",
                        value: function setShaderValues(key, values) {
                            this.valuesCache.set(key, values);
                            this.mutateShaderValueUsage(key, 1);
                        }
                    }, {
                        key: "cleanup",
                        value: function cleanup() {
                            var values = _toConsumableArray(this.valuesCacheUsage.entries()).sort(function(entryA, entryB) {
                                if (entryA[1] < entryB[1]) {
                                    return -1;
                                } else if (entryA[1] > entryB[1]) {
                                    return 1;
                                }
                                return 0;
                            });
                            for (var i = 0; i < values.length; i++) {
                                if (values[i][1] > 0) {
                                    break;
                                }
                                this.valuesCacheUsage.delete(values[i][0]);
                                this.valuesCache.delete(values[i][0]);
                            }
                        }
                    }, {
                        key: "useShader",
                        value: function useShader(shader) {
                            if (this.attachedShader === shader) {
                                return;
                            }
                            if (this.attachedShader && this.attachedShader.detach) {
                                this.attachedShader.detach();
                            }
                            if (shader.attach) {
                                shader.attach();
                            }
                            this.attachedShader = shader;
                        }
                    } ]);
                }();
                var ContextSpy = function() {
                    function ContextSpy() {
                        _classCallCheck(this, ContextSpy);
                        _defineProperty(this, "data", {});
                    }
                    return _createClass(ContextSpy, [ {
                        key: "reset",
                        value: function reset() {
                            this.data = {};
                        }
                    }, {
                        key: "increment",
                        value: function increment(name) {
                            if (!this.data[name]) {
                                this.data[name] = 0;
                            }
                            this.data[name]++;
                        }
                    }, {
                        key: "getData",
                        value: function getData() {
                            return _objectSpread({}, this.data);
                        }
                    } ]);
                }();
                var TextureMemoryManager = function() {
                    function TextureMemoryManager(stage, settings) {
                        _classCallCheck(this, TextureMemoryManager);
                        _defineProperty(this, "stage", void 0);
                        _defineProperty(this, "memUsed", 0);
                        _defineProperty(this, "loadedTextures", []);
                        _defineProperty(this, "orphanedTextures", []);
                        _defineProperty(this, "criticalThreshold", 124e6);
                        _defineProperty(this, "targetThreshold", .5);
                        _defineProperty(this, "cleanupInterval", 5e3);
                        _defineProperty(this, "debugLogging", false);
                        _defineProperty(this, "loggingID", 0);
                        _defineProperty(this, "lastCleanupTime", 0);
                        _defineProperty(this, "baselineMemoryAllocation", 26e6);
                        _defineProperty(this, "hasWarnedAboveCritical", false);
                        _defineProperty(this, "criticalCleanupRequested", false);
                        _defineProperty(this, "doNotExceedCriticalThreshold", false);
                        _defineProperty(this, "frameTime", 0);
                        this.stage = stage;
                        this.updateSettings(settings);
                    }
                    return _createClass(TextureMemoryManager, [ {
                        key: "addToOrphanedTextures",
                        value: function addToOrphanedTextures(texture) {
                            if (this.orphanedTextures.includes(texture)) {
                                this.removeFromOrphanedTextures(texture);
                            }
                            if (texture.preventCleanup === false) {
                                this.orphanedTextures.push(texture);
                            }
                        }
                    }, {
                        key: "removeFromOrphanedTextures",
                        value: function removeFromOrphanedTextures(texture) {
                            var index = this.orphanedTextures.indexOf(texture);
                            if (index !== -1) {
                                this.orphanedTextures.splice(index, 1);
                            }
                        }
                    }, {
                        key: "setTextureMemUse",
                        value: function setTextureMemUse(texture, byteSize) {
                            this.memUsed -= texture.memUsed;
                            if (byteSize === 0) {
                                var index = this.loadedTextures.indexOf(texture);
                                if (index !== -1) {
                                    this.loadedTextures[index] = null;
                                }
                                texture.memUsed = 0;
                                return;
                            } else {
                                texture.memUsed = byteSize;
                                this.memUsed += byteSize;
                                if (this.loadedTextures.indexOf(texture) === -1) {
                                    var emptyIndex = this.loadedTextures.indexOf(null);
                                    if (emptyIndex !== -1) {
                                        this.loadedTextures[emptyIndex] = texture;
                                    } else {
                                        this.loadedTextures.push(texture);
                                    }
                                }
                            }
                            if (this.memUsed > this.criticalThreshold) {
                                this.criticalCleanupRequested = true;
                            }
                        }
                    }, {
                        key: "checkCleanup",
                        value: function checkCleanup() {
                            return this.criticalCleanupRequested || this.memUsed > this.targetThreshold && this.frameTime - this.lastCleanupTime >= this.cleanupInterval;
                        }
                    }, {
                        key: "checkCriticalCleanup",
                        value: function checkCriticalCleanup() {
                            return this.memUsed > this.criticalThreshold;
                        }
                    }, {
                        key: "destroyTexture",
                        value: function destroyTexture(texture) {
                            if (this.debugLogging === true) {
                                console.log("[TextureMemoryManager] Destroying texture. State: ".concat(texture.state));
                            }
                            var index = this.loadedTextures.indexOf(texture);
                            if (index !== -1) {
                                this.loadedTextures[index] = null;
                            }
                            var txManager = this.stage.txManager;
                            txManager.removeTextureFromCache(texture);
                            texture.destroy();
                            this.memUsed -= texture.memUsed;
                            texture.memUsed = 0;
                        }
                    }, {
                        key: "cleanup",
                        value: function cleanup() {
                            var full = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                            var critical = this.criticalCleanupRequested;
                            this.lastCleanupTime = this.frameTime;
                            if (critical === true) {
                                this.stage.queueFrameEvent("criticalCleanup", {
                                    memUsed: this.memUsed,
                                    criticalThreshold: this.criticalThreshold
                                });
                            }
                            if (this.debugLogging === true) {
                                console.log("[TextureMemoryManager] Cleaning up textures. Critical: ".concat(critical, ". Full: ").concat(full));
                            }
                            var memTarget = critical ? this.criticalThreshold : this.targetThreshold;
                            var currentMemUsed = this.memUsed;
                            for (var i = 0; i < this.loadedTextures.length; i++) {
                                if (full === false && currentMemUsed < memTarget) {
                                    break;
                                }
                                var texture = this.loadedTextures[i];
                                if (!texture) continue;
                                var isCleanableType = texture.type === TextureType.image || texture.type === TextureType.noise || texture.type === TextureType.renderToTexture;
                                if (isCleanableType && texture.canBeCleanedUp() === true) {
                                    var textureMemory = texture.memUsed;
                                    this.destroyTexture(texture);
                                    currentMemUsed -= textureMemory;
                                }
                            }
                            if (this.memUsed >= this.criticalThreshold) {
                                this.stage.queueFrameEvent("criticalCleanupFailed", {
                                    memUsed: this.memUsed,
                                    criticalThreshold: this.criticalThreshold
                                });
                                if (!this.hasWarnedAboveCritical && (this.debugLogging === true || isProductionEnvironment === false)) {
                                    console.warn("[TextureMemoryManager] Memory usage above critical threshold after cleanup: ".concat(this.memUsed));
                                    this.hasWarnedAboveCritical = true;
                                }
                            } else {
                                this.criticalCleanupRequested = false;
                                this.hasWarnedAboveCritical = false;
                            }
                        }
                    }, {
                        key: "getMemoryInfo",
                        value: function getMemoryInfo() {
                            var renderableTexturesLoaded = 0;
                            var renderableMemUsed = this.baselineMemoryAllocation;
                            var _iterator9 = _createForOfIteratorHelper(this.loadedTextures), _step9;
                            try {
                                for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                                    var texture = _step9.value;
                                    if (texture && texture.renderable) {
                                        renderableTexturesLoaded += 1;
                                        renderableMemUsed += texture.memUsed;
                                    }
                                }
                            } catch (err) {
                                _iterator9.e(err);
                            } finally {
                                _iterator9.f();
                            }
                            var actualLoadedTextures = this.loadedTextures.filter(function(t) {
                                return t !== null;
                            }).length;
                            return {
                                criticalThreshold: this.criticalThreshold,
                                targetThreshold: this.targetThreshold,
                                renderableMemUsed: renderableMemUsed,
                                memUsed: this.memUsed,
                                renderableTexturesLoaded: renderableTexturesLoaded,
                                loadedTextures: actualLoadedTextures,
                                baselineMemoryAllocation: this.baselineMemoryAllocation
                            };
                        }
                    }, {
                        key: "updateSettings",
                        value: function updateSettings(settings) {
                            var _this17 = this;
                            var criticalThreshold = settings.criticalThreshold, doNotExceedCriticalThreshold = settings.doNotExceedCriticalThreshold;
                            this.doNotExceedCriticalThreshold = doNotExceedCriticalThreshold || false;
                            this.criticalThreshold = Math.round(criticalThreshold);
                            if (this.memUsed === 0) {
                                this.memUsed = Math.round(settings.baselineMemoryAllocation);
                            } else {
                                var memUsedExBaseline = this.memUsed - this.baselineMemoryAllocation;
                                this.memUsed = Math.round(settings.baselineMemoryAllocation + memUsedExBaseline);
                            }
                            this.baselineMemoryAllocation = Math.round(settings.baselineMemoryAllocation);
                            var targetFraction = Math.max(0, Math.min(1, settings.targetThresholdLevel));
                            this.targetThreshold = Math.max(Math.round(criticalThreshold * targetFraction), this.baselineMemoryAllocation);
                            this.cleanupInterval = settings.cleanupInterval;
                            this.debugLogging = settings.debugLogging;
                            if (this.loggingID && !settings.debugLogging) {
                                clearInterval(this.loggingID);
                                this.loggingID = 0;
                            }
                            if (settings.debugLogging && !this.loggingID) {
                                var lastMemUse = 0;
                                this.loggingID = setInterval(function() {
                                    if (lastMemUse !== _this17.memUsed) {
                                        lastMemUse = _this17.memUsed;
                                        console.log("[TextureMemoryManager] Memory used: ".concat(bytesToMb$1(_this17.memUsed), " mb / ").concat(bytesToMb$1(_this17.criticalThreshold), " mb (").concat((_this17.memUsed / _this17.criticalThreshold * 100).toFixed(1), "%)"));
                                    }
                                }, 1e3);
                            }
                            if (criticalThreshold === 0) {
                                this.setTextureMemUse = function() {};
                            }
                        }
                    } ]);
                }();
                var CoreContextTexture = function() {
                    function CoreContextTexture(memManager, textureSource) {
                        _classCallCheck(this, CoreContextTexture);
                        _defineProperty(this, "textureSource", void 0);
                        _defineProperty(this, "memManager", void 0);
                        _defineProperty(this, "state", "freed");
                        this.memManager = memManager;
                        this.textureSource = textureSource;
                    }
                    return _createClass(CoreContextTexture, [ {
                        key: "setTextureMemUse",
                        value: function setTextureMemUse(byteSize) {
                            this.memManager.setTextureMemUse(this.textureSource, byteSize);
                        }
                    }, {
                        key: "renderable",
                        get: function get() {
                            return this.textureSource.renderable;
                        }
                    } ]);
                }();
                var CoreRenderer = _createClass(function CoreRenderer(options) {
                    _classCallCheck(this, CoreRenderer);
                    _defineProperty(this, "options", void 0);
                    _defineProperty(this, "mode", void 0);
                    _defineProperty(this, "defaultTextureCoords", undefined);
                    _defineProperty(this, "stage", void 0);
                    _defineProperty(this, "rttNodes", []);
                    this.options = options;
                    this.stage = options.stage;
                });
                var CoreRenderOp = _createClass(function CoreRenderOp() {
                    _classCallCheck(this, CoreRenderOp);
                });
                var SdfRenderOp = function(_CoreRenderOp) {
                    function SdfRenderOp(renderer, shader, sdfShaderProps, quadBufferCollection, worldAlpha, clippingRect, width, height, rtt, parentHasRenderTexture, framebufferDimensions) {
                        var _this18;
                        _classCallCheck(this, SdfRenderOp);
                        _this18 = _callSuper(this, SdfRenderOp);
                        _defineProperty(_this18, "renderer", void 0);
                        _defineProperty(_this18, "shader", void 0);
                        _defineProperty(_this18, "sdfShaderProps", void 0);
                        _defineProperty(_this18, "quadBufferCollection", void 0);
                        _defineProperty(_this18, "worldAlpha", void 0);
                        _defineProperty(_this18, "clippingRect", void 0);
                        _defineProperty(_this18, "width", void 0);
                        _defineProperty(_this18, "height", void 0);
                        _defineProperty(_this18, "rtt", void 0);
                        _defineProperty(_this18, "parentHasRenderTexture", void 0);
                        _defineProperty(_this18, "framebufferDimensions", void 0);
                        _defineProperty(_this18, "numQuads", 0);
                        _defineProperty(_this18, "isCoreNode", false);
                        _defineProperty(_this18, "renderOpTextures", []);
                        _defineProperty(_this18, "time", 0);
                        _defineProperty(_this18, "stage", void 0);
                        _this18.renderer = renderer;
                        _this18.shader = shader;
                        _this18.sdfShaderProps = sdfShaderProps;
                        _this18.quadBufferCollection = quadBufferCollection;
                        _this18.worldAlpha = worldAlpha;
                        _this18.clippingRect = clippingRect;
                        _this18.width = width;
                        _this18.height = height;
                        _this18.rtt = rtt;
                        _this18.parentHasRenderTexture = parentHasRenderTexture;
                        _this18.framebufferDimensions = framebufferDimensions;
                        _this18.stage = renderer.stage;
                        return _this18;
                    }
                    _inherits(SdfRenderOp, _CoreRenderOp);
                    return _createClass(SdfRenderOp, [ {
                        key: "addTexture",
                        value: function addTexture(texture) {
                            var renderOpTextures = this.renderOpTextures;
                            var length = renderOpTextures.length;
                            for (var i = 0; i < length; i++) {
                                if (renderOpTextures[i] === texture) {
                                    return i;
                                }
                            }
                            renderOpTextures.push(texture);
                            return length;
                        }
                    }, {
                        key: "draw",
                        value: function draw() {
                            var _this$renderer = this.renderer, glw = _this$renderer.glw, options = _this$renderer.options, stage = _this$renderer.stage;
                            stage.shManager.useShader(this.shader.program);
                            this.shader.program.bindRenderOp(this);
                            if (this.clippingRect.valid === true) {
                                var pixelRatio = this.parentHasRenderTexture ? 1 : stage.pixelRatio;
                                var clipX = Math.round(this.clippingRect.x * pixelRatio);
                                var clipWidth = Math.round(this.clippingRect.width * pixelRatio);
                                var clipHeight = Math.round(this.clippingRect.height * pixelRatio);
                                var clipY = Math.round(options.canvas.height - clipHeight - this.clippingRect.y * pixelRatio);
                                if (this.parentHasRenderTexture) {
                                    clipY = this.framebufferDimensions ? this.framebufferDimensions.h - this.height : 0;
                                }
                                glw.setScissorTest(true);
                                glw.scissor(clipX, clipY, clipWidth, clipHeight);
                            } else {
                                glw.setScissorTest(false);
                            }
                            glw.drawArrays(glw.TRIANGLES, 0, 6 * this.numQuads);
                        }
                    } ]);
                }(CoreRenderOp);
                var TextConstraint;
                (function(TextConstraint) {
                    TextConstraint[TextConstraint["none"] = 0] = "none";
                    TextConstraint[TextConstraint["width"] = 1] = "width";
                    TextConstraint[TextConstraint["height"] = 2] = "height";
                    TextConstraint[TextConstraint["both"] = 4] = "both";
                })(TextConstraint || (TextConstraint = {}));
                var CoreTextNode = function(_CoreNode2) {
                    function CoreTextNode(stage, props, textRenderer) {
                        var _this19;
                        _classCallCheck(this, CoreTextNode);
                        _this19 = _callSuper(this, CoreTextNode, [ stage, props ]);
                        _defineProperty(_this19, "textRenderer", void 0);
                        _defineProperty(_this19, "fontHandler", void 0);
                        _defineProperty(_this19, "_layoutGenerated", false);
                        _defineProperty(_this19, "_waitingForFont", false);
                        _defineProperty(_this19, "_containType", TextConstraint.none);
                        _defineProperty(_this19, "_cachedLayout", null);
                        _defineProperty(_this19, "_lastVertexBuffer", null);
                        _defineProperty(_this19, "_cachedRenderOp", null);
                        _defineProperty(_this19, "textProps", void 0);
                        _defineProperty(_this19, "_renderInfo", {
                            width: 0,
                            height: 0
                        });
                        _defineProperty(_this19, "_type", "sdf");
                        _defineProperty(_this19, "onTextureLoaded", function(_, dimensions) {
                            if (_this19.parentHasRenderTexture) {
                                _this19.notifyParentRTTOfUpdate();
                            }
                            if (dimensions.w > 1 && dimensions.h > 1) {
                                _this19.emit("loaded", {
                                    type: "texture",
                                    dimensions: dimensions
                                });
                            }
                            _this19.setUpdateType(UpdateType.IsRenderable);
                        });
                        _defineProperty(_this19, "emitTextLoadedEvent", function() {
                            _this19.emit("loaded", {
                                type: "text",
                                dimensions: {
                                    w: _this19._renderInfo.width,
                                    h: _this19._renderInfo.height
                                }
                            });
                        });
                        _this19.textRenderer = textRenderer;
                        _this19.fontHandler = textRenderer.font;
                        _this19._type = textRenderer.type;
                        _this19.textProps = props;
                        _this19._containType = TextConstraint[props.contain];
                        _this19.setUpdateType(UpdateType.All);
                        return _this19;
                    }
                    _inherits(CoreTextNode, _CoreNode2);
                    return _createClass(CoreTextNode, [ {
                        key: "allowTextGeneration",
                        value: function allowTextGeneration() {
                            var p = this.props.parent;
                            if (p === null) {
                                return false;
                            }
                            if (p.worldAlpha > 0 && p.renderState > CoreNodeRenderState.OutOfBounds) {
                                return true;
                            }
                            return false;
                        }
                    }, {
                        key: "updateLocalTransform",
                        value: function updateLocalTransform() {
                            var p = this.props;
                            var x = p.x, y = p.y, w = p.w, h = p.h;
                            var mountX = p.mountX;
                            var mountY = p.mountY;
                            var mountTranslateX = p.mountX * w;
                            var mountTranslateY = p.mountY * h;
                            var tProps = this.textProps;
                            var textAlign = tProps.textAlign, verticalAlign = tProps.verticalAlign, maxWidth = tProps.maxWidth, maxHeight = tProps.maxHeight;
                            var contain = this._containType;
                            var hasMaxWidth = maxWidth > 0;
                            var hasMaxHeight = maxHeight > 0;
                            var containX = 0;
                            var containY = 0;
                            if (contain > 0 && (hasMaxWidth || hasMaxHeight)) {
                                if (contain & TextConstraint.width && hasMaxWidth === true) {
                                    if (textAlign === "right") {
                                        containX = maxWidth - w;
                                    } else if (textAlign === "center") {
                                        containX = (maxWidth - w) * .5;
                                    }
                                    mountTranslateX = mountX * maxWidth;
                                }
                                if (contain & TextConstraint.height && maxHeight > 0) {
                                    if (verticalAlign === "bottom") {
                                        containY = maxHeight - h;
                                    } else if (verticalAlign === "middle") {
                                        containY = (maxHeight - h) * .5;
                                    }
                                    mountTranslateY = mountY * maxHeight;
                                }
                            }
                            if (p.rotation !== 0 || p.scaleX !== 1 || p.scaleY !== 1) {
                                var scaleRotate = Matrix3d.rotate(p.rotation, Matrix3d.temp).scale(p.scaleX, p.scaleY);
                                var pivotW = contain & TextConstraint.width && maxWidth > 0 ? maxWidth : w;
                                var pivotH = contain & TextConstraint.height && maxHeight > 0 ? maxHeight : h;
                                var pivotTranslateX = p.pivotX * pivotW;
                                var pivotTranslateY = p.pivotY * pivotH;
                                this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(scaleRotate).translate(-pivotTranslateX, -pivotTranslateY);
                            } else {
                                this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
                            }
                            if (containX !== 0 || containY !== 0) {
                                this.localTransform.translate(containX, containY);
                            }
                        }
                    }, {
                        key: "update",
                        value: function update(delta, parentClippingRect) {
                            if ((this.textProps.forceLoad === true || this.allowTextGeneration() === true) && this._layoutGenerated === false) {
                                if (this.fontHandler.isFontLoaded(this.textProps.fontFamily) === true) {
                                    this._waitingForFont = false;
                                    this._cachedLayout = null;
                                    this._lastVertexBuffer = null;
                                    var resp = this.textRenderer.renderText(this.textProps);
                                    this.handleRenderResult(resp);
                                    this._layoutGenerated = true;
                                } else if (this._waitingForFont === false) {
                                    this.fontHandler.waitingForFont(this.textProps.fontFamily, this);
                                    this._waitingForFont = true;
                                }
                            }
                            _superPropGet(CoreTextNode, "update", this, 3)([ delta, parentClippingRect ]);
                        }
                    }, {
                        key: "updateIsRenderable",
                        value: function updateIsRenderable() {
                            if (this._type === "canvas") {
                                _superPropGet(CoreTextNode, "updateIsRenderable", this, 3)([]);
                                return;
                            }
                            this.setRenderable(this._cachedLayout !== null);
                        }
                    }, {
                        key: "handleRenderResult",
                        value: function handleRenderResult(result) {
                            var textRendererType = this._type;
                            var width = result.width;
                            var height = result.height;
                            if (textRendererType === "canvas") {
                                if (result.imageData === undefined) {
                                    this.emit("failed", {
                                        type: "text",
                                        error: new Error("Canvas text rendering failed, no image data returned")
                                    });
                                    return;
                                }
                                this.texture = this.stage.txManager.createTexture("ImageTexture", {
                                    premultiplyAlpha: true,
                                    src: result.imageData
                                });
                                this.setRenderable(false);
                                if (this.renderState > CoreNodeRenderState.OutOfBounds) {
                                    this.texture.setRenderableOwner(this._id, true);
                                }
                            }
                            this._cachedLayout = result.layout || null;
                            this._cachedRenderOp = null;
                            this.props.w = width;
                            this.props.h = height;
                            if (textRendererType === "sdf") {
                                this.setRenderable(true);
                                this.setUpdateType(UpdateType.Local);
                            }
                            this._renderInfo = result;
                            this.emitTextLoadedEvent();
                        }
                    }, {
                        key: "renderQuads",
                        value: function renderQuads(renderer) {
                            if (this.parentHasRenderTexture === true) {
                                var rtt = renderer.renderToTextureActive;
                                if (rtt === false || this.parentRenderTexture !== renderer.activeRttNode) return;
                            }
                            if (this._type === "canvas") {
                                _superPropGet(CoreTextNode, "renderQuads", this, 3)([ renderer ]);
                                return;
                            }
                            if (!this._cachedLayout) {
                                return;
                            }
                            if (this._lastVertexBuffer === null) {
                                this._lastVertexBuffer = this.textRenderer.addQuads(this._cachedLayout);
                            }
                            var props = this.textProps;
                            if (!this._cachedRenderOp) {
                                var op = this.textRenderer.renderQuads(renderer, this._cachedLayout, this._lastVertexBuffer, {
                                    fontFamily: this.textProps.fontFamily,
                                    fontSize: props.fontSize,
                                    color: this.props.color || 4294967295,
                                    offsetY: props.offsetY,
                                    worldAlpha: this.worldAlpha,
                                    globalTransform: this.globalTransform.getFloatArr(),
                                    clippingRect: this.clippingRect,
                                    width: this.props.w,
                                    height: this.props.h,
                                    parentHasRenderTexture: this.parentHasRenderTexture,
                                    framebufferDimensions: this.parentHasRenderTexture === true ? this.parentFramebufferDimensions : null,
                                    stage: this.stage
                                });
                                if (op !== null && op !== undefined) {
                                    this._cachedRenderOp = op;
                                }
                            }
                            if (this._cachedRenderOp) {
                                this._cachedRenderOp.worldAlpha = this.worldAlpha;
                                this._cachedRenderOp.clippingRect = this.clippingRect;
                                this._cachedRenderOp.sdfShaderProps.color = mergeColorAlpha(this.props.color || 4294967295, this.worldAlpha);
                                this._cachedRenderOp.sdfShaderProps.transform = this.globalTransform.getFloatArr();
                                this._cachedRenderOp.parentHasRenderTexture = this.parentHasRenderTexture;
                                this._cachedRenderOp.framebufferDimensions = this.parentHasRenderTexture === true ? this.parentFramebufferDimensions : null;
                                renderer.addRenderOp(this._cachedRenderOp);
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            if (this._waitingForFont === true && this.fontHandler) {
                                this.fontHandler.stopWaitingForFont(this.textProps.fontFamily, this);
                            }
                            this._cachedLayout = null;
                            this._lastVertexBuffer = null;
                            this._cachedRenderOp = null;
                            this.fontHandler = null;
                            this.textRenderer = null;
                            _superPropGet(CoreTextNode, "destroy", this, 3)([]);
                        }
                    }, {
                        key: "w",
                        get: function get() {
                            return this.props.w;
                        },
                        set: function set(value) {
                            this.maxWidth = value;
                        }
                    }, {
                        key: "h",
                        get: function get() {
                            return this.props.h;
                        },
                        set: function set(value) {
                            this.maxHeight = value;
                        }
                    }, {
                        key: "maxWidth",
                        get: function get() {
                            return this.textProps.maxWidth;
                        },
                        set: function set(value) {
                            if (this.textProps.maxWidth !== value) {
                                this.textProps.maxWidth = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "maxHeight",
                        get: function get() {
                            return this.textProps.maxHeight;
                        },
                        set: function set(value) {
                            if (this.textProps.maxHeight !== value) {
                                this.textProps.maxHeight = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "contain",
                        get: function get() {
                            return this.textProps.contain;
                        },
                        set: function set(value) {
                            if (this.textProps.contain !== value) {
                                this.textProps.contain = value;
                                this._containType = TextConstraint[value];
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "text",
                        get: function get() {
                            return this.textProps.text;
                        },
                        set: function set(value) {
                            if (this.textProps.text !== value) {
                                this.textProps.text = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "fontSize",
                        get: function get() {
                            return this.textProps.fontSize;
                        },
                        set: function set(value) {
                            if (this.textProps.fontSize !== value) {
                                this.textProps.fontSize = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "fontFamily",
                        get: function get() {
                            return this.textProps.fontFamily;
                        },
                        set: function set(value) {
                            if (this.textProps.fontFamily !== value) {
                                if (this._waitingForFont === true) {
                                    this.fontHandler.stopWaitingForFont(this.textProps.fontFamily, this);
                                }
                                this.textProps.fontFamily = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "fontStyle",
                        get: function get() {
                            return this.textProps.fontStyle;
                        },
                        set: function set(value) {
                            if (this.textProps.fontStyle !== value) {
                                this.textProps.fontStyle = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "textAlign",
                        get: function get() {
                            return this.textProps.textAlign;
                        },
                        set: function set(value) {
                            if (this.textProps.textAlign !== value) {
                                this.textProps.textAlign = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "letterSpacing",
                        get: function get() {
                            return this.textProps.letterSpacing;
                        },
                        set: function set(value) {
                            if (this.textProps.letterSpacing !== value) {
                                this.textProps.letterSpacing = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "lineHeight",
                        get: function get() {
                            return this.textProps.lineHeight;
                        },
                        set: function set(value) {
                            if (this.textProps.lineHeight !== value) {
                                this.textProps.lineHeight = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "maxLines",
                        get: function get() {
                            return this.textProps.maxLines;
                        },
                        set: function set(value) {
                            if (this.textProps.maxLines !== value) {
                                this.textProps.maxLines = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "verticalAlign",
                        get: function get() {
                            return this.textProps.verticalAlign;
                        },
                        set: function set(value) {
                            if (this.textProps.verticalAlign !== value) {
                                this.textProps.verticalAlign = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "overflowSuffix",
                        get: function get() {
                            return this.textProps.overflowSuffix;
                        },
                        set: function set(value) {
                            if (this.textProps.overflowSuffix !== value) {
                                this.textProps.overflowSuffix = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "wordBreak",
                        get: function get() {
                            return this.textProps.wordBreak;
                        },
                        set: function set(value) {
                            if (this.textProps.wordBreak !== value) {
                                this.textProps.wordBreak = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "offsetY",
                        get: function get() {
                            return this.textProps.offsetY;
                        },
                        set: function set(value) {
                            if (this.textProps.offsetY !== value) {
                                this.textProps.offsetY = value;
                                this._layoutGenerated = false;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "forceLoad",
                        get: function get() {
                            return this.textProps.forceLoad;
                        },
                        set: function set(value) {
                            if (this.textProps.forceLoad !== value) {
                                this.textProps.forceLoad = value;
                                this.setUpdateType(UpdateType.Local);
                            }
                        }
                    }, {
                        key: "renderInfo",
                        get: function get() {
                            return this._renderInfo;
                        }
                    } ]);
                }(CoreNode);
                function santizeCustomDataMap(d) {
                    var validTypes = {
                        boolean: true,
                        string: true,
                        number: true,
                        undefined: true
                    };
                    var keys = Object.keys(d);
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        if (!key) {
                            continue;
                        }
                        var value = d[key];
                        var valueType = _typeof(value);
                        if (valueType === "string" && value.length > 2048) {
                            console.warn("Custom Data value for ".concat(key, " is too long, it will be truncated to 2048 characters"));
                            d[key] = value.substring(0, 2048);
                        }
                        if (!validTypes[valueType]) {
                            console.warn("Custom Data value for ".concat(key, " is not a boolean, string, or number, it will be ignored"));
                            delete d[key];
                        }
                    }
                    return d;
                }
                var Stage = function() {
                    function Stage(options) {
                        var _this20 = this, _fontEngines$;
                        _classCallCheck(this, Stage);
                        _defineProperty(this, "options", void 0);
                        _defineProperty(this, "animationManager", void 0);
                        _defineProperty(this, "txManager", void 0);
                        _defineProperty(this, "txMemManager", void 0);
                        _defineProperty(this, "textRenderers", {});
                        _defineProperty(this, "fontHandlers", {});
                        _defineProperty(this, "shManager", void 0);
                        _defineProperty(this, "renderer", void 0);
                        _defineProperty(this, "root", void 0);
                        _defineProperty(this, "interactiveNodes", new Set);
                        _defineProperty(this, "boundsMargin", void 0);
                        _defineProperty(this, "defShaderNode", null);
                        _defineProperty(this, "strictBound", void 0);
                        _defineProperty(this, "preloadBound", void 0);
                        _defineProperty(this, "defaultTexture", null);
                        _defineProperty(this, "pixelRatio", void 0);
                        _defineProperty(this, "bufferMemory", 2e6);
                        _defineProperty(this, "platform", void 0);
                        _defineProperty(this, "calculateTextureCoord", void 0);
                        _defineProperty(this, "targetFrameTime", 0);
                        _defineProperty(this, "eventBus", void 0);
                        _defineProperty(this, "startTime", 0);
                        _defineProperty(this, "deltaTime", 0);
                        _defineProperty(this, "lastFrameTime", 0);
                        _defineProperty(this, "currentFrameTime", 0);
                        _defineProperty(this, "elapsedTime", 0);
                        _defineProperty(this, "timedNodes", []);
                        _defineProperty(this, "clrColor", 0);
                        _defineProperty(this, "fpsNumFrames", 0);
                        _defineProperty(this, "fpsElapsedTime", 0);
                        _defineProperty(this, "numQuadsRendered", 0);
                        _defineProperty(this, "renderRequested", false);
                        _defineProperty(this, "frameEventQueue", []);
                        _defineProperty(this, "hasOnlyOneFontEngine", void 0);
                        _defineProperty(this, "hasOnlyCanvasFontEngine", void 0);
                        _defineProperty(this, "hasCanvasEngine", void 0);
                        _defineProperty(this, "singleFontEngine", null);
                        _defineProperty(this, "singleFontHandler", null);
                        _defineProperty(this, "contextSpy", null);
                        this.options = options;
                        var canvas = options.canvas, clearColor = options.clearColor, appWidth = options.appWidth, appHeight = options.appHeight, boundsMargin = options.boundsMargin, enableContextSpy = options.enableContextSpy, forceWebGL2 = options.forceWebGL2, numImageWorkers = options.numImageWorkers, textureMemory = options.textureMemory, renderEngine = options.renderEngine, fontEngines = options.fontEngines, createImageBitmapSupport = options.createImageBitmapSupport, platform = options.platform, maxRetryCount = options.maxRetryCount, enableAlphaChannel = options.enableAlphaChannel, textureEnableAlphaFormats = options.textureEnableAlphaFormats;
                        this.platform = platform;
                        this.startTime = platform.getTimeStamp();
                        this.eventBus = options.eventBus;
                        this.targetFrameTime = options.targetFPS > 0 ? 1e3 / options.targetFPS : 0;
                        this.txManager = new CoreTextureManager(this, {
                            numImageWorkers: numImageWorkers,
                            createImageBitmapSupport: createImageBitmapSupport,
                            maxRetryCount: maxRetryCount,
                            enableAlphaChannel: enableAlphaChannel,
                            textureEnableAlphaFormats: textureEnableAlphaFormats
                        });
                        this.txManager.on("initialized", function() {
                            _this20.requestRender();
                        });
                        this.txMemManager = new TextureMemoryManager(this, textureMemory);
                        this.animationManager = new AnimationManager;
                        this.contextSpy = enableContextSpy ? new ContextSpy : null;
                        var bm = [ 0, 0, 0, 0 ];
                        if (boundsMargin) {
                            bm = Array.isArray(boundsMargin) ? boundsMargin : [ boundsMargin, boundsMargin, boundsMargin, boundsMargin ];
                        }
                        this.boundsMargin = bm;
                        this.strictBound = createBound(0, 0, appWidth, appHeight);
                        this.preloadBound = createPreloadBounds(this.strictBound, bm);
                        this.clrColor = clearColor;
                        this.pixelRatio = options.devicePhysicalPixelRatio * options.deviceLogicalPixelRatio;
                        this.renderer = new renderEngine({
                            stage: this,
                            canvas: canvas,
                            contextSpy: this.contextSpy,
                            forceWebGL2: forceWebGL2
                        });
                        this.shManager = new CoreShaderManager(this);
                        this.defShaderNode = this.renderer.getDefaultShaderNode();
                        this.calculateTextureCoord = this.renderer.getTextureCoords !== undefined;
                        var renderMode = this.renderer.mode || "webgl";
                        this.createDefaultTexture();
                        setPremultiplyMode(renderMode);
                        this.txManager.renderer = this.renderer;
                        this.hasOnlyOneFontEngine = fontEngines.length === 1;
                        this.hasOnlyCanvasFontEngine = fontEngines.length === 1 && fontEngines[0].type === "canvas";
                        this.hasCanvasEngine = false;
                        this.singleFontEngine = this.hasOnlyOneFontEngine ? fontEngines[0] : null;
                        this.singleFontHandler = this.hasOnlyOneFontEngine ? (_fontEngines$ = fontEngines[0]) === null || _fontEngines$ === void 0 ? void 0 : _fontEngines$.font : null;
                        if (this.singleFontEngine === null) {
                            var compatibleEngines = fontEngines.filter(function(fontEngine) {
                                var type = fontEngine.type;
                                if (type === "sdf" && renderMode === "canvas") {
                                    console.warn("MsdfTextRenderer is not compatible with Canvas renderer. Skipping...");
                                    return false;
                                }
                                if (type === "canvas") {
                                    _this20.hasCanvasEngine = true;
                                }
                                return true;
                            });
                            var sortedEngines = compatibleEngines.sort(function(a, b) {
                                if (a.type === "sdf") return -1;
                                if (b.type === "sdf") return 1;
                                if (a.type === "canvas") return 1;
                                if (b.type === "canvas") return -1;
                                return 0;
                            });
                            sortedEngines.forEach(function(fontEngine) {
                                var type = fontEngine.type;
                                _this20.textRenderers[type] = fontEngine;
                                _this20.textRenderers[type].init(_this20);
                                _this20.fontHandlers[type] = fontEngine.font;
                            });
                        } else {
                            var fontEngine = this.singleFontEngine;
                            var _type = fontEngine.type;
                            if (_type === "sdf" && renderMode === "canvas") {
                                console.warn("MsdfTextRenderer is not compatible with Canvas renderer. Skipping...");
                            } else {
                                if (_type === "canvas") {
                                    this.hasCanvasEngine = true;
                                }
                                this.textRenderers[_type] = fontEngine;
                                this.fontHandlers[_type] = fontEngine.font;
                                this.textRenderers[_type].init(this);
                            }
                        }
                        if (Object.keys(this.textRenderers).length === 0) {
                            console.warn("No text renderers available. Your text will not render.");
                        }
                        var rootNode = new CoreNode(this, {
                            x: 0,
                            y: 0,
                            w: appWidth,
                            h: appHeight,
                            alpha: 1,
                            autosize: false,
                            boundsMargin: null,
                            clipping: false,
                            color: 0,
                            colorTop: 0,
                            colorBottom: 0,
                            colorLeft: 0,
                            colorRight: 0,
                            colorTl: 0,
                            colorTr: 0,
                            colorBl: 0,
                            colorBr: 0,
                            zIndex: 0,
                            scaleX: 1,
                            scaleY: 1,
                            mountX: 0,
                            mountY: 0,
                            mount: 0,
                            pivot: .5,
                            pivotX: .5,
                            pivotY: .5,
                            rotation: 0,
                            parent: null,
                            texture: null,
                            textureOptions: {},
                            shader: this.defShaderNode,
                            rtt: false,
                            src: null,
                            scale: 1
                        });
                        this.root = rootNode;
                        rootNode.updateLocalTransform();
                        rootNode.globalTransform = Matrix3d.copy(rootNode.localTransform);
                        rootNode.sceneGlobalTransform = Matrix3d.copy(rootNode.localTransform);
                        rootNode.calculateRenderCoords();
                        rootNode.updateBoundingRect();
                        rootNode.createRenderBounds();
                        rootNode.updateRenderState(CoreNodeRenderState.InViewport);
                        rootNode.updateIsRenderable();
                        rootNode.premultipliedColorTl = rootNode.premultipliedColorTr = rootNode.premultipliedColorBl = rootNode.premultipliedColorBr = 0;
                        {
                            this.platform.startLoop(this);
                        }
                    }
                    return _createClass(Stage, [ {
                        key: "setClearColor",
                        value: function setClearColor(color) {
                            this.clearColor = color;
                            this.renderer.updateClearColor(color);
                            this.renderRequested = true;
                        }
                    }, {
                        key: "updateTargetFrameTime",
                        value: function updateTargetFrameTime() {
                            this.targetFrameTime = this.options.targetFPS > 0 ? 1e3 / this.options.targetFPS : 0;
                        }
                    }, {
                        key: "updateFrameTime",
                        value: function updateFrameTime() {
                            var newFrameTime = this.platform.getTimeStamp();
                            this.lastFrameTime = this.currentFrameTime;
                            this.currentFrameTime = newFrameTime;
                            this.elapsedTime = newFrameTime - this.startTime;
                            this.deltaTime = !this.lastFrameTime ? 100 / 6 : newFrameTime - this.lastFrameTime;
                            this.txManager.frameTime = newFrameTime;
                            this.txMemManager.frameTime = newFrameTime;
                            this.eventBus.emit("frameTick", {
                                time: this.currentFrameTime,
                                delta: this.deltaTime
                            });
                        }
                    }, {
                        key: "createDefaultTexture",
                        value: function createDefaultTexture() {
                            var _this21 = this;
                            this.defaultTexture = this.txManager.createTexture("ColorTexture", {
                                color: 4294967295
                            });
                            assertTruthy(this.defaultTexture instanceof ColorTexture);
                            this.txManager.loadTexture(this.defaultTexture, true);
                            this.defaultTexture.setRenderableOwner("stage", true);
                            this.defaultTexture.once("loaded", function() {
                                _this21.requestRender();
                            });
                        }
                    }, {
                        key: "updateAnimations",
                        value: function updateAnimations() {
                            var animationManager = this.animationManager;
                            if (!this.root) {
                                return;
                            }
                            animationManager.update(this.deltaTime);
                        }
                    }, {
                        key: "hasSceneUpdates",
                        value: function hasSceneUpdates() {
                            return !!this.root.updateType || this.renderRequested || this.txManager.hasUpdates();
                        }
                    }, {
                        key: "drawFrame",
                        value: function drawFrame() {
                            var renderer = this.renderer, renderRequested = this.renderRequested, root = this.root;
                            if (root.updateType !== 0) {
                                root.updateType = 0;
                                for (var i = 0, length = root.children.length; i < length; i++) {
                                    var child = root.children[i];
                                    if (root.childUpdateType !== 0) {
                                        child.setUpdateType(root.childUpdateType);
                                    }
                                    if (child.updateType === 0) {
                                        continue;
                                    }
                                    child.update(this.deltaTime, root.clippingRect);
                                }
                                root.childUpdateType = 0;
                            }
                            if (this.txManager.hasUpdates() === true) {
                                this.txManager.processSome(this.options.textureProcessingTimeLimit).catch(function(err) {
                                    console.error("Error processing textures:", err);
                                });
                            }
                            renderer.reset();
                            if (renderer.rttNodes.length > 0) {
                                renderer.renderRTTNodes();
                            }
                            this.addQuads(this.root);
                            renderer.render();
                            if (renderRequested === true) {
                                this.renderRequested = false;
                            }
                            if (this.timedNodes.length > 0) {
                                for (var key in this.timedNodes) {
                                    if (this.timedNodes[key].isRenderable === true) {
                                        this.requestRender();
                                        break;
                                    }
                                }
                            }
                            if (this.txMemManager.criticalCleanupRequested === true) {
                                this.txMemManager.cleanup();
                            }
                        }
                    }, {
                        key: "queueFrameEvent",
                        value: function queueFrameEvent(name, data) {
                            this.frameEventQueue.push([ name, data ]);
                        }
                    }, {
                        key: "flushFrameEvents",
                        value: function flushFrameEvents() {
                            var _iterator0 = _createForOfIteratorHelper(this.frameEventQueue), _step0;
                            try {
                                for (_iterator0.s(); !(_step0 = _iterator0.n()).done; ) {
                                    var _step0$value = _slicedToArray(_step0.value, 2), name = _step0$value[0], data = _step0$value[1];
                                    this.eventBus.emit(name, data);
                                }
                            } catch (err) {
                                _iterator0.e(err);
                            } finally {
                                _iterator0.f();
                            }
                            this.frameEventQueue = [];
                        }
                    }, {
                        key: "calculateFps",
                        value: function calculateFps() {
                            var fpsUpdateInterval = this.options.fpsUpdateInterval;
                            if (fpsUpdateInterval) {
                                this.fpsNumFrames++;
                                this.fpsElapsedTime += this.deltaTime;
                                if (this.fpsElapsedTime >= fpsUpdateInterval) {
                                    var _this$contextSpy$getD, _this$contextSpy, _this$contextSpy2;
                                    var _fps = Math.round(this.fpsNumFrames * 1e3 / this.fpsElapsedTime);
                                    this.fpsNumFrames = 0;
                                    this.fpsElapsedTime = 0;
                                    this.queueFrameEvent("fpsUpdate", {
                                        fps: _fps,
                                        contextSpyData: (_this$contextSpy$getD = (_this$contextSpy = this.contextSpy) === null || _this$contextSpy === void 0 ? void 0 : _this$contextSpy.getData()) !== null && _this$contextSpy$getD !== void 0 ? _this$contextSpy$getD : null
                                    });
                                    (_this$contextSpy2 = this.contextSpy) === null || _this$contextSpy2 === void 0 || _this$contextSpy2.reset();
                                }
                            }
                        }
                    }, {
                        key: "calculateQuads",
                        value: function calculateQuads() {
                            var quads = this.renderer.getQuadCount();
                            if (quads && quads !== this.numQuadsRendered) {
                                this.numQuadsRendered = quads;
                                this.queueFrameEvent("quadsUpdate", {
                                    quads: quads
                                });
                            }
                        }
                    }, {
                        key: "addQuads",
                        value: function addQuads(node) {
                            if (node.isRenderable === true) {
                                node.renderQuads(this.renderer);
                            }
                            var children = node.children;
                            var len = children.length;
                            for (var i = 0; i < len; i++) {
                                var child = children[i];
                                if (child.worldAlpha === 0 || child.renderState === CoreNodeRenderState.OutOfBounds) {
                                    continue;
                                }
                                this.addQuads(child);
                            }
                        }
                    }, {
                        key: "requestRender",
                        value: function requestRender() {
                            this.renderRequested = true;
                        }
                    }, {
                        key: "resolveTextRenderer",
                        value: function resolveTextRenderer(trProps) {
                            var _this$fontHandlers$sd;
                            var textRendererOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                            if (textRendererOverride !== null) {
                                var overrideKey = String(textRendererOverride);
                                if (this.textRenderers[overrideKey] === undefined) {
                                    console.warn("Text renderer override '".concat(overrideKey, "' not found."));
                                    return null;
                                }
                                return this.textRenderers[overrideKey];
                            }
                            if (this.singleFontEngine !== null) {
                                var _this$singleFontHandl;
                                if (this.hasOnlyCanvasFontEngine === true) {
                                    return this.singleFontEngine;
                                }
                                if (((_this$singleFontHandl = this.singleFontHandler) === null || _this$singleFontHandl === void 0 ? void 0 : _this$singleFontHandl.canRenderFont(trProps)) === true) {
                                    return this.singleFontEngine;
                                }
                                console.warn("Text renderer cannot render font", trProps);
                                return null;
                            }
                            if (((_this$fontHandlers$sd = this.fontHandlers["sdf"]) === null || _this$fontHandlers$sd === void 0 ? void 0 : _this$fontHandlers$sd.canRenderFont(trProps)) === true) {
                                return this.textRenderers.sdf || null;
                            }
                            if (this.hasCanvasEngine === true) {
                                return this.textRenderers.canvas || null;
                            }
                            console.warn("No text renderers available. Your text will not render.");
                            return null;
                        }
                    }, {
                        key: "createNode",
                        value: function createNode(props) {
                            var resolvedProps = this.resolveNodeDefaults(props);
                            return new CoreNode(this, resolvedProps);
                        }
                    }, {
                        key: "createTextNode",
                        value: function createTextNode(props) {
                            var fontSize = props.fontSize || 16;
                            var resolvedProps = Object.assign(this.resolveNodeDefaults(props), {
                                text: props.text || "",
                                textRendererOverride: props.textRendererOverride || null,
                                fontSize: fontSize,
                                fontFamily: props.fontFamily || "sans-serif",
                                fontStyle: props.fontStyle || "normal",
                                textAlign: props.textAlign || "left",
                                offsetY: props.offsetY || 0,
                                letterSpacing: props.letterSpacing || 0,
                                lineHeight: props.lineHeight || 1.2,
                                maxLines: props.maxLines || 0,
                                verticalAlign: props.verticalAlign || "top",
                                overflowSuffix: props.overflowSuffix || "...",
                                wordBreak: props.wordBreak || "break-word",
                                contain: props.contain || "none",
                                maxWidth: props.maxWidth || 0,
                                maxHeight: props.maxHeight || 0,
                                forceLoad: props.forceLoad || false
                            });
                            var resolvedTextRenderer = this.resolveTextRenderer(resolvedProps, resolvedProps.textRendererOverride);
                            if (!resolvedTextRenderer) {
                                throw new Error("No compatible text renderer found for ".concat(resolvedProps.fontFamily));
                            }
                            return new CoreTextNode(this, resolvedProps, resolvedTextRenderer);
                        }
                    }, {
                        key: "setBoundsMargin",
                        value: function setBoundsMargin(value) {
                            this.boundsMargin = Array.isArray(value) ? value : [ value, value, value, value ];
                            this.root.setUpdateType(UpdateType.RenderBounds);
                        }
                    }, {
                        key: "updateViewportBounds",
                        value: function updateViewportBounds() {
                            var _this$options = this.options, appWidth = _this$options.appWidth, appHeight = _this$options.appHeight;
                            this.strictBound = createBound(0, 0, appWidth, appHeight);
                            this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
                            this.root.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
                            this.root.childUpdateType |= UpdateType.RenderBounds;
                        }
                    }, {
                        key: "findNodesAtPoint",
                        value: function findNodesAtPoint(data) {
                            var x = data.x / this.options.deviceLogicalPixelRatio;
                            var y = data.y / this.options.deviceLogicalPixelRatio;
                            var nodes = [];
                            var _iterator1 = _createForOfIteratorHelper(this.interactiveNodes), _step1;
                            try {
                                for (_iterator1.s(); !(_step1 = _iterator1.n()).done; ) {
                                    var node = _step1.value;
                                    if (node.isRenderable === false) {
                                        continue;
                                    }
                                    if (pointInBound(x, y, node.renderBound) === true) {
                                        nodes.push(node);
                                    }
                                }
                            } catch (err) {
                                _iterator1.e(err);
                            } finally {
                                _iterator1.f();
                            }
                            return nodes;
                        }
                    }, {
                        key: "getNodeFromPosition",
                        value: function getNodeFromPosition(data) {
                            var nodes = this.findNodesAtPoint(data);
                            if (nodes.length === 0) {
                                return null;
                            }
                            var topNode = nodes[nodes.length - 1];
                            for (var i = 0; i < nodes.length; i++) {
                                if (nodes[i].zIndex > topNode.zIndex) {
                                    topNode = nodes[i];
                                }
                            }
                            return topNode || null;
                        }
                    }, {
                        key: "trackTimedNode",
                        value: function trackTimedNode(node) {
                            if (this.timedNodes[node.id] !== undefined) {
                                return;
                            }
                            this.timedNodes[node.id] = node;
                        }
                    }, {
                        key: "untrackTimedNode",
                        value: function untrackTimedNode(node) {
                            if (this.timedNodes[node.id] === undefined) {
                                return;
                            }
                            delete this.timedNodes[node.id];
                        }
                    }, {
                        key: "resolveNodeDefaults",
                        value: function resolveNodeDefaults(props) {
                            var _props$color, _ref6, _ref7, _props$colorTl, _ref8, _ref9, _props$colorTr, _ref0, _ref1, _props$colorBl, _ref10, _ref11, _props$colorBr, _props$scale, _props$mount, _props$pivot, _props$data, _props$x, _props$y, _props$w3, _props$h3, _props$alpha, _props$autosize, _props$boundsMargin, _props$clipping, _props$zIndex, _props$parent, _props$texture, _props$textureOptions, _props$shader, _props$src2, _ref12, _props$scaleX, _ref13, _props$scaleY, _props$mountX, _props$mountY, _props$pivotX, _props$pivotY, _props$rotation, _props$rtt, _props$interactive;
                            var top = props.colorTop, bottom = props.colorBottom, left = props.colorLeft, right = props.colorRight;
                            var color = (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : 4294967295;
                            var colorTop = top !== null && top !== void 0 ? top : color;
                            var colorBottom = bottom !== null && bottom !== void 0 ? bottom : color;
                            var colorLeft = left !== null && left !== void 0 ? left : color;
                            var colorRight = right !== null && right !== void 0 ? right : color;
                            var colorTl = (_ref6 = (_ref7 = (_props$colorTl = props.colorTl) !== null && _props$colorTl !== void 0 ? _props$colorTl : top) !== null && _ref7 !== void 0 ? _ref7 : left) !== null && _ref6 !== void 0 ? _ref6 : color;
                            var colorTr = (_ref8 = (_ref9 = (_props$colorTr = props.colorTr) !== null && _props$colorTr !== void 0 ? _props$colorTr : top) !== null && _ref9 !== void 0 ? _ref9 : right) !== null && _ref8 !== void 0 ? _ref8 : color;
                            var colorBl = (_ref0 = (_ref1 = (_props$colorBl = props.colorBl) !== null && _props$colorBl !== void 0 ? _props$colorBl : bottom) !== null && _ref1 !== void 0 ? _ref1 : left) !== null && _ref0 !== void 0 ? _ref0 : color;
                            var colorBr = (_ref10 = (_ref11 = (_props$colorBr = props.colorBr) !== null && _props$colorBr !== void 0 ? _props$colorBr : bottom) !== null && _ref11 !== void 0 ? _ref11 : right) !== null && _ref10 !== void 0 ? _ref10 : color;
                            var scale = (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : null;
                            var mount = (_props$mount = props.mount) !== null && _props$mount !== void 0 ? _props$mount : 0;
                            var pivot = (_props$pivot = props.pivot) !== null && _props$pivot !== void 0 ? _props$pivot : .5;
                            var data = this.options.inspector ? santizeCustomDataMap((_props$data = props.data) !== null && _props$data !== void 0 ? _props$data : {}) : {};
                            return {
                                x: (_props$x = props.x) !== null && _props$x !== void 0 ? _props$x : 0,
                                y: (_props$y = props.y) !== null && _props$y !== void 0 ? _props$y : 0,
                                w: (_props$w3 = props.w) !== null && _props$w3 !== void 0 ? _props$w3 : 0,
                                h: (_props$h3 = props.h) !== null && _props$h3 !== void 0 ? _props$h3 : 0,
                                alpha: (_props$alpha = props.alpha) !== null && _props$alpha !== void 0 ? _props$alpha : 1,
                                autosize: (_props$autosize = props.autosize) !== null && _props$autosize !== void 0 ? _props$autosize : false,
                                boundsMargin: (_props$boundsMargin = props.boundsMargin) !== null && _props$boundsMargin !== void 0 ? _props$boundsMargin : null,
                                clipping: (_props$clipping = props.clipping) !== null && _props$clipping !== void 0 ? _props$clipping : false,
                                color: color,
                                colorTop: colorTop,
                                colorBottom: colorBottom,
                                colorLeft: colorLeft,
                                colorRight: colorRight,
                                colorTl: colorTl,
                                colorTr: colorTr,
                                colorBl: colorBl,
                                colorBr: colorBr,
                                zIndex: (_props$zIndex = props.zIndex) !== null && _props$zIndex !== void 0 ? _props$zIndex : 0,
                                parent: (_props$parent = props.parent) !== null && _props$parent !== void 0 ? _props$parent : null,
                                texture: (_props$texture = props.texture) !== null && _props$texture !== void 0 ? _props$texture : null,
                                textureOptions: (_props$textureOptions = props.textureOptions) !== null && _props$textureOptions !== void 0 ? _props$textureOptions : {},
                                shader: (_props$shader = props.shader) !== null && _props$shader !== void 0 ? _props$shader : this.defShaderNode,
                                src: (_props$src2 = props.src) !== null && _props$src2 !== void 0 ? _props$src2 : null,
                                srcHeight: props.srcHeight,
                                srcWidth: props.srcWidth,
                                srcX: props.srcX,
                                srcY: props.srcY,
                                scale: scale,
                                scaleX: (_ref12 = (_props$scaleX = props.scaleX) !== null && _props$scaleX !== void 0 ? _props$scaleX : scale) !== null && _ref12 !== void 0 ? _ref12 : 1,
                                scaleY: (_ref13 = (_props$scaleY = props.scaleY) !== null && _props$scaleY !== void 0 ? _props$scaleY : scale) !== null && _ref13 !== void 0 ? _ref13 : 1,
                                mount: mount,
                                mountX: (_props$mountX = props.mountX) !== null && _props$mountX !== void 0 ? _props$mountX : mount,
                                mountY: (_props$mountY = props.mountY) !== null && _props$mountY !== void 0 ? _props$mountY : mount,
                                pivot: pivot,
                                pivotX: (_props$pivotX = props.pivotX) !== null && _props$pivotX !== void 0 ? _props$pivotX : pivot,
                                pivotY: (_props$pivotY = props.pivotY) !== null && _props$pivotY !== void 0 ? _props$pivotY : pivot,
                                rotation: (_props$rotation = props.rotation) !== null && _props$rotation !== void 0 ? _props$rotation : 0,
                                rtt: (_props$rtt = props.rtt) !== null && _props$rtt !== void 0 ? _props$rtt : false,
                                data: data,
                                imageType: props.imageType,
                                interactive: (_props$interactive = props.interactive) !== null && _props$interactive !== void 0 ? _props$interactive : false
                            };
                        }
                    }, {
                        key: "cleanup",
                        value: function cleanup() {
                            var full = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                            this.txMemManager.cleanup(full);
                        }
                    }, {
                        key: "clearColor",
                        get: function get() {
                            return this.clrColor;
                        },
                        set: function set(value) {
                            this.renderer.updateClearColor(value);
                            this.renderRequested = true;
                            this.clrColor = value;
                        }
                    }, {
                        key: "loadFont",
                        value: function() {
                            var _loadFont = _asyncToGenerator(_regenerator().m(function _callee15(rendererType, options) {
                                var rendererTypeKey, fontHandler;
                                return _regenerator().w(function(_context15) {
                                    while (1) switch (_context15.n) {
                                      case 0:
                                        rendererTypeKey = String(rendererType);
                                        fontHandler = this.fontHandlers[rendererTypeKey];
                                        if (fontHandler) {
                                            _context15.n = 1;
                                            break;
                                        }
                                        throw new Error("Font handler for renderer type '".concat(rendererTypeKey, "' not found. Available types: ").concat(Object.keys(this.fontHandlers).join(", ")));

                                      case 1:
                                        return _context15.a(2, fontHandler.loadFont(this, options));
                                    }
                                }, _callee15, this);
                            }));
                            function loadFont(_x18, _x19) {
                                return _loadFont.apply(this, arguments);
                            }
                            return loadFont;
                        }()
                    } ]);
                }();
                var Platform = _createClass(function Platform() {
                    _classCallCheck(this, Platform);
                });
                var WebPlatform = function(_Platform) {
                    function WebPlatform() {
                        _classCallCheck(this, WebPlatform);
                        return _callSuper(this, WebPlatform, arguments);
                    }
                    _inherits(WebPlatform, _Platform);
                    return _createClass(WebPlatform, [ {
                        key: "createCanvas",
                        value: function createCanvas() {
                            var canvas = document.createElement("canvas");
                            return canvas;
                        }
                    }, {
                        key: "getElementById",
                        value: function getElementById(id) {
                            return document.getElementById(id);
                        }
                    }, {
                        key: "startLoop",
                        value: function startLoop(stage) {
                            var isIdle = false;
                            var lastFrameTime = 0;
                            var buffer = 4;
                            var _runLoop = function runLoop() {
                                var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                                var targetFrameTime = stage.targetFrameTime;
                                if (targetFrameTime > 0) {
                                    var elapsed = currentTime - lastFrameTime;
                                    if (elapsed < targetFrameTime) {
                                        var wait = targetFrameTime - elapsed;
                                        if (wait > buffer) {
                                            setTimeout(function() {
                                                return requestAnimationFrame(_runLoop);
                                            }, wait - buffer);
                                        } else {
                                            requestAnimationFrame(_runLoop);
                                        }
                                        return;
                                    }
                                    lastFrameTime = currentTime - elapsed % targetFrameTime;
                                } else {
                                    lastFrameTime = currentTime;
                                }
                                stage.updateFrameTime();
                                stage.updateAnimations();
                                if (!stage.hasSceneUpdates()) {
                                    stage.calculateFps();
                                    setTimeout(function() {
                                        return requestAnimationFrame(_runLoop);
                                    }, Math.max(targetFrameTime, 15));
                                    if (isIdle === false) {
                                        stage.shManager.cleanup();
                                        stage.eventBus.emit("idle");
                                        isIdle = true;
                                    }
                                    if (stage.txMemManager.checkCleanup() === true) {
                                        stage.txMemManager.cleanup();
                                    }
                                    stage.flushFrameEvents();
                                    return;
                                }
                                isIdle = false;
                                stage.drawFrame();
                                stage.flushFrameEvents();
                                requestAnimationFrame(_runLoop);
                            };
                            requestAnimationFrame(_runLoop);
                        }
                    }, {
                        key: "createImageBitmap",
                        value: function(_createImageBitmap2) {
                            function createImageBitmap(_x20, _x21, _x22, _x23, _x24, _x25) {
                                return _createImageBitmap2.apply(this, arguments);
                            }
                            createImageBitmap.toString = function() {
                                return _createImageBitmap2.toString();
                            };
                            return createImageBitmap;
                        }(function(blob, sxOrOptions, sy, sw, sh, options) {
                            if (typeof sxOrOptions === "number") {
                                return createImageBitmap(blob, sxOrOptions, sy !== null && sy !== void 0 ? sy : 0, sw !== null && sw !== void 0 ? sw : 0, sh !== null && sh !== void 0 ? sh : 0, options);
                            } else {
                                return createImageBitmap(blob, sxOrOptions);
                            }
                        })
                    }, {
                        key: "getTimeStamp",
                        value: function getTimeStamp() {
                            return Date.now();
                        }
                    }, {
                        key: "addFont",
                        value: function addFont(font) {
                            document.fonts.add(font);
                        }
                    } ]);
                }(Platform);
                var RendererMain = function(_EventEmitter7) {
                    function RendererMain(settings, target) {
                        var _settings$clearColor, _settings$enableClear, _settings$enableConte, _settings$forceWebGL, _settings$inspector, _settings$inspectorOp, _settings$quadBufferS, _settings$fontEngines, _settings$maxRetryCou, _settings$enableAlpha, _settings$maxRetryCou2;
                        var _this22;
                        _classCallCheck(this, RendererMain);
                        _this22 = _callSuper(this, RendererMain);
                        _defineProperty(_this22, "root", void 0);
                        _defineProperty(_this22, "canvas", void 0);
                        _defineProperty(_this22, "stage", void 0);
                        _defineProperty(_this22, "inspector", null);
                        var resolvedTxSettings = _this22.resolveTxSettings(settings.textureMemory || {});
                        settings = {
                            appWidth: settings.appWidth || 1920,
                            appHeight: settings.appHeight || 1080,
                            textureMemory: resolvedTxSettings,
                            boundsMargin: settings.boundsMargin || 0,
                            deviceLogicalPixelRatio: settings.deviceLogicalPixelRatio || 1,
                            devicePhysicalPixelRatio: settings.devicePhysicalPixelRatio || window.devicePixelRatio || 1,
                            clearColor: (_settings$clearColor = settings.clearColor) !== null && _settings$clearColor !== void 0 ? _settings$clearColor : 0,
                            fpsUpdateInterval: settings.fpsUpdateInterval || 0,
                            enableClear: (_settings$enableClear = settings.enableClear) !== null && _settings$enableClear !== void 0 ? _settings$enableClear : true,
                            targetFPS: settings.targetFPS || 0,
                            numImageWorkers: settings.numImageWorkers !== undefined ? settings.numImageWorkers : 2,
                            enableContextSpy: (_settings$enableConte = settings.enableContextSpy) !== null && _settings$enableConte !== void 0 ? _settings$enableConte : false,
                            forceWebGL2: (_settings$forceWebGL = settings.forceWebGL2) !== null && _settings$forceWebGL !== void 0 ? _settings$forceWebGL : false,
                            inspector: (_settings$inspector = settings.inspector) !== null && _settings$inspector !== void 0 ? _settings$inspector : false,
                            inspectorOptions: (_settings$inspectorOp = settings.inspectorOptions) !== null && _settings$inspectorOp !== void 0 ? _settings$inspectorOp : {},
                            renderEngine: settings.renderEngine,
                            quadBufferSize: (_settings$quadBufferS = settings.quadBufferSize) !== null && _settings$quadBufferS !== void 0 ? _settings$quadBufferS : 4 * 1024 * 1024,
                            fontEngines: (_settings$fontEngines = settings.fontEngines) !== null && _settings$fontEngines !== void 0 ? _settings$fontEngines : [],
                            textureProcessingTimeLimit: settings.textureProcessingTimeLimit || 10,
                            canvas: settings.canvas,
                            createImageBitmapSupport: settings.createImageBitmapSupport || "full",
                            platform: settings.platform || null,
                            maxRetryCount: (_settings$maxRetryCou = settings.maxRetryCount) !== null && _settings$maxRetryCou !== void 0 ? _settings$maxRetryCou : 5,
                            enableAlphaChannel: (_settings$enableAlpha = settings.enableAlphaChannel) !== null && _settings$enableAlpha !== void 0 ? _settings$enableAlpha : true,
                            textureEnableAlphaFormats: settings.textureEnableAlphaFormats || null
                        };
                        var _settings = settings, appWidth = _settings.appWidth, appHeight = _settings.appHeight, deviceLogicalPixelRatio = _settings.deviceLogicalPixelRatio, devicePhysicalPixelRatio = _settings.devicePhysicalPixelRatio, inspector = _settings.inspector;
                        var platform;
                        if (settings.platform !== undefined && settings.platform !== null && settings.platform.prototype instanceof Platform === true) {
                            platform = new settings.platform;
                        } else {
                            platform = new WebPlatform;
                        }
                        var canvas = settings.canvas || platform.createCanvas();
                        var deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
                        var deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
                        _this22.canvas = canvas;
                        canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
                        canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
                        canvas.style.width = "".concat(deviceLogicalWidth, "px");
                        canvas.style.height = "".concat(deviceLogicalHeight, "px");
                        _this22.stage = new Stage({
                            appWidth: appWidth,
                            appHeight: appHeight,
                            boundsMargin: settings.boundsMargin,
                            clearColor: settings.clearColor,
                            canvas: _this22.canvas,
                            deviceLogicalPixelRatio: deviceLogicalPixelRatio,
                            devicePhysicalPixelRatio: devicePhysicalPixelRatio,
                            enableContextSpy: settings.enableContextSpy,
                            forceWebGL2: settings.forceWebGL2,
                            fpsUpdateInterval: settings.fpsUpdateInterval,
                            enableClear: settings.enableClear,
                            numImageWorkers: settings.numImageWorkers,
                            renderEngine: settings.renderEngine,
                            textureMemory: resolvedTxSettings,
                            eventBus: _this22,
                            quadBufferSize: settings.quadBufferSize,
                            fontEngines: settings.fontEngines,
                            inspector: settings.inspector !== null,
                            targetFPS: settings.targetFPS,
                            textureProcessingTimeLimit: settings.textureProcessingTimeLimit,
                            createImageBitmapSupport: settings.createImageBitmapSupport,
                            platform: platform,
                            maxRetryCount: (_settings$maxRetryCou2 = settings.maxRetryCount) !== null && _settings$maxRetryCou2 !== void 0 ? _settings$maxRetryCou2 : 5,
                            enableAlphaChannel: settings.enableAlphaChannel,
                            textureEnableAlphaFormats: settings.textureEnableAlphaFormats
                        });
                        _this22.root = _this22.stage.root;
                        if (target) {
                            var targetEl;
                            if (typeof target === "string") {
                                targetEl = document.getElementById(target);
                            } else {
                                targetEl = target;
                            }
                            if (!targetEl) {
                                throw new Error("Could not find target element");
                            }
                            targetEl.appendChild(canvas);
                        } else if (settings.canvas !== canvas) {
                            throw new Error("New canvas element could not be appended to undefined target");
                        }
                        return _this22;
                    }
                    _inherits(RendererMain, _EventEmitter7);
                    return _createClass(RendererMain, [ {
                        key: "resolveTxSettings",
                        value: function resolveTxSettings(textureMemory) {
                            var _ref14, _textureMemory$critic, _ref15, _textureMemory$target, _ref16, _textureMemory$cleanu, _ref17, _textureMemory$debugL, _ref18, _textureMemory$baseli, _ref19, _textureMemory$doNotE;
                            var currentTxSettings = this.stage && this.stage.options.textureMemory || {};
                            return {
                                criticalThreshold: (_ref14 = (_textureMemory$critic = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.criticalThreshold) !== null && _textureMemory$critic !== void 0 ? _textureMemory$critic : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.criticalThreshold) !== null && _ref14 !== void 0 ? _ref14 : 124e6,
                                targetThresholdLevel: (_ref15 = (_textureMemory$target = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.targetThresholdLevel) !== null && _textureMemory$target !== void 0 ? _textureMemory$target : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.targetThresholdLevel) !== null && _ref15 !== void 0 ? _ref15 : .5,
                                cleanupInterval: (_ref16 = (_textureMemory$cleanu = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.cleanupInterval) !== null && _textureMemory$cleanu !== void 0 ? _textureMemory$cleanu : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.cleanupInterval) !== null && _ref16 !== void 0 ? _ref16 : 5e3,
                                debugLogging: (_ref17 = (_textureMemory$debugL = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.debugLogging) !== null && _textureMemory$debugL !== void 0 ? _textureMemory$debugL : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.debugLogging) !== null && _ref17 !== void 0 ? _ref17 : false,
                                baselineMemoryAllocation: (_ref18 = (_textureMemory$baseli = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.baselineMemoryAllocation) !== null && _textureMemory$baseli !== void 0 ? _textureMemory$baseli : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.baselineMemoryAllocation) !== null && _ref18 !== void 0 ? _ref18 : 26e6,
                                doNotExceedCriticalThreshold: (_ref19 = (_textureMemory$doNotE = textureMemory === null || textureMemory === void 0 ? void 0 : textureMemory.doNotExceedCriticalThreshold) !== null && _textureMemory$doNotE !== void 0 ? _textureMemory$doNotE : currentTxSettings === null || currentTxSettings === void 0 ? void 0 : currentTxSettings.doNotExceedCriticalThreshold) !== null && _ref19 !== void 0 ? _ref19 : false
                            };
                        }
                    }, {
                        key: "createNode",
                        value: function createNode(props) {
                            var node = this.stage.createNode(props);
                            if (this.inspector) {
                                return this.inspector.createNode(node);
                            }
                            return node;
                        }
                    }, {
                        key: "createTextNode",
                        value: function createTextNode(props) {
                            var textNode = this.stage.createTextNode(props);
                            if (this.inspector) {
                                return this.inspector.createTextNode(textNode);
                            }
                            return textNode;
                        }
                    }, {
                        key: "destroyNode",
                        value: function destroyNode(node) {
                            if (this.inspector) {
                                this.inspector.destroyNode(node.id);
                            }
                            return node.destroy();
                        }
                    }, {
                        key: "createTexture",
                        value: function createTexture(textureType, props) {
                            return this.stage.txManager.createTexture(textureType, props);
                        }
                    }, {
                        key: "createShader",
                        value: function createShader(shType, props) {
                            return this.stage.shManager.createShader(shType, props);
                        }
                    }, {
                        key: "getNodeById",
                        value: function getNodeById(id) {
                            var _this$stage;
                            var root = (_this$stage = this.stage) === null || _this$stage === void 0 ? void 0 : _this$stage.root;
                            if (!root) {
                                return null;
                            }
                            var _findNode = function findNode(node) {
                                if (node.id === id) {
                                    return node;
                                }
                                var _iterator10 = _createForOfIteratorHelper(node.children), _step10;
                                try {
                                    for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                                        var child = _step10.value;
                                        var found = _findNode(child);
                                        if (found) {
                                            return found;
                                        }
                                    }
                                } catch (err) {
                                    _iterator10.e(err);
                                } finally {
                                    _iterator10.f();
                                }
                                return null;
                            };
                            return _findNode(root);
                        }
                    }, {
                        key: "toggleFreeze",
                        value: function toggleFreeze() {
                            throw new Error("Not implemented");
                        }
                    }, {
                        key: "advanceFrame",
                        value: function advanceFrame() {
                            throw new Error("Not implemented");
                        }
                    }, {
                        key: "getBufferInfo",
                        value: function getBufferInfo() {
                            return this.stage.renderer.getBufferInfo();
                        }
                    }, {
                        key: "rerender",
                        value: function rerender() {
                            this.stage.requestRender();
                        }
                    }, {
                        key: "cleanup",
                        value: function cleanup() {
                            this.stage.cleanup();
                        }
                    }, {
                        key: "setClearColor",
                        value: function setClearColor(color) {
                            this.stage.setClearColor(color);
                        }
                    }, {
                        key: "setOptions",
                        value: function setOptions(options) {
                            var stage = this.stage;
                            if (options.textureMemory !== undefined) {
                                var textureMemory = options.textureMemory = this.resolveTxSettings(options.textureMemory);
                                stage.txMemManager.updateSettings(textureMemory);
                                stage.txMemManager.cleanup();
                            }
                            if (options.boundsMargin !== undefined) {
                                var bm = options.boundsMargin;
                                options.boundsMargin = Array.isArray(bm) ? bm : [ bm, bm, bm, bm ];
                            }
                            var stageOptions = stage.options;
                            for (var key in options) {
                                stageOptions[key] = options[key];
                            }
                            if (options.inspector !== undefined && !isProductionEnvironment) ;
                            var needDimensionsUpdate = false;
                            if (options.deviceLogicalPixelRatio || options.devicePhysicalPixelRatio !== undefined) {
                                var _this$inspector;
                                this.stage.pixelRatio = stageOptions.devicePhysicalPixelRatio * stageOptions.deviceLogicalPixelRatio;
                                (_this$inspector = this.inspector) === null || _this$inspector === void 0 || _this$inspector.updateViewport(stageOptions.appWidth, stageOptions.appHeight, stageOptions.deviceLogicalPixelRatio);
                                needDimensionsUpdate = true;
                            }
                            if (options.appWidth !== undefined || options.appHeight !== undefined) {
                                var _this$inspector2;
                                (_this$inspector2 = this.inspector) === null || _this$inspector2 === void 0 || _this$inspector2.updateViewport(stageOptions.appWidth, stageOptions.appHeight, stageOptions.deviceLogicalPixelRatio);
                                needDimensionsUpdate = true;
                            }
                            if (options.boundsMargin !== undefined) {
                                this.stage.setBoundsMargin(options.boundsMargin);
                            }
                            if (options.clearColor !== undefined) {
                                this.stage.setClearColor(options.clearColor);
                            }
                            if (needDimensionsUpdate) {
                                this.updateAppDimensions();
                            }
                        }
                    }, {
                        key: "updateAppDimensions",
                        value: function updateAppDimensions() {
                            var _this$stage$options = this.stage.options, appWidth = _this$stage$options.appWidth, appHeight = _this$stage$options.appHeight, deviceLogicalPixelRatio = _this$stage$options.deviceLogicalPixelRatio, devicePhysicalPixelRatio = _this$stage$options.devicePhysicalPixelRatio;
                            var deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
                            var deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
                            this.canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
                            this.canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
                            this.canvas.style.width = "".concat(deviceLogicalWidth, "px");
                            this.canvas.style.height = "".concat(deviceLogicalHeight, "px");
                            this.stage.renderer.updateViewport();
                            this.root.w = appWidth;
                            this.root.h = appHeight;
                            this.stage.updateViewportBounds();
                        }
                    }, {
                        key: "settings",
                        get: function get() {
                            return this.stage.options;
                        }
                    }, {
                        key: "targetFPS",
                        get: function get() {
                            return this.stage.options.targetFPS || 0;
                        },
                        set: function set(fps) {
                            this.stage.options.targetFPS = fps > 0 ? fps : 0;
                            this.stage.updateTargetFrameTime();
                        }
                    } ]);
                }(EventEmitter);
                var validateArrayLength4 = function validateArrayLength4(value) {
                    if (!Array.isArray(value)) {
                        return [ value, value, value, value ];
                    }
                    if (value.length === 4) {
                        return value;
                    }
                    if (value.length === 3) {
                        value[3] = value[0];
                        return value;
                    }
                    if (value.length === 2) {
                        value[2] = value[0];
                        value[3] = value[1];
                        return value;
                    }
                    value[0] = value[0] || 0;
                    value[1] = value[0];
                    value[2] = value[0];
                    value[3] = value[0];
                    return value;
                };
                function getBorderProps(prefix) {
                    var pf = prefix && prefix.length > 0 ? "".concat(prefix, "-") : "";
                    var w = pf + "w";
                    return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, w, {
                        default: [ 0, 0, 0, 0 ],
                        resolve: function resolve(value) {
                            if (value !== undefined) {
                                return validateArrayLength4(value);
                            }
                            return [].concat(this.default);
                        }
                    }), pf + "color", 4294967295), pf + "top", {
                        default: 0,
                        set: function set(value, props) {
                            props[w][0] = value;
                        },
                        get: function get(props) {
                            return props[w][0];
                        }
                    }), pf + "right", {
                        default: 0,
                        set: function set(value, props) {
                            props[w][1] = value;
                        },
                        get: function get(props) {
                            return props[w][1];
                        }
                    }), pf + "bottom", {
                        default: 0,
                        set: function set(value, props) {
                            props[w][2] = value;
                        },
                        get: function get(props) {
                            return props[w][2];
                        }
                    }), pf + "left", {
                        default: 0,
                        set: function set(value, props) {
                            props[w][3] = value;
                        },
                        get: function get(props) {
                            return props[w][3];
                        }
                    });
                }
                ({
                    props: getBorderProps()
                });
                var HolePunchTemplate = {
                    props: {
                        x: 0,
                        y: 0,
                        w: 50,
                        h: 50,
                        radius: {
                            default: [ 0, 0, 0, 0 ],
                            resolve: function resolve(value) {
                                if (value !== undefined) {
                                    return validateArrayLength4(value);
                                }
                                return [].concat(this.default);
                            }
                        }
                    }
                };
                var RoundedTemplate = {
                    props: {
                        radius: {
                            default: [ 0, 0, 0, 0 ],
                            resolve: function resolve(value) {
                                if (value !== undefined) {
                                    return validateArrayLength4(value);
                                }
                                return [].concat(this.default);
                            }
                        },
                        "top-left": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[0] = value;
                            },
                            get: function get(props) {
                                return props.radius[0];
                            }
                        },
                        "top-right": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[1] = value;
                            },
                            get: function get(props) {
                                return props.radius[1];
                            }
                        },
                        "bottom-right": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[2] = value;
                            },
                            get: function get(props) {
                                return props.radius[2];
                            }
                        },
                        "bottom-left": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[3] = value;
                            },
                            get: function get(props) {
                                return props.radius[3];
                            }
                        }
                    }
                };
                function getShadowProps(prefix) {
                    var pf = prefix && prefix.length > 0 ? "".concat(prefix, "-") : "";
                    var projection = pf + "projection";
                    return _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, pf + "color", 255), projection, {
                        default: [ 0, 0, 5, 5 ]
                    }), pf + "x", {
                        default: 0,
                        set: function set(value, props) {
                            props[projection][0] = value;
                        },
                        get: function get(props) {
                            return props[projection][0];
                        }
                    }), pf + "y", {
                        default: 0,
                        set: function set(value, props) {
                            props[projection][1] = value;
                        },
                        get: function get(props) {
                            return props[projection][1];
                        }
                    }), pf + "blur", {
                        default: 10,
                        set: function set(value, props) {
                            props[projection][2] = value;
                        },
                        get: function get(props) {
                            return props[projection][2];
                        }
                    }), pf + "spread", {
                        default: 10,
                        set: function set(value, props) {
                            props[projection][3] = value;
                        },
                        get: function get(props) {
                            return props[projection][3];
                        }
                    });
                }
                ({
                    props: getShadowProps()
                });
                var LinearGradientTemplate = {
                    props: {
                        colors: {
                            default: [ 255, 4294967295 ],
                            resolve: function resolve(value) {
                                if (value !== undefined && value.length > 0) {
                                    return value;
                                }
                                return [].concat(this.default);
                            }
                        },
                        stops: {
                            default: [ 0, 1 ],
                            resolve: function resolve(value, props) {
                                if (value !== undefined && value.length === props.colors.length) {
                                    return value;
                                }
                                if (value === undefined) {
                                    value = [];
                                }
                                var len = props.colors.length;
                                for (var i = 0; i < len; i++) {
                                    value[i] = i * (1 / (len - 1));
                                }
                                return value;
                            }
                        },
                        angle: 0
                    }
                };
                var RadialGradientTemplate = {
                    props: {
                        colors: {
                            default: [ 255, 4294967295 ],
                            resolve: function resolve(value) {
                                if (value !== undefined && value.length > 0) {
                                    return value;
                                }
                                return [].concat(this.default);
                            }
                        },
                        stops: {
                            default: [ 0, 1 ],
                            resolve: function resolve(value, props) {
                                if (value !== undefined && value.length === props.colors.length) {
                                    return value;
                                }
                                if (value === undefined) {
                                    value = [];
                                }
                                var len = props.colors.length;
                                for (var i = 0; i < len; i++) {
                                    value[i] = i * (1 / (len - 1));
                                }
                                return value;
                            }
                        },
                        w: 50,
                        h: 50,
                        pivot: [ .5, .5 ]
                    }
                };
                var Default = {
                    vertex: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_position;\n    attribute vec2 a_textureCoords;\n    attribute vec4 a_color;\n    attribute vec2 a_nodeCoords;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    void main() {\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      v_color = a_color;\n      v_textureCoords = a_textureCoords;\n      v_nodeCoords = a_nodeCoords;\n\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  ",
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    uniform vec2 u_resolution;\n    uniform sampler2D u_texture;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n\n    void main() {\n      gl_FragColor = v_color * texture2D(u_texture, v_textureCoords);\n    }\n  "
                };
                var WebGlShaderNode = function(_CoreShaderNode2) {
                    function WebGlShaderNode(shaderKey, config, program, stage, props) {
                        var _this23;
                        _classCallCheck(this, WebGlShaderNode);
                        _this23 = _callSuper(this, WebGlShaderNode, [ shaderKey, config, stage, props ]);
                        _defineProperty(_this23, "program", void 0);
                        _defineProperty(_this23, "updater", undefined);
                        _defineProperty(_this23, "valueKey", "");
                        _defineProperty(_this23, "uniforms", {
                            single: {},
                            vec2: {},
                            vec3: {},
                            vec4: {}
                        });
                        _this23.program = program;
                        if (config.update !== undefined) {
                            _this23.updater = config.update;
                            _this23.update = function() {
                                if (_this23.props === undefined) {
                                    _this23.updater(_this23.node, _this23.props);
                                    return;
                                }
                                var prevKey = _this23.valueKey;
                                _this23.valueKey = _this23.createValueKey();
                                if (prevKey === _this23.valueKey) {
                                    return;
                                }
                                if (prevKey.length > 0) {
                                    _this23.stage.shManager.mutateShaderValueUsage(prevKey, -1);
                                }
                                var values = _this23.stage.shManager.getShaderValues(_this23.valueKey);
                                if (values !== undefined) {
                                    _this23.uniforms = values;
                                    return;
                                }
                                _this23.uniforms = {
                                    single: {},
                                    vec2: {},
                                    vec3: {},
                                    vec4: {}
                                };
                                _this23.updater(_this23.node);
                                _this23.stage.shManager.setShaderValues(_this23.valueKey, _this23.uniforms);
                            };
                        }
                        return _this23;
                    }
                    _inherits(WebGlShaderNode, _CoreShaderNode2);
                    return _createClass(WebGlShaderNode, [ {
                        key: "uniformRGBA",
                        value: function uniformRGBA(location, value) {
                            this.uniform4fv(location, new Float32Array(getNormalizedRgbaComponents(value)));
                        }
                    }, {
                        key: "uniform1f",
                        value: function uniform1f(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform1f",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform1fv",
                        value: function uniform1fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform1fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform1i",
                        value: function uniform1i(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform1i",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform1iv",
                        value: function uniform1iv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform1iv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform2f",
                        value: function uniform2f(location, v0, v1) {
                            this.uniforms.vec2[location] = {
                                method: "uniform2f",
                                value: [ v0, v1 ]
                            };
                        }
                    }, {
                        key: "uniform2fv",
                        value: function uniform2fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform2fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform2fa",
                        value: function uniform2fa(location, value) {
                            this.uniforms.vec2[location] = {
                                method: "uniform2f",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform2i",
                        value: function uniform2i(location, v0, v1) {
                            this.uniforms.vec2[location] = {
                                method: "uniform2i",
                                value: [ v0, v1 ]
                            };
                        }
                    }, {
                        key: "uniform2iv",
                        value: function uniform2iv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform2iv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform3f",
                        value: function uniform3f(location, v0, v1, v2) {
                            this.uniforms.vec3[location] = {
                                method: "uniform3f",
                                value: [ v0, v1, v2 ]
                            };
                        }
                    }, {
                        key: "uniform3fa",
                        value: function uniform3fa(location, value) {
                            this.uniforms.vec3[location] = {
                                method: "uniform3f",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform3fv",
                        value: function uniform3fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform3fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform3i",
                        value: function uniform3i(location, v0, v1, v2) {
                            this.uniforms.vec3[location] = {
                                method: "uniform3i",
                                value: [ v0, v1, v2 ]
                            };
                        }
                    }, {
                        key: "uniform3iv",
                        value: function uniform3iv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform3iv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform4f",
                        value: function uniform4f(location, v0, v1, v2, v3) {
                            this.uniforms.vec4[location] = {
                                method: "uniform4f",
                                value: [ v0, v1, v2, v3 ]
                            };
                        }
                    }, {
                        key: "uniform4fa",
                        value: function uniform4fa(location, value) {
                            this.uniforms.vec4[location] = {
                                method: "uniform4f",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform4fv",
                        value: function uniform4fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform4fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniform4i",
                        value: function uniform4i(location, v0, v1, v2, v3) {
                            this.uniforms.vec4[location] = {
                                method: "uniform4i",
                                value: [ v0, v1, v2, v3 ]
                            };
                        }
                    }, {
                        key: "uniform4iv",
                        value: function uniform4iv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniform4iv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniformMatrix2fv",
                        value: function uniformMatrix2fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniformMatrix2fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniformMatrix3fv",
                        value: function uniformMatrix3fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniformMatrix3fv",
                                value: value
                            };
                        }
                    }, {
                        key: "uniformMatrix4fv",
                        value: function uniformMatrix4fv(location, value) {
                            this.uniforms.single[location] = {
                                method: "uniformMatrix4fv",
                                value: value
                            };
                        }
                    } ]);
                }(CoreShaderNode);
                function createShader(glw, type, source) {
                    var shader = glw.createShader(type);
                    if (!shader) {
                        var glError = glw.getError();
                        throw new Error("Unable to create the shader: ".concat(type === glw.VERTEX_SHADER ? "VERTEX_SHADER" : "FRAGMENT_SHADER", ".").concat(glError ? " WebGlContext Error: ".concat(glError) : ""));
                    }
                    glw.shaderSource(shader, source);
                    glw.compileShader(shader);
                    var success = !!glw.getShaderParameter(shader, glw.COMPILE_STATUS);
                    if (success) {
                        return shader;
                    }
                    console.error(glw.getShaderInfoLog(shader));
                    glw.deleteShader(shader);
                }
                function createProgram(glw, vertexShader, fragmentShader) {
                    var program = glw.createProgram();
                    if (!program) {
                        throw new Error("Unable to create program");
                    }
                    glw.attachShader(program, vertexShader);
                    glw.attachShader(program, fragmentShader);
                    glw.linkProgram(program);
                    var success = !!glw.getProgramParameter(program, glw.LINK_STATUS);
                    if (success) {
                        return program;
                    }
                    console.warn(glw.getProgramInfoLog(program));
                    glw.deleteProgram(program);
                    return undefined;
                }
                var WebGlShaderProgram = function() {
                    function WebGlShaderProgram(renderer, config, resolvedProps) {
                        var _this24 = this;
                        _classCallCheck(this, WebGlShaderProgram);
                        _defineProperty(this, "program", void 0);
                        _defineProperty(this, "vao", void 0);
                        _defineProperty(this, "renderer", void 0);
                        _defineProperty(this, "glw", void 0);
                        _defineProperty(this, "attributeLocations", void 0);
                        _defineProperty(this, "uniformLocations", void 0);
                        _defineProperty(this, "lifecycle", void 0);
                        _defineProperty(this, "useSystemAlpha", false);
                        _defineProperty(this, "useSystemDimensions", false);
                        _defineProperty(this, "useTimeValue", false);
                        _defineProperty(this, "isDestroyed", false);
                        _defineProperty(this, "supportsIndexedTextures", false);
                        this.renderer = renderer;
                        var glw = this.glw = renderer.glw;
                        var webGl2 = glw.isWebGl2();
                        var requiredExtensions = [];
                        this.supportsIndexedTextures = config.supportsIndexedTextures || this.supportsIndexedTextures;
                        requiredExtensions = webGl2 && config.webgl2Extensions || !webGl2 && config.webgl1Extensions || [];
                        var glVersion = webGl2 ? "2.0" : "1.0";
                        requiredExtensions.forEach(function(extensionName) {
                            if (!glw.getExtension(extensionName)) {
                                throw new Error('Shader "'.concat(_this24.constructor.name, '" requires extension "').concat(extensionName, '" for WebGL ').concat(glVersion, " but wasn't found"));
                            }
                        });
                        var vertexSource = config.vertex instanceof Function ? config.vertex(renderer, resolvedProps) : config.vertex;
                        if (vertexSource === undefined) {
                            vertexSource = Default.vertex;
                        }
                        var fragmentSource = config.fragment instanceof Function ? config.fragment(renderer, resolvedProps) : config.fragment;
                        var vertexShader = createShader(glw, glw.VERTEX_SHADER, vertexSource);
                        if (!vertexShader) {
                            throw new Error("Vertex shader creation failed");
                        }
                        var fragmentShader = createShader(glw, glw.FRAGMENT_SHADER, fragmentSource);
                        if (!fragmentShader) {
                            throw new Error("fragment shader creation failed");
                        }
                        var program = createProgram(glw, vertexShader, fragmentShader);
                        if (!program) {
                            throw new Error;
                        }
                        this.program = program;
                        this.attributeLocations = glw.getAttributeLocations(program);
                        var uniLocs = this.uniformLocations = glw.getUniformLocations(program);
                        this.useSystemAlpha = uniLocs["u_alpha"] !== undefined;
                        this.useSystemDimensions = uniLocs["u_dimensions"] !== undefined;
                        this.useTimeValue = this.glw.getUniformLocation(program, "u_dimensions") !== null && config.time !== undefined;
                        this.lifecycle = {
                            update: config.update,
                            canBatch: config.canBatch
                        };
                    }
                    return _createClass(WebGlShaderProgram, [ {
                        key: "disableAttribute",
                        value: function disableAttribute(location) {
                            this.glw.disableVertexAttribArray(location);
                        }
                    }, {
                        key: "disableAttributes",
                        value: function disableAttributes() {
                            var glw = this.glw;
                            var attribLen = this.attributeLocations.length;
                            for (var i = 0; i < attribLen; i++) {
                                glw.disableVertexAttribArray(i);
                            }
                        }
                    }, {
                        key: "reuseRenderOp",
                        value: function reuseRenderOp(node, currentRenderOp) {
                            if (this.lifecycle.canBatch !== undefined) {
                                return this.lifecycle.canBatch(node, currentRenderOp);
                            }
                            var time = node.time, worldAlpha = node.worldAlpha, width = node.width, height = node.height;
                            if (this.useTimeValue === true) {
                                if (time !== currentRenderOp.time) {
                                    return false;
                                }
                            }
                            if (this.useSystemAlpha === true) {
                                if (worldAlpha !== currentRenderOp.worldAlpha) {
                                    return false;
                                }
                            }
                            if (this.useSystemDimensions === true) {
                                if (width !== currentRenderOp.width || height !== currentRenderOp.height) {
                                    return false;
                                }
                            }
                            var shaderPropsA = undefined;
                            var shaderPropsB = undefined;
                            var shader = node.props.shader;
                            if (shader !== null) {
                                shaderPropsA = shader.resolvedProps;
                            }
                            var opShader = currentRenderOp.shader;
                            if (opShader !== null) {
                                shaderPropsB = opShader.resolvedProps;
                            }
                            if (shaderPropsA === undefined && shaderPropsB !== undefined || shaderPropsA !== undefined && shaderPropsB === undefined) {
                                return false;
                            }
                            if (shaderPropsA !== undefined && shaderPropsB !== undefined) {
                                for (var key in shaderPropsA) {
                                    if (shaderPropsA[key] !== shaderPropsB[key]) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                    }, {
                        key: "bindRenderOp",
                        value: function bindRenderOp(renderOp) {
                            var isCoreNode = renderOp.isCoreNode;
                            this.bindTextures(renderOp.renderOpTextures);
                            this.bindBufferCollection(renderOp.quadBufferCollection);
                            var parentHasRenderTexture = renderOp.parentHasRenderTexture;
                            var framebufferDimensions = isCoreNode && renderOp.parentHasRenderTexture ? renderOp.parentFramebufferDimensions : renderOp.framebufferDimensions;
                            if (renderOp.rtt === true && parentHasRenderTexture === true) {
                                return;
                            }
                            if (parentHasRenderTexture === true && framebufferDimensions) {
                                var w = framebufferDimensions.w, h = framebufferDimensions.h;
                                this.glw.uniform1f("u_pixelRatio", 1);
                                this.glw.uniform2f("u_resolution", w, h);
                            } else {
                                this.glw.uniform1f("u_pixelRatio", renderOp.stage.pixelRatio);
                                this.glw.uniform2f("u_resolution", this.glw.canvas.width, this.glw.canvas.height);
                            }
                            if (this.useTimeValue === true) {
                                this.glw.uniform1f("u_time", renderOp.time);
                            }
                            if (this.useSystemAlpha === true) {
                                this.glw.uniform1f("u_alpha", renderOp.worldAlpha);
                            }
                            if (this.useSystemDimensions === true) {
                                this.glw.uniform2f("u_dimensions", renderOp.width, renderOp.height);
                            }
                            if (isCoreNode === false && renderOp.sdfShaderProps !== undefined) {
                                var _opShader$shaderType$;
                                var opShader = renderOp.shader;
                                (_opShader$shaderType$ = opShader.shaderType.onSdfBind) === null || _opShader$shaderType$ === void 0 || _opShader$shaderType$.call(this.glw, renderOp.sdfShaderProps);
                                return;
                            }
                            var shader = renderOp.shader;
                            if (shader.props !== undefined) {
                                var uniforms = shader.uniforms;
                                for (var key in uniforms.single) {
                                    var _uniforms$single$key = uniforms.single[key], method = _uniforms$single$key.method, value = _uniforms$single$key.value;
                                    this.glw[method](key, value);
                                }
                                for (var _key3 in uniforms.vec2) {
                                    var _uniforms$vec2$_key = uniforms.vec2[_key3], _method = _uniforms$vec2$_key.method, _value = _uniforms$vec2$_key.value;
                                    this.glw[_method](_key3, _value[0], _value[1]);
                                }
                                for (var _key4 in uniforms.vec3) {
                                    var _uniforms$vec3$_key = uniforms.vec3[_key4], _method2 = _uniforms$vec3$_key.method, _value2 = _uniforms$vec3$_key.value;
                                    this.glw[_method2](_key4, _value2[0], _value2[1], _value2[2]);
                                }
                                for (var _key5 in uniforms.vec4) {
                                    var _uniforms$vec4$_key = uniforms.vec4[_key5], _method3 = _uniforms$vec4$_key.method, _value3 = _uniforms$vec4$_key.value;
                                    this.glw[_method3](_key5, _value3[0], _value3[1], _value3[2], _value3[3]);
                                }
                            }
                        }
                    }, {
                        key: "bindBufferCollection",
                        value: function bindBufferCollection(buffer) {
                            var glw = this.glw;
                            var attribs = this.attributeLocations;
                            var attribLen = attribs.length;
                            for (var i = 0; i < attribLen; i++) {
                                var name = attribs[i];
                                var resolvedBuffer = buffer.getBuffer(name);
                                var resolvedInfo = buffer.getAttributeInfo(name);
                                if (resolvedBuffer === undefined || resolvedInfo === undefined) {
                                    continue;
                                }
                                glw.enableVertexAttribArray(i);
                                glw.vertexAttribPointer(resolvedBuffer, i, resolvedInfo.size, resolvedInfo.type, resolvedInfo.normalized, resolvedInfo.stride, resolvedInfo.offset);
                            }
                        }
                    }, {
                        key: "bindTextures",
                        value: function bindTextures(textures) {
                            this.glw.activeTexture(0);
                            this.glw.bindTexture(textures[0].ctxTexture);
                        }
                    }, {
                        key: "attach",
                        value: function attach() {
                            if (this.isDestroyed === true) {
                                return;
                            }
                            this.glw.useProgram(this.program, this.uniformLocations);
                            if (this.glw.isWebGl2() && this.vao) {
                                this.glw.bindVertexArray(this.vao);
                            }
                        }
                    }, {
                        key: "detach",
                        value: function detach() {
                            this.disableAttributes();
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            if (this.isDestroyed === true) {
                                return;
                            }
                            var glw = this.glw;
                            this.detach();
                            glw.deleteProgram(this.program);
                            this.program = null;
                            this.uniformLocations = null;
                            var attribs = this.attributeLocations;
                            var attribLen = this.attributeLocations.length;
                            for (var i = 0; i < attribLen; i++) {
                                this.glw.deleteBuffer(attribs[i]);
                            }
                        }
                    } ]);
                }();
                ({
                    LEGACY: true
                });
                var DOM_RENDERING = typeof LIGHTNING_DOM_RENDERING === "boolean" && LIGHTNING_DOM_RENDERING;
                var SHADERS_ENABLED = !(typeof LIGHTNING_DISABLE_SHADERS === "boolean" && LIGHTNING_DISABLE_SHADERS);
                var Config = exports("a9", {
                    debug: false,
                    domRendererEnabled: false,
                    focusDebug: false,
                    keyDebug: false,
                    animationsEnabled: true,
                    animationSettings: {
                        duration: 250,
                        easing: "ease-in-out"
                    },
                    fontSettings: {
                        fontFamily: "Ubuntu",
                        fontSize: 100
                    },
                    fontWeightAlias: {
                        thin: 100,
                        light: 300,
                        regular: "",
                        400: "",
                        medium: 500,
                        bold: 700,
                        black: 900
                    },
                    setActiveElement: function setActiveElement() {},
                    focusStateKey: "$focus",
                    lockStyles: true
                });
                var NodeType = {
                    Element: "element",
                    TextNode: "textNode",
                    Text: "text"
                };
                function log(msg, node) {}
                var isFunc = function isFunc(obj) {
                    return obj instanceof Function;
                };
                var isFunction = function isFunction(obj) {
                    return typeof obj === "function";
                };
                function isArray(item) {
                    return Array.isArray(item);
                }
                function isString(item) {
                    return typeof item === "string";
                }
                function isInteger(item) {
                    return Number.isInteger(item);
                }
                function isINode(node) {
                    return "destroy" in node && typeof node.destroy === "function";
                }
                function isElementNode(node) {
                    return node instanceof ElementNode;
                }
                function isElementText(node) {
                    return node._type === NodeType.TextNode;
                }
                function isTextNode(node) {
                    return node._type === NodeType.Text;
                }
                function keyExists(obj, keys) {
                    var _iterator11 = _createForOfIteratorHelper(keys), _step11;
                    try {
                        for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                            var key = _step11.value;
                            if (key in obj) {
                                return true;
                            }
                        }
                    } catch (err) {
                        _iterator11.e(err);
                    } finally {
                        _iterator11.f();
                    }
                    return false;
                }
                function spliceItem(arr, item, deleteCount) {
                    var index = arr.indexOf(item);
                    if (index > -1) {
                        for (var _len = arguments.length, insert = new Array(_len > 3 ? _len - 3 : 0), _key6 = 3; _key6 < _len; _key6++) {
                            insert[_key6 - 3] = arguments[_key6];
                        }
                        arr.splice.apply(arr, [ index, deleteCount ].concat(insert));
                    }
                    return index;
                }
                function isFocused(el) {
                    var _el$states;
                    return el === null || el === void 0 || (_el$states = el.states) === null || _el$states === void 0 ? void 0 : _el$states.has(Config.focusStateKey);
                }
                var hasFocus = isFocused;
                var colorToRgba = function colorToRgba(c) {
                    return "rgba(".concat(c >> 24 & 255, ",").concat(c >> 16 & 255, ",").concat(c >> 8 & 255, ",").concat((c & 255) / 255, ")");
                };
                function applyEasing(easing, progress) {
                    if (isFunc(easing)) {
                        return easing(progress);
                    }
                    switch (easing) {
                      case "linear":
                      default:
                        return progress;

                      case "ease-in":
                        return progress * progress;

                      case "ease-out":
                        return progress * (2 - progress);

                      case "ease-in-out":
                        return progress < .5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;
                    }
                }
                function interpolate(start, end, t) {
                    return start + (end - start) * t;
                }
                function interpolateColor(start, end, t) {
                    return interpolate(start >> 24 & 255, end >> 24 & 255, t) << 24 | interpolate(start >> 16 & 255, end >> 16 & 255, t) << 16 | interpolate(start >> 8 & 255, end >> 8 & 255, t) << 8 | interpolate(start & 255, end & 255, t);
                }
                function interpolateProp(name, start, end, t) {
                    return name.startsWith("color") ? interpolateColor(start, end, t) : interpolate(start, end, t);
                }
                var animationTasks = [];
                var animationFrameRequested = false;
                function requestAnimationUpdate() {
                    if (!animationFrameRequested && animationTasks.length > 0) {
                        animationFrameRequested = true;
                        requestAnimationFrame(updateAnimations);
                    }
                }
                function updateAnimations(time) {
                    animationFrameRequested = false;
                    for (var i = 0; i < animationTasks.length; i++) {
                        var task = animationTasks[i];
                        if (task.pausedTime != null) continue;
                        var elapsed = time - task.timeStart;
                        if (elapsed < task.settings.delay) {
                            requestAnimationUpdate();
                            continue;
                        }
                        var activeTime = elapsed - task.settings.delay;
                        if (activeTime >= task.settings.duration) {
                            if (task.settings.loop || task.iteration < task.settings.repeat - 1) {
                                task.iteration++;
                                task.timeStart = time - task.settings.delay;
                                requestAnimationUpdate();
                            } else {
                                Object.assign(task.node.props, task.propsEnd);
                                updateNodeStyles(task.node);
                                task.stop();
                                i--;
                            }
                            continue;
                        }
                        var t = activeTime / task.settings.duration;
                        t = applyEasing(task.settings.easing, t);
                        for (var prop in task.propsEnd) {
                            var start = task.propsStart[prop];
                            var end = task.propsEnd[prop];
                            task.node.props[prop] = interpolateProp(prop, start, end, t);
                        }
                        updateNodeStyles(task.node);
                    }
                    requestAnimationUpdate();
                }
                var AnimationController = function() {
                    function AnimationController(node, props, rawSettings) {
                        var _rawSettings$duration, _rawSettings$delay, _rawSettings$easing, _rawSettings$loop, _rawSettings$repeat;
                        _classCallCheck(this, AnimationController);
                        this.node = node;
                        this.state = "paused";
                        this.stopPromise = null;
                        this.stopResolve = null;
                        this.propsStart = {};
                        this.propsEnd = {};
                        this.timeStart = performance.now();
                        this.iteration = 0;
                        this.pausedTime = null;
                        this.settings = {
                            duration: (_rawSettings$duration = rawSettings.duration) !== null && _rawSettings$duration !== void 0 ? _rawSettings$duration : 300,
                            delay: (_rawSettings$delay = rawSettings.delay) !== null && _rawSettings$delay !== void 0 ? _rawSettings$delay : 0,
                            easing: (_rawSettings$easing = rawSettings.easing) !== null && _rawSettings$easing !== void 0 ? _rawSettings$easing : "linear",
                            loop: (_rawSettings$loop = rawSettings.loop) !== null && _rawSettings$loop !== void 0 ? _rawSettings$loop : false,
                            repeat: (_rawSettings$repeat = rawSettings.repeat) !== null && _rawSettings$repeat !== void 0 ? _rawSettings$repeat : 1,
                            stopMethod: false
                        };
                        this.timeEnd = this.timeStart + this.settings.delay + this.settings.duration;
                        for (var _i3 = 0, _Object$entries = Object.entries(props); _i3 < _Object$entries.length; _i3++) {
                            var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), prop = _Object$entries$_i[0], value = _Object$entries$_i[1];
                            if (value != null && typeof value === "number") {
                                this.propsStart[prop] = node.props[prop];
                                this.propsEnd[prop] = value;
                            }
                        }
                        animationTasks.push(this);
                    }
                    return _createClass(AnimationController, [ {
                        key: "start",
                        value: function start() {
                            if (this.pausedTime != null) {
                                this.timeStart += performance.now() - this.pausedTime;
                                this.pausedTime = null;
                            } else {
                                this.timeStart = performance.now();
                            }
                            this.state = "running";
                            requestAnimationUpdate();
                            return this;
                        }
                    }, {
                        key: "pause",
                        value: function pause() {
                            this.pausedTime = performance.now();
                            this.state = "paused";
                            return this;
                        }
                    }, {
                        key: "stop",
                        value: function stop() {
                            var index = animationTasks.indexOf(this);
                            if (index !== -1) {
                                animationTasks.splice(index, 1);
                            }
                            this.state = "stopped";
                            if (this.stopResolve) {
                                this.stopResolve();
                                this.stopResolve = null;
                                this.stopPromise = null;
                            }
                            return this;
                        }
                    }, {
                        key: "restore",
                        value: function restore() {
                            return this;
                        }
                    }, {
                        key: "waitUntilStopped",
                        value: function waitUntilStopped() {
                            var _this$stopPromise, _this25 = this;
                            (_this$stopPromise = this.stopPromise) !== null && _this$stopPromise !== void 0 ? _this$stopPromise : this.stopPromise = new Promise(function(resolve) {
                                _this25.stopResolve = resolve;
                            });
                            return this.stopPromise;
                        }
                    }, {
                        key: "on",
                        value: function on() {
                            return this;
                        }
                    }, {
                        key: "once",
                        value: function once() {
                            return this;
                        }
                    }, {
                        key: "off",
                        value: function off() {
                            return this;
                        }
                    }, {
                        key: "emit",
                        value: function emit() {
                            return this;
                        }
                    } ]);
                }();
                function animate(props, settings) {
                    return new AnimationController(this, props, settings);
                }
                var elMap = new WeakMap;
                function updateNodeParent(node) {
                    if (node.parent != null) {
                        elMap.get(node.parent).appendChild(node.div);
                    }
                }
                function getNodeLineHeight(props) {
                    var _ref22, _props$lineHeight;
                    return (_ref22 = (_props$lineHeight = props.lineHeight) !== null && _props$lineHeight !== void 0 ? _props$lineHeight : Config.fontSettings.lineHeight) !== null && _ref22 !== void 0 ? _ref22 : 1.2 * props.fontSize;
                }
                function updateNodeStyles(node) {
                    var props = node.props;
                    var style = "position: absolute; z-index: ".concat(props.zIndex, ";");
                    if (props.alpha !== 1) style += "opacity: ".concat(props.alpha, ";");
                    if (props.clipping) {
                        style += "overflow: hidden;";
                    }
                    {
                        var transform = "";
                        var x = props.x, y = props.y;
                        if (props.mountX != null) {
                            var _props$w4;
                            x -= ((_props$w4 = props.w) !== null && _props$w4 !== void 0 ? _props$w4 : 0) * props.mountX;
                        }
                        if (props.mountY != null) {
                            var _props$h4;
                            y -= ((_props$h4 = props.h) !== null && _props$h4 !== void 0 ? _props$h4 : 0) * props.mountY;
                        }
                        if (x !== 0) transform += "translateX(".concat(x, "px)");
                        if (y !== 0) transform += "translateY(".concat(y, "px)");
                        if (props.rotation !== 0) transform += "rotate(".concat(props.rotation, "rad)");
                        if (props.scale !== 1 && props.scale != null) {
                            transform += "scale(".concat(props.scale, ")");
                        } else {
                            if (props.scaleX !== 1) transform += "scaleX(".concat(props.scaleX, ")");
                            if (props.scaleY !== 1) transform += "scaleY(".concat(props.scaleY, ")");
                        }
                        if (transform.length > 0) {
                            style += "transform: ".concat(transform, ";");
                        }
                    }
                    if (node instanceof DOMText) {
                        var textProps = node.props;
                        if (textProps.color != null && textProps.color !== 0) {
                            style += "color: ".concat(colorToRgba(textProps.color), ";");
                        }
                        if (textProps.fontFamily) {
                            style += "font-family: ".concat(textProps.fontFamily, ";");
                        }
                        if (textProps.fontSize) {
                            style += "font-size: ".concat(textProps.fontSize, "px;");
                        }
                        if (textProps.fontStyle !== "normal") {
                            style += "font-style: ".concat(textProps.fontStyle, ";");
                        }
                        if (textProps.fontWeight !== "normal") {
                            style += "font-weight: ".concat(textProps.fontWeight, ";");
                        }
                        if (textProps.lineHeight != null) {
                            style += "line-height: ".concat(textProps.lineHeight, "px;");
                        }
                        if (textProps.letterSpacing) {
                            style += "letter-spacing: ".concat(textProps.letterSpacing, "px;");
                        }
                        if (textProps.textAlign !== "left") {
                            style += "text-align: ".concat(textProps.textAlign, ";");
                        }
                        var maxLines = textProps.maxLines || Infinity;
                        switch (textProps.contain) {
                          case "width":
                            style += "width: ".concat(props.w, "px; overflow: hidden;");
                            break;

                          case "both":
                            {
                                var lineHeight = getNodeLineHeight(textProps);
                                maxLines = Math.min(maxLines, Math.floor(props.h / lineHeight));
                                maxLines = Math.max(1, maxLines);
                                var height = maxLines * lineHeight;
                                style += "width: ".concat(props.w, "px; height: ").concat(height, "px; overflow: hidden;");
                                break;
                            }

                          case "none":
                            style += "width: max-content;";
                            break;
                        }
                        if (maxLines !== Infinity) {
                            style += "display: -webkit-box;\n        overflow: hidden;\n        -webkit-line-clamp: ".concat(maxLines, ";\n        line-clamp: ").concat(maxLines, ";\n        -webkit-box-orient: vertical;");
                        }
                        scheduleUpdateDOMTextMeasurement(node);
                    } else {
                        var _props$shader2;
                        if (props.w !== 0) style += "width: ".concat(props.w, "px;");
                        if (props.h !== 0) style += "height: ".concat(props.h, "px;");
                        var vGradient = props.colorBottom !== props.colorTop ? "linear-gradient(to bottom, ".concat(colorToRgba(props.colorTop), ", ").concat(colorToRgba(props.colorBottom), ")") : null;
                        var hGradient = props.colorLeft !== props.colorRight ? "linear-gradient(to right, ".concat(colorToRgba(props.colorLeft), ", ").concat(colorToRgba(props.colorRight), ")") : null;
                        var gradient = vGradient && hGradient ? "".concat(vGradient, ", ").concat(hGradient) : vGradient || hGradient;
                        var srcImg = null;
                        var srcPos = null;
                        if (props.texture != null && props.texture.type === TextureType.subTexture) {
                            srcPos = props.texture.props;
                            srcImg = "url(".concat(props.texture.props.texture.props.src, ")");
                        } else if (props.src) {
                            srcImg = "url(".concat(props.src, ")");
                        }
                        var bgStyle = "";
                        var borderStyle = "";
                        var radiusStyle = "";
                        var maskStyle = "";
                        if (srcImg) {
                            var _props$textureOptions2;
                            if (props.color !== 4294967295 && props.color !== 0) {
                                bgStyle += "background-color: ".concat(colorToRgba(props.color), "; background-blend-mode: multiply;");
                                maskStyle += "mask-image: ".concat(srcImg, ";");
                                if (srcPos !== null) {
                                    maskStyle += "mask-position: -".concat(srcPos.x, "px -").concat(srcPos.y, "px;");
                                } else {
                                    maskStyle += "mask-size: 100% 100%;";
                                }
                            } else if (gradient) {
                                maskStyle += "mask-image: ".concat(gradient, ";");
                            }
                            bgStyle += "background-image: ".concat(srcImg, ";");
                            bgStyle += "background-repeat: no-repeat;";
                            if ((_props$textureOptions2 = props.textureOptions.resizeMode) !== null && _props$textureOptions2 !== void 0 && _props$textureOptions2.type) {
                                bgStyle += "background-size: ".concat(props.textureOptions.resizeMode.type, "; background-position: center;");
                            } else if (srcPos !== null) {
                                bgStyle += "background-position: -".concat(srcPos.x, "px -").concat(srcPos.y, "px;");
                            } else {
                                bgStyle += "background-size: 100% 100%;";
                            }
                            if (maskStyle !== "") {
                                bgStyle += maskStyle;
                            }
                            if (maskStyle !== "" && node.divBg == null) {
                                node.div.appendChild(node.divBg = document.createElement("div"));
                                node.div.appendChild(node.divBorder = document.createElement("div"));
                            }
                        } else if (gradient) {
                            bgStyle += "background-image: ".concat(gradient, ";");
                            bgStyle += "background-repeat: no-repeat;";
                            bgStyle += "background-size: 100% 100%;";
                        } else if (props.color !== 0) {
                            bgStyle += "background-color: ".concat(colorToRgba(props.color), ";");
                        }
                        if (((_props$shader2 = props.shader) === null || _props$shader2 === void 0 ? void 0 : _props$shader2.props) != null) {
                            var _shader$borderGap, _shader$borderInset;
                            var shader = props.shader.props;
                            var borderWidth = shader["border-w"];
                            var borderColor = shader["border-color"];
                            var borderGap = (_shader$borderGap = shader["border-gap"]) !== null && _shader$borderGap !== void 0 ? _shader$borderGap : 0;
                            var borderInset = (_shader$borderInset = shader["border-inset"]) !== null && _shader$borderInset !== void 0 ? _shader$borderInset : true;
                            var radius = shader["radius"];
                            if (typeof borderWidth === "number" && borderWidth !== 0 && typeof borderColor === "number" && borderColor !== 0) {
                                var gap = borderInset ? -(borderWidth + borderGap) : borderGap;
                                borderStyle += "outline: ".concat(borderWidth, "px solid ").concat(colorToRgba(borderColor), ";");
                                borderStyle += "outline-offset: ".concat(gap, "px;");
                            }
                            if (typeof radius === "number" && radius > 0) {
                                radiusStyle += "border-radius: ".concat(radius, "px;");
                            } else if (Array.isArray(radius) && radius.length === 4) {
                                radiusStyle += "border-radius: ".concat(radius[0], "px ").concat(radius[1], "px ").concat(radius[2], "px ").concat(radius[3], "px;");
                            }
                        }
                        style += radiusStyle;
                        bgStyle += radiusStyle;
                        borderStyle += radiusStyle;
                        if (node.divBg == null) {
                            style += bgStyle;
                        } else {
                            bgStyle += "position: absolute; inset: 0; z-index: -1;";
                            node.divBg.setAttribute("style", bgStyle);
                        }
                        if (node.divBorder == null) {
                            style += borderStyle;
                        } else {
                            borderStyle += "position: absolute; inset: 0; z-index: -1;";
                            node.divBorder.setAttribute("style", borderStyle);
                        }
                    }
                    node.div.setAttribute("style", style);
                }
                var fontFamiliesToLoad = new Set;
                var textNodesToMeasure = new Set;
                function getElSize(node) {
                    var _Config$rendererOptio, _Config$rendererOptio2;
                    var rect = node.div.getBoundingClientRect();
                    var dpr = (_Config$rendererOptio = (_Config$rendererOptio2 = Config.rendererOptions) === null || _Config$rendererOptio2 === void 0 ? void 0 : _Config$rendererOptio2.deviceLogicalPixelRatio) !== null && _Config$rendererOptio !== void 0 ? _Config$rendererOptio : 1;
                    rect.height /= dpr;
                    rect.width /= dpr;
                    for (;;) {
                        if (node.props.scale != null && node.props.scale !== 1) {
                            rect.height /= node.props.scale;
                            rect.width /= node.props.scale;
                        } else {
                            rect.height /= node.props.scaleY;
                            rect.width /= node.props.scaleX;
                        }
                        if (node.parent instanceof DOMNode) {
                            node = node.parent;
                        } else {
                            break;
                        }
                    }
                    return rect;
                }
                function updateDOMTextSize(node) {
                    var size;
                    switch (node.contain) {
                      case "width":
                        size = getElSize(node);
                        if (node.props.h !== size.height) {
                            node.props.h = size.height;
                            updateNodeStyles(node);
                            node.emit("loaded");
                        }
                        break;

                      case "none":
                        size = getElSize(node);
                        if (node.props.h !== size.height || node.props.w !== size.width) {
                            node.props.w = size.width;
                            node.props.h = size.height;
                            updateNodeStyles(node);
                            node.emit("loaded");
                        }
                        break;
                    }
                }
                function updateDOMTextMeasurements() {
                    textNodesToMeasure.forEach(updateDOMTextSize);
                    textNodesToMeasure.clear();
                }
                function scheduleUpdateDOMTextMeasurement(node) {
                    if (node.fontFamily && !fontFamiliesToLoad.has(node.fontFamily)) {
                        fontFamiliesToLoad.add(node.fontFamily);
                        document.fonts.load("16px ".concat(node.fontFamily));
                    }
                    if (textNodesToMeasure.size === 0) {
                        if (document.fonts.status === "loaded") {
                            setTimeout(updateDOMTextMeasurements);
                        } else {
                            document.fonts.ready.then(updateDOMTextMeasurements);
                        }
                    }
                    textNodesToMeasure.add(node);
                }
                function updateNodeData(node) {
                    for (var key in node.data) {
                        var keyValue = node.data[key];
                        if (keyValue === void 0) {
                            node.div.removeAttribute("data-" + key);
                        } else {
                            node.div.setAttribute("data-" + key, String(keyValue));
                        }
                    }
                }
                function resolveNodeDefaults(props) {
                    var _props$color2, _props$x2, _props$y2, _props$w5, _props$h5, _props$alpha2, _props$autosize2, _props$boundsMargin2, _props$clipping2, _props$colorTop, _props$colorBottom, _props$colorLeft, _props$colorRight, _ref23, _ref24, _props$colorBl2, _ref25, _ref26, _props$colorBr2, _ref27, _ref28, _props$colorTl2, _ref29, _ref30, _props$colorTr2, _props$zIndex2, _props$parent2, _props$texture2, _props$textureOptions3, _props$shader3, _props$src3, _props$scale2, _ref31, _props$scaleX2, _ref32, _props$scaleY2, _props$mount2, _ref33, _props$mountX2, _ref34, _props$mountY2, _props$pivot2, _ref35, _props$pivotX2, _ref36, _props$pivotY2, _props$rotation2, _props$rtt2;
                    var color = (_props$color2 = props.color) !== null && _props$color2 !== void 0 ? _props$color2 : 4294967295;
                    return {
                        x: (_props$x2 = props.x) !== null && _props$x2 !== void 0 ? _props$x2 : 0,
                        y: (_props$y2 = props.y) !== null && _props$y2 !== void 0 ? _props$y2 : 0,
                        w: (_props$w5 = props.w) !== null && _props$w5 !== void 0 ? _props$w5 : 0,
                        h: (_props$h5 = props.h) !== null && _props$h5 !== void 0 ? _props$h5 : 0,
                        alpha: (_props$alpha2 = props.alpha) !== null && _props$alpha2 !== void 0 ? _props$alpha2 : 1,
                        autosize: (_props$autosize2 = props.autosize) !== null && _props$autosize2 !== void 0 ? _props$autosize2 : false,
                        boundsMargin: (_props$boundsMargin2 = props.boundsMargin) !== null && _props$boundsMargin2 !== void 0 ? _props$boundsMargin2 : null,
                        clipping: (_props$clipping2 = props.clipping) !== null && _props$clipping2 !== void 0 ? _props$clipping2 : false,
                        color: color,
                        colorTop: (_props$colorTop = props.colorTop) !== null && _props$colorTop !== void 0 ? _props$colorTop : color,
                        colorBottom: (_props$colorBottom = props.colorBottom) !== null && _props$colorBottom !== void 0 ? _props$colorBottom : color,
                        colorLeft: (_props$colorLeft = props.colorLeft) !== null && _props$colorLeft !== void 0 ? _props$colorLeft : color,
                        colorRight: (_props$colorRight = props.colorRight) !== null && _props$colorRight !== void 0 ? _props$colorRight : color,
                        colorBl: (_ref23 = (_ref24 = (_props$colorBl2 = props.colorBl) !== null && _props$colorBl2 !== void 0 ? _props$colorBl2 : props.colorBottom) !== null && _ref24 !== void 0 ? _ref24 : props.colorLeft) !== null && _ref23 !== void 0 ? _ref23 : color,
                        colorBr: (_ref25 = (_ref26 = (_props$colorBr2 = props.colorBr) !== null && _props$colorBr2 !== void 0 ? _props$colorBr2 : props.colorBottom) !== null && _ref26 !== void 0 ? _ref26 : props.colorRight) !== null && _ref25 !== void 0 ? _ref25 : color,
                        colorTl: (_ref27 = (_ref28 = (_props$colorTl2 = props.colorTl) !== null && _props$colorTl2 !== void 0 ? _props$colorTl2 : props.colorTop) !== null && _ref28 !== void 0 ? _ref28 : props.colorLeft) !== null && _ref27 !== void 0 ? _ref27 : color,
                        colorTr: (_ref29 = (_ref30 = (_props$colorTr2 = props.colorTr) !== null && _props$colorTr2 !== void 0 ? _props$colorTr2 : props.colorTop) !== null && _ref30 !== void 0 ? _ref30 : props.colorRight) !== null && _ref29 !== void 0 ? _ref29 : color,
                        zIndex: (_props$zIndex2 = props.zIndex) !== null && _props$zIndex2 !== void 0 ? _props$zIndex2 : 0,
                        parent: (_props$parent2 = props.parent) !== null && _props$parent2 !== void 0 ? _props$parent2 : null,
                        texture: (_props$texture2 = props.texture) !== null && _props$texture2 !== void 0 ? _props$texture2 : null,
                        textureOptions: (_props$textureOptions3 = props.textureOptions) !== null && _props$textureOptions3 !== void 0 ? _props$textureOptions3 : {},
                        shader: (_props$shader3 = props.shader) !== null && _props$shader3 !== void 0 ? _props$shader3 : defaultShader,
                        src: (_props$src3 = props.src) !== null && _props$src3 !== void 0 ? _props$src3 : null,
                        srcHeight: props.srcHeight,
                        srcWidth: props.srcWidth,
                        srcX: props.srcX,
                        srcY: props.srcY,
                        scale: (_props$scale2 = props.scale) !== null && _props$scale2 !== void 0 ? _props$scale2 : null,
                        scaleX: (_ref31 = (_props$scaleX2 = props.scaleX) !== null && _props$scaleX2 !== void 0 ? _props$scaleX2 : props.scale) !== null && _ref31 !== void 0 ? _ref31 : 1,
                        scaleY: (_ref32 = (_props$scaleY2 = props.scaleY) !== null && _props$scaleY2 !== void 0 ? _props$scaleY2 : props.scale) !== null && _ref32 !== void 0 ? _ref32 : 1,
                        mount: (_props$mount2 = props.mount) !== null && _props$mount2 !== void 0 ? _props$mount2 : 0,
                        mountX: (_ref33 = (_props$mountX2 = props.mountX) !== null && _props$mountX2 !== void 0 ? _props$mountX2 : props.mount) !== null && _ref33 !== void 0 ? _ref33 : 0,
                        mountY: (_ref34 = (_props$mountY2 = props.mountY) !== null && _props$mountY2 !== void 0 ? _props$mountY2 : props.mount) !== null && _ref34 !== void 0 ? _ref34 : 0,
                        pivot: (_props$pivot2 = props.pivot) !== null && _props$pivot2 !== void 0 ? _props$pivot2 : .5,
                        pivotX: (_ref35 = (_props$pivotX2 = props.pivotX) !== null && _props$pivotX2 !== void 0 ? _props$pivotX2 : props.pivot) !== null && _ref35 !== void 0 ? _ref35 : .5,
                        pivotY: (_ref36 = (_props$pivotY2 = props.pivotY) !== null && _props$pivotY2 !== void 0 ? _props$pivotY2 : props.pivot) !== null && _ref36 !== void 0 ? _ref36 : .5,
                        rotation: (_props$rotation2 = props.rotation) !== null && _props$rotation2 !== void 0 ? _props$rotation2 : 0,
                        rtt: (_props$rtt2 = props.rtt) !== null && _props$rtt2 !== void 0 ? _props$rtt2 : false,
                        data: {},
                        imageType: props.imageType
                    };
                }
                function resolveTextNodeDefaults(props) {
                    var _props$text, _props$textRendererOv, _props$fontSize, _props$fontFamily, _props$fontStyle, _props$fontWeight, _props$forceLoad, _props$textAlign, _props$contain, _props$offsetY, _props$letterSpacing, _props$lineHeight2, _props$maxLines, _props$maxWidth, _props$maxHeight, _props$verticalAlign, _props$overflowSuffix, _props$wordBreak;
                    return _objectSpread(_objectSpread({}, resolveNodeDefaults(props)), {}, {
                        text: (_props$text = props.text) !== null && _props$text !== void 0 ? _props$text : "",
                        textRendererOverride: (_props$textRendererOv = props.textRendererOverride) !== null && _props$textRendererOv !== void 0 ? _props$textRendererOv : null,
                        fontSize: (_props$fontSize = props.fontSize) !== null && _props$fontSize !== void 0 ? _props$fontSize : 16,
                        fontFamily: (_props$fontFamily = props.fontFamily) !== null && _props$fontFamily !== void 0 ? _props$fontFamily : "sans-serif",
                        fontStyle: (_props$fontStyle = props.fontStyle) !== null && _props$fontStyle !== void 0 ? _props$fontStyle : "normal",
                        fontWeight: (_props$fontWeight = props.fontWeight) !== null && _props$fontWeight !== void 0 ? _props$fontWeight : "normal",
                        forceLoad: (_props$forceLoad = props.forceLoad) !== null && _props$forceLoad !== void 0 ? _props$forceLoad : false,
                        textAlign: (_props$textAlign = props.textAlign) !== null && _props$textAlign !== void 0 ? _props$textAlign : "left",
                        contain: (_props$contain = props.contain) !== null && _props$contain !== void 0 ? _props$contain : "none",
                        offsetY: (_props$offsetY = props.offsetY) !== null && _props$offsetY !== void 0 ? _props$offsetY : 0,
                        letterSpacing: (_props$letterSpacing = props.letterSpacing) !== null && _props$letterSpacing !== void 0 ? _props$letterSpacing : 0,
                        lineHeight: (_props$lineHeight2 = props.lineHeight) !== null && _props$lineHeight2 !== void 0 ? _props$lineHeight2 : 0,
                        maxLines: (_props$maxLines = props.maxLines) !== null && _props$maxLines !== void 0 ? _props$maxLines : 0,
                        maxWidth: (_props$maxWidth = props.maxWidth) !== null && _props$maxWidth !== void 0 ? _props$maxWidth : 0,
                        maxHeight: (_props$maxHeight = props.maxHeight) !== null && _props$maxHeight !== void 0 ? _props$maxHeight : 0,
                        verticalAlign: (_props$verticalAlign = props.verticalAlign) !== null && _props$verticalAlign !== void 0 ? _props$verticalAlign : "middle",
                        overflowSuffix: (_props$overflowSuffix = props.overflowSuffix) !== null && _props$overflowSuffix !== void 0 ? _props$overflowSuffix : "...",
                        wordBreak: (_props$wordBreak = props.wordBreak) !== null && _props$wordBreak !== void 0 ? _props$wordBreak : "overflow"
                    });
                }
                var defaultShader = {
                    shaderType: "",
                    props: void 0
                };
                var lastNodeId = 0;
                var DOMNode = function(_EventEmitter8) {
                    function DOMNode(stage, props) {
                        var _this26;
                        _classCallCheck(this, DOMNode);
                        _this26 = _callSuper(this, DOMNode);
                        _this26.stage = stage;
                        _this26.props = props;
                        _this26.div = document.createElement("div");
                        _this26.id = ++lastNodeId;
                        _this26.renderState = 0;
                        _this26.animate = animate;
                        _this26.div._node = _this26;
                        _this26.div.setAttribute("data-id", String(_this26.id));
                        elMap.set(_this26, _this26.div);
                        updateNodeParent(_this26);
                        updateNodeStyles(_this26);
                        updateNodeData(_this26);
                        return _this26;
                    }
                    _inherits(DOMNode, _EventEmitter8);
                    return _createClass(DOMNode, [ {
                        key: "destroy",
                        value: function destroy() {
                            elMap.delete(this);
                            this.div.parentNode.removeChild(this.div);
                        }
                    }, {
                        key: "parent",
                        get: function get() {
                            return this.props.parent;
                        },
                        set: function set(value) {
                            this.props.parent = value;
                            updateNodeParent(this);
                        }
                    }, {
                        key: "x",
                        get: function get() {
                            return this.props.x;
                        },
                        set: function set(v) {
                            this.props.x = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "y",
                        get: function get() {
                            return this.props.y;
                        },
                        set: function set(v) {
                            this.props.y = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "w",
                        get: function get() {
                            return this.props.w;
                        },
                        set: function set(v) {
                            this.props.w = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "h",
                        get: function get() {
                            return this.props.h;
                        },
                        set: function set(v) {
                            this.props.h = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "width",
                        get: function get() {
                            return this.props.w;
                        },
                        set: function set(v) {
                            this.props.w = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "height",
                        get: function get() {
                            return this.props.h;
                        },
                        set: function set(v) {
                            this.props.h = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "alpha",
                        get: function get() {
                            return this.props.alpha;
                        },
                        set: function set(v) {
                            this.props.alpha = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "autosize",
                        get: function get() {
                            return this.props.autosize;
                        },
                        set: function set(v) {
                            this.props.autosize = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "clipping",
                        get: function get() {
                            return this.props.clipping;
                        },
                        set: function set(v) {
                            this.props.clipping = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "color",
                        get: function get() {
                            return this.props.color;
                        },
                        set: function set(v) {
                            this.props.color = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorTop",
                        get: function get() {
                            return this.props.colorTop;
                        },
                        set: function set(v) {
                            this.props.colorTop = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorBottom",
                        get: function get() {
                            return this.props.colorBottom;
                        },
                        set: function set(v) {
                            this.props.colorBottom = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorLeft",
                        get: function get() {
                            return this.props.colorLeft;
                        },
                        set: function set(v) {
                            this.props.colorLeft = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorRight",
                        get: function get() {
                            return this.props.colorRight;
                        },
                        set: function set(v) {
                            this.props.colorRight = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorTl",
                        get: function get() {
                            return this.props.colorTl;
                        },
                        set: function set(v) {
                            this.props.colorTl = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorTr",
                        get: function get() {
                            return this.props.colorTr;
                        },
                        set: function set(v) {
                            this.props.colorTr = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorBr",
                        get: function get() {
                            return this.props.colorBr;
                        },
                        set: function set(v) {
                            this.props.colorBr = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "colorBl",
                        get: function get() {
                            return this.props.colorBl;
                        },
                        set: function set(v) {
                            this.props.colorBl = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "zIndex",
                        get: function get() {
                            return this.props.zIndex;
                        },
                        set: function set(v) {
                            this.props.zIndex = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "texture",
                        get: function get() {
                            return this.props.texture;
                        },
                        set: function set(v) {
                            this.props.texture = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "textureOptions",
                        get: function get() {
                            return this.props.textureOptions;
                        },
                        set: function set(v) {
                            this.props.textureOptions = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "src",
                        get: function get() {
                            return this.props.src;
                        },
                        set: function set(v) {
                            this.props.src = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "scale",
                        get: function get() {
                            var _this$props$scale;
                            return (_this$props$scale = this.props.scale) !== null && _this$props$scale !== void 0 ? _this$props$scale : 1;
                        },
                        set: function set(v) {
                            this.props.scale = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "scaleX",
                        get: function get() {
                            return this.props.scaleX;
                        },
                        set: function set(v) {
                            this.props.scaleX = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "scaleY",
                        get: function get() {
                            return this.props.scaleY;
                        },
                        set: function set(v) {
                            this.props.scaleY = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "mount",
                        get: function get() {
                            return this.props.mount;
                        },
                        set: function set(v) {
                            this.props.mount = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "mountX",
                        get: function get() {
                            return this.props.mountX;
                        },
                        set: function set(v) {
                            this.props.mountX = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "mountY",
                        get: function get() {
                            return this.props.mountY;
                        },
                        set: function set(v) {
                            this.props.mountY = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "pivot",
                        get: function get() {
                            return this.props.pivot;
                        },
                        set: function set(v) {
                            this.props.pivot = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "pivotX",
                        get: function get() {
                            return this.props.pivotX;
                        },
                        set: function set(v) {
                            this.props.pivotX = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "pivotY",
                        get: function get() {
                            return this.props.pivotY;
                        },
                        set: function set(v) {
                            this.props.pivotY = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "rotation",
                        get: function get() {
                            return this.props.rotation;
                        },
                        set: function set(v) {
                            this.props.rotation = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "rtt",
                        get: function get() {
                            return this.props.rtt;
                        },
                        set: function set(v) {
                            this.props.rtt = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "shader",
                        get: function get() {
                            return this.props.shader;
                        },
                        set: function set(v) {
                            this.props.shader = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "data",
                        get: function get() {
                            return this.props.data;
                        },
                        set: function set(v) {
                            this.props.data = v;
                            updateNodeData(this);
                        }
                    }, {
                        key: "imageType",
                        get: function get() {
                            return this.props.imageType;
                        },
                        set: function set(v) {
                            this.props.imageType = v;
                        }
                    }, {
                        key: "srcWidth",
                        get: function get() {
                            return this.props.srcWidth;
                        },
                        set: function set(v) {
                            this.props.srcWidth = v;
                        }
                    }, {
                        key: "srcHeight",
                        get: function get() {
                            return this.props.srcHeight;
                        },
                        set: function set(v) {
                            this.props.srcHeight = v;
                        }
                    }, {
                        key: "srcX",
                        get: function get() {
                            return this.props.srcX;
                        },
                        set: function set(v) {
                            this.props.srcX = v;
                        }
                    }, {
                        key: "srcY",
                        get: function get() {
                            return this.props.srcY;
                        },
                        set: function set(v) {
                            this.props.srcY = v;
                        }
                    }, {
                        key: "boundsMargin",
                        get: function get() {
                            return this.props.boundsMargin;
                        },
                        set: function set(value) {
                            this.props.boundsMargin = value;
                        }
                    }, {
                        key: "absX",
                        get: function get() {
                            var _this$parent$absX, _this$parent2;
                            return this.x + -this.width * this.mountX + ((_this$parent$absX = (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.absX) !== null && _this$parent$absX !== void 0 ? _this$parent$absX : 0);
                        }
                    }, {
                        key: "absY",
                        get: function get() {
                            var _this$parent$absY, _this$parent3;
                            return this.y + -this.height * this.mountY + ((_this$parent$absY = (_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.absY) !== null && _this$parent$absY !== void 0 ? _this$parent$absY : 0);
                        }
                    } ]);
                }(EventEmitter);
                var DOMText = function(_DOMNode) {
                    function DOMText(stage, props) {
                        var _this27;
                        _classCallCheck(this, DOMText);
                        _this27 = _callSuper(this, DOMText, [ stage, props ]);
                        _this27.props = props;
                        _this27.div.innerText = props.text;
                        return _this27;
                    }
                    _inherits(DOMText, _DOMNode);
                    return _createClass(DOMText, [ {
                        key: "text",
                        get: function get() {
                            return this.props.text;
                        },
                        set: function set(v) {
                            this.props.text = v;
                            this.div.innerText = v;
                            scheduleUpdateDOMTextMeasurement(this);
                        }
                    }, {
                        key: "fontFamily",
                        get: function get() {
                            return this.props.fontFamily;
                        },
                        set: function set(v) {
                            this.props.fontFamily = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "fontSize",
                        get: function get() {
                            return this.props.fontSize;
                        },
                        set: function set(v) {
                            this.props.fontSize = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "fontStyle",
                        get: function get() {
                            return this.props.fontStyle;
                        },
                        set: function set(v) {
                            this.props.fontStyle = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "fontWeight",
                        get: function get() {
                            return this.props.fontWeight;
                        },
                        set: function set(v) {
                            this.props.fontWeight = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "forceLoad",
                        get: function get() {
                            return this.props.forceLoad;
                        },
                        set: function set(v) {
                            this.props.forceLoad = v;
                        }
                    }, {
                        key: "lineHeight",
                        get: function get() {
                            return this.props.lineHeight;
                        },
                        set: function set(v) {
                            this.props.lineHeight = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "maxWidth",
                        get: function get() {
                            return this.props.maxWidth;
                        },
                        set: function set(v) {
                            this.props.maxWidth = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "maxHeight",
                        get: function get() {
                            return this.props.maxHeight;
                        },
                        set: function set(v) {
                            this.props.maxHeight = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "letterSpacing",
                        get: function get() {
                            return this.props.letterSpacing;
                        },
                        set: function set(v) {
                            this.props.letterSpacing = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "textAlign",
                        get: function get() {
                            return this.props.textAlign;
                        },
                        set: function set(v) {
                            this.props.textAlign = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "overflowSuffix",
                        get: function get() {
                            return this.props.overflowSuffix;
                        },
                        set: function set(v) {
                            this.props.overflowSuffix = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "maxLines",
                        get: function get() {
                            return this.props.maxLines;
                        },
                        set: function set(v) {
                            this.props.maxLines = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "contain",
                        get: function get() {
                            return this.props.contain;
                        },
                        set: function set(v) {
                            this.props.contain = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "verticalAlign",
                        get: function get() {
                            return this.props.verticalAlign;
                        },
                        set: function set(v) {
                            this.props.verticalAlign = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "textRendererOverride",
                        get: function get() {
                            return this.props.textRendererOverride;
                        },
                        set: function set(v) {
                            this.props.textRendererOverride = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "offsetY",
                        get: function get() {
                            return this.props.offsetY;
                        },
                        set: function set(v) {
                            this.props.offsetY = v;
                            updateNodeStyles(this);
                        }
                    }, {
                        key: "wordBreak",
                        get: function get() {
                            return this.props.wordBreak;
                        },
                        set: function set(v) {
                            this.props.wordBreak = v;
                            updateNodeStyles(this);
                        }
                    } ]);
                }(DOMNode);
                function updateRootPosition() {
                    var _settings$deviceLogic, _settings$appHeight, _settings$appWidth;
                    var canvas = this.canvas, settings = this.settings;
                    var rect = canvas.getBoundingClientRect();
                    var top = document.documentElement.scrollTop + rect.top;
                    var left = document.documentElement.scrollLeft + rect.left;
                    var dpr = (_settings$deviceLogic = settings.deviceLogicalPixelRatio) !== null && _settings$deviceLogic !== void 0 ? _settings$deviceLogic : 1;
                    var height = Math.ceil((_settings$appHeight = settings.appHeight) !== null && _settings$appHeight !== void 0 ? _settings$appHeight : 1080 / dpr);
                    var width = Math.ceil((_settings$appWidth = settings.appWidth) !== null && _settings$appWidth !== void 0 ? _settings$appWidth : 1920 / dpr);
                    this.root.div.style.left = "".concat(left, "px");
                    this.root.div.style.top = "".concat(top, "px");
                    this.root.div.style.width = "".concat(width, "px");
                    this.root.div.style.height = "".concat(height, "px");
                    this.root.div.style.position = "absolute";
                    this.root.div.style.transformOrigin = "0 0 0";
                    this.root.div.style.transform = "scale(".concat(dpr, ", ").concat(dpr, ")");
                    this.root.div.style.overflow = "hidden";
                }
                var DOMRendererMain = function() {
                    function DOMRendererMain(settings, rawTarget) {
                        var _settings$appWidth2, _settings$appHeight2;
                        _classCallCheck(this, DOMRendererMain);
                        this.settings = settings;
                        var target;
                        if (typeof rawTarget === "string") {
                            var result = document.getElementById(rawTarget);
                            if (result instanceof HTMLElement) {
                                target = result;
                            } else {
                                throw new Error("Target #".concat(rawTarget, " not found"));
                            }
                        } else {
                            target = rawTarget;
                        }
                        var canvas = document.body.appendChild(document.createElement("canvas"));
                        canvas.style.position = "absolute";
                        canvas.style.top = "0";
                        canvas.style.left = "0";
                        canvas.style.width = "100vw";
                        canvas.style.height = "100vh";
                        this.canvas = canvas;
                        this.stage = {
                            root: null,
                            renderer: {
                                mode: "canvas"
                            },
                            loadFont: function() {
                                var _loadFont2 = _asyncToGenerator(_regenerator().m(function _callee16() {
                                    return _regenerator().w(function(_context16) {
                                        while (1) switch (_context16.n) {
                                          case 0:
                                            return _context16.a(2);
                                        }
                                    }, _callee16);
                                }));
                                function loadFont() {
                                    return _loadFont2.apply(this, arguments);
                                }
                                return loadFont;
                            }(),
                            shManager: {
                                registerShaderType: function registerShaderType() {}
                            },
                            animationManager: {
                                registerAnimation: function registerAnimation() {},
                                unregisterAnimation: function unregisterAnimation() {}
                            }
                        };
                        this.root = new DOMNode(this.stage, resolveNodeDefaults({
                            w: (_settings$appWidth2 = settings.appWidth) !== null && _settings$appWidth2 !== void 0 ? _settings$appWidth2 : 1920,
                            h: (_settings$appHeight2 = settings.appHeight) !== null && _settings$appHeight2 !== void 0 ? _settings$appHeight2 : 1080,
                            shader: defaultShader,
                            zIndex: 65534
                        }));
                        this.stage.root = this.root;
                        target.appendChild(this.root.div);
                        if (Config.fontSettings.fontFamily) {
                            this.root.div.style.fontFamily = Config.fontSettings.fontFamily;
                        }
                        if (Config.fontSettings.fontSize) {
                            this.root.div.style.fontSize = Config.fontSettings.fontSize + "px";
                        }
                        if (Config.fontSettings.lineHeight) {
                            this.root.div.style.lineHeight = Config.fontSettings.lineHeight + "px";
                        } else {
                            this.root.div.style.lineHeight = "1.2";
                        }
                        if (Config.fontSettings.fontWeight) {
                            if (typeof Config.fontSettings.fontWeight === "number") {
                                this.root.div.style.fontWeight = Config.fontSettings.fontWeight + "px";
                            } else {
                                this.root.div.style.fontWeight = Config.fontSettings.fontWeight;
                            }
                        }
                        updateRootPosition.call(this);
                        new MutationObserver(updateRootPosition.bind(this)).observe(this.canvas, {
                            attributes: true
                        });
                        new ResizeObserver(updateRootPosition.bind(this)).observe(this.canvas);
                        window.addEventListener("resize", updateRootPosition.bind(this));
                    }
                    return _createClass(DOMRendererMain, [ {
                        key: "createNode",
                        value: function createNode(props) {
                            return new DOMNode(this.stage, resolveNodeDefaults(props));
                        }
                    }, {
                        key: "createTextNode",
                        value: function createTextNode(props) {
                            return new DOMText(this.stage, resolveTextNodeDefaults(props));
                        }
                    }, {
                        key: "createShader",
                        value: function createShader(shaderType, props) {
                            return {
                                shaderType: shaderType,
                                props: props,
                                program: {}
                            };
                        }
                    }, {
                        key: "createTexture",
                        value: function createTexture(textureType, props) {
                            var type = TextureType.generic;
                            switch (textureType) {
                              case "SubTexture":
                                type = TextureType.subTexture;
                                break;

                              case "ImageTexture":
                                type = TextureType.image;
                                break;

                              case "ColorTexture":
                                type = TextureType.color;
                                break;

                              case "NoiseTexture":
                                type = TextureType.noise;
                                break;

                              case "RenderTexture":
                                type = TextureType.renderToTexture;
                                break;
                            }
                            return {
                                type: type,
                                props: props
                            };
                        }
                    }, {
                        key: "on",
                        value: function on(name, callback) {
                            console.log("on", name, callback);
                        }
                    } ]);
                }();
                var renderer$2;
                function startLightningRenderer(options) {
                    var rootId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "app";
                    renderer$2 = DOM_RENDERING ? new DOMRendererMain(options, rootId) : new RendererMain(options, rootId);
                    return renderer$2;
                }
                function loadFonts(fonts) {
                    var _iterator12 = _createForOfIteratorHelper(fonts), _step12;
                    try {
                        for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                            var _font = _step12.value;
                            if (renderer$2.stage.renderer.mode === "webgl" && "type" in _font && (_font.type === "msdf" || _font.type === "ssdf")) {
                                renderer$2.stage.loadFont("sdf", _font);
                            } else if ("fontUrl" in _font && renderer$2.stage.renderer.mode !== "webgl") {
                                renderer$2.stage.loadFont("canvas", _font);
                            }
                        }
                    } catch (err) {
                        _iterator12.e(err);
                    } finally {
                        _iterator12.f();
                    }
                }
                var States = function(_Array) {
                    function States(callback) {
                        var _this28;
                        var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        _classCallCheck(this, States);
                        if (isArray(initialState)) {
                            _this28 = _callSuper(this, States, _toConsumableArray(initialState));
                        } else if (isString(initialState)) {
                            _this28 = _callSuper(this, States, [ initialState ]);
                        } else {
                            _this28 = _callSuper(this, States, _toConsumableArray(Object.entries(initialState).filter(function(_ref37) {
                                var _ref38 = _slicedToArray(_ref37, 2), _key = _ref38[0], value = _ref38[1];
                                return value;
                            }).map(function(_ref39) {
                                var _ref40 = _slicedToArray(_ref39, 1), key = _ref40[0];
                                return key;
                            })));
                        }
                        _this28.onChange = callback;
                        return _possibleConstructorReturn(_this28, _assertThisInitialized(_this28));
                    }
                    _inherits(States, _Array);
                    return _createClass(States, [ {
                        key: "has",
                        value: function has(state) {
                            return this.indexOf(state) >= 0 || this.indexOf("$".concat(state)) >= 0;
                        }
                    }, {
                        key: "is",
                        value: function is(state) {
                            return this.indexOf(state) >= 0;
                        }
                    }, {
                        key: "add",
                        value: function add(state) {
                            if (this.has(state)) {
                                return;
                            }
                            this.push(state);
                            this.onChange();
                        }
                    }, {
                        key: "toggle",
                        value: function toggle(state, force) {
                            if (force === true) {
                                this.add(state);
                            } else if (force === false) {
                                this.remove(state);
                            } else {
                                if (this.has(state)) {
                                    this.remove(state);
                                } else {
                                    this.add(state);
                                }
                            }
                        }
                    }, {
                        key: "merge",
                        value: function merge(newStates) {
                            if (isArray(newStates)) {
                                this.length = 0;
                                this.push.apply(this, _toConsumableArray(newStates));
                            } else if (isString(newStates)) {
                                this.length = 0;
                                this.push(newStates);
                            } else {
                                for (var state in newStates) {
                                    var value = newStates[state];
                                    if (value) {
                                        if (!this.has(state)) {
                                            this.push(state);
                                        }
                                    } else {
                                        var stateIndexToRemove = this.indexOf(state);
                                        if (stateIndexToRemove >= 0) {
                                            this.splice(stateIndexToRemove, 1);
                                        }
                                    }
                                }
                            }
                            return this;
                        }
                    }, {
                        key: "remove",
                        value: function remove(state) {
                            var stateIndexToRemove = this.indexOf(state);
                            if (stateIndexToRemove >= 0) {
                                this.splice(stateIndexToRemove, 1);
                                this.onChange();
                            }
                        }
                    } ]);
                }(_wrapNativeSuper(Array));
                function calculateFlex(node) {
                    var direction = node.flexDirection || "row";
                    var isRow = direction === "row";
                    var dimension = isRow ? "width" : "height";
                    var crossDimension = isRow ? "height" : "width";
                    var marginOne = isRow ? "marginLeft" : "marginTop";
                    var crossMarginOne = isRow ? "marginTop" : "marginLeft";
                    var marginTwo = isRow ? "marginRight" : "marginBottom";
                    var crossMarginTwo = isRow ? "marginBottom" : "marginRight";
                    var processedChildren = [];
                    var hasOrder = false;
                    var totalFlexGrow = 0;
                    for (var i = 0; i < node.children.length; i++) {
                        var c = node.children[i];
                        if (isElementText(c) && c.text && !(c.width || c.height)) {
                            return false;
                        }
                        if (isTextNode(c) || c.flexItem === false) {
                            continue;
                        }
                        var flexOrder = c.flexOrder;
                        if (flexOrder !== void 0) {
                            hasOrder = true;
                        }
                        var flexGrow = c.flexGrow;
                        var isGrowItem = flexGrow !== void 0 && flexGrow >= 0;
                        if (isGrowItem) {
                            totalFlexGrow += flexGrow;
                        }
                        var mainSize = c[dimension] || 0;
                        var currentMarginStart = c[marginOne] || 0;
                        var currentMarginEnd = c[marginTwo] || 0;
                        processedChildren.push({
                            node: c,
                            mainSize: mainSize,
                            marginStart: currentMarginStart,
                            marginEnd: currentMarginEnd,
                            totalMainSizeOnAxis: mainSize + currentMarginStart + currentMarginEnd,
                            isGrowItem: isGrowItem,
                            flexGrowValue: isGrowItem ? flexGrow : 0,
                            flexOrder: flexOrder || 0,
                            crossSize: c[crossDimension] || 0,
                            crossMarginStart: c[crossMarginOne] || 0,
                            crossMarginEnd: c[crossMarginTwo] || 0
                        });
                    }
                    if (hasOrder) {
                        processedChildren.sort(function(a, b) {
                            return a.flexOrder - b.flexOrder;
                        });
                    } else if (node.direction === "rtl") {
                        processedChildren.reverse();
                    }
                    var numProcessedChildren = processedChildren.length;
                    if (numProcessedChildren === 0) {
                        return false;
                    }
                    var prop = isRow ? "x" : "y";
                    var crossProp = isRow ? "y" : "x";
                    var containerSize = Math.max(node[dimension] || 0, 0);
                    var containerCrossSize = Math.max(node[crossDimension] || 0, 0);
                    var gap = node.gap || 0;
                    var justify = node.justifyContent || "flexStart";
                    var containerUpdated = false;
                    if (totalFlexGrow > 0 && numProcessedChildren > 1) {
                        node.flexBoundary = node.flexBoundary || "fixed";
                        var sumOfFlexBaseSizesWithMargins = 0;
                        var _iterator13 = _createForOfIteratorHelper(processedChildren), _step13;
                        try {
                            for (_iterator13.s(); !(_step13 = _iterator13.n()).done; ) {
                                var _pc2 = _step13.value;
                                sumOfFlexBaseSizesWithMargins += _pc2.mainSize + _pc2.marginStart + _pc2.marginEnd;
                            }
                        } catch (err) {
                            _iterator13.e(err);
                        } finally {
                            _iterator13.f();
                        }
                        var totalGapSpace = numProcessedChildren > 0 ? gap * (numProcessedChildren - 1) : 0;
                        var availableSpace = containerSize - sumOfFlexBaseSizesWithMargins - totalGapSpace;
                        if (availableSpace > 0) {
                            var _iterator14 = _createForOfIteratorHelper(processedChildren), _step14;
                            try {
                                for (_iterator14.s(); !(_step14 = _iterator14.n()).done; ) {
                                    var pc = _step14.value;
                                    if (pc.isGrowItem && pc.flexGrowValue > 0) {
                                        var shareOfSpace = pc.flexGrowValue / totalFlexGrow * availableSpace;
                                        var newMainSize = pc.mainSize + shareOfSpace;
                                        pc.node[dimension] = newMainSize;
                                        pc.mainSize = newMainSize;
                                        pc.totalMainSizeOnAxis = newMainSize + pc.marginStart + pc.marginEnd;
                                    }
                                }
                            } catch (err) {
                                _iterator14.e(err);
                            } finally {
                                _iterator14.f();
                            }
                            node._containsFlexGrow = node._containsFlexGrow ? null : true;
                        } else if (node._containsFlexGrow) {
                            node._containsFlexGrow = null;
                        } else {
                            console.warn("No available space for flex-grow items to expand, or items overflow.");
                        }
                    }
                    var totalItemSize = 0;
                    if (justify === "center" || justify === "spaceBetween" || justify === "spaceEvenly" || justify === "spaceAround") {
                        var _iterator15 = _createForOfIteratorHelper(processedChildren), _step15;
                        try {
                            for (_iterator15.s(); !(_step15 = _iterator15.n()).done; ) {
                                var _pc3 = _step15.value;
                                totalItemSize += _pc3.totalMainSizeOnAxis;
                            }
                        } catch (err) {
                            _iterator15.e(err);
                        } finally {
                            _iterator15.f();
                        }
                    }
                    var align = node.alignItems || (node.flexWrap ? "flexStart" : void 0);
                    var doCrossAlign = containerCrossSize ? function(pc) {
                        var crossCurrentPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                        var alignSelf = pc.node.alignSelf || align;
                        if (!alignSelf) {
                            return;
                        }
                        if (alignSelf === "flexStart") {
                            pc.node[crossProp] = crossCurrentPos + pc.crossMarginStart;
                        } else if (alignSelf === "center") {
                            pc.node[crossProp] = crossCurrentPos + (containerCrossSize - pc.crossSize) / 2 + pc.crossMarginStart;
                        } else if (alignSelf === "flexEnd") {
                            pc.node[crossProp] = crossCurrentPos + containerCrossSize - pc.crossSize - pc.crossMarginEnd;
                        }
                    } : function(_pc) {
                        var _crossCurrentPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    };
                    if (isRow && node._calcHeight && !node.flexCrossBoundary) {
                        var maxHeight = processedChildren.reduce(function(max, pc) {
                            return Math.max(max, pc.crossSize);
                        }, 0);
                        var newHeight = maxHeight || node.height;
                        if (newHeight !== node.height) {
                            containerUpdated = true;
                            node.height = containerCrossSize = newHeight;
                        }
                    }
                    var currentPos = node.padding || 0;
                    if (justify === "flexStart") {
                        if (node.flexWrap === "wrap") {
                            var _processedChildren$, _node$columnGap, _node$rowGap;
                            var crossCurrentPos = 0;
                            var childCrossSize = ((_processedChildren$ = processedChildren[0]) === null || _processedChildren$ === void 0 ? void 0 : _processedChildren$.crossSize) || containerCrossSize;
                            var crossGap = isRow ? (_node$columnGap = node.columnGap) !== null && _node$columnGap !== void 0 ? _node$columnGap : gap : (_node$rowGap = node.rowGap) !== null && _node$rowGap !== void 0 ? _node$rowGap : gap;
                            var _iterator16 = _createForOfIteratorHelper(processedChildren), _step16;
                            try {
                                for (_iterator16.s(); !(_step16 = _iterator16.n()).done; ) {
                                    var _pc4 = _step16.value;
                                    if (currentPos + _pc4.totalMainSizeOnAxis > containerSize && currentPos > (node.padding || 0)) {
                                        currentPos = node.padding || 0;
                                        crossCurrentPos += childCrossSize + crossGap;
                                    }
                                    _pc4.node[prop] = currentPos + _pc4.marginStart;
                                    currentPos += _pc4.totalMainSizeOnAxis + gap;
                                    doCrossAlign(_pc4, crossCurrentPos);
                                }
                            } catch (err) {
                                _iterator16.e(err);
                            } finally {
                                _iterator16.f();
                            }
                            var finalCrossSize = crossCurrentPos + childCrossSize;
                            if (node[crossDimension] !== finalCrossSize) {
                                node["preFlex".concat(crossDimension)] = node[crossDimension];
                                node[crossDimension] = finalCrossSize;
                                containerUpdated = true;
                            }
                        } else {
                            var _iterator17 = _createForOfIteratorHelper(processedChildren), _step17;
                            try {
                                for (_iterator17.s(); !(_step17 = _iterator17.n()).done; ) {
                                    var _pc5 = _step17.value;
                                    _pc5.node[prop] = currentPos + _pc5.marginStart;
                                    currentPos += _pc5.totalMainSizeOnAxis + gap;
                                    doCrossAlign(_pc5);
                                }
                            } catch (err) {
                                _iterator17.e(err);
                            } finally {
                                _iterator17.f();
                            }
                        }
                        if (node.flexBoundary !== "fixed" && node.flexWrap !== "wrap") {
                            var calculatedSize = currentPos - gap + (node.padding || 0);
                            if (calculatedSize !== containerSize) {
                                node["preFlex".concat(dimension)] = containerSize;
                                node[dimension] = calculatedSize;
                                return true;
                            }
                        }
                    } else if (justify === "flexEnd") {
                        currentPos = containerSize - (node.padding || 0);
                        for (var _i4 = numProcessedChildren - 1; _i4 >= 0; _i4--) {
                            var _pc6 = processedChildren[_i4];
                            _pc6.node[prop] = currentPos - _pc6.mainSize - _pc6.marginEnd;
                            currentPos -= _pc6.totalMainSizeOnAxis + gap;
                            doCrossAlign(_pc6);
                        }
                    } else if (justify === "center") {
                        currentPos = (containerSize - (totalItemSize + gap * (numProcessedChildren - 1))) / 2 + (node.padding || 0);
                        var _iterator18 = _createForOfIteratorHelper(processedChildren), _step18;
                        try {
                            for (_iterator18.s(); !(_step18 = _iterator18.n()).done; ) {
                                var _pc7 = _step18.value;
                                _pc7.node[prop] = currentPos + _pc7.marginStart;
                                currentPos += _pc7.totalMainSizeOnAxis + gap;
                                doCrossAlign(_pc7);
                            }
                        } catch (err) {
                            _iterator18.e(err);
                        } finally {
                            _iterator18.f();
                        }
                    } else if (justify === "spaceBetween") {
                        var spaceBetween = numProcessedChildren > 1 ? (containerSize - totalItemSize - (node.padding || 0) * 2) / (numProcessedChildren - 1) : 0;
                        currentPos = node.padding || 0;
                        var _iterator19 = _createForOfIteratorHelper(processedChildren), _step19;
                        try {
                            for (_iterator19.s(); !(_step19 = _iterator19.n()).done; ) {
                                var _pc8 = _step19.value;
                                _pc8.node[prop] = currentPos + _pc8.marginStart;
                                currentPos += _pc8.totalMainSizeOnAxis + spaceBetween;
                                doCrossAlign(_pc8);
                            }
                        } catch (err) {
                            _iterator19.e(err);
                        } finally {
                            _iterator19.f();
                        }
                    } else if (justify === "spaceAround") {
                        var spaceAround = numProcessedChildren > 0 ? (containerSize - totalItemSize - (node.padding || 0) * 2) / numProcessedChildren : 0;
                        currentPos = (node.padding || 0) + spaceAround / 2;
                        var _iterator20 = _createForOfIteratorHelper(processedChildren), _step20;
                        try {
                            for (_iterator20.s(); !(_step20 = _iterator20.n()).done; ) {
                                var _pc9 = _step20.value;
                                _pc9.node[prop] = currentPos + _pc9.marginStart;
                                currentPos += _pc9.totalMainSizeOnAxis + spaceAround;
                                doCrossAlign(_pc9);
                            }
                        } catch (err) {
                            _iterator20.e(err);
                        } finally {
                            _iterator20.f();
                        }
                    } else if (justify === "spaceEvenly") {
                        var spaceEvenly = (containerSize - totalItemSize - (node.padding || 0) * 2) / (numProcessedChildren + 1);
                        currentPos = spaceEvenly + (node.padding || 0);
                        var _iterator21 = _createForOfIteratorHelper(processedChildren), _step21;
                        try {
                            for (_iterator21.s(); !(_step21 = _iterator21.n()).done; ) {
                                var _pc0 = _step21.value;
                                _pc0.node[prop] = currentPos + _pc0.marginStart;
                                currentPos += _pc0.totalMainSizeOnAxis + spaceEvenly;
                                doCrossAlign(_pc0);
                            }
                        } catch (err) {
                            _iterator21.e(err);
                        } finally {
                            _iterator21.f();
                        }
                    }
                    return containerUpdated;
                }
                var keyMapEntries = {
                    ArrowLeft: "Left",
                    ArrowRight: "Right",
                    ArrowUp: "Up",
                    ArrowDown: "Down",
                    Enter: "Enter",
                    l: "Last",
                    " ": "Space",
                    Backspace: "Back",
                    Escape: "Escape"
                };
                var keyHoldMapEntries = {};
                var flattenKeyMap = function flattenKeyMap(keyMap, targetMap) {
                    var _loop2 = function _loop2() {
                        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i5], 2), key = _Object$entries2$_i[0], value = _Object$entries2$_i[1];
                        if (Array.isArray(value)) {
                            value.forEach(function(v) {
                                targetMap[v] = key;
                            });
                        } else if (value === null) {
                            delete targetMap[key];
                        } else {
                            targetMap[value] = key;
                        }
                    };
                    for (var _i5 = 0, _Object$entries2 = Object.entries(keyMap); _i5 < _Object$entries2.length; _i5++) {
                        _loop2();
                    }
                };
                var needFocusDebugStyles = true;
                var addFocusDebug = function addFocusDebug(prevFocusPath, newFocusPath) {
                    if (needFocusDebugStyles) {
                        var style = document.createElement("style");
                        style.type = "text/css";
                        style.innerHTML = '\n      [data-focus="3"] {\n        border: 2px solid rgba(255, 33, 33, 0.2);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus="2"] {\n        border: 2px solid rgba(255, 33, 33, 0.4);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus="1"] {\n        border: 4px solid rgba(255, 33, 33, 0.9);\n        border-radius: 5px;\n        transition: border-color 0.5s ease;\n      }\n    ';
                        document.head.appendChild(style);
                        needFocusDebugStyles = false;
                    }
                    prevFocusPath.forEach(function(elm) {
                        elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
                            focus: void 0
                        });
                    });
                    newFocusPath.forEach(function(elm, i) {
                        elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
                            focus: i + 1
                        });
                    });
                };
                var activeElement$1;
                var setActiveElement$1 = function setActiveElement$1(elm) {
                    updateFocusPath(elm, activeElement$1);
                    activeElement$1 = elm;
                    Config.setActiveElement(elm);
                };
                var focusPath$1 = [];
                var updateFocusPath = function updateFocusPath(currentFocusedElm, prevFocusedElm) {
                    var current = currentFocusedElm;
                    var fp = [];
                    while (current) {
                        if (!current.states.has(Config.focusStateKey) || current === currentFocusedElm) {
                            var _current$onFocus, _current$onFocusChang;
                            current.states.add(Config.focusStateKey);
                            (_current$onFocus = current.onFocus) === null || _current$onFocus === void 0 || _current$onFocus.call(current, currentFocusedElm, prevFocusedElm, current);
                            (_current$onFocusChang = current.onFocusChanged) === null || _current$onFocusChang === void 0 || _current$onFocusChang.call(current, true, currentFocusedElm, prevFocusedElm, current);
                        }
                        fp.push(current);
                        current = current.parent;
                    }
                    focusPath$1.forEach(function(elm) {
                        if (!fp.includes(elm)) {
                            var _elm$onBlur, _elm$onFocusChanged;
                            elm.states.remove(Config.focusStateKey);
                            (_elm$onBlur = elm.onBlur) === null || _elm$onBlur === void 0 || _elm$onBlur.call(elm, currentFocusedElm, prevFocusedElm, elm);
                            (_elm$onFocusChanged = elm.onFocusChanged) === null || _elm$onFocusChanged === void 0 || _elm$onFocusChanged.call(elm, false, currentFocusedElm, prevFocusedElm, elm);
                        }
                    });
                    if (Config.focusDebug) {
                        addFocusDebug(focusPath$1, fp);
                    }
                    focusPath$1 = fp;
                    return fp;
                };
                var lastGlobalKeyPressTime = 0;
                var lastInputKey;
                var propagateKeyPress = function propagateKeyPress(e, mappedEvent) {
                    var isHold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    var isUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                    var currentTime = performance.now();
                    var key = e.key || e.keyCode;
                    var sameKey = lastInputKey === key;
                    lastInputKey = key;
                    if (!isUp && Config.throttleInput) {
                        if (sameKey && currentTime - lastGlobalKeyPressTime < Config.throttleInput) {
                            return false;
                        }
                        lastGlobalKeyPressTime = currentTime;
                    }
                    var finalFocusElm;
                    var numItems = focusPath$1.length;
                    var captureEvent = "onCapture".concat(mappedEvent || e.key) + isUp ? "Release" : "";
                    var captureKey = isUp ? "onCaptureKeyRelease" : "onCaptureKey";
                    for (var i = numItems - 1; i >= 0; i--) {
                        var elm = focusPath$1[i];
                        if (elm.throttleInput) {
                            if (sameKey && elm._lastAnyKeyPressTime !== void 0 && currentTime - elm._lastAnyKeyPressTime < elm.throttleInput) {
                                return true;
                            }
                        }
                        var captureHandler = elm[captureEvent] || elm[captureKey];
                        if (isFunction(captureHandler) && captureHandler.call(elm, e, elm, finalFocusElm, mappedEvent) === true) {
                            elm._lastAnyKeyPressTime = currentTime;
                            return true;
                        }
                    }
                    var eventHandlerKey;
                    var releaseEventHandlerKey;
                    var fallbackHandlerKey;
                    if (mappedEvent) {
                        eventHandlerKey = "on".concat(mappedEvent);
                        releaseEventHandlerKey = "on".concat(mappedEvent, "Release");
                    }
                    if (!isUp) {
                        fallbackHandlerKey = isHold ? "onKeyHold" : "onKeyPress";
                    }
                    for (var _i6 = 0; _i6 < numItems; _i6++) {
                        var _elm = focusPath$1[_i6];
                        if (!finalFocusElm) {
                            finalFocusElm = _elm;
                        }
                        if (_elm.throttleInput) {
                            if (sameKey && _elm._lastAnyKeyPressTime !== void 0 && currentTime - _elm._lastAnyKeyPressTime < _elm.throttleInput) {
                                return true;
                            }
                        }
                        var handled = false;
                        if (isUp && releaseEventHandlerKey) {
                            var eventHandler = _elm[releaseEventHandlerKey];
                            if (isFunction(eventHandler)) {
                                if (eventHandler.call(_elm, e, _elm, finalFocusElm) === true) handled = true;
                            }
                        } else if (!isUp && eventHandlerKey) {
                            var _eventHandler = _elm[eventHandlerKey];
                            if (isFunction(_eventHandler)) {
                                if (_eventHandler.call(_elm, e, _elm, finalFocusElm) === true) handled = true;
                            }
                        }
                        if (!handled && fallbackHandlerKey) {
                            var fallbackHandler = _elm[fallbackHandlerKey];
                            if (isFunction(fallbackHandler)) {
                                if (fallbackHandler.call(_elm, e, mappedEvent, _elm, finalFocusElm) === true) handled = true;
                            }
                        }
                        if (handled) {
                            _elm._lastAnyKeyPressTime = currentTime;
                            return true;
                        }
                    }
                    return false;
                };
                var DEFAULT_KEY_HOLD_THRESHOLD = 500;
                var keyHoldTimeouts = {};
                var handleKeyEvents = function handleKeyEvents(delay, keydown, keyup) {
                    if (keydown) {
                        var key = keydown.key || keydown.keyCode;
                        var mappedKeyHoldEvent = keyHoldMapEntries[keydown.key] || keyHoldMapEntries[keydown.keyCode];
                        var mappedKeyEvent = keyMapEntries[keydown.key] || keyMapEntries[keydown.keyCode];
                        if (mappedKeyHoldEvent) {
                            if (!keyHoldTimeouts[key]) {
                                keyHoldTimeouts[key] = window.setTimeout(function() {
                                    keyHoldTimeouts[key] = true;
                                    propagateKeyPress(keydown, mappedKeyHoldEvent, true);
                                }, delay);
                            }
                            return;
                        }
                        propagateKeyPress(keydown, mappedKeyEvent, false);
                    } else if (keyup) {
                        var _key7 = keyup.key || keyup.keyCode;
                        var _mappedKeyEvent = keyMapEntries[keyup.key] || keyMapEntries[keyup.keyCode];
                        if (keyHoldTimeouts[_key7] === true) {
                            delete keyHoldTimeouts[_key7];
                        } else if (keyHoldTimeouts[_key7]) {
                            clearTimeout(keyHoldTimeouts[_key7]);
                            delete keyHoldTimeouts[_key7];
                            propagateKeyPress(keyup, _mappedKeyEvent, false);
                        }
                        propagateKeyPress(keyup, _mappedKeyEvent, false, true);
                    }
                };
                var useFocusManager$1 = function useFocusManager$1() {
                    var _ref41 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, userKeyMap = _ref41.userKeyMap, keyHoldOptions = _ref41.keyHoldOptions, _ref41$ownerContext = _ref41.ownerContext, ownerContext = _ref41$ownerContext === void 0 ? function(cb) {
                        cb();
                    } : _ref41$ownerContext;
                    if (userKeyMap) {
                        flattenKeyMap(userKeyMap, keyMapEntries);
                    }
                    if (keyHoldOptions !== null && keyHoldOptions !== void 0 && keyHoldOptions.userKeyHoldMap) {
                        flattenKeyMap(keyHoldOptions.userKeyHoldMap, keyHoldMapEntries);
                    }
                    var delay = (keyHoldOptions === null || keyHoldOptions === void 0 ? void 0 : keyHoldOptions.holdThreshold) || DEFAULT_KEY_HOLD_THRESHOLD;
                    var runKeyEvent = handleKeyEvents.bind(null, delay);
                    var keyPressHandler = function keyPressHandler(event) {
                        return ownerContext(function() {
                            runKeyEvent(event, void 0);
                        });
                    };
                    var keyUpHandler = function keyUpHandler(event) {
                        return ownerContext(function() {
                            runKeyEvent(void 0, event);
                        });
                    };
                    document.addEventListener("keyup", keyUpHandler);
                    document.addEventListener("keydown", keyPressHandler);
                    return {
                        cleanup: function cleanup() {
                            document.removeEventListener("keydown", keyPressHandler);
                            document.removeEventListener("keyup", keyUpHandler);
                            for (var _i7 = 0, _Object$entries3 = Object.entries(keyHoldTimeouts); _i7 < _Object$entries3.length; _i7++) {
                                var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i7], 2), _ = _Object$entries3$_i[0], timeout = _Object$entries3$_i[1];
                                if (timeout && timeout !== true) clearTimeout(timeout);
                            }
                        },
                        focusPath: function focusPath() {
                            return focusPath$1;
                        }
                    };
                };
                var SimpleAnimation = function() {
                    function SimpleAnimation() {
                        _classCallCheck(this, SimpleAnimation);
                        this.nodeConfigs = [];
                        this.isRegistered = false;
                    }
                    return _createClass(SimpleAnimation, [ {
                        key: "register",
                        value: function register(stage) {
                            if (this.isRegistered) {
                                return;
                            }
                            this.isRegistered = true;
                            this.stage = stage;
                            stage.animationManager.registerAnimation(this);
                        }
                    }, {
                        key: "add",
                        value: function add(node, key, value, settings) {
                            var _settings$duration2, _settings$delay2;
                            var existingConfig = this.nodeConfigs.find(function(config) {
                                return config.node === node && config.propName === key;
                            });
                            var duration = (_settings$duration2 = settings.duration) !== null && _settings$duration2 !== void 0 ? _settings$duration2 : 0;
                            var delay = (_settings$delay2 = settings.delay) !== null && _settings$delay2 !== void 0 ? _settings$delay2 : 0;
                            var easing = settings.easing || "linear";
                            var timingFunction = isFunc(easing) ? easing : getTimingFunction(easing);
                            var targetValue = value;
                            var startValue = node[key];
                            if (existingConfig) {
                                existingConfig.duration = duration;
                                existingConfig.delay = delay;
                                existingConfig.easing = easing;
                                existingConfig.timingFunction = timingFunction;
                                existingConfig.targetValue = targetValue;
                                existingConfig.startValue = startValue;
                                existingConfig.progress = 0;
                                existingConfig.delayFor = delay;
                            } else {
                                this.nodeConfigs.push({
                                    node: node,
                                    duration: duration,
                                    delay: delay,
                                    easing: easing,
                                    progress: 0,
                                    delayFor: delay,
                                    timingFunction: timingFunction,
                                    propName: key,
                                    startValue: startValue,
                                    targetValue: targetValue
                                });
                            }
                        }
                    }, {
                        key: "update",
                        value: function update(dt) {
                            for (var i = this.nodeConfigs.length - 1; i >= 0; i--) {
                                var nodeConfig = this.nodeConfigs[i];
                                var node = nodeConfig.node, duration = nodeConfig.duration, timingFunction = nodeConfig.timingFunction, propName = nodeConfig.propName, startValue = nodeConfig.startValue, targetValue = nodeConfig.targetValue;
                                var remainingDt = dt;
                                if (nodeConfig.delayFor > 0) {
                                    nodeConfig.delayFor -= remainingDt;
                                    if (nodeConfig.delayFor >= 0) {
                                        continue;
                                    } else {
                                        remainingDt = -nodeConfig.delayFor;
                                        nodeConfig.delayFor = 0;
                                    }
                                }
                                if (duration > 0) {
                                    nodeConfig.progress += remainingDt / duration;
                                    nodeConfig.progress = Math.max(0, Math.min(1, nodeConfig.progress));
                                } else if (duration === 0 && nodeConfig.delayFor <= 0) {
                                    nodeConfig.progress = 1;
                                }
                                var easedProgress = timingFunction(nodeConfig.progress) || nodeConfig.progress;
                                var interpolatedValue = void 0;
                                if (nodeConfig.progress === 1) {
                                    interpolatedValue = targetValue;
                                } else {
                                    if (propName.includes("color")) {
                                        interpolatedValue = mergeColorProgress(startValue, targetValue, easedProgress);
                                    } else {
                                        interpolatedValue = startValue + (targetValue - startValue) * easedProgress;
                                    }
                                }
                                node.lng[propName] = interpolatedValue;
                                if (nodeConfig.progress === 1) {
                                    this.nodeConfigs.splice(i, 1);
                                }
                                if (this.nodeConfigs.length === 0) {
                                    var _this$stage2;
                                    (_this$stage2 = this.stage) === null || _this$stage2 === void 0 || _this$stage2.animationManager.unregisterAnimation(this);
                                    this.isRegistered = false;
                                }
                            }
                        }
                    } ]);
                }();
                var simpleAnimation = new SimpleAnimation;
                var layoutRunQueued = false;
                var layoutQueue = new Set;
                function addToLayoutQueue(node) {
                    layoutQueue.add(node);
                    if (!layoutRunQueued) {
                        layoutRunQueued = true;
                        queueMicrotask(runLayout);
                    }
                }
                function runLayout() {
                    layoutRunQueued = false;
                    var queue = _toConsumableArray(layoutQueue);
                    layoutQueue.clear();
                    for (var i = queue.length - 1; i >= 0; i--) {
                        var node = queue[i];
                        node.updateLayout();
                    }
                }
                var parseAndAssignShaderProps = function parseAndAssignShaderProps(prefix, obj) {
                    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    if (!obj) return;
                    props[prefix] = obj;
                    Object.entries(obj).forEach(function(_ref42) {
                        var _ref43 = _slicedToArray(_ref42, 2), key = _ref43[0], value = _ref43[1];
                        var transformedKey = key === "width" ? "w" : key;
                        props["".concat(prefix, "-").concat(transformedKey)] = value;
                    });
                };
                function convertToShader(_node, v) {
                    var type = "rounded";
                    if (v.border) type += "WithBorder";
                    if (v.shadow) type += "WithShadow";
                    return renderer$2.createShader(type, v);
                }
                function getPropertyAlias(name) {
                    if (name === "w") return "width";
                    if (name === "h") return "height";
                    return name;
                }
                var LightningRendererNumberProps = [ "alpha", "color", "colorTop", "colorRight", "colorLeft", "colorBottom", "colorTl", "colorTr", "colorBl", "colorBr", "h", "fontSize", "lineHeight", "mount", "mountX", "mountY", "pivot", "pivotX", "pivotY", "rotation", "scale", "scaleX", "scaleY", "w", "worldX", "worldY", "x", "y", "zIndex", "zIndexLocked" ];
                var LightningRendererNonAnimatingProps = [ "absX", "absY", "autosize", "clipping", "contain", "data", "destroyed", "fontFamily", "fontStretch", "fontStyle", "imageType", "letterSpacing", "maxHeight", "maxLines", "maxWidth", "offsetY", "overflowSuffix", "preventCleanup", "rtt", "scrollable", "scrollY", "srcHeight", "srcWidth", "srcX", "srcY", "strictBounds", "text", "textAlign", "textBaseline", "textOverflow", "texture", "textureOptions", "verticalAlign", "wordWrap" ];
                var ElementNode = function(_Object) {
                    function ElementNode(name) {
                        var _this29;
                        _classCallCheck(this, ElementNode);
                        _this29 = _callSuper(this, ElementNode);
                        _this29._type = name === "text" ? NodeType.TextNode : NodeType.Element;
                        _this29.rendered = false;
                        _this29.lng = {};
                        _this29.children = [];
                        return _this29;
                    }
                    _inherits(ElementNode, _Object);
                    return _createClass(ElementNode, [ {
                        key: "effects",
                        get: function get() {
                            return this.lng.shader;
                        },
                        set: function set(v) {
                            var _this$lng$shader;
                            if (!SHADERS_ENABLED) return;
                            var target = this.lng.shader || {};
                            if ((_this$lng$shader = this.lng.shader) !== null && _this$lng$shader !== void 0 && _this$lng$shader.program) {
                                target = this.lng.shader.props;
                            }
                            if (v.rounded) target.radius = v.rounded.radius;
                            if (v.borderRadius) target.radius = v.borderRadius;
                            if (v.border) parseAndAssignShaderProps("border", v.border, target);
                            if (v.shadow) parseAndAssignShaderProps("shadow", v.shadow, target);
                            if (this.rendered) {
                                if (!this.lng.shader) {
                                    this.lng.shader = convertToShader(this, target);
                                } else if (DOM_RENDERING) {
                                    this.lng.shader = this.lng.shader;
                                }
                            } else {
                                this.lng.shader = target;
                            }
                        }
                    }, {
                        key: "id",
                        get: function get() {
                            return this._id;
                        },
                        set: function set(id) {
                            var _Config$rendererOptio3;
                            this._id = id;
                            if ((_Config$rendererOptio3 = Config.rendererOptions) !== null && _Config$rendererOptio3 !== void 0 && _Config$rendererOptio3.inspector) {
                                this.data = _objectSpread(_objectSpread({}, this.data), {}, {
                                    testId: id
                                });
                            }
                        }
                    }, {
                        key: "parent",
                        get: function get() {
                            return this._parent;
                        },
                        set: function set(p) {
                            this._parent = p;
                            if (this.rendered && p !== null && p !== void 0 && p.rendered) {
                                var _p$lng;
                                this.lng.parent = (_p$lng = p.lng) !== null && _p$lng !== void 0 ? _p$lng : null;
                            }
                        }
                    }, {
                        key: "height",
                        get: function get() {
                            return this.h;
                        },
                        set: function set(h) {
                            this.h = h;
                        }
                    }, {
                        key: "width",
                        get: function get() {
                            return this.w;
                        },
                        set: function set(w) {
                            this.w = w;
                        }
                    }, {
                        key: "fontWeight",
                        get: function get() {
                            return this._fontWeight;
                        },
                        set: function set(v) {
                            var _Config$fontSettings, _ref44;
                            this._fontWeight = v;
                            var family = this.fontFamily || ((_Config$fontSettings = Config.fontSettings) === null || _Config$fontSettings === void 0 ? void 0 : _Config$fontSettings.fontFamily);
                            var weight = (_ref44 = Config.fontWeightAlias && Config.fontWeightAlias[v]) !== null && _ref44 !== void 0 ? _ref44 : v;
                            this.fontFamily = "".concat(family).concat(weight);
                        }
                    }, {
                        key: "insertChild",
                        value: function insertChild(node, beforeNode) {
                            if (node.parent) {
                                node.parent.removeChild(node);
                                if (!this.rendered) {
                                    this._hasRenderedChildren = true;
                                }
                            }
                            node.parent = this;
                            if (beforeNode) {
                                spliceItem(this.children, node, 1);
                                if (spliceItem(this.children, beforeNode, 0, node) > -1) {
                                    return;
                                }
                            }
                            this.children.push(node);
                        }
                    }, {
                        key: "removeChild",
                        value: function removeChild(node) {
                            if (spliceItem(this.children, node, 1) > -1) {
                                var _node$onRemove;
                                (_node$onRemove = node.onRemove) === null || _node$onRemove === void 0 || _node$onRemove.call(node, node);
                                if (this.requiresLayout()) {
                                    addToLayoutQueue(this);
                                }
                            }
                        }
                    }, {
                        key: "selectedNode",
                        get: function get() {
                            var selectedIndex = this.selected || 0;
                            for (var i = selectedIndex; i < this.children.length; i++) {
                                var element = this.children[i];
                                if (isElementNode(element)) {
                                    this.selected = i;
                                    return element;
                                }
                            }
                            return void 0;
                        }
                    }, {
                        key: "shader",
                        set: function set(shaderProps) {
                            var _renderer$;
                            this.lng.shader = isArray(shaderProps) ? (_renderer$ = renderer$2).createShader.apply(_renderer$, _toConsumableArray(shaderProps)) : shaderProps;
                        }
                    }, {
                        key: "_sendToLightningAnimatable",
                        value: function _sendToLightningAnimatable(name, value) {
                            var _this30 = this;
                            if (this.transition && this.rendered && Config.animationsEnabled && (this.transition === true || this.transition[name] || this.transition[getPropertyAlias(name)])) {
                                var animationSettings = this.transition === true || this.transition[name] === true ? void 0 : this.transition[name];
                                if (Config.simpleAnimationsEnabled) {
                                    simpleAnimation.add(this, name, value, animationSettings || this.animationSettings);
                                    simpleAnimation.register(renderer$2.stage);
                                    return;
                                } else {
                                    var animationController = this.animate(_defineProperty({}, name, value), animationSettings);
                                    if (this.onAnimation) {
                                        var animationEvents = Object.keys(this.onAnimation);
                                        var _loop3 = function _loop3() {
                                            var event = _animationEvents[_i8];
                                            var handler = _this30.onAnimation[event];
                                            animationController.on(event, function(controller, props) {
                                                handler.call(_this30, controller, name, value, props);
                                            });
                                        };
                                        for (var _i8 = 0, _animationEvents = animationEvents; _i8 < _animationEvents.length; _i8++) {
                                            _loop3();
                                        }
                                    }
                                    return animationController.start();
                                }
                            }
                            this.lng[name] = value;
                        }
                    }, {
                        key: "animate",
                        value: function animate(props, animationSettings) {
                            return this.lng.animate(props, animationSettings || this.animationSettings || {});
                        }
                    }, {
                        key: "chain",
                        value: function chain(props, animationSettings) {
                            if (this._animationRunning) {
                                this._animationQueue = [];
                                this._animationRunning = false;
                            }
                            if (animationSettings) {
                                this._animationQueueSettings = animationSettings;
                            } else if (!this._animationQueueSettings) {
                                this._animationQueueSettings = animationSettings || this.animationSettings;
                            }
                            animationSettings = animationSettings || this._animationQueueSettings;
                            this._animationQueue = this._animationQueue || [];
                            this._animationQueue.push({
                                props: props,
                                animationSettings: animationSettings
                            });
                            return this;
                        }
                    }, {
                        key: "start",
                        value: function() {
                            var _start = _asyncToGenerator(_regenerator().m(function _callee17() {
                                var animation;
                                return _regenerator().w(function(_context17) {
                                    while (1) switch (_context17.n) {
                                      case 0:
                                        animation = this._animationQueue.shift();

                                      case 1:
                                        if (!animation) {
                                            _context17.n = 3;
                                            break;
                                        }
                                        this._animationRunning = true;
                                        _context17.n = 2;
                                        return this.animate(animation.props, animation.animationSettings).start().waitUntilStopped();

                                      case 2:
                                        animation = this._animationQueue.shift();
                                        _context17.n = 1;
                                        break;

                                      case 3:
                                        this._animationRunning = false;
                                        this._animationQueueSettings = void 0;

                                      case 4:
                                        return _context17.a(2);
                                    }
                                }, _callee17, this);
                            }));
                            function start() {
                                return _start.apply(this, arguments);
                            }
                            return start;
                        }()
                    }, {
                        key: "emit",
                        value: function emit(event) {
                            var current = this;
                            var capitalizedEvent = "on".concat(event.charAt(0).toUpperCase()).concat(event.slice(1));
                            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key8 = 1; _key8 < _len2; _key8++) {
                                args[_key8 - 1] = arguments[_key8];
                            }
                            while (current) {
                                var handler = current[capitalizedEvent];
                                if (isFunction(handler)) {
                                    if (handler.call.apply(handler, [ current, this ].concat(args)) === true) {
                                        return true;
                                    }
                                }
                                current = current.parent;
                            }
                            return false;
                        }
                    }, {
                        key: "setFocus",
                        value: function setFocus() {
                            var _this31 = this;
                            if (this.rendered) {
                                if (this.forwardFocus !== void 0) {
                                    if (isFunc(this.forwardFocus)) {
                                        if (this.forwardFocus.call(this, this) !== false) {
                                            return;
                                        }
                                    } else {
                                        var focusedIndex = typeof this.forwardFocus === "number" ? this.forwardFocus : null;
                                        var nodes = this.children;
                                        if (focusedIndex !== null && focusedIndex < nodes.length) {
                                            var child = nodes[focusedIndex];
                                            isElementNode(child) && child.setFocus();
                                            return;
                                        }
                                    }
                                }
                                queueMicrotask(function() {
                                    return setActiveElement$1(_this31);
                                });
                            } else {
                                this._autofocus = true;
                            }
                        }
                    }, {
                        key: "_layoutOnLoad",
                        value: function _layoutOnLoad() {
                            var _this32 = this;
                            this.lng.on("loaded", function() {
                                _this32.parent.updateLayout();
                            });
                        }
                    }, {
                        key: "getText",
                        value: function getText() {
                            var result = "";
                            for (var i = 0; i < this.children.length; i++) {
                                result += this.children[i].text;
                            }
                            return result;
                        }
                    }, {
                        key: "destroy",
                        value: function destroy() {
                            var _this33 = this;
                            if (this.onDestroy) {
                                var destroyPromise = this.onDestroy(this);
                                if (destroyPromise instanceof Promise) {
                                    destroyPromise.then(function() {
                                        return _this33._destroy();
                                    });
                                } else {
                                    this._destroy();
                                }
                            } else {
                                this._destroy();
                            }
                        }
                    }, {
                        key: "_destroy",
                        value: function _destroy() {
                            if (isINode(this.lng)) {
                                this.lng.destroy();
                            }
                        }
                    }, {
                        key: "style",
                        get: function get() {
                            return this._style;
                        },
                        set: function set(style) {
                            if (Config.lockStyles && this._style) {
                                return;
                            }
                            if (!style) {
                                return;
                            }
                            this._style = style;
                            for (var key in this._style) {
                                if (this[key] === void 0) {
                                    this[key] = this._style[key];
                                }
                            }
                        }
                    }, {
                        key: "hasChildren",
                        get: function get() {
                            return this.children.length > 0;
                        }
                    }, {
                        key: "src",
                        get: function get() {
                            return this.lng.src;
                        },
                        set: function set(src) {
                            if (typeof src === "string") {
                                this.lng.src = src;
                                if (!this.color && this.rendered) {
                                    this.color = 4294967295;
                                }
                            } else {
                                this.color = 0;
                            }
                        }
                    }, {
                        key: "getChildById",
                        value: function getChildById(id) {
                            return this.children.find(function(c) {
                                return c.id === id;
                            });
                        }
                    }, {
                        key: "searchChildrenById",
                        value: function searchChildrenById(id) {
                            for (var i = 0; i < this.children.length; i++) {
                                var child = this.children[i];
                                if (isElementNode(child)) {
                                    if (child.id === id) {
                                        return child;
                                    }
                                    var found = child.searchChildrenById(id);
                                    if (found) {
                                        return found;
                                    }
                                }
                            }
                        }
                    }, {
                        key: "states",
                        get: function get() {
                            this._states = this._states || new States(this._stateChanged.bind(this));
                            return this._states;
                        },
                        set: function set(states) {
                            this._states = this._states ? this._states.merge(states) : new States(this._stateChanged.bind(this), states);
                            if (this.rendered) {
                                this._stateChanged();
                            }
                        }
                    }, {
                        key: "animationSettings",
                        get: function get() {
                            return this._animationSettings || Config.animationSettings;
                        },
                        set: function set(animationSettings) {
                            this._animationSettings = animationSettings;
                        }
                    }, {
                        key: "hidden",
                        get: function get() {
                            return this.alpha === 0;
                        },
                        set: function set(val) {
                            this.alpha = val ? 0 : 1;
                        }
                    }, {
                        key: "autofocus",
                        get: function get() {
                            return this._autofocus;
                        },
                        set: function set(val) {
                            var _this34 = this;
                            this._autofocus = val;
                            val && queueMicrotask(function() {
                                return _this34.setFocus();
                            });
                        }
                    }, {
                        key: "requiresLayout",
                        value: function requiresLayout() {
                            return this.display === "flex" || this.onLayout;
                        }
                    }, {
                        key: "updateLayoutOn",
                        get: function get() {
                            return null;
                        },
                        set: function set(v) {
                            this.updateLayout();
                        }
                    }, {
                        key: "updateLayout",
                        value: function updateLayout() {
                            var _this35 = this;
                            if (this.hasChildren) {
                                if (this.display === "flex" && this.flexGrow && this.width === 0) {
                                    return;
                                }
                                var flexChanged = this.display === "flex" && calculateFlex(this);
                                layoutQueue.delete(this);
                                var onLayoutChanged = isFunc(this.onLayout) && this.onLayout.call(this, this);
                                if ((flexChanged || onLayoutChanged) && this.parent) {
                                    addToLayoutQueue(this.parent);
                                }
                                if (this._containsFlexGrow === true) {
                                    this.children.forEach(function(c) {
                                        if (c.display === "flex" && isElementNode(c)) {
                                            calculateFlex(c);
                                            isFunc(c.onLayout) && c.onLayout.call(c, c);
                                            addToLayoutQueue(_this35);
                                        }
                                    });
                                }
                            }
                        }
                    }, {
                        key: "_stateChanged",
                        value: function _stateChanged() {
                            var _this36 = this;
                            if (this.forwardStates) {
                                var states2 = this.states.slice();
                                this.children.forEach(function(c) {
                                    c.states = states2;
                                });
                            }
                            var states = this.states;
                            if (this._undoStyles || keyExists(this, states)) {
                                var stylesToUndo;
                                if (this._undoStyles && this._undoStyles.length) {
                                    stylesToUndo = {};
                                    this._undoStyles.forEach(function(styleKey) {
                                        stylesToUndo[styleKey] = _this36.style[styleKey];
                                    });
                                }
                                var numStates = states.length;
                                if (numStates === 0) {
                                    Object.assign(this, stylesToUndo);
                                    this._undoStyles = [];
                                    return;
                                }
                                var newStyles;
                                if (numStates === 1) {
                                    newStyles = this[states[0]];
                                    newStyles = stylesToUndo ? _objectSpread(_objectSpread({}, stylesToUndo), newStyles) : newStyles;
                                } else {
                                    newStyles = states.reduce(function(acc, state) {
                                        var styles = _this36[state];
                                        return styles ? _objectSpread(_objectSpread({}, acc), styles) : acc;
                                    }, stylesToUndo || {});
                                }
                                if (newStyles) {
                                    this._undoStyles = Object.keys(newStyles);
                                    if (newStyles.transition !== void 0) {
                                        this.transition = newStyles.transition;
                                    }
                                    Object.assign(this, newStyles);
                                } else {
                                    this._undoStyles = [];
                                }
                            }
                        }
                    }, {
                        key: "render",
                        value: function render(topNode) {
                            var _this$onCreate, _this$onRender2, _node$lng;
                            var node = this;
                            var parent = this.parent;
                            if (!parent) {
                                console.warn("Parent not set - no node created for: ", this);
                                return;
                            }
                            if (!parent.rendered) {
                                console.warn("Parent not rendered yet: ", this);
                                return;
                            }
                            if (parent.requiresLayout()) {
                                layoutQueue.add(parent);
                            }
                            if (this.rendered) {
                                var _this$onRender;
                                (_this$onRender = this.onRender) === null || _this$onRender === void 0 || _this$onRender.call(this, this);
                                return;
                            }
                            if (this._states) {
                                this._stateChanged();
                            }
                            var props = node.lng;
                            var parentWidth = parent.w || 0;
                            var parentHeight = parent.h || 0;
                            props.x = props.x || 0;
                            props.y = props.y || 0;
                            props.parent = parent.lng;
                            if (this.right || this.right === 0) {
                                props.x = parentWidth - this.right;
                                props.mountX = 1;
                            }
                            if (this.bottom || this.bottom === 0) {
                                props.y = parentHeight - this.bottom;
                                props.mountY = 1;
                            }
                            if (this.center) {
                                this.centerX = this.centerY = true;
                            }
                            if (this.centerX) {
                                props.x += parentWidth / 2;
                                props.mountX = .5;
                            }
                            if (this.centerY) {
                                props.y += parentHeight / 2;
                                props.mountY = .5;
                            }
                            if (isElementText(node)) {
                                var textProps = props;
                                if (Config.fontSettings) {
                                    for (var key in Config.fontSettings) {
                                        if (textProps[key] === void 0) {
                                            textProps[key] = Config.fontSettings[key];
                                        }
                                    }
                                }
                                textProps.text = textProps.text || node.getText();
                                if (textProps.textAlign && !textProps.contain) {
                                    console.warn("Text align requires contain: ", node.getText());
                                }
                                if (textProps.contain) {
                                    if (textProps.contain === "both") {
                                        var _textProps$maxWidth, _textProps$maxHeight;
                                        textProps.maxWidth = (_textProps$maxWidth = textProps.maxWidth) !== null && _textProps$maxWidth !== void 0 ? _textProps$maxWidth : textProps.w;
                                        textProps.maxHeight = (_textProps$maxHeight = textProps.maxHeight) !== null && _textProps$maxHeight !== void 0 ? _textProps$maxHeight : textProps.h;
                                    } else if (textProps.contain === "width") {
                                        var _textProps$maxWidth2;
                                        textProps.maxWidth = (_textProps$maxWidth2 = textProps.maxWidth) !== null && _textProps$maxWidth2 !== void 0 ? _textProps$maxWidth2 : textProps.w;
                                    }
                                    if (!textProps.h && !textProps.maxHeight) {
                                        var _textProps$maxLines;
                                        textProps.maxLines = (_textProps$maxLines = textProps.maxLines) !== null && _textProps$maxLines !== void 0 ? _textProps$maxLines : 99;
                                    }
                                    if (!textProps.maxWidth) {
                                        textProps.maxWidth = parentWidth - textProps.x - (textProps.marginRight || 0);
                                    }
                                    if (textProps.contain === "both" && !textProps.maxHeight) {
                                        textProps.maxHeight = parentHeight - textProps.y - (textProps.marginBottom || 0);
                                    } else if (textProps.maxLines === 1) {
                                        textProps.maxHeight = textProps.maxHeight || textProps.lineHeight || textProps.fontSize;
                                    }
                                    textProps.w = textProps.h = void 0;
                                }
                                if (SHADERS_ENABLED && props.shader && !props.shader.program) {
                                    props.shader = convertToShader(node, props.shader);
                                }
                                node.lng = renderer$2.createTextNode(props);
                                if (parent.requiresLayout()) {
                                    if (!textProps.maxWidth || !textProps.maxHeight) {
                                        node._layoutOnLoad();
                                    }
                                }
                            } else {
                                if (!props.texture) {
                                    if (isNaN(props.w)) {
                                        props.w = node.flexGrow ? 0 : parentWidth - props.x;
                                        node._calcWidth = true;
                                    }
                                    if (isNaN(props.h)) {
                                        props.h = parentHeight - props.y;
                                        node._calcHeight = true;
                                    }
                                    if (props.rtt && !props.color) {
                                        props.color = 4294967295;
                                    }
                                    if (!props.color && !props.src) {
                                        props.color = 0;
                                    }
                                }
                                if (SHADERS_ENABLED && props.shader && !props.shader.program) {
                                    props.shader = convertToShader(node, props.shader);
                                }
                                node.lng = renderer$2.createNode(props);
                                if (node._hasRenderedChildren) {
                                    node._hasRenderedChildren = false;
                                    var _iterator22 = _createForOfIteratorHelper(node.children), _step22;
                                    try {
                                        for (_iterator22.s(); !(_step22 = _iterator22.n()).done; ) {
                                            var child = _step22.value;
                                            if (isElementNode(child) && isINode(child.lng)) {
                                                child.lng.parent = node.lng;
                                            }
                                        }
                                    } catch (err) {
                                        _iterator22.e(err);
                                    } finally {
                                        _iterator22.f();
                                    }
                                }
                            }
                            node.rendered = true;
                            if (node.autosize && parent.requiresLayout()) {
                                node._layoutOnLoad();
                            }
                            (_this$onCreate = this.onCreate) === null || _this$onCreate === void 0 || _this$onCreate.call(this, this);
                            (_this$onRender2 = this.onRender) === null || _this$onRender2 === void 0 || _this$onRender2.call(this, this);
                            if (node.onEvent) {
                                var _loop4 = function _loop4() {
                                    var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i9], 2), name = _Object$entries4$_i[0], handler = _Object$entries4$_i[1];
                                    node.lng.on(name, function(_inode, data) {
                                        return handler.call(node, node, data);
                                    });
                                };
                                for (var _i9 = 0, _Object$entries4 = Object.entries(node.onEvent); _i9 < _Object$entries4.length; _i9++) {
                                    _loop4();
                                }
                            }
                            if ((_node$lng = node.lng) !== null && _node$lng !== void 0 && _node$lng.div) {
                                node.lng.div.element = node;
                            }
                            if (node._type === NodeType.Element) {
                                var numChildren = node.children.length;
                                for (var i = 0; i < numChildren; i++) {
                                    var c = node.children[i];
                                    if (isElementNode(c)) {
                                        c.render();
                                    }
                                }
                            }
                            if (topNode && !layoutRunQueued) {
                                layoutRunQueued = true;
                                queueMicrotask(runLayout);
                            }
                            node._autofocus && node.setFocus();
                        }
                    } ]);
                }(_wrapNativeSuper(Object));
                exports("E", ElementNode);
                var _loop5 = function _loop5() {
                    var key = _LightningRendererNum[_i0];
                    Object.defineProperty(ElementNode.prototype, key, {
                        get: function get() {
                            return this.lng[key];
                        },
                        set: function set(v) {
                            this._sendToLightningAnimatable(key, v);
                        }
                    });
                };
                for (var _i0 = 0, _LightningRendererNum = LightningRendererNumberProps; _i0 < _LightningRendererNum.length; _i0++) {
                    _loop5();
                }
                var _loop6 = function _loop6() {
                    var key = _LightningRendererNon[_i1];
                    Object.defineProperty(ElementNode.prototype, key, {
                        get: function get() {
                            return this.lng[key];
                        },
                        set: function set(v) {
                            this.lng[key] = v;
                        }
                    });
                };
                for (var _i1 = 0, _LightningRendererNon = LightningRendererNonAnimatingProps; _i1 < _LightningRendererNon.length; _i1++) {
                    _loop6();
                }
                function createRawShaderAccessor(key) {
                    return {
                        set: function set(value) {
                            this.shader = [ key, value ];
                        },
                        get: function get() {
                            return this.shader;
                        }
                    };
                }
                function shaderAccessor(key) {
                    return {
                        set: function set(value) {
                            var _this$lng$shader2;
                            var target = this.lng.shader || {};
                            var animationSettings;
                            if ((_this$lng$shader2 = this.lng.shader) !== null && _this$lng$shader2 !== void 0 && _this$lng$shader2.program) {
                                target = this.lng.shader.props;
                                var transitionKey = key === "rounded" ? "borderRadius" : key;
                                if (this.transition && (this.transition === true || this.transition[transitionKey])) {
                                    target = {};
                                    animationSettings = this.transition === true || this.transition[transitionKey] === true ? void 0 : this.transition[transitionKey];
                                }
                            }
                            if (key === "rounded" || typeof value === "number") {
                                target.radius = value;
                            } else {
                                parseAndAssignShaderProps(key, value, target);
                            }
                            if (this.rendered) {
                                if (!this.lng.shader) {
                                    this.lng.shader = convertToShader(this, target);
                                }
                            } else {
                                this.lng.shader = target;
                            }
                            if (animationSettings) {
                                this.animate({
                                    shaderProps: target
                                }, animationSettings).start();
                            }
                        },
                        get: function get() {
                            var _this$effects;
                            return (_this$effects = this.effects) === null || _this$effects === void 0 ? void 0 : _this$effects[key];
                        }
                    };
                }
                Object.defineProperties(ElementNode.prototype, {
                    border: shaderAccessor("border"),
                    shadow: shaderAccessor("shadow"),
                    rounded: shaderAccessor("rounded"),
                    borderRadius: shaderAccessor("rounded"),
                    linearGradient: createRawShaderAccessor("linearGradient"),
                    radialGradient: createRawShaderAccessor("radialGradient")
                });
                var Rounded = {
                    props: RoundedTemplate.props,
                    update: function update(node) {
                        this.uniform4fa("u_radius", calcFactoredRadiusArray$1(this.props.radius, node.w, node.h));
                    },
                    vertex: "\n  # ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  # else\n  precision mediump float;\n  # endif\n\n  attribute vec2 a_position;\n  attribute vec2 a_textureCoords;\n  attribute vec4 a_color;\n  attribute vec2 a_nodeCoords;\n\n  uniform vec2 u_resolution;\n  uniform float u_pixelRatio;\n  uniform vec2 u_dimensions;\n\n  varying vec4 v_color;\n  varying vec2 v_textureCoords;\n  varying vec2 v_nodeCoords;\n\n  void main() {\n    vec2 normalized = a_position * u_pixelRatio;\n    vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);\n\n    v_color = a_color;\n    v_nodeCoords = a_nodeCoords;\n    v_textureCoords = a_textureCoords;\n\n    gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);\n    gl_Position.y = -sign(screenSpace.y) * gl_Position.y;\n  }\n",
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    //renderer applies these uniforms automatically\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_pixelRatio;\n    uniform sampler2D u_texture;\n\n    //custom uniforms\n    uniform vec4 u_radius;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    float roundedBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      return (min(max(q.x, q.y), 0.0) + length(max(q, 0.0))) - r.x;\n    }\n\n    void main() {\n      vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n      vec2 halfDimensions = (u_dimensions * 0.5);\n\n      vec2 boxUv = v_nodeCoords.xy * u_dimensions - halfDimensions;\n      float boxDist = roundedBox(boxUv, halfDimensions, u_radius);\n\n      float edgeWidth = 1.0 / u_pixelRatio;\n      float roundedAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, boxDist);\n\n      vec4 resColor = vec4(0.0);\n      resColor = mix(resColor, color, roundedAlpha);\n      gl_FragColor = resColor * u_alpha;\n    }\n  "
                };
                var props$1 = Object.assign({}, RoundedTemplate.props, getBorderProps("border"), getShadowProps("shadow"));
                var RoundedWithBorderAndShadowTemplate = {
                    props: props$1
                };
                var RoundedWithBorderAndShadow = {
                    props: RoundedWithBorderAndShadowTemplate.props,
                    update: function update(node) {
                        var props = this.props;
                        this.uniformRGBA("u_borderColor", props["border-color"]);
                        this.uniform4fa("u_borderWidth", props["border-w"]);
                        this.uniformRGBA("u_shadowColor", props["shadow-color"]);
                        this.uniform4fa("u_shadow", props["shadow-projection"]);
                        this.uniform4fa("u_radius", calcFactoredRadiusArray$1(props.radius, node.w, node.h));
                    },
                    vertex: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_position;\n    attribute vec2 a_textureCoords;\n    attribute vec4 a_color;\n    attribute vec2 a_nodeCoords;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform float u_rtt;\n    uniform vec2 u_dimensions;\n\n    uniform vec4 u_shadow;\n    uniform vec4 u_radius;\n    uniform vec4 u_borderWidth;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    varying vec4 v_innerRadius;\n    varying vec2 v_innerSize;\n    varying vec2 v_halfDimensions;\n    varying float v_borderZero;\n\n    void main() {\n      vec2 screenSpace = vec2(2.0 / u_resolution.x,  -2.0 / u_resolution.y);\n      vec2 outerEdge = clamp(a_nodeCoords * 2.0 - vec2(1.0), -1.0, 1.0);\n\n      vec2 shadowEdge = outerEdge * ((u_shadow.w * 2.0)+ u_shadow.z) + u_shadow.xy;\n      vec2 normVertexPos = a_position * u_pixelRatio;\n\n      vec2 vertexPos = (a_position + outerEdge + shadowEdge) * u_pixelRatio;\n      gl_Position = vec4(vertexPos.x * screenSpace.x - 1.0, -sign(screenSpace.y) * (vertexPos.y * -abs(screenSpace.y)) + 1.0, 0.0, 1.0);\n\n      v_halfDimensions = u_dimensions * 0.5;\n\n      v_color = a_color;\n      v_nodeCoords = a_nodeCoords + (screenSpace + shadowEdge) / (u_dimensions);\n      v_textureCoords = a_textureCoords + (screenSpace + shadowEdge) / (u_dimensions);\n\n      v_borderZero = u_borderWidth == vec4(0.0) ? 1.0 : 0.0;\n\n\n      if(v_borderZero == 0.0) {\n        v_innerRadius = vec4(\n          max(0.0, u_radius.x - max(u_borderWidth.x, u_borderWidth.w) - 0.5),\n          max(0.0, u_radius.y - max(u_borderWidth.x, u_borderWidth.y) - 0.5),\n          max(0.0, u_radius.z - max(u_borderWidth.z, u_borderWidth.y) - 0.5),\n          max(0.0, u_radius.w - max(u_borderWidth.z, u_borderWidth.w) - 0.5)\n        );\n\n        v_innerSize = (vec2(u_dimensions.x - (u_borderWidth[3] + u_borderWidth[1]) - 1.0, u_dimensions.y - (u_borderWidth[0] + u_borderWidth[2])) - 2.0) * 0.5;\n      }\n    }\n  ",
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform float u_alpha;\n    uniform vec2 u_dimensions;\n    uniform sampler2D u_texture;\n    uniform float u_rtt;\n\n    uniform vec4 u_radius;\n    uniform vec4 u_borderWidth;\n    uniform vec4 u_borderColor;\n    uniform vec4 u_shadowColor;\n    uniform vec4 u_shadow;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    varying vec2 v_halfDimensions;\n    varying vec4 v_innerRadius;\n    varying vec2 v_innerSize;\n    varying float v_borderZero;\n\n    float roundedBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      return (min(max(q.x, q.y), 0.0) + length(max(q, 0.0))) - r.x;\n    }\n\n    float shadowBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      float dist = min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n      return 1.0 - smoothstep(-u_shadow.w, u_shadow.w + u_shadow.z, dist);\n    }\n\n    void main() {\n      vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n\n      vec2 boxUv = v_nodeCoords.xy * u_dimensions - v_halfDimensions;\n      float outerDist = roundedBox(boxUv, v_halfDimensions - 1.0, u_radius);\n\n      float edgeWidth = 1.0 / u_pixelRatio;\n      float outerAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, outerDist);\n\n      float shadowAlpha = shadowBox(boxUv - u_shadow.xy, v_halfDimensions + u_shadow.w, u_radius + u_shadow.z);\n      vec4 shadow = mix(vec4(0.0), u_shadowColor, shadowAlpha);\n\n      if(v_borderZero == 1.0) {\n        gl_FragColor = mix(shadow, color, outerAlpha) * u_alpha;\n        return;\n      }\n\n      boxUv.x += u_borderWidth.y > u_borderWidth.w ? (u_borderWidth.y - u_borderWidth.w) * 0.5 : -(u_borderWidth.w - u_borderWidth.y) * 0.5;\n      boxUv.y += u_borderWidth.z > u_borderWidth.x ? ((u_borderWidth.z - u_borderWidth.x) * 0.5 + 0.5) : -(u_borderWidth.x - u_borderWidth.z) * 0.5;\n\n      float innerDist = roundedBox(boxUv, v_innerSize, v_innerRadius);\n      float innerAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, innerDist);\n\n      vec4 resColor = mix(u_borderColor, color, innerAlpha);\n      resColor = mix(shadow, resColor, outerAlpha);\n      gl_FragColor = resColor * u_alpha;\n    }\n  "
                };
                var props = Object.assign({}, RoundedTemplate.props, getShadowProps("shadow"));
                var RoundedWithShadowTemplate = {
                    props: props
                };
                var Shadow = {
                    vertex: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_position;\n    attribute vec2 a_textureCoords;\n    attribute vec4 a_color;\n    attribute vec2 a_nodeCoords;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform float u_rtt;\n    uniform vec2 u_dimensions;\n\n    uniform vec4 u_shadow;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    void main() {\n      vec2 screenSpace = vec2(2.0 / u_resolution.x,  -2.0 / u_resolution.y);\n      vec2 outerEdge = clamp(a_nodeCoords * 2.0 - vec2(1.0), -1.0, 1.0);\n\n      vec2 shadowEdge = outerEdge * ((u_shadow.w * 2.0)+ u_shadow.z) + u_shadow.xy;\n      vec2 normVertexPos = a_position * u_pixelRatio;\n\n      vec2 vertexPos = (a_position + outerEdge + shadowEdge) * u_pixelRatio;\n      gl_Position = vec4(vertexPos.x * screenSpace.x - 1.0, -sign(screenSpace.y) * (vertexPos.y * -abs(screenSpace.y)) + 1.0, 0.0, 1.0);\n\n      v_color = a_color;\n      v_nodeCoords = a_nodeCoords + (screenSpace + shadowEdge) / (u_dimensions);\n      v_textureCoords = a_textureCoords + (screenSpace + shadowEdge) / (u_dimensions);\n    }\n  "
                };
                var RoundedWithShadow = {
                    props: RoundedWithShadowTemplate.props,
                    update: function update(node) {
                        this.uniformRGBA("u_shadow_color", this.props["shadow-color"]);
                        this.uniform4fa("u_shadow", this.props["shadow-projection"]);
                        this.uniform4fa("u_radius", calcFactoredRadiusArray$1(this.props.radius, node.w, node.h));
                    },
                    vertex: Shadow.vertex,
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform float u_alpha;\n    uniform vec2 u_dimensions;\n    uniform sampler2D u_texture;\n\n    uniform vec4 u_shadow_color;\n    uniform vec4 u_shadow;\n    uniform vec4 u_radius;\n\n    uniform int u_asymWidth;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    float roundedBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      return (min(max(q.x, q.y), 0.0) + length(max(q, 0.0))) - r.x;\n    }\n\n    float shadowBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      float dist = min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n      return 1.0 - smoothstep(-(u_shadow.w), (u_shadow.w + u_shadow.z), dist);\n    }\n\n    void main() {\n      vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n      vec2 halfDimensions = (u_dimensions * 0.5);\n\n      vec2 boxUv = v_nodeCoords.xy * u_dimensions - halfDimensions;\n      float boxDist = roundedBox(boxUv, halfDimensions, u_radius);\n\n      float edgeWidth = 1.0 / u_pixelRatio;\n      float roundedAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, boxDist);\n\n      float shadowAlpha = shadowBox(boxUv - u_shadow.xy, halfDimensions + u_shadow.w, u_radius + u_shadow.z);\n\n      vec4 resColor = vec4(0.0);\n      resColor = mix(resColor, u_shadow_color, shadowAlpha);\n      resColor = mix(resColor, color, min(color.a, roundedAlpha));\n      gl_FragColor = resColor * u_alpha;\n    }\n  "
                };
                var HolePunch = {
                    props: HolePunchTemplate.props,
                    update: function update() {
                        var props = this.props;
                        this.uniform2f("u_pos", props.x, props.y);
                        this.uniform2f("u_size", props.w * .5, props.h * .5);
                        this.uniform4fa("u_radius", calcFactoredRadiusArray$1(props.radius, props.w, props.h));
                    },
                    getCacheMarkers: function getCacheMarkers(props) {
                        return "radiusArray:".concat(Array.isArray(props.radius));
                    },
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    uniform float u_alpha;\n    uniform float u_pixelRatio;\n    uniform vec2 u_dimensions;\n    uniform sampler2D u_texture;\n\n    uniform vec2 u_size;\n    uniform vec2 u_pos;\n\n    uniform vec4 u_radius;\n\n    uniform vec4 u_color;\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n\n    void main() {\n      vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n      vec2 p = (v_textureCoords.xy * u_dimensions.xy - u_pos) - u_size;\n      vec4 r = u_radius;\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      p = abs(p) - u_size + r.x;\n      float dist = min(max(p.x, p.y), 0.0) + length(max(p, 0.0)) - r.x + 2.0;\n      float roundedAlpha = 1.0 - smoothstep(0.0, u_pixelRatio, dist);\n      gl_FragColor = mix(color, vec4(0.0), min(color.a, roundedAlpha));\n    }\n  "
                };
                var LinearGradient = {
                    props: LinearGradientTemplate.props,
                    update: function update() {
                        var props = this.props;
                        this.uniform1f("u_angle", props.angle - Math.PI / 180 * 90);
                        this.uniform1fv("u_stops", new Float32Array(props.stops));
                        var colors = [];
                        for (var i = 0; i < props.colors.length; i++) {
                            var norm = getNormalizedRgbaComponents(props.colors[i]);
                            colors.push(norm[0], norm[1], norm[2], norm[3]);
                        }
                        this.uniform4fv("u_colors", new Float32Array(colors));
                    },
                    getCacheMarkers: function getCacheMarkers(props) {
                        return "colors:".concat(props.colors.length);
                    },
                    fragment: function fragment(renderer, props) {
                        return "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n    #define MAX_STOPS ".concat(props.colors.length, "\n    #define LAST_STOP ").concat(props.colors.length - 1, "\n\n    uniform float u_alpha;\n    uniform vec2 u_dimensions;\n\n    uniform sampler2D u_texture;\n\n    uniform float u_angle;\n    uniform float u_stops[MAX_STOPS];\n    uniform vec4 u_colors[MAX_STOPS];\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n\n    vec2 calcPoint(float d, float angle) {\n      return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n    }\n\n    vec4 getGradientColor(float dist) {\n      dist = clamp(dist, 0.0, 1.0);\n\n      if(dist <= u_stops[0]) {\n        return u_colors[0];\n      }\n\n      if(dist >= u_stops[LAST_STOP]) {\n        return u_colors[LAST_STOP];\n      }\n\n      for(int i = 0; i < LAST_STOP; i++) {\n        float left = u_stops[i];\n        float right = u_stops[i + 1];\n        if(dist >= left && dist <= right) {\n          float lDist = smoothstep(left, right, dist);\n          return mix(u_colors[i], u_colors[i + 1], lDist);\n        }\n      }\n    }\n\n    void main() {\n      vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n      float a = u_angle;\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = calcPoint(lineDist * 0.5, a);\n      vec2 t = calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoords.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n      vec4 colorOut = getGradientColor(dist);\n      vec3 blendedRGB = mix(color.rgb, colorOut.rgb, clamp(colorOut.a, 0.0, 1.0));\n      gl_FragColor = vec4(blendedRGB, color.a);\n    }\n  ");
                    }
                };
                var RadialGradient = {
                    props: RadialGradientTemplate.props,
                    update: function update(node) {
                        var props = this.props;
                        this.uniform2f("u_projection", props.pivot[0] * node.w, props.pivot[1] * node.h);
                        this.uniform2f("u_size", props.w, props.h);
                        this.uniform1fv("u_stops", new Float32Array(props.stops));
                        var colors = [];
                        for (var i = 0; i < props.colors.length; i++) {
                            var norm = getNormalizedRgbaComponents(props.colors[i]);
                            colors.push(norm[0], norm[1], norm[2], norm[3]);
                        }
                        this.uniform4fv("u_colors", new Float32Array(colors));
                    },
                    getCacheMarkers: function getCacheMarkers(props) {
                        return "colors:".concat(props.colors.length);
                    },
                    fragment: function fragment(renderer, props) {
                        return "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      #define MAX_STOPS ".concat(props.colors.length, "\n      #define LAST_STOP ").concat(props.colors.length - 1, "\n\n      uniform float u_alpha;\n      uniform vec2 u_dimensions;\n\n      uniform sampler2D u_texture;\n\n      uniform vec2 u_projection;\n      uniform vec2 u_size;\n\n      uniform float u_stops[MAX_STOPS];\n      uniform vec4 u_colors[MAX_STOPS];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoords;\n      varying vec2 v_nodeCoords;\n\n      vec4 getGradientColor(float dist) {\n        dist = clamp(dist, 0.0, 1.0);\n\n        if(dist <= u_stops[0]) {\n          return u_colors[0];\n        }\n\n        if(dist >= u_stops[LAST_STOP]) {\n          return u_colors[LAST_STOP];\n        }\n\n        for(int i = 0; i < LAST_STOP; i++) {\n          float left = u_stops[i];\n          float right = u_stops[i + 1];\n          if(dist >= left && dist <= right) {\n            float lDist = smoothstep(left, right, dist);\n            return mix(u_colors[i], u_colors[i + 1], lDist);\n          }\n        }\n\n        return u_colors[LAST_STOP];\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoords) * v_color;\n        vec2 point = v_nodeCoords.xy * u_dimensions;\n        float dist = length((point - u_projection) / u_size);\n\n        vec4 colorOut = getGradientColor(dist);\n        vec3 blendedRGB = mix(color.rgb, colorOut.rgb, clamp(colorOut.a, 0.0, 1.0));\n        gl_FragColor = vec4(blendedRGB, color.a);\n      }\n    ");
                    }
                };
                var sharedConfig = {
                    context: undefined,
                    registry: undefined,
                    effects: undefined,
                    done: false,
                    getContextId: function getContextId() {
                        return _getContextId(this.context.count);
                    },
                    getNextContextId: function getNextContextId() {
                        return _getContextId(this.context.count++);
                    }
                };
                function _getContextId(count) {
                    var num = String(count), len = num.length - 1;
                    return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
                }
                function setHydrateContext(context) {
                    sharedConfig.context = context;
                }
                var IS_DEV = false;
                var equalFn = function equalFn(a, b) {
                    return a === b;
                };
                var $PROXY = Symbol("solid-proxy");
                var SUPPORTS_PROXY$1 = typeof Proxy === "function";
                var $TRACK = Symbol("solid-track");
                var signalOptions = {
                    equals: equalFn
                };
                var runEffects = runQueue;
                var STALE = 1;
                var PENDING = 2;
                var UNOWNED = {
                    owned: null,
                    cleanups: null,
                    context: null,
                    owner: null
                };
                var NO_INIT = {};
                var Owner = null;
                var Transition = null;
                var ExternalSourceConfig = null;
                var Listener = null;
                var Updates = null;
                var Effects = null;
                var ExecCount = 0;
                function createRoot(fn, detachedOwner) {
                    var listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === undefined ? owner : detachedOwner, root = unowned ? UNOWNED : {
                        owned: null,
                        cleanups: null,
                        context: current ? current.context : null,
                        owner: current
                    }, updateFn = unowned ? fn : function() {
                        return fn(function() {
                            return untrack(function() {
                                return cleanNode(root);
                            });
                        });
                    };
                    Owner = root;
                    Listener = null;
                    try {
                        return runUpdates(updateFn, true);
                    } finally {
                        Listener = listener;
                        Owner = owner;
                    }
                }
                function createSignal(value, options) {
                    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
                    var s = {
                        value: value,
                        observers: null,
                        observerSlots: null,
                        comparator: options.equals || undefined
                    };
                    var setter = function setter(value) {
                        if (typeof value === "function") {
                            if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue); else value = value(s.value);
                        }
                        return writeSignal(s, value);
                    };
                    return [ readSignal.bind(s), setter ];
                }
                function createComputed(fn, value, options) {
                    var c = createComputation(fn, value, true, STALE);
                    updateComputation(c);
                }
                function createRenderEffect(fn, value, options) {
                    var c = createComputation(fn, value, false, STALE);
                    updateComputation(c);
                }
                function createEffect(fn, value, options) {
                    runEffects = runUserEffects;
                    var c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
                    if (s) c.suspense = s;
                    c.user = true;
                    Effects ? Effects.push(c) : updateComputation(c);
                }
                function createMemo(fn, value, options) {
                    options = options ? Object.assign({}, signalOptions, options) : signalOptions;
                    var c = createComputation(fn, value, true, 0);
                    c.observers = null;
                    c.observerSlots = null;
                    c.comparator = options.equals || undefined;
                    updateComputation(c);
                    return readSignal.bind(c);
                }
                function isPromise(v) {
                    return v && _typeof(v) === "object" && "then" in v;
                }
                function createResource(pSource, pFetcher, pOptions) {
                    var source;
                    var fetcher;
                    var options;
                    if (typeof pFetcher === "function") {
                        source = pSource;
                        fetcher = pFetcher;
                        options = {};
                    } else {
                        source = true;
                        fetcher = pSource;
                        options = pFetcher || {};
                    }
                    var pr = null, initP = NO_INIT, id = null, loadedUnderTransition = false, scheduled = false, resolved = "initialValue" in options, dynamic = typeof source === "function" && createMemo(source);
                    var contexts = new Set, _ref45 = (options.storage || createSignal)(options.initialValue), _ref46 = _slicedToArray(_ref45, 2), value = _ref46[0], setValue = _ref46[1], _createSignal = createSignal(undefined), _createSignal2 = _slicedToArray(_createSignal, 2), error = _createSignal2[0], setError = _createSignal2[1], _createSignal3 = createSignal(undefined, {
                        equals: false
                    }), _createSignal4 = _slicedToArray(_createSignal3, 2), track = _createSignal4[0], trigger = _createSignal4[1], _createSignal5 = createSignal(resolved ? "ready" : "unresolved"), _createSignal6 = _slicedToArray(_createSignal5, 2), state = _createSignal6[0], setState = _createSignal6[1];
                    if (sharedConfig.context) {
                        id = sharedConfig.getNextContextId();
                        if (options.ssrLoadFrom === "initial") initP = options.initialValue; else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
                    }
                    function loadEnd(p, v, error, key) {
                        if (pr === p) {
                            pr = null;
                            key !== undefined && (resolved = true);
                            if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(function() {
                                return options.onHydrated(key, {
                                    value: v
                                });
                            });
                            initP = NO_INIT;
                            if (Transition && p && loadedUnderTransition) {
                                Transition.promises.delete(p);
                                loadedUnderTransition = false;
                                runUpdates(function() {
                                    Transition.running = true;
                                    completeLoad(v, error);
                                }, false);
                            } else completeLoad(v, error);
                        }
                        return v;
                    }
                    function completeLoad(v, err) {
                        runUpdates(function() {
                            if (err === undefined) setValue(function() {
                                return v;
                            });
                            setState(err !== undefined ? "errored" : resolved ? "ready" : "unresolved");
                            setError(err);
                            var _iterator23 = _createForOfIteratorHelper(contexts.keys()), _step23;
                            try {
                                for (_iterator23.s(); !(_step23 = _iterator23.n()).done; ) {
                                    var c = _step23.value;
                                    c.decrement();
                                }
                            } catch (err) {
                                _iterator23.e(err);
                            } finally {
                                _iterator23.f();
                            }
                            contexts.clear();
                        }, false);
                    }
                    function read() {
                        var c = SuspenseContext && useContext(SuspenseContext), v = value(), err = error();
                        if (err !== undefined && !pr) throw err;
                        if (Listener && !Listener.user && c) {
                            createComputed(function() {
                                track();
                                if (pr) {
                                    if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr); else if (!contexts.has(c)) {
                                        c.increment();
                                        contexts.add(c);
                                    }
                                }
                            });
                        }
                        return v;
                    }
                    function load() {
                        var refetching = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                        if (refetching !== false && scheduled) return;
                        scheduled = false;
                        var lookup = dynamic ? dynamic() : source;
                        loadedUnderTransition = Transition && Transition.running;
                        if (lookup == null || lookup === false) {
                            loadEnd(pr, untrack(value));
                            return;
                        }
                        if (Transition && pr) Transition.promises.delete(pr);
                        var error;
                        var p = initP !== NO_INIT ? initP : untrack(function() {
                            try {
                                return fetcher(lookup, {
                                    value: value(),
                                    refetching: refetching
                                });
                            } catch (fetcherError) {
                                error = fetcherError;
                            }
                        });
                        if (error !== undefined) {
                            loadEnd(pr, undefined, castError(error), lookup);
                            return;
                        } else if (!isPromise(p)) {
                            loadEnd(pr, p, undefined, lookup);
                            return p;
                        }
                        pr = p;
                        if ("v" in p) {
                            if (p.s === 1) loadEnd(pr, p.v, undefined, lookup); else loadEnd(pr, undefined, castError(p.v), lookup);
                            return p;
                        }
                        scheduled = true;
                        queueMicrotask(function() {
                            return scheduled = false;
                        });
                        runUpdates(function() {
                            setState(resolved ? "refreshing" : "pending");
                            trigger();
                        }, false);
                        return p.then(function(v) {
                            return loadEnd(p, v, undefined, lookup);
                        }, function(e) {
                            return loadEnd(p, undefined, castError(e), lookup);
                        });
                    }
                    Object.defineProperties(read, {
                        state: {
                            get: function get() {
                                return state();
                            }
                        },
                        error: {
                            get: function get() {
                                return error();
                            }
                        },
                        loading: {
                            get: function get() {
                                var s = state();
                                return s === "pending" || s === "refreshing";
                            }
                        },
                        latest: {
                            get: function get() {
                                if (!resolved) return read();
                                var err = error();
                                if (err && !pr) throw err;
                                return value();
                            }
                        }
                    });
                    var owner = Owner;
                    if (dynamic) createComputed(function() {
                        return owner = Owner, load(false);
                    }); else load(false);
                    return [ read, {
                        refetch: function refetch(info) {
                            return runWithOwner(owner, function() {
                                return load(info);
                            });
                        },
                        mutate: setValue
                    } ];
                }
                function createSelector(source) {
                    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : equalFn;
                    var options = arguments.length > 2 ? arguments[2] : undefined;
                    var subs = new Map;
                    var node = createComputation(function(p) {
                        var v = source();
                        var _iterator24 = _createForOfIteratorHelper(subs.entries()), _step24;
                        try {
                            for (_iterator24.s(); !(_step24 = _iterator24.n()).done; ) {
                                var _step24$value = _slicedToArray(_step24.value, 2), key = _step24$value[0], val = _step24$value[1];
                                if (fn(key, v) !== fn(key, p)) {
                                    var _iterator25 = _createForOfIteratorHelper(val.values()), _step25;
                                    try {
                                        for (_iterator25.s(); !(_step25 = _iterator25.n()).done; ) {
                                            var c = _step25.value;
                                            c.state = STALE;
                                            if (c.pure) Updates.push(c); else Effects.push(c);
                                        }
                                    } catch (err) {
                                        _iterator25.e(err);
                                    } finally {
                                        _iterator25.f();
                                    }
                                }
                            }
                        } catch (err) {
                            _iterator24.e(err);
                        } finally {
                            _iterator24.f();
                        }
                        return v;
                    }, undefined, true, STALE);
                    updateComputation(node);
                    return function(key) {
                        var listener = Listener;
                        if (listener) {
                            var l;
                            if (l = subs.get(key)) l.add(listener); else subs.set(key, l = new Set([ listener ]));
                            onCleanup(function() {
                                l.delete(listener);
                                !l.size && subs.delete(key);
                            });
                        }
                        return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
                    };
                }
                function batch(fn) {
                    return runUpdates(fn, false);
                }
                function untrack(fn) {
                    if (Listener === null) return fn();
                    var listener = Listener;
                    Listener = null;
                    try {
                        if (ExternalSourceConfig) ;
                        return fn();
                    } finally {
                        Listener = listener;
                    }
                }
                function on(deps, fn, options) {
                    var isArray = Array.isArray(deps);
                    var prevInput;
                    var defer = options && options.defer;
                    return function(prevValue) {
                        var input;
                        if (isArray) {
                            input = Array(deps.length);
                            for (var i = 0; i < deps.length; i++) input[i] = deps[i]();
                        } else input = deps();
                        if (defer) {
                            defer = false;
                            return prevValue;
                        }
                        var result = untrack(function() {
                            return fn(input, prevInput, prevValue);
                        });
                        prevInput = input;
                        return result;
                    };
                }
                function onMount(fn) {
                    createEffect(function() {
                        return untrack(fn);
                    });
                }
                function onCleanup(fn) {
                    if (Owner === null) ; else if (Owner.cleanups === null) Owner.cleanups = [ fn ]; else Owner.cleanups.push(fn);
                    return fn;
                }
                function getListener() {
                    return Listener;
                }
                function getOwner() {
                    return Owner;
                }
                function runWithOwner(o, fn) {
                    var prev = Owner;
                    var prevListener = Listener;
                    Owner = o;
                    Listener = null;
                    try {
                        return runUpdates(fn, true);
                    } catch (err) {
                        handleError(err);
                    } finally {
                        Owner = prev;
                        Listener = prevListener;
                    }
                }
                function startTransition(fn) {
                    if (Transition && Transition.running) {
                        fn();
                        return Transition.done;
                    }
                    var l = Listener;
                    var o = Owner;
                    return Promise.resolve().then(function() {
                        Listener = l;
                        Owner = o;
                        var t;
                        if (SuspenseContext) {
                            t = Transition || (Transition = {
                                sources: new Set,
                                effects: [],
                                promises: new Set,
                                disposed: new Set,
                                queue: new Set,
                                running: true
                            });
                            t.done || (t.done = new Promise(function(res) {
                                return t.resolve = res;
                            }));
                            t.running = true;
                        }
                        runUpdates(fn, false);
                        Listener = Owner = null;
                        return t ? t.done : undefined;
                    });
                }
                var _createSignal7 = createSignal(false), _createSignal8 = _slicedToArray(_createSignal7, 2), transPending = _createSignal8[0], setTransPending = _createSignal8[1];
                function resumeEffects(e) {
                    Effects.push.apply(Effects, e);
                    e.length = 0;
                }
                function createContext(defaultValue, options) {
                    var id = Symbol("context");
                    return {
                        id: id,
                        Provider: createProvider(id),
                        defaultValue: defaultValue
                    };
                }
                function useContext(context) {
                    var value;
                    return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined ? value : context.defaultValue;
                }
                function children(fn) {
                    var children = createMemo(fn);
                    var memo = createMemo(function() {
                        return resolveChildren(children());
                    });
                    memo.toArray = function() {
                        var c = memo();
                        return Array.isArray(c) ? c : c != null ? [ c ] : [];
                    };
                    return memo;
                }
                var SuspenseContext;
                function getSuspenseContext() {
                    return SuspenseContext || (SuspenseContext = createContext());
                }
                function readSignal() {
                    var _this37 = this;
                    var runningTransition = Transition && Transition.running;
                    if (this.sources && (runningTransition ? this.tState : this.state)) {
                        if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this); else {
                            var updates = Updates;
                            Updates = null;
                            runUpdates(function() {
                                return lookUpstream(_this37);
                            }, false);
                            Updates = updates;
                        }
                    }
                    if (Listener) {
                        var sSlot = this.observers ? this.observers.length : 0;
                        if (!Listener.sources) {
                            Listener.sources = [ this ];
                            Listener.sourceSlots = [ sSlot ];
                        } else {
                            Listener.sources.push(this);
                            Listener.sourceSlots.push(sSlot);
                        }
                        if (!this.observers) {
                            this.observers = [ Listener ];
                            this.observerSlots = [ Listener.sources.length - 1 ];
                        } else {
                            this.observers.push(Listener);
                            this.observerSlots.push(Listener.sources.length - 1);
                        }
                    }
                    if (runningTransition && Transition.sources.has(this)) return this.tValue;
                    return this.value;
                }
                function writeSignal(node, value, isComp) {
                    var current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
                    if (!node.comparator || !node.comparator(current, value)) {
                        if (Transition) {
                            var TransitionRunning = Transition.running;
                            if (TransitionRunning || !isComp && Transition.sources.has(node)) {
                                Transition.sources.add(node);
                                node.tValue = value;
                            }
                            if (!TransitionRunning) node.value = value;
                        } else node.value = value;
                        if (node.observers && node.observers.length) {
                            runUpdates(function() {
                                for (var i = 0; i < node.observers.length; i += 1) {
                                    var o = node.observers[i];
                                    var _TransitionRunning = Transition && Transition.running;
                                    if (_TransitionRunning && Transition.disposed.has(o)) continue;
                                    if (_TransitionRunning ? !o.tState : !o.state) {
                                        if (o.pure) Updates.push(o); else Effects.push(o);
                                        if (o.observers) markDownstream(o);
                                    }
                                    if (!_TransitionRunning) o.state = STALE; else o.tState = STALE;
                                }
                                if (Updates.length > 1e6) {
                                    Updates = [];
                                    if (IS_DEV) ;
                                    throw new Error;
                                }
                            }, false);
                        }
                    }
                    return value;
                }
                function updateComputation(node) {
                    if (!node.fn) return;
                    cleanNode(node);
                    var time = ExecCount;
                    runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
                    if (Transition && !Transition.running && Transition.sources.has(node)) {
                        queueMicrotask(function() {
                            runUpdates(function() {
                                Transition && (Transition.running = true);
                                Listener = Owner = node;
                                runComputation(node, node.tValue, time);
                                Listener = Owner = null;
                            }, false);
                        });
                    }
                }
                function runComputation(node, value, time) {
                    var nextValue;
                    var owner = Owner, listener = Listener;
                    Listener = Owner = node;
                    try {
                        nextValue = node.fn(value);
                    } catch (err) {
                        if (node.pure) {
                            if (Transition && Transition.running) {
                                node.tState = STALE;
                                node.tOwned && node.tOwned.forEach(cleanNode);
                                node.tOwned = undefined;
                            } else {
                                node.state = STALE;
                                node.owned && node.owned.forEach(cleanNode);
                                node.owned = null;
                            }
                        }
                        node.updatedAt = time + 1;
                        return handleError(err);
                    } finally {
                        Listener = listener;
                        Owner = owner;
                    }
                    if (!node.updatedAt || node.updatedAt <= time) {
                        if (node.updatedAt != null && "observers" in node) {
                            writeSignal(node, nextValue, true);
                        } else if (Transition && Transition.running && node.pure) {
                            Transition.sources.add(node);
                            node.tValue = nextValue;
                        } else node.value = nextValue;
                        node.updatedAt = time;
                    }
                }
                function createComputation(fn, init, pure) {
                    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STALE;
                    var options = arguments.length > 4 ? arguments[4] : undefined;
                    var c = {
                        fn: fn,
                        state: state,
                        updatedAt: null,
                        owned: null,
                        sources: null,
                        sourceSlots: null,
                        cleanups: null,
                        value: init,
                        owner: Owner,
                        context: Owner ? Owner.context : null,
                        pure: pure
                    };
                    if (Transition && Transition.running) {
                        c.state = 0;
                        c.tState = state;
                    }
                    if (Owner === null) ; else if (Owner !== UNOWNED) {
                        if (Transition && Transition.running && Owner.pure) {
                            if (!Owner.tOwned) Owner.tOwned = [ c ]; else Owner.tOwned.push(c);
                        } else {
                            if (!Owner.owned) Owner.owned = [ c ]; else Owner.owned.push(c);
                        }
                    }
                    return c;
                }
                function runTop(node) {
                    var runningTransition = Transition && Transition.running;
                    if ((runningTransition ? node.tState : node.state) === 0) return;
                    if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
                    if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
                    var ancestors = [ node ];
                    while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
                        if (runningTransition && Transition.disposed.has(node)) return;
                        if (runningTransition ? node.tState : node.state) ancestors.push(node);
                    }
                    for (var i = ancestors.length - 1; i >= 0; i--) {
                        node = ancestors[i];
                        if (runningTransition) {
                            var top = node, prev = ancestors[i + 1];
                            while ((top = top.owner) && top !== prev) {
                                if (Transition.disposed.has(top)) return;
                            }
                        }
                        if ((runningTransition ? node.tState : node.state) === STALE) {
                            updateComputation(node);
                        } else if ((runningTransition ? node.tState : node.state) === PENDING) {
                            var updates = Updates;
                            Updates = null;
                            runUpdates(function() {
                                return lookUpstream(node, ancestors[0]);
                            }, false);
                            Updates = updates;
                        }
                    }
                }
                function runUpdates(fn, init) {
                    if (Updates) return fn();
                    var wait = false;
                    if (!init) Updates = [];
                    if (Effects) wait = true; else Effects = [];
                    ExecCount++;
                    try {
                        var res = fn();
                        completeUpdates(wait);
                        return res;
                    } catch (err) {
                        if (!wait) Effects = null;
                        Updates = null;
                        handleError(err);
                    }
                }
                function completeUpdates(wait) {
                    if (Updates) {
                        runQueue(Updates);
                        Updates = null;
                    }
                    if (wait) return;
                    var res;
                    if (Transition) {
                        if (!Transition.promises.size && !Transition.queue.size) {
                            var sources = Transition.sources;
                            var disposed = Transition.disposed;
                            Effects.push.apply(Effects, Transition.effects);
                            res = Transition.resolve;
                            var _iterator26 = _createForOfIteratorHelper(Effects), _step26;
                            try {
                                for (_iterator26.s(); !(_step26 = _iterator26.n()).done; ) {
                                    var _e = _step26.value;
                                    "tState" in _e && (_e.state = _e.tState);
                                    delete _e.tState;
                                }
                            } catch (err) {
                                _iterator26.e(err);
                            } finally {
                                _iterator26.f();
                            }
                            Transition = null;
                            runUpdates(function() {
                                var _iterator27 = _createForOfIteratorHelper(disposed), _step27;
                                try {
                                    for (_iterator27.s(); !(_step27 = _iterator27.n()).done; ) {
                                        var d = _step27.value;
                                        cleanNode(d);
                                    }
                                } catch (err) {
                                    _iterator27.e(err);
                                } finally {
                                    _iterator27.f();
                                }
                                var _iterator28 = _createForOfIteratorHelper(sources), _step28;
                                try {
                                    for (_iterator28.s(); !(_step28 = _iterator28.n()).done; ) {
                                        var v = _step28.value;
                                        v.value = v.tValue;
                                        if (v.owned) {
                                            for (var i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
                                        }
                                        if (v.tOwned) v.owned = v.tOwned;
                                        delete v.tValue;
                                        delete v.tOwned;
                                        v.tState = 0;
                                    }
                                } catch (err) {
                                    _iterator28.e(err);
                                } finally {
                                    _iterator28.f();
                                }
                                setTransPending(false);
                            }, false);
                        } else if (Transition.running) {
                            Transition.running = false;
                            Transition.effects.push.apply(Transition.effects, Effects);
                            Effects = null;
                            setTransPending(true);
                            return;
                        }
                    }
                    var e = Effects;
                    Effects = null;
                    if (e.length) runUpdates(function() {
                        return runEffects(e);
                    }, false);
                    if (res) res();
                }
                function runQueue(queue) {
                    for (var i = 0; i < queue.length; i++) runTop(queue[i]);
                }
                function runUserEffects(queue) {
                    var i, userLength = 0;
                    for (i = 0; i < queue.length; i++) {
                        var e = queue[i];
                        if (!e.user) runTop(e); else queue[userLength++] = e;
                    }
                    if (sharedConfig.context) {
                        if (sharedConfig.count) {
                            var _sharedConfig$effects;
                            sharedConfig.effects || (sharedConfig.effects = []);
                            (_sharedConfig$effects = sharedConfig.effects).push.apply(_sharedConfig$effects, _toConsumableArray(queue.slice(0, userLength)));
                            return;
                        }
                        setHydrateContext();
                    }
                    if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
                        queue = [].concat(_toConsumableArray(sharedConfig.effects), _toConsumableArray(queue));
                        userLength += sharedConfig.effects.length;
                        delete sharedConfig.effects;
                    }
                    for (i = 0; i < userLength; i++) runTop(queue[i]);
                }
                function lookUpstream(node, ignore) {
                    var runningTransition = Transition && Transition.running;
                    if (runningTransition) node.tState = 0; else node.state = 0;
                    for (var i = 0; i < node.sources.length; i += 1) {
                        var source = node.sources[i];
                        if (source.sources) {
                            var state = runningTransition ? source.tState : source.state;
                            if (state === STALE) {
                                if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
                            } else if (state === PENDING) lookUpstream(source, ignore);
                        }
                    }
                }
                function markDownstream(node) {
                    var runningTransition = Transition && Transition.running;
                    for (var i = 0; i < node.observers.length; i += 1) {
                        var o = node.observers[i];
                        if (runningTransition ? !o.tState : !o.state) {
                            if (runningTransition) o.tState = PENDING; else o.state = PENDING;
                            if (o.pure) Updates.push(o); else Effects.push(o);
                            o.observers && markDownstream(o);
                        }
                    }
                }
                function cleanNode(node) {
                    var i;
                    if (node.sources) {
                        while (node.sources.length) {
                            var source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
                            if (obs && obs.length) {
                                var n = obs.pop(), s = source.observerSlots.pop();
                                if (index < obs.length) {
                                    n.sourceSlots[s] = index;
                                    obs[index] = n;
                                    source.observerSlots[index] = s;
                                }
                            }
                        }
                    }
                    if (node.tOwned) {
                        for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
                        delete node.tOwned;
                    }
                    if (Transition && Transition.running && node.pure) {
                        reset(node, true);
                    } else if (node.owned) {
                        for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
                        node.owned = null;
                    }
                    if (node.cleanups) {
                        for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
                        node.cleanups = null;
                    }
                    if (Transition && Transition.running) node.tState = 0; else node.state = 0;
                }
                function reset(node, top) {
                    if (!top) {
                        node.tState = 0;
                        Transition.disposed.add(node);
                    }
                    if (node.owned) {
                        for (var i = 0; i < node.owned.length; i++) reset(node.owned[i]);
                    }
                }
                function castError(err) {
                    if (err instanceof Error) return err;
                    return new Error(typeof err === "string" ? err : "Unknown error", {
                        cause: err
                    });
                }
                function handleError(err) {
                    var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Owner;
                    var error = castError(err);
                    throw error;
                }
                function resolveChildren(children) {
                    if (typeof children === "function" && !children.length) return resolveChildren(children());
                    if (Array.isArray(children)) {
                        var results = [];
                        for (var i = 0; i < children.length; i++) {
                            var result = resolveChildren(children[i]);
                            Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
                        }
                        return results;
                    }
                    return children;
                }
                function createProvider(id, options) {
                    return function provider(props) {
                        var res;
                        createRenderEffect(function() {
                            return res = untrack(function() {
                                Owner.context = _objectSpread(_objectSpread({}, Owner.context), {}, _defineProperty({}, id, props.value));
                                return children(function() {
                                    return props.children;
                                });
                            });
                        }, undefined);
                        return res;
                    };
                }
                var FALLBACK = Symbol("fallback");
                function dispose(d) {
                    for (var i = 0; i < d.length; i++) d[i]();
                }
                function mapArray(list, mapFn) {
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
                    onCleanup(function() {
                        return dispose(disposers);
                    });
                    return function() {
                        var newItems = list() || [], newLen = newItems.length, i, j;
                        newItems[$TRACK];
                        return untrack(function() {
                            var newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
                            if (newLen === 0) {
                                if (len !== 0) {
                                    dispose(disposers);
                                    disposers = [];
                                    items = [];
                                    mapped = [];
                                    len = 0;
                                    indexes && (indexes = []);
                                }
                                if (options.fallback) {
                                    items = [ FALLBACK ];
                                    mapped[0] = createRoot(function(disposer) {
                                        disposers[0] = disposer;
                                        return options.fallback();
                                    });
                                    len = 1;
                                }
                            } else if (len === 0) {
                                mapped = new Array(newLen);
                                for (j = 0; j < newLen; j++) {
                                    items[j] = newItems[j];
                                    mapped[j] = createRoot(mapper);
                                }
                                len = newLen;
                            } else {
                                temp = new Array(newLen);
                                tempdisposers = new Array(newLen);
                                indexes && (tempIndexes = new Array(newLen));
                                for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
                                for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, 
                                newEnd--) {
                                    temp[newEnd] = mapped[end];
                                    tempdisposers[newEnd] = disposers[end];
                                    indexes && (tempIndexes[newEnd] = indexes[end]);
                                }
                                newIndices = new Map;
                                newIndicesNext = new Array(newEnd + 1);
                                for (j = newEnd; j >= start; j--) {
                                    item = newItems[j];
                                    i = newIndices.get(item);
                                    newIndicesNext[j] = i === undefined ? -1 : i;
                                    newIndices.set(item, j);
                                }
                                for (i = start; i <= end; i++) {
                                    item = items[i];
                                    j = newIndices.get(item);
                                    if (j !== undefined && j !== -1) {
                                        temp[j] = mapped[i];
                                        tempdisposers[j] = disposers[i];
                                        indexes && (tempIndexes[j] = indexes[i]);
                                        j = newIndicesNext[j];
                                        newIndices.set(item, j);
                                    } else disposers[i]();
                                }
                                for (j = start; j < newLen; j++) {
                                    if (j in temp) {
                                        mapped[j] = temp[j];
                                        disposers[j] = tempdisposers[j];
                                        if (indexes) {
                                            indexes[j] = tempIndexes[j];
                                            indexes[j](j);
                                        }
                                    } else mapped[j] = createRoot(mapper);
                                }
                                mapped = mapped.slice(0, len = newLen);
                                items = newItems.slice(0);
                            }
                            return mapped;
                        });
                        function mapper(disposer) {
                            disposers[j] = disposer;
                            if (indexes) {
                                var _createSignal9 = createSignal(j), _createSignal0 = _slicedToArray(_createSignal9, 2), s = _createSignal0[0], set = _createSignal0[1];
                                indexes[j] = set;
                                return mapFn(newItems[j], s);
                            }
                            return mapFn(newItems[j]);
                        }
                    };
                }
                function indexArray(list, mapFn) {
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var items = [], mapped = [], disposers = [], signals = [], len = 0, i;
                    onCleanup(function() {
                        return dispose(disposers);
                    });
                    return function() {
                        var newItems = list() || [], newLen = newItems.length;
                        newItems[$TRACK];
                        return untrack(function() {
                            if (newLen === 0) {
                                if (len !== 0) {
                                    dispose(disposers);
                                    disposers = [];
                                    items = [];
                                    mapped = [];
                                    len = 0;
                                    signals = [];
                                }
                                if (options.fallback) {
                                    items = [ FALLBACK ];
                                    mapped[0] = createRoot(function(disposer) {
                                        disposers[0] = disposer;
                                        return options.fallback();
                                    });
                                    len = 1;
                                }
                                return mapped;
                            }
                            if (items[0] === FALLBACK) {
                                disposers[0]();
                                disposers = [];
                                items = [];
                                mapped = [];
                                len = 0;
                            }
                            for (i = 0; i < newLen; i++) {
                                if (i < items.length && items[i] !== newItems[i]) {
                                    signals[i](function() {
                                        return newItems[i];
                                    });
                                } else if (i >= items.length) {
                                    mapped[i] = createRoot(mapper);
                                }
                            }
                            for (;i < items.length; i++) {
                                disposers[i]();
                            }
                            len = signals.length = disposers.length = newLen;
                            items = newItems.slice(0);
                            return mapped = mapped.slice(0, len);
                        });
                        function mapper(disposer) {
                            disposers[i] = disposer;
                            var _createSignal1 = createSignal(newItems[i]), _createSignal10 = _slicedToArray(_createSignal1, 2), s = _createSignal10[0], set = _createSignal10[1];
                            signals[i] = set;
                            return mapFn(s, i);
                        }
                    };
                }
                function createComponent$1(Comp, props) {
                    return untrack(function() {
                        return Comp(props || {});
                    });
                }
                function trueFn() {
                    return true;
                }
                var propTraps = {
                    get: function get(_, property, receiver) {
                        if (property === $PROXY) return receiver;
                        return _.get(property);
                    },
                    has: function has(_, property) {
                        if (property === $PROXY) return true;
                        return _.has(property);
                    },
                    set: trueFn,
                    deleteProperty: trueFn,
                    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_, property) {
                        return {
                            configurable: true,
                            enumerable: true,
                            get: function get() {
                                return _.get(property);
                            },
                            set: trueFn,
                            deleteProperty: trueFn
                        };
                    },
                    ownKeys: function ownKeys(_) {
                        return _.keys();
                    }
                };
                function resolveSource(s) {
                    return !(s = typeof s === "function" ? s() : s) ? {} : s;
                }
                function resolveSources() {
                    for (var i = 0, length = this.length; i < length; ++i) {
                        var v = this[i]();
                        if (v !== undefined) return v;
                    }
                }
                function mergeProps$1() {
                    for (var _len3 = arguments.length, sources = new Array(_len3), _key9 = 0; _key9 < _len3; _key9++) {
                        sources[_key9] = arguments[_key9];
                    }
                    var proxy = false;
                    for (var i = 0; i < sources.length; i++) {
                        var s = sources[i];
                        proxy = proxy || !!s && $PROXY in s;
                        sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
                    }
                    if (SUPPORTS_PROXY$1 && proxy) {
                        return new Proxy({
                            get: function get(property) {
                                for (var _i10 = sources.length - 1; _i10 >= 0; _i10--) {
                                    var v = resolveSource(sources[_i10])[property];
                                    if (v !== undefined) return v;
                                }
                            },
                            has: function has(property) {
                                for (var _i11 = sources.length - 1; _i11 >= 0; _i11--) {
                                    if (property in resolveSource(sources[_i11])) return true;
                                }
                                return false;
                            },
                            keys: function keys() {
                                var keys = [];
                                for (var _i12 = 0; _i12 < sources.length; _i12++) keys.push.apply(keys, _toConsumableArray(Object.keys(resolveSource(sources[_i12]))));
                                return _toConsumableArray(new Set(keys));
                            }
                        }, propTraps);
                    }
                    var sourcesMap = {};
                    var defined = Object.create(null);
                    for (var _i13 = sources.length - 1; _i13 >= 0; _i13--) {
                        var source = sources[_i13];
                        if (!source) continue;
                        var sourceKeys = Object.getOwnPropertyNames(source);
                        var _loop7 = function _loop7() {
                            var key = sourceKeys[_i14];
                            if (key === "__proto__" || key === "constructor") return 1;
                            var desc = Object.getOwnPropertyDescriptor(source, key);
                            if (!defined[key]) {
                                defined[key] = desc.get ? {
                                    enumerable: true,
                                    configurable: true,
                                    get: resolveSources.bind(sourcesMap[key] = [ desc.get.bind(source) ])
                                } : desc.value !== undefined ? desc : undefined;
                            } else {
                                var _sources = sourcesMap[key];
                                if (_sources) {
                                    if (desc.get) _sources.push(desc.get.bind(source)); else if (desc.value !== undefined) _sources.push(function() {
                                        return desc.value;
                                    });
                                }
                            }
                        };
                        for (var _i14 = sourceKeys.length - 1; _i14 >= 0; _i14--) {
                            if (_loop7()) continue;
                        }
                    }
                    var target = {};
                    var definedKeys = Object.keys(defined);
                    for (var _i15 = definedKeys.length - 1; _i15 >= 0; _i15--) {
                        var key = definedKeys[_i15], desc = defined[key];
                        if (desc && desc.get) Object.defineProperty(target, key, desc); else target[key] = desc ? desc.value : undefined;
                    }
                    return target;
                }
                function splitProps(props) {
                    for (var _len4 = arguments.length, keys = new Array(_len4 > 1 ? _len4 - 1 : 0), _key0 = 1; _key0 < _len4; _key0++) {
                        keys[_key0 - 1] = arguments[_key0];
                    }
                    if (SUPPORTS_PROXY$1 && $PROXY in props) {
                        var blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
                        var res = keys.map(function(k) {
                            return new Proxy({
                                get: function get(property) {
                                    return k.includes(property) ? props[property] : undefined;
                                },
                                has: function has(property) {
                                    return k.includes(property) && property in props;
                                },
                                keys: function keys() {
                                    return k.filter(function(property) {
                                        return property in props;
                                    });
                                }
                            }, propTraps);
                        });
                        res.push(new Proxy({
                            get: function get(property) {
                                return blocked.has(property) ? undefined : props[property];
                            },
                            has: function has(property) {
                                return blocked.has(property) ? false : property in props;
                            },
                            keys: function keys() {
                                return Object.keys(props).filter(function(k) {
                                    return !blocked.has(k);
                                });
                            }
                        }, propTraps));
                        return res;
                    }
                    var otherObject = {};
                    var objects = keys.map(function() {
                        return {};
                    });
                    var _iterator29 = _createForOfIteratorHelper(Object.getOwnPropertyNames(props)), _step29;
                    try {
                        for (_iterator29.s(); !(_step29 = _iterator29.n()).done; ) {
                            var propName = _step29.value;
                            var desc = Object.getOwnPropertyDescriptor(props, propName);
                            var isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
                            var _blocked = false;
                            var objectIndex = 0;
                            var _iterator30 = _createForOfIteratorHelper(keys), _step30;
                            try {
                                for (_iterator30.s(); !(_step30 = _iterator30.n()).done; ) {
                                    var k = _step30.value;
                                    if (k.includes(propName)) {
                                        _blocked = true;
                                        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
                                    }
                                    ++objectIndex;
                                }
                            } catch (err) {
                                _iterator30.e(err);
                            } finally {
                                _iterator30.f();
                            }
                            if (!_blocked) {
                                isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
                            }
                        }
                    } catch (err) {
                        _iterator29.e(err);
                    } finally {
                        _iterator29.f();
                    }
                    return [].concat(_toConsumableArray(objects), [ otherObject ]);
                }
                function lazy(fn) {
                    var comp;
                    var p;
                    var wrap = function wrap(props) {
                        var ctx = sharedConfig.context;
                        if (ctx) {
                            var _createSignal11 = createSignal(), _createSignal12 = _slicedToArray(_createSignal11, 2), s = _createSignal12[0], set = _createSignal12[1];
                            sharedConfig.count || (sharedConfig.count = 0);
                            sharedConfig.count++;
                            (p || (p = fn())).then(function(mod) {
                                !sharedConfig.done && setHydrateContext(ctx);
                                sharedConfig.count--;
                                set(function() {
                                    return mod.default;
                                });
                                setHydrateContext();
                            });
                            comp = s;
                        } else if (!comp) {
                            var _createResource = createResource(function() {
                                return (p || (p = fn())).then(function(mod) {
                                    return mod.default;
                                });
                            }), _createResource2 = _slicedToArray(_createResource, 1), _s = _createResource2[0];
                            comp = _s;
                        }
                        var Comp;
                        return createMemo(function() {
                            return (Comp = comp()) ? untrack(function() {
                                if (IS_DEV) ;
                                if (!ctx || sharedConfig.done) return Comp(props);
                                var c = sharedConfig.context;
                                setHydrateContext(ctx);
                                var r = Comp(props);
                                setHydrateContext(c);
                                return r;
                            }) : "";
                        });
                    };
                    wrap.preload = function() {
                        return p || ((p = fn()).then(function(mod) {
                            return comp = function comp() {
                                return mod.default;
                            };
                        }), p);
                    };
                    return wrap;
                }
                var narrowedError = function narrowedError(name) {
                    return "Stale read from <".concat(name, ">.");
                };
                function For(props) {
                    var fallback = "fallback" in props && {
                        fallback: function fallback() {
                            return props.fallback;
                        }
                    };
                    return createMemo(mapArray(function() {
                        return props.each;
                    }, props.children, fallback || undefined));
                }
                function Index(props) {
                    var fallback = "fallback" in props && {
                        fallback: function fallback() {
                            return props.fallback;
                        }
                    };
                    return createMemo(indexArray(function() {
                        return props.each;
                    }, props.children, fallback || undefined));
                }
                function Show(props) {
                    var keyed = props.keyed;
                    var conditionValue = createMemo(function() {
                        return props.when;
                    }, undefined, undefined);
                    var condition = keyed ? conditionValue : createMemo(conditionValue, undefined, {
                        equals: function equals(a, b) {
                            return !a === !b;
                        }
                    });
                    return createMemo(function() {
                        var c = condition();
                        if (c) {
                            var child = props.children;
                            var fn = typeof child === "function" && child.length > 0;
                            return fn ? untrack(function() {
                                return child(keyed ? c : function() {
                                    if (!untrack(condition)) throw narrowedError("Show");
                                    return conditionValue();
                                });
                            }) : child;
                        }
                        return props.fallback;
                    }, undefined, undefined);
                }
                function Switch(props) {
                    var chs = children(function() {
                        return props.children;
                    });
                    var switchFunc = createMemo(function() {
                        var ch = chs();
                        var mps = Array.isArray(ch) ? ch : [ ch ];
                        var func = function func() {
                            return undefined;
                        };
                        var _loop8 = function _loop8() {
                            var index = i;
                            var mp = mps[i];
                            var prevFunc = func;
                            var conditionValue = createMemo(function() {
                                return prevFunc() ? undefined : mp.when;
                            }, undefined, undefined);
                            var condition = mp.keyed ? conditionValue : createMemo(conditionValue, undefined, {
                                equals: function equals(a, b) {
                                    return !a === !b;
                                }
                            });
                            func = function func() {
                                return prevFunc() || (condition() ? [ index, conditionValue, mp ] : undefined);
                            };
                        };
                        for (var i = 0; i < mps.length; i++) {
                            _loop8();
                        }
                        return func;
                    });
                    return createMemo(function() {
                        var sel = switchFunc()();
                        if (!sel) return props.fallback;
                        var _sel = _slicedToArray(sel, 3), index = _sel[0], conditionValue = _sel[1], mp = _sel[2];
                        var child = mp.children;
                        var fn = typeof child === "function" && child.length > 0;
                        return fn ? untrack(function() {
                            return child(mp.keyed ? conditionValue() : function() {
                                var _untrack;
                                if (((_untrack = untrack(switchFunc)()) === null || _untrack === void 0 ? void 0 : _untrack[0]) !== index) throw narrowedError("Match");
                                return conditionValue();
                            });
                        }) : child;
                    }, undefined, undefined);
                }
                function Match(props) {
                    return props;
                }
                var SuspenseListContext = createContext();
                function Suspense(props) {
                    var counter = 0, show, ctx, p, flicker, error;
                    var _createSignal13 = createSignal(false), _createSignal14 = _slicedToArray(_createSignal13, 2), inFallback = _createSignal14[0], setFallback = _createSignal14[1], SuspenseContext = getSuspenseContext(), store = {
                        increment: function increment() {
                            if (++counter === 1) setFallback(true);
                        },
                        decrement: function decrement() {
                            if (--counter === 0) setFallback(false);
                        },
                        inFallback: inFallback,
                        effects: [],
                        resolved: false
                    }, owner = getOwner();
                    if (sharedConfig.context && sharedConfig.load) {
                        var key = sharedConfig.getContextId();
                        var ref = sharedConfig.load(key);
                        if (ref) {
                            if (_typeof(ref) !== "object" || ref.s !== 1) p = ref; else sharedConfig.gather(key);
                        }
                        if (p && p !== "$$f") {
                            var _createSignal15 = createSignal(undefined, {
                                equals: false
                            }), _createSignal16 = _slicedToArray(_createSignal15, 2), s = _createSignal16[0], set = _createSignal16[1];
                            flicker = s;
                            p.then(function() {
                                if (sharedConfig.done) return set();
                                sharedConfig.gather(key);
                                setHydrateContext(ctx);
                                set();
                                setHydrateContext();
                            }, function(err) {
                                error = err;
                                set();
                            });
                        }
                    }
                    var listContext = useContext(SuspenseListContext);
                    if (listContext) show = listContext.register(store.inFallback);
                    var dispose;
                    onCleanup(function() {
                        return dispose && dispose();
                    });
                    return createComponent$1(SuspenseContext.Provider, {
                        value: store,
                        get children() {
                            return createMemo(function() {
                                if (error) throw error;
                                ctx = sharedConfig.context;
                                if (flicker) {
                                    flicker();
                                    return flicker = undefined;
                                }
                                if (ctx && p === "$$f") setHydrateContext();
                                var rendered = createMemo(function() {
                                    return props.children;
                                });
                                return createMemo(function(prev) {
                                    var inFallback = store.inFallback(), _ref47 = show ? show() : {}, _ref47$showContent = _ref47.showContent, showContent = _ref47$showContent === void 0 ? true : _ref47$showContent, _ref47$showFallback = _ref47.showFallback, showFallback = _ref47$showFallback === void 0 ? true : _ref47$showFallback;
                                    if ((!inFallback || p && p !== "$$f") && showContent) {
                                        store.resolved = true;
                                        dispose && dispose();
                                        dispose = ctx = p = undefined;
                                        resumeEffects(store.effects);
                                        return rendered();
                                    }
                                    if (!showFallback) return;
                                    if (dispose) return prev;
                                    return createRoot(function(disposer) {
                                        dispose = disposer;
                                        if (ctx) {
                                            setHydrateContext({
                                                id: ctx.id + "F",
                                                count: 0
                                            });
                                            ctx = undefined;
                                        }
                                        return props.fallback;
                                    }, owner);
                                });
                            });
                        }
                    });
                }
                var _createSignal17 = createSignal(void 0), _createSignal18 = _slicedToArray(_createSignal17, 2), activeElement = _createSignal18[0], setActiveElement = _createSignal18[1];
                exports("w", activeElement);
                function hexColor() {
                    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
                    if (isInteger(color)) {
                        return color;
                    }
                    if (typeof color === "string") {
                        if (color.startsWith("#")) {
                            return Number(color.replace("#", "0x") + (color.length === 7 ? "ff" : ""));
                        }
                        if (color.startsWith("0x")) {
                            return Number(color);
                        }
                        return Number("0x" + (color.length === 6 ? color + "ff" : color));
                    }
                    return 0;
                }
                function combineStyles(style1, style2) {
                    if (!style1) {
                        return style2;
                    }
                    if (!style2) {
                        return style1;
                    }
                    return _objectSpread(_objectSpread({}, style2), style1);
                }
                var clamp = function clamp(value, min, max) {
                    return min < max ? Math.min(Math.max(value, min), max) : Math.min(Math.max(value, max), min);
                };
                function mod(n, m) {
                    if (m === 0) return 0;
                    return (n % m + m) % m;
                }
                var memo$1 = function memo$1(fn) {
                    return createMemo(function() {
                        return fn();
                    });
                };
                function createRenderer$1(_ref48) {
                    var createElement = _ref48.createElement, createTextNode = _ref48.createTextNode, isTextNode = _ref48.isTextNode, replaceText = _ref48.replaceText, insertNode = _ref48.insertNode, removeNode = _ref48.removeNode, setProperty = _ref48.setProperty, getParentNode = _ref48.getParentNode, getFirstChild = _ref48.getFirstChild, getNextSibling = _ref48.getNextSibling;
                    function insert(parent, accessor, marker, initial) {
                        if (marker !== undefined && !initial) initial = [];
                        if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
                        createRenderEffect(function(current) {
                            return insertExpression(parent, accessor(), current, marker);
                        }, initial);
                    }
                    function insertExpression(parent, value, current, marker, unwrapArray) {
                        while (typeof current === "function") current = current();
                        if (value === current) return current;
                        var t = _typeof(value), multi = marker !== undefined;
                        if (t === "string" || t === "number") {
                            if (t === "number") value = value.toString();
                            if (multi) {
                                var node = current[0];
                                if (node && isTextNode(node)) {
                                    replaceText(node, value);
                                } else node = createTextNode(value);
                                current = cleanChildren(parent, current, marker, node);
                            } else {
                                if (current !== "" && typeof current === "string") {
                                    replaceText(getFirstChild(parent), current = value);
                                } else {
                                    cleanChildren(parent, current, marker, createTextNode(value));
                                    current = value;
                                }
                            }
                        } else if (value == null || t === "boolean") {
                            current = cleanChildren(parent, current, marker);
                        } else if (t === "function") {
                            createRenderEffect(function() {
                                var v = value();
                                while (typeof v === "function") v = v();
                                current = insertExpression(parent, v, current, marker);
                            });
                            return function() {
                                return current;
                            };
                        } else if (Array.isArray(value)) {
                            var array = [];
                            if (normalizeIncomingArray(array, value, unwrapArray)) {
                                createRenderEffect(function() {
                                    return current = insertExpression(parent, array, current, marker, true);
                                });
                                return function() {
                                    return current;
                                };
                            }
                            if (array.length === 0) {
                                var replacement = cleanChildren(parent, current, marker);
                                if (multi) return current = replacement;
                            } else {
                                if (Array.isArray(current)) {
                                    if (current.length === 0) {
                                        appendNodes(parent, array, marker);
                                    } else reconcileArrays(parent, current, array);
                                } else if (current == null || current === "") {
                                    appendNodes(parent, array);
                                } else {
                                    reconcileArrays(parent, multi && current || [ getFirstChild(parent) ], array);
                                }
                            }
                            current = array;
                        } else {
                            if (Array.isArray(current)) {
                                if (multi) return current = cleanChildren(parent, current, marker, value);
                                cleanChildren(parent, current, null, value);
                            } else if (current == null || current === "" || !getFirstChild(parent)) {
                                insertNode(parent, value);
                            } else replaceNode(parent, value, getFirstChild(parent));
                            current = value;
                        }
                        return current;
                    }
                    function normalizeIncomingArray(normalized, array, unwrap) {
                        var dynamic = false;
                        for (var i = 0, len = array.length; i < len; i++) {
                            var item = array[i], t = void 0;
                            if (item == null || item === true || item === false) ; else if (Array.isArray(item)) {
                                dynamic = normalizeIncomingArray(normalized, item) || dynamic;
                            } else if ((t = _typeof(item)) === "string" || t === "number") {
                                normalized.push(createTextNode(item));
                            } else if (t === "function") {
                                if (unwrap) {
                                    while (typeof item === "function") item = item();
                                    dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [ item ]) || dynamic;
                                } else {
                                    normalized.push(item);
                                    dynamic = true;
                                }
                            } else normalized.push(item);
                        }
                        return dynamic;
                    }
                    function reconcileArrays(parentNode, a, b) {
                        var bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = getNextSibling(a[aEnd - 1]), map = null;
                        while (aStart < aEnd || bStart < bEnd) {
                            if (a[aStart] === b[bStart]) {
                                aStart++;
                                bStart++;
                                continue;
                            }
                            while (a[aEnd - 1] === b[bEnd - 1]) {
                                aEnd--;
                                bEnd--;
                            }
                            if (aEnd === aStart) {
                                var node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
                                while (bStart < bEnd) insertNode(parentNode, b[bStart++], node);
                            } else if (bEnd === bStart) {
                                while (aStart < aEnd) {
                                    if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
                                    aStart++;
                                }
                            } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
                                var _node2 = getNextSibling(a[--aEnd]);
                                insertNode(parentNode, b[bStart++], getNextSibling(a[aStart++]));
                                insertNode(parentNode, b[--bEnd], _node2);
                                a[aEnd] = b[bEnd];
                            } else {
                                if (!map) {
                                    map = new Map;
                                    var i = bStart;
                                    while (i < bEnd) map.set(b[i], i++);
                                }
                                var index = map.get(a[aStart]);
                                if (index != null) {
                                    if (bStart < index && index < bEnd) {
                                        var _i16 = aStart, sequence = 1, t = void 0;
                                        while (++_i16 < aEnd && _i16 < bEnd) {
                                            if ((t = map.get(a[_i16])) == null || t !== index + sequence) break;
                                            sequence++;
                                        }
                                        if (sequence > index - bStart) {
                                            var _node3 = a[aStart];
                                            while (bStart < index) insertNode(parentNode, b[bStart++], _node3);
                                        } else replaceNode(parentNode, b[bStart++], a[aStart++]);
                                    } else aStart++;
                                } else removeNode(parentNode, a[aStart++]);
                            }
                        }
                    }
                    function cleanChildren(parent, current, marker, replacement) {
                        if (marker === undefined) {
                            var removed;
                            while (removed = getFirstChild(parent)) removeNode(parent, removed);
                            replacement && insertNode(parent, replacement);
                            return "";
                        }
                        var node = replacement || createTextNode("");
                        if (current.length) {
                            var inserted = false;
                            for (var i = current.length - 1; i >= 0; i--) {
                                var el = current[i];
                                if (node !== el) {
                                    var isParent = getParentNode(el) === parent;
                                    if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode(parent, node, marker); else isParent && removeNode(parent, el);
                                } else inserted = true;
                            }
                        } else insertNode(parent, node, marker);
                        return [ node ];
                    }
                    function appendNodes(parent, array, marker) {
                        for (var i = 0, len = array.length; i < len; i++) insertNode(parent, array[i], marker);
                    }
                    function replaceNode(parent, newNode, oldNode) {
                        insertNode(parent, newNode, oldNode);
                        removeNode(parent, oldNode);
                    }
                    function spreadExpression(node, props) {
                        var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                        var skipChildren = arguments.length > 3 ? arguments[3] : undefined;
                        props || (props = {});
                        if (!skipChildren) {
                            createRenderEffect(function() {
                                return prevProps.children = insertExpression(node, props.children, prevProps.children);
                            });
                        }
                        createRenderEffect(function() {
                            return props.ref && props.ref(node);
                        });
                        createRenderEffect(function() {
                            for (var prop in props) {
                                if (prop === "children" || prop === "ref") continue;
                                var value = props[prop];
                                if (value === prevProps[prop]) continue;
                                setProperty(node, prop, value, prevProps[prop]);
                                prevProps[prop] = value;
                            }
                        });
                        return prevProps;
                    }
                    return {
                        render: function render(code, element) {
                            var disposer;
                            createRoot(function(dispose) {
                                disposer = dispose;
                                insert(element, code());
                            });
                            return disposer;
                        },
                        insert: insert,
                        spread: function spread(node, accessor, skipChildren) {
                            if (typeof accessor === "function") {
                                createRenderEffect(function(current) {
                                    return spreadExpression(node, accessor(), current, skipChildren);
                                });
                            } else spreadExpression(node, accessor, undefined, skipChildren);
                        },
                        createElement: createElement,
                        createTextNode: createTextNode,
                        insertNode: insertNode,
                        setProp: function setProp(node, name, value, prev) {
                            setProperty(node, name, value, prev);
                            return value;
                        },
                        mergeProps: mergeProps$1,
                        effect: createRenderEffect,
                        memo: memo$1,
                        createComponent: createComponent$1,
                        use: function use(fn, element, arg) {
                            return untrack(function() {
                                return fn(element, arg);
                            });
                        }
                    };
                }
                function createRenderer$2(options) {
                    var renderer = createRenderer$1(options);
                    renderer.mergeProps = mergeProps$1;
                    return renderer;
                }
                Object.defineProperty(ElementNode.prototype, "preserve", {
                    get: function get() {
                        return this._queueDelete === 0;
                    },
                    set: function set(v) {
                        this._queueDelete = v ? 0 : void 0;
                    }
                });
                var elementDeleteQueue = [];
                function flushDeleteQueue() {
                    var _iterator31 = _createForOfIteratorHelper(elementDeleteQueue), _step31;
                    try {
                        for (_iterator31.s(); !(_step31 = _iterator31.n()).done; ) {
                            var el = _step31.value;
                            if (Number(el._queueDelete) < 0) {
                                el.destroy();
                            }
                            el._queueDelete = void 0;
                        }
                    } catch (err) {
                        _iterator31.e(err);
                    } finally {
                        _iterator31.f();
                    }
                    elementDeleteQueue.length = 0;
                }
                function pushDeleteQueue(node, n) {
                    if (node._queueDelete === void 0) {
                        node._queueDelete = n;
                        if (elementDeleteQueue.push(node) === 1) {
                            queueMicrotask(flushDeleteQueue);
                        }
                    } else {
                        node._queueDelete += n;
                    }
                }
                var nodeOpts = {
                    createElement: function createElement(name) {
                        return new ElementNode(name);
                    },
                    createTextNode: function createTextNode(text) {
                        return {
                            _type: NodeType.Text,
                            text: text
                        };
                    },
                    replaceText: function replaceText(node, value) {
                        log("Replace Text: ", node, value);
                        node.text = value;
                        var parent = node.parent;
                        parent.text = parent.getText();
                    },
                    setProperty: function setProperty(node, name) {
                        var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                        node[name] = value;
                    },
                    insertNode: function insertNode(parent, node, anchor) {
                        log("INSERT: ", parent, node, anchor);
                        var prevParent = node.parent;
                        parent.insertChild(node, anchor);
                        if (node instanceof ElementNode) {
                            node.parent.rendered && node.render(true);
                            if (prevParent !== void 0) {
                                pushDeleteQueue(node, 1);
                            }
                        } else if (isElementText(parent)) {
                            parent.text = parent.getText();
                        }
                    },
                    isTextNode: function isTextNode(node) {
                        return isElementText(node);
                    },
                    removeNode: function removeNode(parent, node) {
                        log("REMOVE: ", parent, node);
                        parent.removeChild(node);
                        if (node instanceof ElementNode) {
                            pushDeleteQueue(node, -1);
                        } else if (isElementText(parent)) {
                            parent.text = parent.getText();
                        }
                    },
                    getParentNode: function getParentNode(node) {
                        return node.parent;
                    },
                    getFirstChild: function getFirstChild(node) {
                        return node.children[0];
                    },
                    getNextSibling: function getNextSibling(node) {
                        var children = node.parent.children || [];
                        var index = children.indexOf(node) + 1;
                        if (index < children.length) {
                            return children[index];
                        }
                        return void 0;
                    }
                };
                var solidRenderer = createRenderer$2(nodeOpts);
                var renderer$1;
                var rootNode = exports("a5", nodeOpts.createElement("App"));
                var render$1 = function render$1(code) {
                    return solidRenderer.render(code, rootNode);
                };
                function createRenderer(rendererOptions, node) {
                    var options = Config.rendererOptions;
                    renderer$1 = startLightningRenderer(options, "app");
                    Config.setActiveElement = setActiveElement;
                    rootNode.lng = renderer$1.root;
                    rootNode.rendered = true;
                    renderer$1.on("idle", function() {
                        tasksEnabled = true;
                        processTasks();
                    });
                    return {
                        renderer: renderer$1,
                        rootNode: rootNode,
                        render: render$1
                    };
                }
                var effect = solidRenderer.effect, memo = solidRenderer.memo, createComponent = solidRenderer.createComponent, createElement = solidRenderer.createElement, createTextNode = solidRenderer.createTextNode, insertNode = solidRenderer.insertNode, insert = solidRenderer.insert, spread = solidRenderer.spread, setProp = solidRenderer.setProp, mergeProps = solidRenderer.mergeProps, use = solidRenderer.use;
                exports({
                    a6: effect,
                    B: memo,
                    c: createComponent,
                    l: createElement,
                    ab: createTextNode,
                    a7: insertNode,
                    r: insert,
                    q: spread,
                    a4: setProp,
                    m: mergeProps,
                    p: use
                });
                var taskQueue = [];
                var tasksEnabled = false;
                createRoot(function() {
                    createRenderEffect(function() {
                        activeElement();
                        tasksEnabled = false;
                    });
                });
                function scheduleTask(callback) {
                    var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "low";
                    if (priority === "high") {
                        taskQueue.unshift(callback);
                    } else {
                        taskQueue.push(callback);
                    }
                    processTasks();
                }
                function processTasks() {
                    if (tasksEnabled && taskQueue.length) {
                        setTimeout(function() {
                            var task = taskQueue.shift();
                            if (task) {
                                task();
                                processTasks();
                            }
                        }, Config.taskDelay || 50);
                    }
                }
                function Dynamic(props) {
                    var _splitProps = splitProps(props, [ "component" ]), _splitProps2 = _slicedToArray(_splitProps, 2), p = _splitProps2[0], others = _splitProps2[1];
                    var cached = createMemo(function() {
                        return p.component;
                    });
                    return createMemo(function() {
                        var component = cached();
                        switch (_typeof(component)) {
                          case "function":
                            return untrack(function() {
                                return component(others);
                            });

                          case "string":
                            {
                                var el = createElement(component);
                                spread(el, others);
                                return el;
                            }
                        }
                    });
                }
                var View = exports("V", function(props) {
                    var el = createElement("node");
                    spread(el, props, false);
                    return el;
                });
                var Text = exports("T", function(props) {
                    var el = createElement("text");
                    spread(el, props, false);
                    return el;
                });
                var invisibleChars = /[\u200B\u200C\u200D\uFEFF\u00AD\u2060]/g;
                function hasZeroWidthSpace(space) {
                    return invisibleChars.test(space) === true;
                }
                var spaceRegex = /[ \u200B]+/g;
                var defaultFontMetrics = {
                    ascender: 800,
                    descender: -200,
                    lineGap: 200,
                    unitsPerEm: 1e3
                };
                var normalizeFontMetrics = function normalizeFontMetrics(metrics, fontSize) {
                    var scale = fontSize / metrics.unitsPerEm;
                    return {
                        ascender: metrics.ascender * scale,
                        descender: metrics.descender * scale,
                        lineGap: metrics.lineGap * scale
                    };
                };
                var mapTextLayout = function mapTextLayout(measureText, metrics, text, textAlign, fontFamily, lineHeight, overflowSuffix, wordBreak, letterSpacing, maxLines, maxWidth, maxHeight) {
                    var ascPx = metrics.ascender;
                    var descPx = metrics.descender;
                    var bareLineHeight = ascPx - descPx;
                    var lineHeightPx = lineHeight <= 3 ? lineHeight * bareLineHeight : lineHeight;
                    var lineHeightDelta = lineHeightPx - bareLineHeight;
                    var halfDelta = lineHeightDelta * .5;
                    var effectiveMaxLines = maxLines;
                    if (maxHeight > 0) {
                        var maxFromHeight = Math.floor(maxHeight / lineHeightPx);
                        if (maxFromHeight < 1) {
                            maxFromHeight = 1;
                        }
                        if (effectiveMaxLines === 0 || maxFromHeight < effectiveMaxLines) {
                            effectiveMaxLines = maxFromHeight;
                        }
                    }
                    var wrappedText = maxWidth > 0;
                    var _ref49 = wrappedText === true ? wrapText(measureText, text, fontFamily, maxWidth, letterSpacing, overflowSuffix, wordBreak, effectiveMaxLines) : measureLines(measureText, text.split("\n"), fontFamily, letterSpacing, effectiveMaxLines), _ref50 = _slicedToArray(_ref49, 3), lines = _ref50[0], remainingLines = _ref50[1], remainingText = _ref50[2];
                    var effectiveLineAmount = lines.length;
                    var effectiveMaxWidth = 0;
                    if (effectiveLineAmount > 0) {
                        effectiveMaxWidth = lines[0][1];
                        if (effectiveLineAmount > 1) {
                            for (var i = 1; i < effectiveLineAmount; i++) {
                                effectiveMaxWidth = Math.max(effectiveMaxWidth, lines[i][1]);
                            }
                        }
                    }
                    if (textAlign !== "left") {
                        for (var _i17 = 0; _i17 < effectiveLineAmount; _i17++) {
                            var line = lines[_i17];
                            var w = line[1];
                            line[3] = textAlign === "right" ? effectiveMaxWidth - w : (effectiveMaxWidth - w) / 2;
                        }
                    }
                    var effectiveMaxHeight = effectiveLineAmount * lineHeightPx;
                    var firstBaseLine = halfDelta;
                    var startY = firstBaseLine;
                    for (var _i18 = 0; _i18 < effectiveLineAmount; _i18++) {
                        var _line = lines[_i18];
                        _line[4] = startY + lineHeightPx * _i18;
                    }
                    return [ lines, remainingLines, remainingText, bareLineHeight, lineHeightPx, effectiveMaxWidth, effectiveMaxHeight ];
                };
                var measureLines = function measureLines(measureText, lines, fontFamily, letterSpacing, maxLines) {
                    var measuredLines = [];
                    var remainingLines = maxLines > 0 ? maxLines : lines.length;
                    var i = 0;
                    while (remainingLines > 0) {
                        var line = lines[i];
                        i++;
                        remainingLines--;
                        if (line === undefined) {
                            continue;
                        }
                        var width = measureText(line, fontFamily, letterSpacing);
                        measuredLines.push([ line, width, false, 0, 0 ]);
                    }
                    return [ measuredLines, remainingLines, maxLines > 0 ? lines.length - measuredLines.length > 0 : false ];
                };
                var wrapText = function wrapText(measureText, text, fontFamily, maxWidth, letterSpacing, overflowSuffix, wordBreak, maxLines) {
                    var lines = text.split("\n");
                    var wrappedLines = [];
                    var spaceWidth = measureText(" ", fontFamily, letterSpacing);
                    var overflowWidth = measureText(overflowSuffix, fontFamily, letterSpacing);
                    var wrappedLine = [];
                    var remainingLines = maxLines > 0 ? maxLines : 1e3;
                    var hasRemainingText = true;
                    var hasMaxLines = maxLines > 0;
                    for (var i = 0; i < lines.length; i++) {
                        var line = lines[i];
                        if (line === undefined) {
                            continue;
                        }
                        var _ref51 = line.length > 0 ? wrapLine(measureText, line, fontFamily, maxWidth, letterSpacing, spaceWidth, overflowSuffix, overflowWidth, wordBreak, remainingLines) : [ [ [ "", 0, false, 0, 0 ] ], remainingLines, i < lines.length - 1 ];
                        var _ref52 = _slicedToArray(_ref51, 3);
                        wrappedLine = _ref52[0];
                        remainingLines = _ref52[1];
                        hasRemainingText = _ref52[2];
                        remainingLines--;
                        wrappedLines.push.apply(wrappedLines, _toConsumableArray(wrappedLine));
                        if (hasMaxLines === true && remainingLines <= 0) {
                            var lastLine = wrappedLines[wrappedLines.length - 1];
                            if (i < lines.length - 1) {
                                if (lastLine[2] === false) {
                                    var remainingText = "";
                                    var _truncateLineEnd = truncateLineEnd(measureText, fontFamily, letterSpacing, lastLine[0], lastLine[1], remainingText, maxWidth, overflowSuffix, overflowWidth), _truncateLineEnd2 = _slicedToArray(_truncateLineEnd, 2), _line2 = _truncateLineEnd2[0], lineWidth = _truncateLineEnd2[1];
                                    lastLine[0] = _line2;
                                    lastLine[1] = lineWidth;
                                    lastLine[2] = true;
                                }
                            }
                            break;
                        }
                    }
                    return [ wrappedLines, remainingLines, hasRemainingText ];
                };
                var wrapLine = function wrapLine(measureText, line, fontFamily, maxWidth, letterSpacing, spaceWidth, overflowSuffix, overflowWidth, wordBreak, remainingLines) {
                    var words = line.split(spaceRegex);
                    var spaces = line.match(spaceRegex) || [];
                    var wrappedLines = [];
                    var currentLine = "";
                    var currentLineWidth = 0;
                    var hasRemainingText = true;
                    var wrapFn = getWrapStrategy(wordBreak);
                    while (words.length > 0 && remainingLines > 0) {
                        var word = words.shift();
                        var wordWidth = measureText(word, fontFamily, letterSpacing);
                        var remainingWord = "";
                        if (currentLineWidth === 0) {
                            if (wordWidth > maxWidth) {
                                remainingLines--;
                                var _ref53 = remainingLines === 0 ? truncateWord(measureText, word, wordWidth, maxWidth, fontFamily, letterSpacing, overflowSuffix, overflowWidth) : splitWord(measureText, word, wordWidth, maxWidth, fontFamily, letterSpacing);
                                var _ref54 = _slicedToArray(_ref53, 3);
                                word = _ref54[0];
                                remainingWord = _ref54[1];
                                wordWidth = _ref54[2];
                                if (remainingWord.length > 0) {
                                    words.unshift(remainingWord);
                                }
                                wrappedLines.push([ word, wordWidth, false, 0, 0 ]);
                            } else if (wordWidth + spaceWidth >= maxWidth) {
                                remainingLines--;
                                wrappedLines.push([ word, wordWidth, false, 0, 0 ]);
                            } else {
                                currentLine = word;
                                currentLineWidth = wordWidth;
                            }
                            continue;
                        }
                        var space = spaces.shift() || "";
                        var effectiveSpaceWidth = space === "" ? 0 : spaceWidth;
                        var totalWidth = currentLineWidth + effectiveSpaceWidth + wordWidth;
                        if (totalWidth < maxWidth) {
                            currentLine += effectiveSpaceWidth > 0 ? space + word : word;
                            currentLineWidth = totalWidth;
                            continue;
                        }
                        remainingLines--;
                        if (totalWidth === maxWidth) {
                            currentLine += effectiveSpaceWidth > 0 ? space + word : word;
                            currentLineWidth = totalWidth;
                            wrappedLines.push([ currentLine, currentLineWidth, false, 0, 0 ]);
                            currentLine = "";
                            currentLineWidth = 0;
                            continue;
                        }
                        var _wrapFn = wrapFn(measureText, word, wordWidth, fontFamily, letterSpacing, wrappedLines, currentLine, currentLineWidth, remainingLines, remainingWord, maxWidth, space, spaceWidth, overflowSuffix, overflowWidth);
                        var _wrapFn2 = _slicedToArray(_wrapFn, 3);
                        currentLine = _wrapFn2[0];
                        currentLineWidth = _wrapFn2[1];
                        remainingWord = _wrapFn2[2];
                        if (remainingWord.length > 0) {
                            words.unshift(remainingWord);
                        }
                    }
                    if (currentLineWidth > 0 && remainingLines > 0) {
                        wrappedLines.push([ currentLine, currentLineWidth, false, 0, 0 ]);
                    }
                    return [ wrappedLines, remainingLines, hasRemainingText ];
                };
                var getWrapStrategy = function getWrapStrategy(wordBreak) {
                    if (wordBreak === "break-word") {
                        return breakWord;
                    }
                    if (wordBreak === "break-all") {
                        return breakAll;
                    }
                    if (wordBreak === "overflow") {
                        return overflow;
                    }
                    return breakWord;
                };
                var overflow = function overflow(measureText, word, wordWidth, fontFamily, letterSpacing, wrappedLines, currentLine, currentLineWidth, remainingLines, remainingWord, maxWidth, space, spaceWidth, overflowSuffix, overflowWidth) {
                    currentLine += space + word;
                    currentLineWidth += spaceWidth + wordWidth;
                    if (remainingLines === 0) {
                        currentLine += overflowSuffix;
                        currentLineWidth += overflowWidth;
                    }
                    wrappedLines.push([ currentLine, currentLineWidth, true, 0, 0 ]);
                    return [ "", 0, "" ];
                };
                var breakWord = function breakWord(measureText, word, wordWidth, fontFamily, letterSpacing, wrappedLines, currentLine, currentLineWidth, remainingLines, remainingWord, maxWidth, space, spaceWidth, overflowSuffix, overflowWidth) {
                    remainingWord = word;
                    if (remainingLines === 0) {
                        var _truncateLineEnd3 = truncateLineEnd(measureText, fontFamily, letterSpacing, currentLine, currentLineWidth, remainingWord, maxWidth, overflowSuffix, overflowWidth);
                        var _truncateLineEnd4 = _slicedToArray(_truncateLineEnd3, 3);
                        currentLine = _truncateLineEnd4[0];
                        currentLineWidth = _truncateLineEnd4[1];
                        remainingWord = _truncateLineEnd4[2];
                        wrappedLines.push([ currentLine, currentLineWidth, true, 0, 0 ]);
                    } else {
                        wrappedLines.push([ currentLine, currentLineWidth, false, 0, 0 ]);
                        currentLine = "";
                        currentLineWidth = 0;
                    }
                    return [ currentLine, currentLineWidth, remainingWord ];
                };
                var breakAll = function breakAll(measureText, word, wordWidth, fontFamily, letterSpacing, wrappedLines, currentLine, currentLineWidth, remainingLines, remainingWord, maxWidth, space, spaceWidth, overflowSuffix, overflowWidth) {
                    var remainingSpace = maxWidth - currentLineWidth;
                    if (currentLineWidth > 0) {
                        remainingSpace -= spaceWidth;
                    }
                    var truncate = remainingLines === 0;
                    var _ref55 = truncate ? truncateWord(measureText, word, wordWidth, remainingSpace, fontFamily, letterSpacing, overflowSuffix, overflowWidth) : splitWord(measureText, word, wordWidth, remainingSpace, fontFamily, letterSpacing);
                    var _ref56 = _slicedToArray(_ref55, 3);
                    word = _ref56[0];
                    remainingWord = _ref56[1];
                    wordWidth = _ref56[2];
                    currentLine += space + word;
                    currentLineWidth += spaceWidth + wordWidth;
                    wrappedLines.push([ currentLine, currentLineWidth, truncate, 0, 0 ]);
                    currentLine = "";
                    currentLineWidth = 0;
                    return [ currentLine, currentLineWidth, remainingWord ];
                };
                var truncateLineEnd = function truncateLineEnd(measureText, fontFamily, letterSpacing, currentLine, currentLineWidth, remainingWord, maxWidth, overflowSuffix, overflowWidth) {
                    if (currentLineWidth + overflowWidth <= maxWidth) {
                        currentLine += overflowSuffix;
                        currentLineWidth += overflowWidth;
                        remainingWord = "";
                        return [ currentLine, currentLineWidth, remainingWord ];
                    }
                    var truncated = false;
                    for (var i = currentLine.length - 1; i > 0; i--) {
                        var char = currentLine.charAt(i);
                        var charWidth = measureText(char, fontFamily, letterSpacing);
                        currentLineWidth -= charWidth;
                        if (currentLineWidth + overflowWidth <= maxWidth) {
                            currentLine = currentLine.substring(0, i) + overflowSuffix;
                            currentLineWidth += overflowWidth;
                            remainingWord = currentLine.substring(i) + " " + remainingWord;
                            truncated = true;
                            break;
                        }
                    }
                    if (truncated === false) {
                        currentLine = overflowSuffix;
                        currentLineWidth = overflowWidth;
                        remainingWord = currentLine;
                    }
                    return [ currentLine, currentLineWidth, remainingWord ];
                };
                var truncateWord = function truncateWord(measureText, word, wordWidth, maxWidth, fontFamily, letterSpacing, overflowSuffix, overflowWidth) {
                    var targetWidth = maxWidth - overflowWidth;
                    if (targetWidth <= 0) {
                        return [ "", word, 0 ];
                    }
                    var excessWidth = wordWidth - targetWidth;
                    var shouldStartFromBack = excessWidth < wordWidth / 2;
                    if (shouldStartFromBack === false) {
                        var _currentWidth = wordWidth;
                        for (var i = word.length - 1; i > 0; i--) {
                            var char = word.charAt(i);
                            var charWidth = measureText(char, fontFamily, letterSpacing);
                            _currentWidth -= charWidth;
                            if (_currentWidth <= targetWidth) {
                                var remainingWord = word.substring(i);
                                return [ word.substring(0, i) + overflowSuffix, remainingWord, _currentWidth + overflowWidth ];
                            }
                        }
                        return [ overflowSuffix, word, overflowWidth ];
                    }
                    var currentWidth = 0;
                    for (var _i19 = 0; _i19 < word.length; _i19++) {
                        var _char = word.charAt(_i19);
                        var _charWidth = measureText(_char, fontFamily, letterSpacing);
                        if (currentWidth + _charWidth > targetWidth) {
                            var _remainingWord = word.substring(_i19);
                            return [ word.substring(0, _i19) + overflowSuffix, _remainingWord, currentWidth + overflowWidth ];
                        }
                        currentWidth += _charWidth;
                    }
                    return [ word + overflowSuffix, "", wordWidth + overflowWidth ];
                };
                var splitWord = function splitWord(measureText, word, wordWidth, maxWidth, fontFamily, letterSpacing) {
                    if (maxWidth <= 0) {
                        return [ "", word, 0 ];
                    }
                    var excessWidth = wordWidth - maxWidth;
                    var shouldStartFromBack = excessWidth < wordWidth / 2;
                    if (shouldStartFromBack === false) {
                        var _currentWidth2 = wordWidth;
                        for (var i = word.length - 1; i > 0; i--) {
                            var char = word.charAt(i);
                            var charWidth = measureText(char, fontFamily, letterSpacing);
                            _currentWidth2 -= charWidth;
                            if (_currentWidth2 <= maxWidth) {
                                var remainingWord = word.substring(i);
                                return [ word.substring(0, i), remainingWord, _currentWidth2 ];
                            }
                        }
                        return [ "", word, 0 ];
                    }
                    var currentWidth = 0;
                    for (var _i20 = 0; _i20 < word.length; _i20++) {
                        var _char2 = word.charAt(_i20);
                        var _charWidth2 = measureText(_char2, fontFamily, letterSpacing);
                        if (currentWidth + _charWidth2 > maxWidth) {
                            var _remainingWord2 = word.substring(_i20);
                            return [ word.substring(0, _i20), _remainingWord2, currentWidth ];
                        }
                        currentWidth += _charWidth2;
                    }
                    return [ word, "", wordWidth ];
                };
                var fontCache$1 = new Map;
                var fontLoadPromises$1 = new Map;
                var normalizedMetrics$1 = new Map;
                var nodesWaitingForFont$1 = Object.create(null);
                var initialized$1 = false;
                var buildKerningTable = function buildKerningTable(kernings) {
                    var kerningTable = {};
                    var i = 0;
                    var length = kernings.length;
                    while (i < length) {
                        var kerning = kernings[i];
                        i++;
                        if (kerning === undefined) {
                            continue;
                        }
                        var second = kerning.second;
                        var firsts = kerningTable[second];
                        if (firsts === undefined) {
                            firsts = {};
                            kerningTable[second] = firsts;
                        }
                        firsts[kerning.first] = kerning.amount;
                    }
                    return kerningTable;
                };
                var buildGlyphMap = function buildGlyphMap(chars) {
                    var glyphMap = new Map;
                    var i = 0;
                    var length = chars.length;
                    while (i < length) {
                        var glyph = chars[i];
                        i++;
                        if (glyph === undefined) {
                            continue;
                        }
                        glyphMap.set(glyph.id, glyph);
                        glyph.yoffset + glyph.height;
                    }
                    return glyphMap;
                };
                var processFontData$1 = function processFontData$1(fontFamily, fontData, atlasTexture, metrics) {
                    var glyphMap = buildGlyphMap(fontData.chars);
                    var kernings = buildKerningTable(fontData.kernings);
                    var maxCharHeight = 0;
                    var i = 0;
                    var length = fontData.chars.length;
                    while (i < length) {
                        var glyph = fontData.chars[i];
                        if (glyph !== undefined) {
                            var charHeight = glyph.yoffset + glyph.height;
                            if (charHeight > maxCharHeight) {
                                maxCharHeight = charHeight;
                            }
                        }
                        i++;
                    }
                    if (metrics === undefined && fontData.lightningMetrics === undefined) {
                        console.warn("Font metrics not found for SDF font ".concat(fontFamily, ". ") + "Make sure you are using the latest version of the Lightning " + "3 msdf-generator tool to generate your SDF fonts. Using default metrics.");
                    }
                    metrics = metrics || fontData.lightningMetrics || {
                        ascender: 800,
                        descender: -200,
                        lineGap: 200,
                        unitsPerEm: 1e3
                    };
                    fontCache$1.set(fontFamily, {
                        data: fontData,
                        glyphMap: glyphMap,
                        kernings: kernings,
                        atlasTexture: atlasTexture,
                        metrics: metrics,
                        maxCharHeight: maxCharHeight
                    });
                };
                var canRenderFont$1 = function canRenderFont$1(trProps) {
                    return isFontLoaded$1(trProps.fontFamily) || fontLoadPromises$1.has(trProps.fontFamily);
                };
                var loadFont$1 = function() {
                    var _ref57 = _asyncToGenerator(_regenerator().m(function _callee19(stage, options) {
                        var fontFamily, atlasUrl, atlasDataUrl, metrics, existingPromise, nwff, loadPromise;
                        return _regenerator().w(function(_context19) {
                            while (1) switch (_context19.n) {
                              case 0:
                                fontFamily = options.fontFamily, atlasUrl = options.atlasUrl, atlasDataUrl = options.atlasDataUrl, 
                                metrics = options.metrics;
                                if (!(fontCache$1.get(fontFamily) !== undefined)) {
                                    _context19.n = 1;
                                    break;
                                }
                                return _context19.a(2);

                              case 1:
                                existingPromise = fontLoadPromises$1.get(fontFamily);
                                if (!(existingPromise !== undefined)) {
                                    _context19.n = 2;
                                    break;
                                }
                                return _context19.a(2, existingPromise);

                              case 2:
                                if (!(atlasDataUrl === undefined)) {
                                    _context19.n = 3;
                                    break;
                                }
                                throw new Error("Atlas data URL must be provided for SDF font: ".concat(fontFamily));

                              case 3:
                                nwff = nodesWaitingForFont$1[fontFamily] = [];
                                loadPromise = _asyncToGenerator(_regenerator().m(function _callee18() {
                                    var response, fontData;
                                    return _regenerator().w(function(_context18) {
                                        while (1) switch (_context18.n) {
                                          case 0:
                                            _context18.n = 1;
                                            return fetch(atlasDataUrl);

                                          case 1:
                                            response = _context18.v;
                                            if (response.ok) {
                                                _context18.n = 2;
                                                break;
                                            }
                                            throw new Error("Failed to load font data: ".concat(response.statusText));

                                          case 2:
                                            _context18.n = 3;
                                            return response.json();

                                          case 3:
                                            fontData = _context18.v;
                                            if (!(!fontData || !fontData.chars)) {
                                                _context18.n = 4;
                                                break;
                                            }
                                            throw new Error("Invalid SDF font data format");

                                          case 4:
                                            if (atlasUrl) {
                                                _context18.n = 5;
                                                break;
                                            }
                                            throw new Error("Atlas texture must be provided for SDF fonts");

                                          case 5:
                                            return _context18.a(2, new Promise(function(resolve, reject) {
                                                var atlasTexture = stage.txManager.createTexture("ImageTexture", {
                                                    src: atlasUrl,
                                                    premultiplyAlpha: false
                                                });
                                                atlasTexture.setRenderableOwner(fontFamily, true);
                                                atlasTexture.preventCleanup = true;
                                                if (atlasTexture.state === "loaded") {
                                                    processFontData$1(fontFamily, fontData, atlasTexture, metrics);
                                                    fontLoadPromises$1.delete(fontFamily);
                                                    for (var key in nwff) {
                                                        nwff[key].setUpdateType(UpdateType.Local);
                                                    }
                                                    delete nodesWaitingForFont$1[fontFamily];
                                                    return resolve();
                                                }
                                                atlasTexture.on("loaded", function() {
                                                    processFontData$1(fontFamily, fontData, atlasTexture, metrics);
                                                    fontLoadPromises$1.delete(fontFamily);
                                                    for (var _key1 in nwff) {
                                                        nwff[_key1].setUpdateType(UpdateType.Local);
                                                    }
                                                    delete nodesWaitingForFont$1[fontFamily];
                                                    resolve();
                                                });
                                                atlasTexture.on("failed", function(error) {
                                                    fontLoadPromises$1.delete(fontFamily);
                                                    if (fontCache$1[fontFamily]) {
                                                        delete fontCache$1[fontFamily];
                                                    }
                                                    console.error("Failed to load SDF font: ".concat(fontFamily), error);
                                                    reject(error);
                                                });
                                            }));
                                        }
                                    }, _callee18);
                                }))();
                                fontLoadPromises$1.set(fontFamily, loadPromise);
                                return _context19.a(2, loadPromise);
                            }
                        }, _callee19);
                    }));
                    return function loadFont$1(_x26, _x27) {
                        return _ref57.apply(this, arguments);
                    };
                }();
                var waitingForFont$1 = function waitingForFont$1(fontFamily, node) {
                    if (nodesWaitingForFont$1[fontFamily] === undefined) {
                        return;
                    }
                    nodesWaitingForFont$1[fontFamily][node.id] = node;
                };
                var stopWaitingForFont$1 = function stopWaitingForFont$1(fontFamily, node) {
                    if (nodesWaitingForFont$1[fontFamily] === undefined) {
                        return;
                    }
                    delete nodesWaitingForFont$1[fontFamily][node.id];
                };
                var getFontFamilies$1 = function getFontFamilies$1() {
                    var families = {};
                    return families;
                };
                var init$3 = function init$3(c) {
                    if (initialized$1 === true) {
                        return;
                    }
                    initialized$1 = true;
                };
                var type$3 = "sdf";
                var isFontLoaded$1 = function isFontLoaded$1(fontFamily) {
                    return fontCache$1.has(fontFamily);
                };
                var getFontMetrics$1 = function getFontMetrics$1(fontFamily, fontSize) {
                    var out = normalizedMetrics$1.get(fontFamily);
                    if (out !== undefined) {
                        return out;
                    }
                    var metrics = fontCache$1.get(fontFamily).metrics;
                    return processFontMetrics$1(fontFamily, fontSize, metrics);
                };
                var processFontMetrics$1 = function processFontMetrics$1(fontFamily, fontSize, metrics) {
                    var label = fontFamily + fontSize;
                    var normalized = normalizeFontMetrics(metrics, fontSize);
                    normalizedMetrics$1.set(label, normalized);
                    return normalized;
                };
                var getGlyph = function getGlyph(fontFamily, codepoint) {
                    var cache = fontCache$1.get(fontFamily);
                    if (cache === undefined) return null;
                    return cache.glyphMap.get(codepoint) || cache.glyphMap.get(63) || null;
                };
                var getKerning = function getKerning(fontFamily, firstGlyph, secondGlyph) {
                    var cache = fontCache$1.get(fontFamily);
                    if (cache === undefined) return 0;
                    var seconds = cache.kernings[secondGlyph];
                    return seconds ? seconds[firstGlyph] || 0 : 0;
                };
                var getAtlas = function getAtlas(fontFamily) {
                    var cache = fontCache$1.get(fontFamily);
                    return cache !== undefined ? cache.atlasTexture : null;
                };
                var getFontData = function getFontData(fontFamily) {
                    return fontCache$1.get(fontFamily);
                };
                var getMaxCharHeight = function getMaxCharHeight(fontFamily) {
                    var cache = fontCache$1.get(fontFamily);
                    return cache !== undefined ? cache.maxCharHeight : 0;
                };
                var getLoadedFonts = function getLoadedFonts() {
                    return Array.from(fontCache$1.keys());
                };
                var unloadFont = function unloadFont(fontFamily) {
                    var cache = fontCache$1.get(fontFamily);
                    if (cache !== undefined) {
                        if (typeof cache.atlasTexture.free === "function") {
                            cache.atlasTexture.free();
                        }
                        fontCache$1.delete(fontFamily);
                    }
                };
                var measureText$1 = function measureText$1(text, fontFamily, letterSpacing) {
                    if (text.length === 1) {
                        var char = text.charAt(0);
                        var codepoint = text.codePointAt(0);
                        if (codepoint === undefined) return 0;
                        if (hasZeroWidthSpace(char) === true) return 0;
                        var glyph = getGlyph(fontFamily, codepoint);
                        if (glyph === null) return 0;
                        return glyph.xadvance + letterSpacing;
                    }
                    var width = 0;
                    var prevCodepoint = 0;
                    for (var i = 0; i < text.length; i++) {
                        var _char3 = text.charAt(i);
                        var _codepoint = text.codePointAt(i);
                        if (_codepoint === undefined) continue;
                        if (hasZeroWidthSpace(_char3)) {
                            continue;
                        }
                        var _glyph = getGlyph(fontFamily, _codepoint);
                        if (_glyph === null) continue;
                        var advance = _glyph.xadvance;
                        if (prevCodepoint !== 0) {
                            var kerning = getKerning(fontFamily, prevCodepoint, _codepoint);
                            advance += kerning;
                        }
                        width += advance + letterSpacing;
                        prevCodepoint = _codepoint;
                    }
                    return width;
                };
                var SdfFontHandler = Object.freeze(Object.defineProperty({
                    __proto__: null,
                    canRenderFont: canRenderFont$1,
                    getAtlas: getAtlas,
                    getFontData: getFontData,
                    getFontFamilies: getFontFamilies$1,
                    getFontMetrics: getFontMetrics$1,
                    getGlyph: getGlyph,
                    getKerning: getKerning,
                    getLoadedFonts: getLoadedFonts,
                    getMaxCharHeight: getMaxCharHeight,
                    init: init$3,
                    isFontLoaded: isFontLoaded$1,
                    loadFont: loadFont$1,
                    measureText: measureText$1,
                    processFontMetrics: processFontMetrics$1,
                    stopWaitingForFont: stopWaitingForFont$1,
                    type: type$3,
                    unloadFont: unloadFont,
                    waitingForFont: waitingForFont$1
                }, Symbol.toStringTag, {
                    value: "Module"
                }));
                function getWebGlParameters(glw) {
                    var params = {
                        MAX_RENDERBUFFER_SIZE: 0,
                        MAX_TEXTURE_SIZE: 0,
                        MAX_VIEWPORT_DIMS: 0,
                        MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0,
                        MAX_TEXTURE_IMAGE_UNITS: 0,
                        MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0,
                        MAX_VERTEX_ATTRIBS: 0,
                        MAX_VARYING_VECTORS: 0,
                        MAX_VERTEX_UNIFORM_VECTORS: 0,
                        MAX_FRAGMENT_UNIFORM_VECTORS: 0
                    };
                    var keys = Object.keys(params);
                    keys.forEach(function(key) {
                        params[key] = glw.getParameter(glw[key]);
                    });
                    return params;
                }
                function getWebGlExtensions(glw) {
                    var extensions = {
                        ANGLE_instanced_arrays: null,
                        WEBGL_compressed_texture_s3tc: null,
                        WEBGL_compressed_texture_astc: null,
                        WEBGL_compressed_texture_etc: null,
                        WEBGL_compressed_texture_etc1: null,
                        WEBGL_compressed_texture_pvrtc: null,
                        WEBKIT_WEBGL_compressed_texture_pvrtc: null,
                        WEBGL_compressed_texture_s3tc_srgb: null,
                        OES_vertex_array_object: null
                    };
                    var keys = Object.keys(extensions);
                    keys.forEach(function(key) {
                        extensions[key] = glw.getExtension(key);
                    });
                    return extensions;
                }
                function createIndexBuffer(glw, size) {
                    var maxQuads = ~~(size / 80);
                    var indices = new Uint16Array(maxQuads * 6);
                    for (var i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
                        indices[i] = j;
                        indices[i + 1] = j + 1;
                        indices[i + 2] = j + 2;
                        indices[i + 3] = j + 2;
                        indices[i + 4] = j + 1;
                        indices[i + 5] = j + 3;
                    }
                    var buffer = glw.createBuffer();
                    glw.elementArrayBufferData(buffer, indices, glw.STATIC_DRAW);
                }
                function isHTMLImageElement(obj) {
                    return obj !== null && (_typeof(obj) === "object" && obj.constructor && obj.constructor.name === "HTMLImageElement" || typeof HTMLImageElement !== "undefined" && obj instanceof HTMLImageElement);
                }
                var TRANSPARENT_TEXTURE_DATA = new Uint8Array([ 0, 0, 0, 0 ]);
                var WebGlCtxTexture = function(_CoreContextTexture2) {
                    function WebGlCtxTexture(glw, memManager, textureSource) {
                        var _this38;
                        _classCallCheck(this, WebGlCtxTexture);
                        _this38 = _callSuper(this, WebGlCtxTexture, [ memManager, textureSource ]);
                        _defineProperty(_this38, "glw", void 0);
                        _defineProperty(_this38, "_nativeCtxTexture", null);
                        _defineProperty(_this38, "_w", 0);
                        _defineProperty(_this38, "_h", 0);
                        _defineProperty(_this38, "txCoords", {
                            x1: 0,
                            y1: 0,
                            x2: 1,
                            y2: 1
                        });
                        _this38.glw = glw;
                        return _this38;
                    }
                    _inherits(WebGlCtxTexture, _CoreContextTexture2);
                    return _createClass(WebGlCtxTexture, [ {
                        key: "checkGLError",
                        value: function checkGLError() {
                            if (this.state === "failed") {
                                return true;
                            }
                            return false;
                        }
                    }, {
                        key: "ctxTexture",
                        get: function get() {
                            if (this.state === "freed") {
                                this.load();
                                return null;
                            }
                            return this._nativeCtxTexture;
                        }
                    }, {
                        key: "w",
                        get: function get() {
                            return this._w;
                        }
                    }, {
                        key: "h",
                        get: function get() {
                            return this._h;
                        }
                    }, {
                        key: "load",
                        value: function() {
                            var _load = _asyncToGenerator(_regenerator().m(function _callee20() {
                                var error, _yield$this$onLoadReq, w, h, _error, _t7;
                                return _regenerator().w(function(_context20) {
                                    while (1) switch (_context20.p = _context20.n) {
                                      case 0:
                                        if (!(this.state === "loading" || this.state === "loaded")) {
                                            _context20.n = 1;
                                            break;
                                        }
                                        return _context20.a(2, Promise.resolve());

                                      case 1:
                                        this.state = "loading";
                                        this.textureSource.setState("loading");
                                        this._nativeCtxTexture = this.createNativeCtxTexture();
                                        if (!(this._nativeCtxTexture === null)) {
                                            _context20.n = 2;
                                            break;
                                        }
                                        this.state = "failed";
                                        error = new Error("Could not create WebGL Texture");
                                        this.textureSource.setState("failed", error);
                                        console.error("Could not create WebGL Texture");
                                        throw error;

                                      case 2:
                                        _context20.p = 2;
                                        _context20.n = 3;
                                        return this.onLoadRequest();

                                      case 3:
                                        _yield$this$onLoadReq = _context20.v;
                                        w = _yield$this$onLoadReq.w;
                                        h = _yield$this$onLoadReq.h;
                                        if (!(this.state === "freed")) {
                                            _context20.n = 4;
                                            break;
                                        }
                                        return _context20.a(2);

                                      case 4:
                                        this.state = "loaded";
                                        this._w = w;
                                        this._h = h;
                                        this.textureSource.setState("loaded", {
                                            w: w,
                                            h: h
                                        });
                                        this.textureSource.freeTextureData();
                                        _context20.n = 7;
                                        break;

                                      case 5:
                                        _context20.p = 5;
                                        _t7 = _context20.v;
                                        if (!(this.state === "freed")) {
                                            _context20.n = 6;
                                            break;
                                        }
                                        return _context20.a(2);

                                      case 6:
                                        this.state = "failed";
                                        _error = _t7 instanceof Error ? _t7 : new Error(String(_t7));
                                        this.textureSource.setState("failed", _error);
                                        this.textureSource.freeTextureData();
                                        console.error(_t7);
                                        throw _error;

                                      case 7:
                                        return _context20.a(2);
                                    }
                                }, _callee20, this, [ [ 2, 5 ] ]);
                            }));
                            function load() {
                                return _load.apply(this, arguments);
                            }
                            return load;
                        }()
                    }, {
                        key: "onLoadRequest",
                        value: function() {
                            var _onLoadRequest = _asyncToGenerator(_regenerator().m(function _callee21() {
                                var _textureData$enableAl;
                                var glw, textureData, w, h, tdata, alpha, format, formatBytes, memoryPadding, isImageBitmap, _mipmaps$0$byteLength, _mipmaps$, mipmaps, _type2, blockInfo;
                                return _regenerator().w(function(_context21) {
                                    while (1) switch (_context21.n) {
                                      case 0:
                                        glw = this.glw;
                                        textureData = this.textureSource.textureData;
                                        if (!(textureData === null || this._nativeCtxTexture === null)) {
                                            _context21.n = 1;
                                            break;
                                        }
                                        throw new Error("Texture data or native texture is null " + this.textureSource.type);

                                      case 1:
                                        glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                                        this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
                                        w = 0;
                                        h = 0;
                                        glw.activeTexture(0);
                                        tdata = textureData.data;
                                        alpha = (_textureData$enableAl = textureData.enableAlphaChannel) !== null && _textureData$enableAl !== void 0 ? _textureData$enableAl : false;
                                        format = alpha ? glw.RGBA : glw.RGB;
                                        formatBytes = alpha ? 4 : 3;
                                        memoryPadding = 1.1;
                                        isImageBitmap = typeof ImageBitmap !== "undefined" && tdata instanceof ImageBitmap;
                                        if (!(isImageBitmap || tdata instanceof ImageData || isHTMLImageElement(tdata) === true)) {
                                            _context21.n = 3;
                                            break;
                                        }
                                        w = tdata.width;
                                        h = tdata.height;
                                        glw.bindTexture(this._nativeCtxTexture);
                                        glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, isImageBitmap ? false : !!textureData.premultiplyAlpha);
                                        glw.texImage2D(0, format, format, glw.UNSIGNED_BYTE, tdata);
                                        if (!(this.checkGLError() === true)) {
                                            _context21.n = 2;
                                            break;
                                        }
                                        return _context21.a(2, {
                                            w: 0,
                                            h: 0
                                        });

                                      case 2:
                                        this.setTextureMemUse(h * w * formatBytes * memoryPadding);
                                        _context21.n = 9;
                                        break;

                                      case 3:
                                        if (!(tdata === null)) {
                                            _context21.n = 4;
                                            break;
                                        }
                                        w = 0;
                                        h = 0;
                                        glw.bindTexture(this._nativeCtxTexture);
                                        glw.texImage2D(0, format, 1, 1, 0, format, glw.UNSIGNED_BYTE, TRANSPARENT_TEXTURE_DATA);
                                        this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
                                        _context21.n = 9;
                                        break;

                                      case 4:
                                        if (!("mipmaps" in tdata && tdata.mipmaps)) {
                                            _context21.n = 6;
                                            break;
                                        }
                                        mipmaps = tdata.mipmaps, _type2 = tdata.type, blockInfo = tdata.blockInfo;
                                        uploadCompressedTexture[_type2](glw, this._nativeCtxTexture, tdata);
                                        if (!(this.checkGLError() === true)) {
                                            _context21.n = 5;
                                            break;
                                        }
                                        return _context21.a(2, {
                                            w: 0,
                                            h: 0
                                        });

                                      case 5:
                                        w = tdata.w;
                                        h = tdata.h;
                                        this.txCoords.x2 = w / (Math.ceil(w / blockInfo.width) * blockInfo.width);
                                        this.txCoords.y2 = h / (Math.ceil(h / blockInfo.height) * blockInfo.height);
                                        this.setTextureMemUse((_mipmaps$0$byteLength = (_mipmaps$ = mipmaps[0]) === null || _mipmaps$ === void 0 ? void 0 : _mipmaps$.byteLength) !== null && _mipmaps$0$byteLength !== void 0 ? _mipmaps$0$byteLength : 0);
                                        _context21.n = 9;
                                        break;

                                      case 6:
                                        if (!(tdata && tdata instanceof Uint8Array)) {
                                            _context21.n = 8;
                                            break;
                                        }
                                        w = 1;
                                        h = 1;
                                        glw.bindTexture(this._nativeCtxTexture);
                                        glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
                                        glw.texImage2D(0, format, w, h, 0, format, glw.UNSIGNED_BYTE, tdata);
                                        if (!(this.checkGLError() === true)) {
                                            _context21.n = 7;
                                            break;
                                        }
                                        return _context21.a(2, {
                                            w: 0,
                                            h: 0
                                        });

                                      case 7:
                                        this.setTextureMemUse(w * h * formatBytes);
                                        _context21.n = 9;
                                        break;

                                      case 8:
                                        throw new Error("WebGlCoreCtxTexture.onLoadRequest: Unexpected textureData returned");

                                      case 9:
                                        return _context21.a(2, {
                                            w: w,
                                            h: h
                                        });
                                    }
                                }, _callee21, this);
                            }));
                            function onLoadRequest() {
                                return _onLoadRequest.apply(this, arguments);
                            }
                            return onLoadRequest;
                        }()
                    }, {
                        key: "free",
                        value: function free() {
                            if (this.state === "freed") {
                                return;
                            }
                            this.state = "freed";
                            this.textureSource.setState("freed");
                            this.release();
                        }
                    }, {
                        key: "release",
                        value: function release() {
                            this._w = 0;
                            this._h = 0;
                            if (this._nativeCtxTexture !== null) {
                                this.glw.deleteTexture(this._nativeCtxTexture);
                                this.setTextureMemUse(0);
                                this._nativeCtxTexture = null;
                            }
                            this.textureSource.freeTextureData();
                        }
                    }, {
                        key: "createNativeCtxTexture",
                        value: function createNativeCtxTexture() {
                            var glw = this.glw;
                            var nativeTexture = glw.createTexture();
                            if (!nativeTexture) {
                                return null;
                            }
                            glw.activeTexture(0);
                            glw.bindTexture(nativeTexture);
                            glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                            glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
                            glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                            glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                            return nativeTexture;
                        }
                    } ]);
                }(CoreContextTexture);
                var WebGlCtxSubTexture = function(_WebGlCtxTexture2) {
                    function WebGlCtxSubTexture(glw, memManager, textureSource) {
                        _classCallCheck(this, WebGlCtxSubTexture);
                        return _callSuper(this, WebGlCtxSubTexture, [ glw, memManager, textureSource ]);
                    }
                    _inherits(WebGlCtxSubTexture, _WebGlCtxTexture2);
                    return _createClass(WebGlCtxSubTexture, [ {
                        key: "onLoadRequest",
                        value: function() {
                            var _onLoadRequest2 = _asyncToGenerator(_regenerator().m(function _callee22() {
                                var props;
                                return _regenerator().w(function(_context22) {
                                    while (1) switch (_context22.n) {
                                      case 0:
                                        props = this.textureSource.textureData;
                                        if (!(props.data instanceof Uint8Array)) {
                                            _context22.n = 1;
                                            break;
                                        }
                                        return _context22.a(2, {
                                            w: 1,
                                            h: 1
                                        });

                                      case 1:
                                        return _context22.a(2, this.extractDimensions(props.data));
                                    }
                                }, _callee22, this);
                            }));
                            function onLoadRequest() {
                                return _onLoadRequest2.apply(this, arguments);
                            }
                            return onLoadRequest;
                        }()
                    }, {
                        key: "extractDimensions",
                        value: function extractDimensions(data) {
                            if (data === null) {
                                return {
                                    w: 0,
                                    h: 0
                                };
                            }
                            if (this.hasWidthHeight(data) === true) {
                                return {
                                    w: data.width,
                                    h: data.height
                                };
                            }
                            if (this.hasWH(data) === true) {
                                return {
                                    w: data.w,
                                    h: data.h
                                };
                            }
                            return {
                                w: 0,
                                h: 0
                            };
                        }
                    }, {
                        key: "hasWidthHeight",
                        value: function hasWidthHeight(data) {
                            return typeof data.width === "number" && typeof data.height === "number";
                        }
                    }, {
                        key: "hasWH",
                        value: function hasWH(data) {
                            return typeof data.w === "number" && typeof data.h === "number";
                        }
                    } ]);
                }(WebGlCtxTexture);
                var BufferCollection = function() {
                    function BufferCollection(config) {
                        _classCallCheck(this, BufferCollection);
                        _defineProperty(this, "config", void 0);
                        this.config = config;
                    }
                    return _createClass(BufferCollection, [ {
                        key: "getBuffer",
                        value: function getBuffer(attributeName) {
                            var _this$config$find;
                            return (_this$config$find = this.config.find(function(item) {
                                return item.attributes[attributeName];
                            })) === null || _this$config$find === void 0 ? void 0 : _this$config$find.buffer;
                        }
                    }, {
                        key: "getAttributeInfo",
                        value: function getAttributeInfo(attributeName) {
                            var _this$config$find2;
                            return (_this$config$find2 = this.config.find(function(item) {
                                return item.attributes[attributeName];
                            })) === null || _this$config$find2 === void 0 ? void 0 : _this$config$find2.attributes[attributeName];
                        }
                    } ]);
                }();
                function _isWebGl(gl) {
                    return self.WebGL2RenderingContext && gl instanceof self.WebGL2RenderingContext;
                }
                var WebGlContextWrapper = function() {
                    function WebGlContextWrapper(gl) {
                        var _this39 = this;
                        _classCallCheck(this, WebGlContextWrapper);
                        _defineProperty(this, "gl", void 0);
                        _defineProperty(this, "activeTextureUnit", 0);
                        _defineProperty(this, "texture2dUnits", void 0);
                        _defineProperty(this, "texture2dParams", new WeakMap);
                        _defineProperty(this, "scissorEnabled", void 0);
                        _defineProperty(this, "scissorX", void 0);
                        _defineProperty(this, "scissorY", void 0);
                        _defineProperty(this, "scissorWidth", void 0);
                        _defineProperty(this, "scissorHeight", void 0);
                        _defineProperty(this, "blendEnabled", void 0);
                        _defineProperty(this, "blendSrcRgb", void 0);
                        _defineProperty(this, "blendDstRgb", void 0);
                        _defineProperty(this, "blendSrcAlpha", void 0);
                        _defineProperty(this, "blendDstAlpha", void 0);
                        _defineProperty(this, "boundArrayBuffer", void 0);
                        _defineProperty(this, "boundElementArrayBuffer", void 0);
                        _defineProperty(this, "curProgram", void 0);
                        _defineProperty(this, "curUniformLocations", {});
                        _defineProperty(this, "canvas", void 0);
                        _defineProperty(this, "MAX_RENDERBUFFER_SIZE", void 0);
                        _defineProperty(this, "MAX_TEXTURE_SIZE", void 0);
                        _defineProperty(this, "MAX_VIEWPORT_DIMS", void 0);
                        _defineProperty(this, "MAX_VERTEX_TEXTURE_IMAGE_UNITS", void 0);
                        _defineProperty(this, "MAX_TEXTURE_IMAGE_UNITS", void 0);
                        _defineProperty(this, "MAX_COMBINED_TEXTURE_IMAGE_UNITS", void 0);
                        _defineProperty(this, "MAX_VERTEX_ATTRIBS", void 0);
                        _defineProperty(this, "MAX_VARYING_VECTORS", void 0);
                        _defineProperty(this, "MAX_VERTEX_UNIFORM_VECTORS", void 0);
                        _defineProperty(this, "MAX_FRAGMENT_UNIFORM_VECTORS", void 0);
                        _defineProperty(this, "TEXTURE_MAG_FILTER", void 0);
                        _defineProperty(this, "TEXTURE_MIN_FILTER", void 0);
                        _defineProperty(this, "TEXTURE_WRAP_S", void 0);
                        _defineProperty(this, "TEXTURE_WRAP_T", void 0);
                        _defineProperty(this, "LINEAR", void 0);
                        _defineProperty(this, "LINEAR_MIPMAP_LINEAR", void 0);
                        _defineProperty(this, "CLAMP_TO_EDGE", void 0);
                        _defineProperty(this, "RGB", void 0);
                        _defineProperty(this, "RGBA", void 0);
                        _defineProperty(this, "UNSIGNED_BYTE", void 0);
                        _defineProperty(this, "UNPACK_PREMULTIPLY_ALPHA_WEBGL", void 0);
                        _defineProperty(this, "UNPACK_FLIP_Y_WEBGL", void 0);
                        _defineProperty(this, "FLOAT", void 0);
                        _defineProperty(this, "TRIANGLES", void 0);
                        _defineProperty(this, "UNSIGNED_SHORT", void 0);
                        _defineProperty(this, "ONE", void 0);
                        _defineProperty(this, "ONE_MINUS_SRC_ALPHA", void 0);
                        _defineProperty(this, "VERTEX_SHADER", void 0);
                        _defineProperty(this, "FRAGMENT_SHADER", void 0);
                        _defineProperty(this, "STATIC_DRAW", void 0);
                        _defineProperty(this, "COMPILE_STATUS", void 0);
                        _defineProperty(this, "LINK_STATUS", void 0);
                        _defineProperty(this, "DYNAMIC_DRAW", void 0);
                        _defineProperty(this, "COLOR_ATTACHMENT0", void 0);
                        _defineProperty(this, "INVALID_ENUM", void 0);
                        _defineProperty(this, "INVALID_OPERATION", void 0);
                        this.gl = gl;
                        this.activeTextureUnit = gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
                        var maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                        this.texture2dUnits = new Array(maxTextureUnits).fill(undefined).map(function(_, i) {
                            _this39.activeTexture(i);
                            return gl.getParameter(gl.TEXTURE_BINDING_2D);
                        });
                        this.activeTexture(this.activeTextureUnit);
                        this.scissorEnabled = gl.isEnabled(gl.SCISSOR_TEST);
                        var scissorBox = gl.getParameter(gl.SCISSOR_BOX);
                        this.scissorX = scissorBox[0];
                        this.scissorY = scissorBox[1];
                        this.scissorWidth = scissorBox[2];
                        this.scissorHeight = scissorBox[3];
                        this.blendEnabled = gl.isEnabled(gl.BLEND);
                        this.blendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
                        this.blendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
                        this.blendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
                        this.blendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
                        this.boundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
                        this.boundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
                        this.curProgram = gl.getParameter(gl.CURRENT_PROGRAM);
                        this.canvas = gl.canvas;
                        this.MAX_RENDERBUFFER_SIZE = gl.MAX_RENDERBUFFER_SIZE;
                        this.MAX_TEXTURE_SIZE = gl.MAX_TEXTURE_SIZE;
                        this.MAX_VIEWPORT_DIMS = gl.MAX_VIEWPORT_DIMS;
                        this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
                        this.MAX_TEXTURE_IMAGE_UNITS = gl.MAX_TEXTURE_IMAGE_UNITS;
                        this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
                        this.MAX_VERTEX_ATTRIBS = gl.MAX_VERTEX_ATTRIBS;
                        this.MAX_VARYING_VECTORS = gl.MAX_VARYING_VECTORS;
                        this.MAX_VERTEX_UNIFORM_VECTORS = gl.MAX_VERTEX_UNIFORM_VECTORS;
                        this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.MAX_FRAGMENT_UNIFORM_VECTORS;
                        this.TEXTURE_MAG_FILTER = gl.TEXTURE_MAG_FILTER;
                        this.TEXTURE_MIN_FILTER = gl.TEXTURE_MIN_FILTER;
                        this.TEXTURE_WRAP_S = gl.TEXTURE_WRAP_S;
                        this.TEXTURE_WRAP_T = gl.TEXTURE_WRAP_T;
                        this.LINEAR = gl.LINEAR;
                        this.LINEAR_MIPMAP_LINEAR = gl.LINEAR_MIPMAP_LINEAR;
                        this.CLAMP_TO_EDGE = gl.CLAMP_TO_EDGE;
                        this.RGB = gl.RGB;
                        this.RGBA = gl.RGBA;
                        this.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
                        this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
                        this.UNPACK_FLIP_Y_WEBGL = gl.UNPACK_FLIP_Y_WEBGL;
                        this.FLOAT = gl.FLOAT;
                        this.TRIANGLES = gl.TRIANGLES;
                        this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
                        this.ONE = gl.ONE;
                        this.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
                        this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
                        this.TRIANGLES = gl.TRIANGLES;
                        this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
                        this.VERTEX_SHADER = gl.VERTEX_SHADER;
                        this.FRAGMENT_SHADER = gl.FRAGMENT_SHADER;
                        this.STATIC_DRAW = gl.STATIC_DRAW;
                        this.COMPILE_STATUS = gl.COMPILE_STATUS;
                        this.LINK_STATUS = gl.LINK_STATUS;
                        this.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;
                        this.COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
                        this.INVALID_ENUM = gl.INVALID_ENUM;
                        this.INVALID_OPERATION = gl.INVALID_OPERATION;
                    }
                    return _createClass(WebGlContextWrapper, [ {
                        key: "isWebGl2",
                        value: function isWebGl2() {
                            return _isWebGl(this.gl);
                        }
                    }, {
                        key: "activeTexture",
                        value: function activeTexture(textureUnit) {
                            if (this.activeTextureUnit !== textureUnit) {
                                this.gl.activeTexture(textureUnit + this.gl.TEXTURE0);
                                this.activeTextureUnit = textureUnit;
                            }
                        }
                    }, {
                        key: "bindTexture",
                        value: function bindTexture(texture) {
                            if (this.texture2dUnits[this.activeTextureUnit] === texture) {
                                return;
                            }
                            this.texture2dUnits[this.activeTextureUnit] = texture;
                            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
                        }
                    }, {
                        key: "_getActiveTexture",
                        value: function _getActiveTexture() {
                            return this.texture2dUnits[this.activeTextureUnit];
                        }
                    }, {
                        key: "texParameteri",
                        value: function texParameteri(pname, param) {
                            var activeTexture = this._getActiveTexture();
                            if (!activeTexture) {
                                throw new Error("No active texture");
                            }
                            var textureParams = this.texture2dParams.get(activeTexture);
                            if (!textureParams) {
                                textureParams = {};
                                this.texture2dParams.set(activeTexture, textureParams);
                            }
                            if (textureParams[pname] === param) {
                                return;
                            }
                            textureParams[pname] = param;
                            this.gl.texParameteri(this.gl.TEXTURE_2D, pname, param);
                        }
                    }, {
                        key: "texImage2D",
                        value: function texImage2D(level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels) {
                            if (format) {
                                this.gl.texImage2D(this.gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels);
                            } else {
                                this.gl.texImage2D(this.gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource);
                            }
                        }
                    }, {
                        key: "compressedTexImage2D",
                        value: function compressedTexImage2D(level, internalformat, width, height, border, data) {
                            this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, level, internalformat, width, height, border, data);
                        }
                    }, {
                        key: "pixelStorei",
                        value: function pixelStorei(pname, param) {
                            this.gl.pixelStorei(pname, param);
                        }
                    }, {
                        key: "generateMipmap",
                        value: function generateMipmap() {
                            this.gl.generateMipmap(this.gl.TEXTURE_2D);
                        }
                    }, {
                        key: "createTexture",
                        value: function createTexture() {
                            return this.gl.createTexture();
                        }
                    }, {
                        key: "deleteTexture",
                        value: function deleteTexture(texture) {
                            if (texture) {
                                this.texture2dParams.delete(texture);
                            }
                            this.gl.deleteTexture(texture);
                        }
                    }, {
                        key: "deleteFramebuffer",
                        value: function deleteFramebuffer(framebuffer) {
                            this.gl.deleteFramebuffer(framebuffer);
                        }
                    }, {
                        key: "viewport",
                        value: function viewport(x, y, width, height) {
                            this.gl.viewport(x, y, width, height);
                        }
                    }, {
                        key: "clearColor",
                        value: function clearColor(red, green, blue, alpha) {
                            this.gl.clearColor(red, green, blue, alpha);
                        }
                    }, {
                        key: "setScissorTest",
                        value: function setScissorTest(enable) {
                            if (enable === this.scissorEnabled) {
                                return;
                            }
                            if (enable) {
                                this.gl.enable(this.gl.SCISSOR_TEST);
                            } else {
                                this.gl.disable(this.gl.SCISSOR_TEST);
                            }
                            this.scissorEnabled = enable;
                        }
                    }, {
                        key: "scissor",
                        value: function scissor(x, y, width, height) {
                            if (x !== this.scissorX || y !== this.scissorY || width !== this.scissorWidth || height !== this.scissorHeight) {
                                this.gl.scissor(x, y, width, height);
                                this.scissorX = x;
                                this.scissorY = y;
                                this.scissorWidth = width;
                                this.scissorHeight = height;
                            }
                        }
                    }, {
                        key: "setBlend",
                        value: function setBlend(blend) {
                            if (blend === this.blendEnabled) {
                                return;
                            }
                            if (blend) {
                                this.gl.enable(this.gl.BLEND);
                            } else {
                                this.gl.disable(this.gl.BLEND);
                            }
                            this.blendEnabled = blend;
                        }
                    }, {
                        key: "blendFunc",
                        value: function blendFunc(src, dst) {
                            if (src !== this.blendSrcRgb || dst !== this.blendDstRgb || src !== this.blendSrcAlpha || dst !== this.blendDstAlpha) {
                                this.gl.blendFunc(src, dst);
                                this.blendSrcRgb = src;
                                this.blendDstRgb = dst;
                                this.blendSrcAlpha = src;
                                this.blendDstAlpha = dst;
                            }
                        }
                    }, {
                        key: "createBuffer",
                        value: function createBuffer() {
                            return this.gl.createBuffer();
                        }
                    }, {
                        key: "createFramebuffer",
                        value: function createFramebuffer() {
                            return this.gl.createFramebuffer();
                        }
                    }, {
                        key: "bindFramebuffer",
                        value: function bindFramebuffer(framebuffer) {
                            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, framebuffer);
                        }
                    }, {
                        key: "framebufferTexture2D",
                        value: function framebufferTexture2D(attachment, texture, level) {
                            var gl = this.gl;
                            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
                        }
                    }, {
                        key: "clear",
                        value: function clear() {
                            this.gl.clear(this.gl.COLOR_BUFFER_BIT);
                        }
                    }, {
                        key: "arrayBufferData",
                        value: function arrayBufferData(buffer, data, usage) {
                            if (this.boundArrayBuffer !== buffer) {
                                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                                this.boundArrayBuffer = buffer;
                            }
                            this.gl.bufferData(this.gl.ARRAY_BUFFER, data, usage);
                        }
                    }, {
                        key: "elementArrayBufferData",
                        value: function elementArrayBufferData(buffer, data, usage) {
                            if (this.boundElementArrayBuffer !== buffer) {
                                this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
                                this.boundElementArrayBuffer = buffer;
                            }
                            this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, data, usage);
                        }
                    }, {
                        key: "vertexAttribPointer",
                        value: function vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
                            if (this.boundArrayBuffer !== buffer) {
                                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
                                this.boundArrayBuffer = buffer;
                            }
                            this.gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
                        }
                    }, {
                        key: "getUniformLocations",
                        value: function getUniformLocations(program) {
                            var gl = this.gl;
                            var length = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                            var result = {};
                            for (var i = 0; i < length; i++) {
                                var info = gl.getActiveUniform(program, i);
                                var name = info.name.replace(/\[.*?\]/g, "");
                                result[name] = gl.getUniformLocation(program, name);
                            }
                            return result;
                        }
                    }, {
                        key: "getAttributeLocations",
                        value: function getAttributeLocations(program) {
                            var gl = this.gl;
                            var length = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                            var result = [];
                            for (var i = 0; i < length; i++) {
                                var _gl$getActiveAttrib = gl.getActiveAttrib(program, i), name = _gl$getActiveAttrib.name;
                                result[gl.getAttribLocation(program, name)] = name;
                            }
                            return result;
                        }
                    }, {
                        key: "useProgram",
                        value: function useProgram(program, uniformLocations) {
                            if (this.curProgram === program) {
                                return;
                            }
                            this.gl.useProgram(program);
                            this.curProgram = program;
                            this.curUniformLocations = uniformLocations;
                        }
                    }, {
                        key: "uniform1f",
                        value: function uniform1f(location, v0) {
                            this.gl.uniform1f(this.curUniformLocations[location] || null, v0);
                        }
                    }, {
                        key: "uniform1fv",
                        value: function uniform1fv(location, value) {
                            this.gl.uniform1fv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform1i",
                        value: function uniform1i(location, v0) {
                            this.gl.uniform1i(this.curUniformLocations[location] || null, v0);
                        }
                    }, {
                        key: "uniform1iv",
                        value: function uniform1iv(location, value) {
                            this.gl.uniform1iv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform2f",
                        value: function uniform2f(location, v0, v1) {
                            this.gl.uniform2f(this.curUniformLocations[location] || null, v0, v1);
                        }
                    }, {
                        key: "uniform2fa",
                        value: function uniform2fa(location, value) {
                            this.gl.uniform2f(this.curUniformLocations[location] || null, value[0], value[1]);
                        }
                    }, {
                        key: "uniform2fv",
                        value: function uniform2fv(location, value) {
                            this.gl.uniform2fv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform2i",
                        value: function uniform2i(location, v0, v1) {
                            this.gl.uniform2i(this.curUniformLocations[location] || null, v0, v1);
                        }
                    }, {
                        key: "uniform2iv",
                        value: function uniform2iv(location, value) {
                            this.gl.uniform2iv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform3f",
                        value: function uniform3f(location, v0, v1, v2) {
                            this.gl.uniform3f(this.curUniformLocations[location] || null, v0, v1, v2);
                        }
                    }, {
                        key: "uniform3fa",
                        value: function uniform3fa(location, value) {
                            this.gl.uniform3f(this.curUniformLocations[location] || null, value[0], value[1], value[2]);
                        }
                    }, {
                        key: "uniform3fv",
                        value: function uniform3fv(location, value) {
                            this.gl.uniform3fv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform3i",
                        value: function uniform3i(location, v0, v1, v2) {
                            this.gl.uniform3i(this.curUniformLocations[location] || null, v0, v1, v2);
                        }
                    }, {
                        key: "uniform3iv",
                        value: function uniform3iv(location, value) {
                            this.gl.uniform3iv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform4f",
                        value: function uniform4f(location, v0, v1, v2, v3) {
                            this.gl.uniform4f(this.curUniformLocations[location] || null, v0, v1, v2, v3);
                        }
                    }, {
                        key: "uniform4fa",
                        value: function uniform4fa(location, value) {
                            this.gl.uniform4f(this.curUniformLocations[location] || null, value[0], value[1], value[2], value[3]);
                        }
                    }, {
                        key: "uniform4fv",
                        value: function uniform4fv(location, value) {
                            this.gl.uniform4fv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniform4i",
                        value: function uniform4i(location, v0, v1, v2, v3) {
                            this.gl.uniform4i(this.curUniformLocations[location] || null, v0, v1, v2, v3);
                        }
                    }, {
                        key: "uniform4iv",
                        value: function uniform4iv(location, value) {
                            this.gl.uniform4iv(this.curUniformLocations[location] || null, value);
                        }
                    }, {
                        key: "uniformMatrix2fv",
                        value: function uniformMatrix2fv(location, value) {
                            this.gl.uniformMatrix2fv(this.curUniformLocations[location] || null, false, value);
                        }
                    }, {
                        key: "uniformMatrix3fv",
                        value: function uniformMatrix3fv(location, value) {
                            this.gl.uniformMatrix3fv(this.curUniformLocations[location] || null, false, value);
                        }
                    }, {
                        key: "uniformMatrix4fv",
                        value: function uniformMatrix4fv(location, value) {
                            this.gl.uniformMatrix4fv(this.curUniformLocations[location] || null, false, value);
                        }
                    }, {
                        key: "getParameter",
                        value: function getParameter(pname) {
                            return this.gl.getParameter(pname);
                        }
                    }, {
                        key: "drawElements",
                        value: function drawElements(mode, count, type, offset) {
                            this.gl.drawElements(mode, count, type, offset);
                        }
                    }, {
                        key: "drawArrays",
                        value: function drawArrays(mode, first, count) {
                            this.gl.drawArrays(mode, first, count);
                        }
                    }, {
                        key: "getExtension",
                        value: function getExtension(name) {
                            return this.gl.getExtension(name);
                        }
                    }, {
                        key: "getError",
                        value: function getError() {
                            return this.gl.getError();
                        }
                    }, {
                        key: "createVertexArray",
                        value: function createVertexArray() {
                            if (this.gl instanceof WebGL2RenderingContext) {
                                return this.gl.createVertexArray();
                            }
                            return undefined;
                        }
                    }, {
                        key: "bindVertexArray",
                        value: function bindVertexArray(vertexArray) {
                            if (this.gl instanceof WebGL2RenderingContext) {
                                this.gl.bindVertexArray(vertexArray);
                            }
                        }
                    }, {
                        key: "getAttribLocation",
                        value: function getAttribLocation(program, name) {
                            return this.gl.getAttribLocation(program, name);
                        }
                    }, {
                        key: "getUniformLocation",
                        value: function getUniformLocation(program, name) {
                            return this.gl.getUniformLocation(program, name);
                        }
                    }, {
                        key: "enableVertexAttribArray",
                        value: function enableVertexAttribArray(index) {
                            this.gl.enableVertexAttribArray(index);
                        }
                    }, {
                        key: "disableVertexAttribArray",
                        value: function disableVertexAttribArray(index) {
                            this.gl.disableVertexAttribArray(index);
                        }
                    }, {
                        key: "createShader",
                        value: function createShader(type) {
                            return this.gl.createShader(type);
                        }
                    }, {
                        key: "compileShader",
                        value: function compileShader(shader) {
                            this.gl.compileShader(shader);
                        }
                    }, {
                        key: "attachShader",
                        value: function attachShader(program, shader) {
                            this.gl.attachShader(program, shader);
                        }
                    }, {
                        key: "linkProgram",
                        value: function linkProgram(program) {
                            this.gl.linkProgram(program);
                        }
                    }, {
                        key: "deleteProgram",
                        value: function deleteProgram(shader) {
                            this.gl.deleteProgram(shader);
                        }
                    }, {
                        key: "getShaderParameter",
                        value: function getShaderParameter(shader, pname) {
                            return this.gl.getShaderParameter(shader, pname);
                        }
                    }, {
                        key: "getShaderInfoLog",
                        value: function getShaderInfoLog(shader) {
                            return this.gl.getShaderInfoLog(shader);
                        }
                    }, {
                        key: "createProgram",
                        value: function createProgram() {
                            return this.gl.createProgram();
                        }
                    }, {
                        key: "getProgramParameter",
                        value: function getProgramParameter(program, pname) {
                            return this.gl.getProgramParameter(program, pname);
                        }
                    }, {
                        key: "getProgramInfoLog",
                        value: function getProgramInfoLog(program) {
                            return this.gl.getProgramInfoLog(program);
                        }
                    }, {
                        key: "shaderSource",
                        value: function shaderSource(shader, source) {
                            this.gl.shaderSource(shader, source);
                        }
                    }, {
                        key: "deleteShader",
                        value: function deleteShader(shader) {
                            this.gl.deleteShader(shader);
                        }
                    }, {
                        key: "deleteBuffer",
                        value: function deleteBuffer(buffer) {
                            var gl = this.gl;
                            gl.deleteBuffer(buffer);
                            if (this.boundArrayBuffer === buffer) {
                                this.boundArrayBuffer = null;
                            }
                        }
                    }, {
                        key: "deleteVertexArray",
                        value: function deleteVertexArray(vertexArray) {
                            if (this.isWebGl2()) {
                                this.gl.deleteVertexArray(vertexArray);
                            }
                        }
                    }, {
                        key: "checkError",
                        value: function checkError(operation) {
                            var error = this.getError();
                            if (error !== 0) {
                                var errorName = "UNKNOWN_ERROR";
                                switch (error) {
                                  case this.INVALID_ENUM:
                                    errorName = "INVALID_ENUM";
                                    break;

                                  case 1281:
                                    errorName = "INVALID_VALUE";
                                    break;

                                  case this.INVALID_OPERATION:
                                    errorName = "INVALID_OPERATION";
                                    break;

                                  case 1285:
                                    errorName = "OUT_OF_MEMORY";
                                    break;

                                  case 37442:
                                    errorName = "CONTEXT_LOST_WEBGL";
                                    break;
                                }
                                var message = "WebGL ".concat(errorName, " (0x").concat(error.toString(16), ") during ").concat(operation);
                                return {
                                    error: error,
                                    errorName: errorName,
                                    message: message
                                };
                            }
                            return null;
                        }
                    } ]);
                }();
                var WebGlCtxRenderTexture = function(_WebGlCtxTexture3) {
                    function WebGlCtxRenderTexture(glw, memManager, textureSource) {
                        var _this40;
                        _classCallCheck(this, WebGlCtxRenderTexture);
                        _this40 = _callSuper(this, WebGlCtxRenderTexture, [ glw, memManager, textureSource ]);
                        _defineProperty(_this40, "framebuffer", null);
                        _defineProperty(_this40, "txCoords", {
                            x1: 0,
                            y1: 1,
                            x2: 1,
                            y2: 0
                        });
                        return _this40;
                    }
                    _inherits(WebGlCtxRenderTexture, _WebGlCtxTexture3);
                    return _createClass(WebGlCtxRenderTexture, [ {
                        key: "onLoadRequest",
                        value: function() {
                            var _onLoadRequest3 = _asyncToGenerator(_regenerator().m(function _callee23() {
                                var glw, nativeTexture, _this$textureSource, w, h;
                                return _regenerator().w(function(_context23) {
                                    while (1) switch (_context23.n) {
                                      case 0:
                                        glw = this.glw;
                                        nativeTexture = this._nativeCtxTexture = this.createNativeCtxTexture();
                                        if (nativeTexture) {
                                            _context23.n = 1;
                                            break;
                                        }
                                        throw new Error("Failed to create native texture for RenderTexture");

                                      case 1:
                                        _this$textureSource = this.textureSource, w = _this$textureSource.w, h = _this$textureSource.h;
                                        this.framebuffer = glw.createFramebuffer();
                                        glw.texImage2D(0, glw.RGBA, w, h, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                                        this.setTextureMemUse(w * h * 4);
                                        glw.bindFramebuffer(this.framebuffer);
                                        glw.framebufferTexture2D(glw.COLOR_ATTACHMENT0, nativeTexture, 0);
                                        glw.bindFramebuffer(null);
                                        return _context23.a(2, {
                                            w: w,
                                            h: h
                                        });
                                    }
                                }, _callee23, this);
                            }));
                            function onLoadRequest() {
                                return _onLoadRequest3.apply(this, arguments);
                            }
                            return onLoadRequest;
                        }()
                    }, {
                        key: "free",
                        value: function free() {
                            _superPropGet(WebGlCtxRenderTexture, "free", this, 3)([]);
                            this.glw.deleteFramebuffer(this.framebuffer);
                            this.framebuffer = null;
                        }
                    } ]);
                }(WebGlCtxTexture);
                var WebGlRenderer = function(_CoreRenderer2) {
                    function WebGlRenderer(options) {
                        var _this41;
                        _classCallCheck(this, WebGlRenderer);
                        _this41 = _callSuper(this, WebGlRenderer, [ options ]);
                        _defineProperty(_this41, "glw", void 0);
                        _defineProperty(_this41, "system", void 0);
                        _defineProperty(_this41, "quadBuffer", void 0);
                        _defineProperty(_this41, "fQuadBuffer", void 0);
                        _defineProperty(_this41, "uiQuadBuffer", void 0);
                        _defineProperty(_this41, "renderOps", []);
                        _defineProperty(_this41, "curBufferIdx", 0);
                        _defineProperty(_this41, "curRenderOp", null);
                        _defineProperty(_this41, "rttNodes", []);
                        _defineProperty(_this41, "activeRttNode", null);
                        _defineProperty(_this41, "defaultTextureCoords", {
                            x1: 0,
                            y1: 0,
                            x2: 1,
                            y2: 1
                        });
                        _defineProperty(_this41, "defaultShaderNode", null);
                        _defineProperty(_this41, "quadBufferCollection", void 0);
                        _defineProperty(_this41, "clearColor", {
                            raw: 0,
                            normalized: [ 0, 0, 0, 0 ]
                        });
                        _defineProperty(_this41, "quadBufferUsage", 0);
                        _defineProperty(_this41, "numQuadsRendered", 0);
                        _defineProperty(_this41, "renderToTextureActive", false);
                        _this41.quadBuffer = new ArrayBuffer(_this41.stage.options.quadBufferSize);
                        _this41.fQuadBuffer = new Float32Array(_this41.quadBuffer);
                        _this41.uiQuadBuffer = new Uint32Array(_this41.quadBuffer);
                        _this41.mode = "webgl";
                        var gl = createWebGLContext(options.canvas, options.forceWebGL2, options.contextSpy);
                        var glw = _this41.glw = new WebGlContextWrapper(gl);
                        glw.viewport(0, 0, options.canvas.width, options.canvas.height);
                        _this41.updateClearColor(_this41.stage.clearColor);
                        glw.setBlend(true);
                        glw.blendFunc(glw.ONE, glw.ONE_MINUS_SRC_ALPHA);
                        createIndexBuffer(glw, _this41.stage.bufferMemory);
                        _this41.system = {
                            parameters: getWebGlParameters(_this41.glw),
                            extensions: getWebGlExtensions(_this41.glw)
                        };
                        var quadBuffer = glw.createBuffer();
                        var stride = 8 * Float32Array.BYTES_PER_ELEMENT;
                        _this41.quadBufferCollection = new BufferCollection([ {
                            buffer: quadBuffer,
                            attributes: {
                                a_position: {
                                    name: "a_position",
                                    size: 2,
                                    type: glw.FLOAT,
                                    normalized: false,
                                    stride: stride,
                                    offset: 0
                                },
                                a_textureCoords: {
                                    name: "a_textureCoords",
                                    size: 2,
                                    type: glw.FLOAT,
                                    normalized: false,
                                    stride: stride,
                                    offset: 2 * Float32Array.BYTES_PER_ELEMENT
                                },
                                a_color: {
                                    name: "a_color",
                                    size: 4,
                                    type: glw.UNSIGNED_BYTE,
                                    normalized: true,
                                    stride: stride,
                                    offset: 4 * Float32Array.BYTES_PER_ELEMENT
                                },
                                a_textureIndex: {
                                    name: "a_textureIndex",
                                    size: 1,
                                    type: glw.FLOAT,
                                    normalized: false,
                                    stride: stride,
                                    offset: 5 * Float32Array.BYTES_PER_ELEMENT
                                },
                                a_nodeCoords: {
                                    name: "a_nodeCoords",
                                    size: 2,
                                    type: glw.FLOAT,
                                    normalized: false,
                                    stride: stride,
                                    offset: 6 * Float32Array.BYTES_PER_ELEMENT
                                }
                            }
                        } ]);
                        return _this41;
                    }
                    _inherits(WebGlRenderer, _CoreRenderer2);
                    return _createClass(WebGlRenderer, [ {
                        key: "reset",
                        value: function reset() {
                            var glw = this.glw;
                            this.curBufferIdx = 0;
                            this.curRenderOp = null;
                            this.renderOps.length = 0;
                            glw.setScissorTest(false);
                            if (this.stage.options.enableClear !== false) {
                                glw.clear();
                            }
                        }
                    }, {
                        key: "createShaderProgram",
                        value: function createShaderProgram(shaderType, props) {
                            return new WebGlShaderProgram(this, shaderType, props);
                        }
                    }, {
                        key: "createShaderNode",
                        value: function createShaderNode(shaderKey, shaderType, props, program) {
                            return new WebGlShaderNode(shaderKey, shaderType, program, this.stage, props);
                        }
                    }, {
                        key: "supportsShaderType",
                        value: function supportsShaderType(shaderType) {
                            return shaderType.fragment !== undefined;
                        }
                    }, {
                        key: "createCtxTexture",
                        value: function createCtxTexture(textureSource) {
                            if (textureSource instanceof SubTexture) {
                                return new WebGlCtxSubTexture(this.glw, this.stage.txMemManager, textureSource);
                            } else if (textureSource instanceof RenderTexture) {
                                return new WebGlCtxRenderTexture(this.glw, this.stage.txMemManager, textureSource);
                            }
                            return new WebGlCtxTexture(this.glw, this.stage.txMemManager, textureSource);
                        }
                    }, {
                        key: "addQuad",
                        value: function addQuad(node) {
                            var f = this.fQuadBuffer;
                            var u = this.uiQuadBuffer;
                            var i = this.curBufferIdx;
                            var reuse = this.reuseRenderOp(node);
                            if (reuse === false) {
                                this.newRenderOp(node, i);
                            }
                            var props = node.props;
                            var tx = props.texture || this.stage.defaultTexture;
                            if (tx.type === TextureType.subTexture) {
                                tx = tx.parentTexture;
                            }
                            var texture = tx.ctxTexture;
                            var tidx = this.curRenderOp.addTexture(texture);
                            if (tidx === 4294967295) {
                                this.newRenderOp(node, i);
                                tidx = this.curRenderOp.addTexture(texture);
                            }
                            var rc = node.renderCoords;
                            var tc = node.textureCoords || this.defaultTextureCoords;
                            var cTl = node.premultipliedColorTl;
                            var cTr = node.premultipliedColorTr;
                            var cBl = node.premultipliedColorBl;
                            var cBr = node.premultipliedColorBr;
                            f[i] = rc.x1;
                            f[i + 1] = rc.y1;
                            f[i + 2] = tc.x1;
                            f[i + 3] = tc.y1;
                            u[i + 4] = cTl;
                            f[i + 5] = tidx;
                            f[i + 6] = 0;
                            f[i + 7] = 0;
                            f[i + 8] = rc.x2;
                            f[i + 9] = rc.y2;
                            f[i + 10] = tc.x2;
                            f[i + 11] = tc.y1;
                            u[i + 12] = cTr;
                            f[i + 13] = tidx;
                            f[i + 14] = 1;
                            f[i + 15] = 0;
                            f[i + 16] = rc.x4;
                            f[i + 17] = rc.y4;
                            f[i + 18] = tc.x1;
                            f[i + 19] = tc.y2;
                            u[i + 20] = cBl;
                            f[i + 21] = tidx;
                            f[i + 22] = 0;
                            f[i + 23] = 1;
                            f[i + 24] = rc.x3;
                            f[i + 25] = rc.y3;
                            f[i + 26] = tc.x2;
                            f[i + 27] = tc.y2;
                            u[i + 28] = cBr;
                            f[i + 29] = tidx;
                            f[i + 30] = 1;
                            f[i + 31] = 1;
                            this.curRenderOp.numQuads++;
                            this.curBufferIdx = i + 32;
                        }
                    }, {
                        key: "newRenderOp",
                        value: function newRenderOp(node, bufferIdx) {
                            var curRenderOp = node;
                            curRenderOp.renderOpBufferIdx = bufferIdx;
                            curRenderOp.numQuads = 0;
                            curRenderOp.renderOpTextures.length = 0;
                            this.curRenderOp = curRenderOp;
                            this.renderOps.push(curRenderOp);
                        }
                    }, {
                        key: "reuseRenderOp",
                        value: function reuseRenderOp(node) {
                            var curRenderOp = this.curRenderOp;
                            if (curRenderOp === null) {
                                return false;
                            }
                            var shader = node.props.shader;
                            var curShader = curRenderOp.shader;
                            if (curShader !== shader) {
                                return false;
                            }
                            if (curRenderOp.parentHasRenderTexture !== node.parentHasRenderTexture || curRenderOp.rtt === true !== (node.props.rtt === true)) {
                                return false;
                            }
                            if (compareRect(curRenderOp.clippingRect, node.clippingRect) === false) {
                                return false;
                            }
                            if (node.parentHasRenderTexture === true && node.parentFramebufferDimensions !== null) {
                                var curFbDims = curRenderOp.isCoreNode ? curRenderOp.parentFramebufferDimensions : curRenderOp.framebufferDimensions;
                                if (curFbDims === null || curFbDims.w !== node.parentFramebufferDimensions.w || curFbDims.h !== node.parentFramebufferDimensions.h) {
                                    return false;
                                }
                            }
                            if (curShader.shaderKey === "default" && shader.shaderKey === "default") {
                                return true;
                            }
                            if (curShader.program.reuseRenderOp(node, curRenderOp) === false) {
                                return false;
                            }
                            return true;
                        }
                    }, {
                        key: "addRenderOp",
                        value: function addRenderOp(renderable) {
                            this.renderOps.push(renderable);
                            this.curRenderOp = null;
                        }
                    }, {
                        key: "render",
                        value: function render() {
                            var surface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "screen";
                            var glw = this.glw, quadBuffer = this.quadBuffer;
                            var arr = new Float32Array(quadBuffer, 0, this.curBufferIdx);
                            var buffer = this.quadBufferCollection.getBuffer("a_position") || null;
                            glw.arrayBufferData(buffer, arr, glw.STATIC_DRAW);
                            for (var i = 0, length = this.renderOps.length; i < length; i++) {
                                this.renderOps[i].draw(this);
                            }
                            this.quadBufferUsage = this.curBufferIdx * arr.BYTES_PER_ELEMENT;
                            var QUAD_SIZE_IN_BYTES = 4 * (8 * arr.BYTES_PER_ELEMENT);
                            this.numQuadsRendered = this.quadBufferUsage / QUAD_SIZE_IN_BYTES;
                        }
                    }, {
                        key: "getQuadCount",
                        value: function getQuadCount() {
                            return this.numQuadsRendered;
                        }
                    }, {
                        key: "renderToTexture",
                        value: function renderToTexture(node) {
                            for (var i = 0; i < this.rttNodes.length; i++) {
                                if (this.rttNodes[i] === node) {
                                    return;
                                }
                            }
                            this.insertRTTNodeInOrder(node);
                        }
                    }, {
                        key: "insertRTTNodeInOrder",
                        value: function insertRTTNodeInOrder(node) {
                            var insertIndex = this.rttNodes.length;
                            var currentNode = node;
                            while (currentNode) {
                                if (!currentNode.parent) {
                                    break;
                                }
                                var parentIndex = this.rttNodes.indexOf(currentNode.parent);
                                if (parentIndex !== -1) {
                                    insertIndex = parentIndex;
                                    break;
                                }
                                currentNode = currentNode.parent;
                            }
                            var maxChildIndex = this.findMaxChildRTTIndex(node);
                            if (maxChildIndex !== -1) {
                                insertIndex = Math.max(insertIndex, maxChildIndex + 1);
                            }
                            this.rttNodes.splice(insertIndex, 0, node);
                        }
                    }, {
                        key: "findMaxChildRTTIndex",
                        value: function findMaxChildRTTIndex(node) {
                            var _this42 = this;
                            var maxIndex = -1;
                            var _traverseChildren = function traverseChildren(currentNode) {
                                var currentIndex = _this42.rttNodes.indexOf(currentNode);
                                if (currentIndex !== -1) {
                                    maxIndex = Math.max(maxIndex, currentIndex);
                                }
                                var _iterator32 = _createForOfIteratorHelper(currentNode.children), _step32;
                                try {
                                    for (_iterator32.s(); !(_step32 = _iterator32.n()).done; ) {
                                        var child = _step32.value;
                                        _traverseChildren(child);
                                    }
                                } catch (err) {
                                    _iterator32.e(err);
                                } finally {
                                    _iterator32.f();
                                }
                            };
                            _traverseChildren(node);
                            return maxIndex;
                        }
                    }, {
                        key: "renderRTTNodes",
                        value: function renderRTTNodes() {
                            var glw = this.glw;
                            for (var i = 0; i < this.rttNodes.length; i++) {
                                var node = this.rttNodes[i];
                                if (node === undefined || node.hasRTTupdates === false) {
                                    continue;
                                }
                                if (node.worldAlpha === 0 || node.renderState === CoreNodeRenderState.OutOfBounds) {
                                    continue;
                                }
                                if (node.texture === null || node.texture.state !== "loaded") {
                                    continue;
                                }
                                this.activeRttNode = node;
                                var ctxTexture = node.texture.ctxTexture;
                                this.renderToTextureActive = true;
                                glw.bindFramebuffer(ctxTexture.framebuffer);
                                glw.viewport(0, 0, ctxTexture.w, ctxTexture.h);
                                glw.clearColor(0, 0, 0, 0);
                                glw.clear();
                                for (var _i21 = 0; _i21 < node.children.length; _i21++) {
                                    var child = node.children[_i21];
                                    if (child === undefined) {
                                        continue;
                                    }
                                    this.stage.addQuads(child);
                                    child.hasRTTupdates = false;
                                }
                                this.render();
                                this.renderOps.length = 0;
                                node.hasRTTupdates = false;
                            }
                            var clearColor = this.clearColor.normalized;
                            glw.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                            glw.bindFramebuffer(null);
                            glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
                            this.renderToTextureActive = false;
                        }
                    }, {
                        key: "updateViewport",
                        value: function updateViewport() {
                            this.glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
                        }
                    }, {
                        key: "removeRTTNode",
                        value: function removeRTTNode(node) {
                            var index = this.rttNodes.indexOf(node);
                            if (index === -1) {
                                return;
                            }
                            this.rttNodes.splice(index, 1);
                        }
                    }, {
                        key: "getBufferInfo",
                        value: function getBufferInfo() {
                            var bufferInfo = {
                                totalAvailable: this.stage.options.quadBufferSize,
                                totalUsed: this.quadBufferUsage
                            };
                            return bufferInfo;
                        }
                    }, {
                        key: "getDefaultShaderNode",
                        value: function getDefaultShaderNode() {
                            if (this.defaultShaderNode !== null) {
                                return this.defaultShaderNode;
                            }
                            this.stage.shManager.registerShaderType("default", Default);
                            this.defaultShaderNode = this.stage.shManager.createShader("default");
                            return this.defaultShaderNode;
                        }
                    }, {
                        key: "getTextureCoords",
                        value: function getTextureCoords(node) {
                            var texture = node.texture;
                            if (texture === null) {
                                return undefined;
                            }
                            var ctxTexture = texture.parentTexture !== undefined ? texture.parentTexture.ctxTexture : texture.ctxTexture;
                            if (ctxTexture === undefined) {
                                return undefined;
                            }
                            var textureOptions = node.props.textureOptions;
                            if (texture.type !== TextureType.subTexture && textureOptions === undefined) {
                                return ctxTexture.txCoords;
                            }
                            var _ctxTexture$txCoords = ctxTexture.txCoords, x1 = _ctxTexture$txCoords.x1, x2 = _ctxTexture$txCoords.x2, y1 = _ctxTexture$txCoords.y1, y2 = _ctxTexture$txCoords.y2;
                            if (texture.type === TextureType.subTexture) {
                                var _texture$parentTextur = texture.parentTexture.dimensions, parentW = _texture$parentTextur.w, parentH = _texture$parentTextur.h;
                                var _texture$props = texture.props, x = _texture$props.x, y = _texture$props.y, w = _texture$props.w, h = _texture$props.h;
                                x1 = x / parentW;
                                y1 = y / parentH;
                                x2 = x1 + w / parentW;
                                y2 = y1 + h / parentH;
                            }
                            var resizeMode = textureOptions.resizeMode;
                            if (resizeMode !== undefined && resizeMode.type === "cover" && texture.dimensions !== null) {
                                var dimensions = texture.dimensions;
                                var _w2 = node.props.w;
                                var _h2 = node.props.h;
                                var scaleX = _w2 / dimensions.w;
                                var scaleY = _h2 / dimensions.h;
                                var scale = Math.max(scaleX, scaleY);
                                var precision = 1 / scale;
                                if (scaleX < scale) {
                                    var _resizeMode$clipX;
                                    var desiredSize = precision * node.props.w;
                                    x1 = (1 - desiredSize / dimensions.w) * ((_resizeMode$clipX = resizeMode.clipX) !== null && _resizeMode$clipX !== void 0 ? _resizeMode$clipX : .5);
                                    x2 = x1 + desiredSize / dimensions.w;
                                }
                                if (scaleY < scale) {
                                    var _resizeMode$clipY;
                                    var _desiredSize = precision * node.props.h;
                                    y1 = (1 - _desiredSize / dimensions.h) * ((_resizeMode$clipY = resizeMode.clipY) !== null && _resizeMode$clipY !== void 0 ? _resizeMode$clipY : .5);
                                    y2 = y1 + _desiredSize / dimensions.h;
                                }
                            }
                            if (textureOptions.flipX === true) {
                                var _ref59 = [ x2, x1 ];
                                x1 = _ref59[0];
                                x2 = _ref59[1];
                            }
                            if (textureOptions.flipY === true) {
                                var _ref60 = [ y2, y1 ];
                                y1 = _ref60[0];
                                y2 = _ref60[1];
                            }
                            return {
                                x1: x1,
                                y1: y1,
                                x2: x2,
                                y2: y2
                            };
                        }
                    }, {
                        key: "updateClearColor",
                        value: function updateClearColor(color) {
                            if (this.clearColor.raw === color) {
                                return;
                            }
                            var glw = this.glw;
                            var normalizedColor = getNormalizedRgbaComponents(color);
                            glw.clearColor(normalizedColor[0], normalizedColor[1], normalizedColor[2], normalizedColor[3]);
                            this.clearColor = {
                                raw: color,
                                normalized: normalizedColor
                            };
                        }
                    } ]);
                }(CoreRenderer);
                var IDENTITY_MATRIX_3x3 = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
                var Sdf = {
                    props: {
                        transform: IDENTITY_MATRIX_3x3,
                        color: 4294967295,
                        size: 16,
                        distanceRange: 1
                    },
                    onSdfBind: function onSdfBind(props) {
                        this.uniformMatrix3fv("u_transform", props.transform);
                        this.uniform4fa("u_color", getNormalizedRgbaComponents(props.color));
                        this.uniform1f("u_size", props.size);
                        this.uniform1f("u_distanceRange", props.distanceRange);
                    },
                    vertex: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n    // an attribute is an input (in) to a vertex shader.\n    // It will receive data from a buffer\n    attribute vec2 a_position;\n    attribute vec2 a_textureCoords;\n\n    uniform vec2 u_resolution;\n    uniform mat3 u_transform;\n    uniform float u_pixelRatio;\n    uniform float u_size;\n    uniform float u_distanceRange;\n\n    varying vec2 v_texcoord;\n    varying float v_scaledDistRange;\n\n    void main() {\n      vec2 scrolledPosition = a_position * u_size;\n      vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;\n\n      // Calculate screen space with pixel ratio\n      vec2 screenSpace = (transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1);\n\n      gl_Position = vec4(screenSpace, 0.0, 1.0);\n      v_texcoord = a_textureCoords;\n      v_scaledDistRange = u_distanceRange * u_pixelRatio;\n    }\n  ",
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n    uniform vec4 u_color;\n    uniform sampler2D u_texture;\n\n    varying vec2 v_texcoord;\n    varying float v_scaledDistRange;\n\n    float median(float r, float g, float b) {\n        return clamp(b, min(r, g), max(r, g));\n    }\n\n    void main() {\n        vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n        float sigDist = v_scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n        float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n        // Build the final color.\n        // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n        gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n    }\n  "
                };
                var FLOATS_PER_VERTEX = 4;
                var VERTICES_PER_GLYPH = 6;
                var type$2 = "sdf";
                var sdfShader = null;
                var init$2 = function init$2(stage) {
                    init$3();
                    stage.shManager.registerShaderType("Sdf", Sdf);
                    sdfShader = stage.shManager.createShader("Sdf");
                };
                var font = SdfFontHandler;
                var renderText$1 = function renderText$1(props) {
                    if (props.text.length === 0) {
                        return {
                            width: 0,
                            height: 0
                        };
                    }
                    var fontData = getFontData(props.fontFamily);
                    if (fontData === undefined) {
                        return {
                            width: 0,
                            height: 0
                        };
                    }
                    var layout = generateTextLayout(props, fontData);
                    return {
                        remainingLines: 0,
                        hasRemainingText: false,
                        width: layout.width,
                        height: layout.height,
                        layout: layout
                    };
                };
                var addQuads$1 = function addQuads$1(layout) {
                    if (layout === undefined) {
                        return null;
                    }
                    var glyphs = layout.glyphs;
                    var glyphsLength = glyphs.length;
                    if (glyphsLength === 0) {
                        return null;
                    }
                    var vertexBuffer = new Float32Array(glyphsLength * VERTICES_PER_GLYPH * FLOATS_PER_VERTEX);
                    var bufferIndex = 0;
                    var glyphIndex = 0;
                    while (glyphIndex < glyphsLength) {
                        var glyph = glyphs[glyphIndex];
                        glyphIndex++;
                        if (glyph === undefined) {
                            continue;
                        }
                        var x1 = glyph.x;
                        var y1 = glyph.y;
                        var x2 = x1 + glyph.width;
                        var y2 = y1 + glyph.height;
                        var u1 = glyph.atlasX;
                        var v1 = glyph.atlasY;
                        var u2 = u1 + glyph.atlasWidth;
                        var v2 = v1 + glyph.atlasHeight;
                        vertexBuffer[bufferIndex++] = x1;
                        vertexBuffer[bufferIndex++] = y1;
                        vertexBuffer[bufferIndex++] = u1;
                        vertexBuffer[bufferIndex++] = v1;
                        vertexBuffer[bufferIndex++] = x2;
                        vertexBuffer[bufferIndex++] = y1;
                        vertexBuffer[bufferIndex++] = u2;
                        vertexBuffer[bufferIndex++] = v1;
                        vertexBuffer[bufferIndex++] = x1;
                        vertexBuffer[bufferIndex++] = y2;
                        vertexBuffer[bufferIndex++] = u1;
                        vertexBuffer[bufferIndex++] = v2;
                        vertexBuffer[bufferIndex++] = x2;
                        vertexBuffer[bufferIndex++] = y1;
                        vertexBuffer[bufferIndex++] = u2;
                        vertexBuffer[bufferIndex++] = v1;
                        vertexBuffer[bufferIndex++] = x2;
                        vertexBuffer[bufferIndex++] = y2;
                        vertexBuffer[bufferIndex++] = u2;
                        vertexBuffer[bufferIndex++] = v2;
                        vertexBuffer[bufferIndex++] = x1;
                        vertexBuffer[bufferIndex++] = y2;
                        vertexBuffer[bufferIndex++] = u1;
                        vertexBuffer[bufferIndex++] = v2;
                    }
                    return vertexBuffer;
                };
                var renderQuads$1 = function renderQuads$1(renderer, layout, vertexBuffer, renderProps) {
                    var fontFamily = renderProps.fontFamily;
                    var color = renderProps.color;
                    var worldAlpha = renderProps.worldAlpha;
                    var globalTransform = renderProps.globalTransform;
                    var atlasTexture = getAtlas(fontFamily);
                    if (atlasTexture === null) {
                        console.warn("SDF atlas texture not found for font: ".concat(fontFamily));
                        return null;
                    }
                    var glw = renderer.glw;
                    var stride = 4 * Float32Array.BYTES_PER_ELEMENT;
                    var webGlBuffer = glw.createBuffer();
                    if (!webGlBuffer) {
                        console.warn("Failed to create WebGL buffer for SDF text");
                        return null;
                    }
                    var webGlBuffers = new BufferCollection([ {
                        buffer: webGlBuffer,
                        attributes: {
                            a_position: {
                                name: "a_position",
                                size: 2,
                                type: glw.FLOAT,
                                normalized: false,
                                stride: stride,
                                offset: 0
                            },
                            a_textureCoords: {
                                name: "a_textureCoords",
                                size: 2,
                                type: glw.FLOAT,
                                normalized: false,
                                stride: stride,
                                offset: 2 * Float32Array.BYTES_PER_ELEMENT
                            }
                        }
                    } ]);
                    var buffer = webGlBuffers.getBuffer("a_position");
                    if (buffer !== undefined) {
                        glw.arrayBufferData(buffer, vertexBuffer, glw.STATIC_DRAW);
                    }
                    var renderOp = new SdfRenderOp(renderer, sdfShader, {
                        transform: globalTransform,
                        color: mergeColorAlpha(color, worldAlpha),
                        size: layout.fontScale,
                        distanceRange: layout.distanceRange
                    }, webGlBuffers, worldAlpha, renderProps.clippingRect, layout.width, layout.height, false, renderProps.parentHasRenderTexture, renderProps.framebufferDimensions);
                    renderOp.addTexture(atlasTexture.ctxTexture);
                    renderOp.numQuads = layout.glyphs.length;
                    return renderOp;
                };
                var generateTextLayout = function generateTextLayout(props, fontCache) {
                    var fontSize = props.fontSize;
                    var fontFamily = props.fontFamily;
                    var lineHeight = props.lineHeight;
                    var metrics = getFontMetrics$1(fontFamily, fontSize);
                    props.verticalAlign;
                    var fontData = fontCache.data;
                    var commonFontData = fontData.common;
                    var designFontSize = fontData.info.size;
                    var atlasWidth = commonFontData.scaleW;
                    var atlasHeight = commonFontData.scaleH;
                    var fontScale = fontSize / designFontSize;
                    var letterSpacing = props.letterSpacing / fontScale;
                    var maxWidth = props.maxWidth / fontScale;
                    var maxHeight = props.maxHeight;
                    var _mapTextLayout = mapTextLayout(measureText$1, metrics, props.text, props.textAlign, fontFamily, lineHeight, props.overflowSuffix, props.wordBreak, letterSpacing, props.maxLines, maxWidth, maxHeight), _mapTextLayout2 = _slicedToArray(_mapTextLayout, 7), lines = _mapTextLayout2[0], remainingLines = _mapTextLayout2[1], hasRemainingText = _mapTextLayout2[2], bareLineHeight = _mapTextLayout2[3], lineHeightPx = _mapTextLayout2[4], effectiveWidth = _mapTextLayout2[5], effectiveHeight = _mapTextLayout2[6];
                    var lineAmount = lines.length;
                    var glyphs = [];
                    var currentX = 0;
                    var currentY = 0;
                    for (var i = 0; i < lineAmount; i++) {
                        var line = lines[i];
                        var textLine = line[0];
                        var textLineLength = textLine.length;
                        var prevCodepoint = 0;
                        currentX = line[3];
                        currentY = line[4] / fontScale;
                        for (var j = 0; j < textLineLength; j++) {
                            var char = textLine.charAt(j);
                            if (hasZeroWidthSpace(char) === true) {
                                continue;
                            }
                            var codepoint = char.codePointAt(0);
                            if (codepoint === undefined) {
                                continue;
                            }
                            var glyph = getGlyph(fontFamily, codepoint);
                            if (glyph === null) {
                                continue;
                            }
                            var advance = glyph.xadvance;
                            if (prevCodepoint !== 0) {
                                var kerning = getKerning(fontFamily, prevCodepoint, codepoint);
                                advance += kerning;
                            }
                            var glyphLayout = {
                                codepoint: codepoint,
                                glyphId: glyph.id,
                                x: currentX + glyph.xoffset,
                                y: currentY + glyph.yoffset,
                                width: glyph.width,
                                height: glyph.height,
                                xOffset: glyph.xoffset,
                                yOffset: glyph.yoffset,
                                atlasX: glyph.x / atlasWidth,
                                atlasY: glyph.y / atlasHeight,
                                atlasWidth: glyph.width / atlasWidth,
                                atlasHeight: glyph.height / atlasHeight
                            };
                            glyphs.push(glyphLayout);
                            currentX += advance + letterSpacing;
                            prevCodepoint = codepoint;
                        }
                        currentY += lineHeightPx;
                    }
                    return {
                        glyphs: glyphs,
                        distanceRange: fontScale * fontData.distanceField.distanceRange,
                        width: effectiveWidth * fontScale,
                        height: effectiveHeight,
                        fontScale: fontScale,
                        lineHeight: lineHeightPx,
                        fontFamily: fontFamily
                    };
                };
                var SdfTextRenderer = {
                    type: type$2,
                    font: font,
                    renderText: renderText$1,
                    addQuads: addQuads$1,
                    renderQuads: renderQuads$1,
                    init: init$2
                };
                var fontFamilies = {};
                var fontLoadPromises = new Map;
                var normalizedMetrics = new Map;
                var nodesWaitingForFont = Object.create(null);
                var fontCache = new Map;
                var initialized = false;
                var measureContext$1;
                var canRenderFont = function canRenderFont() {
                    return true;
                };
                var processFontData = function processFontData(fontFamily, fontFace, metrics) {
                    metrics = metrics || defaultFontMetrics;
                    fontCache.set(fontFamily, {
                        fontFamily: fontFamily,
                        fontFace: fontFace,
                        metrics: metrics
                    });
                };
                var loadFont = function() {
                    var _ref61 = _asyncToGenerator(_regenerator().m(function _callee24(stage, options) {
                        var fontFamily, fontUrl, metrics, existingPromise, nwff, loadPromise;
                        return _regenerator().w(function(_context24) {
                            while (1) switch (_context24.n) {
                              case 0:
                                fontFamily = options.fontFamily, fontUrl = options.fontUrl, metrics = options.metrics;
                                if (!(fontCache.has(fontFamily) === true)) {
                                    _context24.n = 1;
                                    break;
                                }
                                return _context24.a(2);

                              case 1:
                                existingPromise = fontLoadPromises.get(fontFamily);
                                if (!(existingPromise !== undefined)) {
                                    _context24.n = 2;
                                    break;
                                }
                                return _context24.a(2, existingPromise);

                              case 2:
                                nwff = nodesWaitingForFont[fontFamily] = [];
                                loadPromise = new FontFace(fontFamily, "url(".concat(fontUrl, ")")).load().then(function(loadedFont) {
                                    stage.platform.addFont(loadedFont);
                                    processFontData(fontFamily, loadedFont, metrics);
                                    fontLoadPromises.delete(fontFamily);
                                    for (var key in nwff) {
                                        nwff[key].setUpdateType(UpdateType.Local);
                                    }
                                    delete nodesWaitingForFont[fontFamily];
                                }).catch(function(error) {
                                    fontLoadPromises.delete(fontFamily);
                                    console.error("Failed to load font: ".concat(fontFamily), error);
                                    throw error;
                                });
                                fontLoadPromises.set(fontFamily, loadPromise);
                                return _context24.a(2, loadPromise);
                            }
                        }, _callee24);
                    }));
                    return function loadFont(_x28, _x29) {
                        return _ref61.apply(this, arguments);
                    };
                }();
                var getFontFamilies = function getFontFamilies() {
                    return fontFamilies;
                };
                var init$1 = function init$1(c, mc) {
                    if (initialized === true) {
                        return;
                    }
                    if (c === undefined) {
                        throw new Error("Canvas context is not provided for font handler initialization");
                    }
                    measureContext$1 = mc;
                    var defaultMetrics = {
                        ascender: 800,
                        descender: -200,
                        lineGap: 200,
                        unitsPerEm: 1e3
                    };
                    processFontData("sans-serif", undefined, defaultMetrics);
                    initialized = true;
                };
                var type$1 = "canvas";
                var isFontLoaded = function isFontLoaded(fontFamily) {
                    return fontCache.has(fontFamily);
                };
                var waitingForFont = function waitingForFont(fontFamily, node) {
                    if (nodesWaitingForFont[fontFamily] === undefined) {
                        return;
                    }
                    nodesWaitingForFont[fontFamily][node.id] = node;
                };
                var stopWaitingForFont = function stopWaitingForFont(fontFamily, node) {
                    if (nodesWaitingForFont[fontFamily] === undefined) {
                        return;
                    }
                    delete nodesWaitingForFont[fontFamily][node.id];
                };
                var getFontMetrics = function getFontMetrics(fontFamily, fontSize) {
                    var out = normalizedMetrics.get(fontFamily + fontSize);
                    if (out !== undefined) {
                        return out;
                    }
                    var metrics = fontCache.get(fontFamily).metrics;
                    if (metrics === undefined) {
                        metrics = calculateFontMetrics(fontFamily);
                    }
                    return processFontMetrics(fontFamily, fontSize, metrics);
                };
                var processFontMetrics = function processFontMetrics(fontFamily, fontSize, metrics) {
                    var label = fontFamily + fontSize;
                    var normalized = normalizeFontMetrics(metrics, fontSize);
                    normalizedMetrics.set(label, normalized);
                    return normalized;
                };
                var measureText = function measureText(text, fontFamily, letterSpacing) {
                    if (letterSpacing === 0) {
                        return measureContext$1.measureText(text).width;
                    }
                    if (hasZeroWidthSpace(text) === false) {
                        return measureContext$1.measureText(text).width + letterSpacing * text.length;
                    }
                    return text.split("").reduce(function(acc, char) {
                        if (hasZeroWidthSpace(char) === true) {
                            return acc;
                        }
                        return acc + measureContext$1.measureText(char).width + letterSpacing;
                    }, 0);
                };
                function calculateFontMetrics(fontFamily, fontSize) {
                    var _ref62, _metrics$fontBounding, _ref63, _metrics$fontBounding2, _metrics$emHeightAsce, _metrics$emHeightDesc, _metrics$emHeightAsce2, _metrics$emHeightDesc2;
                    var metrics = measureContext$1.measureText("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
                    console.warn("Font metrics not provided for Canvas Web font ".concat(fontFamily, ". ") + "Using fallback values. It is HIGHLY recommended you use the latest " + "version of the Lightning 3 `msdf-generator` tool to extract the default " + "metrics for the font and provide them in the Canvas Web font definition.");
                    var ascender = (_ref62 = (_metrics$fontBounding = metrics.fontBoundingBoxAscent) !== null && _metrics$fontBounding !== void 0 ? _metrics$fontBounding : metrics.actualBoundingBoxAscent) !== null && _ref62 !== void 0 ? _ref62 : 0;
                    var descender = (_ref63 = (_metrics$fontBounding2 = metrics.fontBoundingBoxDescent) !== null && _metrics$fontBounding2 !== void 0 ? _metrics$fontBounding2 : metrics.actualBoundingBoxDescent) !== null && _ref63 !== void 0 ? _ref63 : 0;
                    return {
                        ascender: ascender,
                        descender: -descender,
                        lineGap: ((_metrics$emHeightAsce = metrics.emHeightAscent) !== null && _metrics$emHeightAsce !== void 0 ? _metrics$emHeightAsce : 0) + ((_metrics$emHeightDesc = metrics.emHeightDescent) !== null && _metrics$emHeightDesc !== void 0 ? _metrics$emHeightDesc : 0) - (ascender + descender),
                        unitsPerEm: ((_metrics$emHeightAsce2 = metrics.emHeightAscent) !== null && _metrics$emHeightAsce2 !== void 0 ? _metrics$emHeightAsce2 : 0) + ((_metrics$emHeightDesc2 = metrics.emHeightDescent) !== null && _metrics$emHeightDesc2 !== void 0 ? _metrics$emHeightDesc2 : 0)
                    };
                }
                var CanvasFontHandler = Object.freeze(Object.defineProperty({
                    __proto__: null,
                    calculateFontMetrics: calculateFontMetrics,
                    canRenderFont: canRenderFont,
                    getFontFamilies: getFontFamilies,
                    getFontMetrics: getFontMetrics,
                    init: init$1,
                    isFontLoaded: isFontLoaded,
                    loadFont: loadFont,
                    measureText: measureText,
                    processFontMetrics: processFontMetrics,
                    stopWaitingForFont: stopWaitingForFont,
                    type: type$1,
                    waitingForFont: waitingForFont
                }, Symbol.toStringTag, {
                    value: "Module"
                }));
                var type = "canvas";
                var canvas = null;
                var context = null;
                var measureCanvas = null;
                var measureContext = null;
                var layoutCache = new Map;
                var init = function init(stage) {
                    var dpr = stage.options.devicePhysicalPixelRatio;
                    canvas = stage.platform.createCanvas();
                    context = canvas.getContext("2d", {
                        willReadFrequently: true
                    });
                    context.setTransform(dpr, 0, 0, dpr, 0, 0);
                    context.textRendering = "optimizeSpeed";
                    measureCanvas = stage.platform.createCanvas();
                    measureContext = measureCanvas.getContext("2d");
                    measureContext.setTransform(dpr, 0, 0, dpr, 0, 0);
                    measureContext.textRendering = "optimizeSpeed";
                    measureCanvas.width = 1;
                    measureCanvas.height = 1;
                    init$1(context, measureContext);
                };
                var renderText = function renderText(props) {
                    var text = props.text, fontFamily = props.fontFamily, fontStyle = props.fontStyle, fontSize = props.fontSize, textAlign = props.textAlign, maxLines = props.maxLines, lineHeight = props.lineHeight, verticalAlign = props.verticalAlign, overflowSuffix = props.overflowSuffix, maxWidth = props.maxWidth, maxHeight = props.maxHeight, wordBreak = props.wordBreak;
                    var font = "".concat(fontStyle, " ").concat(fontSize, "px Unknown, ").concat(fontFamily);
                    measureContext.font = font;
                    measureContext.textBaseline = "hanging";
                    var metrics = getFontMetrics(fontFamily, fontSize);
                    var letterSpacing = props.letterSpacing;
                    var _mapTextLayout3 = mapTextLayout(measureText, metrics, text, textAlign, fontFamily, lineHeight, overflowSuffix, wordBreak, letterSpacing, maxLines, maxWidth, maxHeight), _mapTextLayout4 = _slicedToArray(_mapTextLayout3, 7), lines = _mapTextLayout4[0], remainingLines = _mapTextLayout4[1], hasRemainingText = _mapTextLayout4[2], bareLineHeight = _mapTextLayout4[3], lineHeightPx = _mapTextLayout4[4], effectiveWidth = _mapTextLayout4[5], effectiveHeight = _mapTextLayout4[6];
                    var lineAmount = lines.length;
                    var canvasW = Math.ceil(effectiveWidth);
                    var canvasH = Math.ceil(effectiveHeight);
                    canvas.width = canvasW;
                    canvas.height = canvasH;
                    context.fillStyle = "white";
                    context.font = font;
                    context.textBaseline = "hanging";
                    if (fontSize >= 128) {
                        context.globalAlpha = .01;
                        context.fillRect(0, 0, .01, .01);
                        context.globalAlpha = 1;
                    }
                    for (var i = 0; i < lineAmount; i++) {
                        var line = lines[i];
                        var textLine = line[0];
                        var currentX = Math.ceil(line[3]);
                        var currentY = Math.ceil(line[4]);
                        if (letterSpacing === 0) {
                            context.fillText(textLine, currentX, currentY);
                        } else {
                            var textLineLength = textLine.length;
                            for (var j = 0; j < textLineLength; j++) {
                                var char = textLine.charAt(j);
                                if (hasZeroWidthSpace(char) === true) {
                                    continue;
                                }
                                context.fillText(char, currentX, currentY);
                                currentX += measureText(char, fontFamily, letterSpacing);
                            }
                        }
                    }
                    var imageData = null;
                    if (canvas.width > 0 && canvas.height > 0) {
                        imageData = context.getImageData(0, 0, canvasW, canvasH);
                    }
                    return {
                        imageData: imageData,
                        width: effectiveWidth,
                        height: effectiveHeight,
                        remainingLines: remainingLines,
                        hasRemainingText: hasRemainingText
                    };
                };
                var clearLayoutCache = function clearLayoutCache() {
                    layoutCache.clear();
                };
                var addQuads = function addQuads() {
                    return null;
                };
                var renderQuads = function renderQuads() {};
                var CanvasTextRenderer = {
                    type: type,
                    font: CanvasFontHandler,
                    renderText: renderText,
                    addQuads: addQuads,
                    renderQuads: renderQuads,
                    init: init,
                    clearLayoutCache: clearLayoutCache
                };
                var WHITE = {
                    isWhite: true,
                    a: 1,
                    r: 255,
                    g: 255,
                    b: 255
                };
                function parseColor(abgr) {
                    if (abgr === 4294967295) {
                        return WHITE;
                    }
                    var a = (abgr >>> 24 & 255) / 255;
                    var b = abgr >>> 16 & 255 & 255;
                    var g = abgr >>> 8 & 255 & 255;
                    var r = abgr & 255 & 255;
                    return {
                        isWhite: false,
                        a: a,
                        r: r,
                        g: g,
                        b: b
                    };
                }
                function parseToAbgrString(abgr) {
                    var a = (abgr >>> 24 & 255) / 255;
                    var b = abgr >>> 16 & 255 & 255;
                    var g = abgr >>> 8 & 255 & 255;
                    var r = abgr & 255 & 255;
                    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
                }
                function parseToRgbaString(rgba) {
                    var r = rgba >>> 24 & 255;
                    var g = rgba >>> 16 & 255 & 255;
                    var b = rgba >>> 8 & 255 & 255;
                    var a = (rgba & 255 & 255) / 255;
                    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
                }
                function formatRgba(_ref64) {
                    var a = _ref64.a, r = _ref64.r, g = _ref64.g, b = _ref64.b;
                    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
                }
                var CanvasTexture = function(_CoreContextTexture3) {
                    function CanvasTexture() {
                        var _this43;
                        _classCallCheck(this, CanvasTexture);
                        for (var _len5 = arguments.length, args = new Array(_len5), _key10 = 0; _key10 < _len5; _key10++) {
                            args[_key10] = arguments[_key10];
                        }
                        _this43 = _callSuper(this, CanvasTexture, [].concat(args));
                        _defineProperty(_this43, "image", void 0);
                        _defineProperty(_this43, "tintCache", void 0);
                        return _this43;
                    }
                    _inherits(CanvasTexture, _CoreContextTexture3);
                    return _createClass(CanvasTexture, [ {
                        key: "load",
                        value: function() {
                            var _load2 = _asyncToGenerator(_regenerator().m(function _callee25() {
                                var size, _t8;
                                return _regenerator().w(function(_context25) {
                                    while (1) switch (_context25.p = _context25.n) {
                                      case 0:
                                        this.textureSource.setState("loading");
                                        _context25.p = 1;
                                        _context25.n = 2;
                                        return this.onLoadRequest();

                                      case 2:
                                        size = _context25.v;
                                        this.textureSource.setState("loaded", size);
                                        this.textureSource.freeTextureData();
                                        this.updateMemSize();
                                        _context25.n = 4;
                                        break;

                                      case 3:
                                        _context25.p = 3;
                                        _t8 = _context25.v;
                                        this.textureSource.setState("failed", _t8);
                                        this.textureSource.freeTextureData();
                                        throw _t8;

                                      case 4:
                                        return _context25.a(2);
                                    }
                                }, _callee25, this, [ [ 1, 3 ] ]);
                            }));
                            function load() {
                                return _load2.apply(this, arguments);
                            }
                            return load;
                        }()
                    }, {
                        key: "release",
                        value: function release() {
                            this.image = undefined;
                            this.tintCache = undefined;
                        }
                    }, {
                        key: "free",
                        value: function free() {
                            this.release();
                            this.textureSource.setState("freed");
                            this.setTextureMemUse(0);
                            this.textureSource.freeTextureData();
                        }
                    }, {
                        key: "updateMemSize",
                        value: function updateMemSize() {
                            var mult = this.tintCache ? 8 : 4;
                            if (this.textureSource.dimensions) {
                                this.setTextureMemUse(this.textureSource.dimensions.w * this.textureSource.dimensions.h * mult);
                            }
                        }
                    }, {
                        key: "hasImage",
                        value: function hasImage() {
                            return this.image !== undefined;
                        }
                    }, {
                        key: "getImage",
                        value: function getImage(color) {
                            var _this$tintCache;
                            var image = this.image;
                            if (color.isWhite) {
                                if (this.tintCache) {
                                    this.tintCache = undefined;
                                    this.updateMemSize();
                                }
                                return image;
                            }
                            var key = formatRgba(color);
                            if (((_this$tintCache = this.tintCache) === null || _this$tintCache === void 0 ? void 0 : _this$tintCache.key) === key) {
                                return this.tintCache.image;
                            }
                            var tintedImage = this.tintTexture(image, key);
                            this.tintCache = {
                                key: key,
                                image: tintedImage
                            };
                            this.updateMemSize();
                            return tintedImage;
                        }
                    }, {
                        key: "tintTexture",
                        value: function tintTexture(source, color) {
                            var width = source.width, height = source.height;
                            var canvas = document.createElement("canvas");
                            canvas.width = width;
                            canvas.height = height;
                            var ctx = canvas.getContext("2d");
                            if (ctx) {
                                ctx.fillStyle = color;
                                ctx.globalCompositeOperation = "copy";
                                ctx.fillRect(0, 0, width, height);
                                ctx.globalCompositeOperation = "multiply";
                                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
                                ctx.globalCompositeOperation = "destination-in";
                                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
                            }
                            return canvas;
                        }
                    }, {
                        key: "onLoadRequest",
                        value: function() {
                            var _onLoadRequest4 = _asyncToGenerator(_regenerator().m(function _callee26() {
                                var _this$textureSource2;
                                var data, _canvas, ctx;
                                return _regenerator().w(function(_context26) {
                                    while (1) switch (_context26.n) {
                                      case 0:
                                        assertTruthy((_this$textureSource2 = this.textureSource) === null || _this$textureSource2 === void 0 || (_this$textureSource2 = _this$textureSource2.textureData) === null || _this$textureSource2 === void 0 ? void 0 : _this$textureSource2.data);
                                        data = this.textureSource.textureData.data;
                                        if (!(data instanceof ImageData)) {
                                            _context26.n = 1;
                                            break;
                                        }
                                        _canvas = document.createElement("canvas");
                                        _canvas.width = data.width;
                                        _canvas.height = data.height;
                                        ctx = _canvas.getContext("2d");
                                        if (ctx) ctx.putImageData(data, 0, 0);
                                        this.image = _canvas;
                                        return _context26.a(2, {
                                            w: data.width,
                                            h: data.height
                                        });

                                      case 1:
                                        if (!(typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap || data instanceof HTMLImageElement)) {
                                            _context26.n = 2;
                                            break;
                                        }
                                        this.image = data;
                                        return _context26.a(2, {
                                            w: data.width,
                                            h: data.height
                                        });

                                      case 2:
                                        return _context26.a(2, {
                                            w: 0,
                                            h: 0
                                        });
                                    }
                                }, _callee26, this);
                            }));
                            function onLoadRequest() {
                                return _onLoadRequest4.apply(this, arguments);
                            }
                            return onLoadRequest;
                        }()
                    } ]);
                }(CoreContextTexture);
                var parsedArgbColors = new Map;
                var parsedRgbaColors = new Map;
                function normalizeCanvasColor(color) {
                    var isRGBA = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var targetCache = isRGBA === true ? parsedRgbaColors : parsedArgbColors;
                    var out = targetCache.get(color);
                    if (out !== undefined) {
                        return out;
                    }
                    if (isRGBA === true) {
                        out = parseToRgbaString(color);
                    } else {
                        out = parseToAbgrString(color);
                    }
                    targetCache.set(color, out);
                    return out;
                }
                var CanvasShaderNode = function(_CoreShaderNode3) {
                    function CanvasShaderNode(shaderKey, config, stage, props) {
                        var _this44;
                        _classCallCheck(this, CanvasShaderNode);
                        _this44 = _callSuper(this, CanvasShaderNode, [ shaderKey, config, stage, props ]);
                        _defineProperty(_this44, "updater", undefined);
                        _defineProperty(_this44, "valueKey", "");
                        _defineProperty(_this44, "computed", {});
                        _defineProperty(_this44, "applySNR", void 0);
                        _defineProperty(_this44, "render", void 0);
                        _this44.applySNR = config.saveAndRestore || false;
                        _this44.render = config.render;
                        if (config.update !== undefined) {
                            _this44.updater = config.update;
                            if (_this44.props === undefined) {
                                _this44.updater(_this44.node, _this44.props);
                                return _possibleConstructorReturn(_this44);
                            }
                            _this44.update = function() {
                                var prevKey = _this44.valueKey;
                                _this44.valueKey = _this44.createValueKey();
                                if (prevKey === _this44.valueKey) {
                                    return;
                                }
                                if (prevKey.length > 0) {
                                    _this44.stage.shManager.mutateShaderValueUsage(prevKey, -1);
                                }
                                var computed = _this44.stage.shManager.getShaderValues(_this44.valueKey);
                                if (computed !== undefined) {
                                    _this44.computed = computed;
                                }
                                _this44.computed = {};
                                _this44.updater(_this44.node);
                                _this44.stage.shManager.setShaderValues(_this44.valueKey, _this44.computed);
                            };
                        }
                        return _this44;
                    }
                    _inherits(CanvasShaderNode, _CoreShaderNode3);
                    return _createClass(CanvasShaderNode, [ {
                        key: "toColorString",
                        value: function toColorString(rgba) {
                            return normalizeCanvasColor(rgba, true);
                        }
                    } ]);
                }(CoreShaderNode);
                var CanvasRenderer = function(_CoreRenderer3) {
                    function CanvasRenderer(options) {
                        var _this45;
                        _classCallCheck(this, CanvasRenderer);
                        _this45 = _callSuper(this, CanvasRenderer, [ options ]);
                        _defineProperty(_this45, "context", void 0);
                        _defineProperty(_this45, "canvas", void 0);
                        _defineProperty(_this45, "pixelRatio", void 0);
                        _defineProperty(_this45, "clearColor", void 0);
                        _defineProperty(_this45, "renderToTextureActive", false);
                        _defineProperty(_this45, "activeRttNode", null);
                        _this45.mode = "canvas";
                        var canvas = options.canvas;
                        _this45.canvas = canvas;
                        _this45.context = canvas.getContext("2d");
                        _this45.pixelRatio = _this45.stage.pixelRatio;
                        _this45.clearColor = normalizeCanvasColor(_this45.stage.clearColor);
                        return _this45;
                    }
                    _inherits(CanvasRenderer, _CoreRenderer3);
                    return _createClass(CanvasRenderer, [ {
                        key: "reset",
                        value: function reset() {
                            this.canvas.width = this.canvas.width;
                            var ctx = this.context;
                            if (this.clearColor) {
                                ctx.fillStyle = this.clearColor;
                                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                            }
                            ctx.scale(this.pixelRatio, this.pixelRatio);
                        }
                    }, {
                        key: "render",
                        value: function render() {}
                    }, {
                        key: "addQuad",
                        value: function addQuad(node) {
                            var _this46 = this;
                            var ctx = this.context;
                            var _node$globalTransform = node.globalTransform, tx = _node$globalTransform.tx, ty = _node$globalTransform.ty, ta = _node$globalTransform.ta, tb = _node$globalTransform.tb, tc = _node$globalTransform.tc, td = _node$globalTransform.td;
                            var clippingRect = node.clippingRect;
                            var texture = node.renderTexture;
                            if (texture !== null) {
                                var textureType = texture.type;
                                if (textureType !== TextureType.image && textureType !== TextureType.subTexture && textureType !== TextureType.color && textureType !== TextureType.noise) {
                                    return;
                                }
                            }
                            var hasTransform = ta !== 1;
                            var hasClipping = clippingRect.width !== 0 && clippingRect.height !== 0;
                            var shader = node.props.shader;
                            var hasShader = shader !== null;
                            var saveAndRestore = hasTransform === true || hasClipping === true;
                            if (hasShader === true) {
                                saveAndRestore = saveAndRestore || shader.applySNR;
                            }
                            if (saveAndRestore) {
                                ctx.save();
                            }
                            if (hasClipping === true) {
                                var path = new Path2D;
                                var x = clippingRect.x, y = clippingRect.y, width = clippingRect.width, height = clippingRect.height;
                                path.rect(x, y, width, height);
                                ctx.clip(path);
                            }
                            if (hasTransform === true) {
                                var scale = this.pixelRatio;
                                ctx.setTransform(ta, tc, tb, td, tx * scale, ty * scale);
                                ctx.scale(scale, scale);
                                ctx.translate(-tx, -ty);
                            }
                            if (hasShader === true) {
                                var renderContext = function renderContext() {
                                    _this46.renderContext(node);
                                };
                                var quad = {
                                    width: node.props.w,
                                    height: node.props.h,
                                    colorTl: node.premultipliedColorTl,
                                    colorTr: node.premultipliedColorTr,
                                    colorBl: node.premultipliedColorBl,
                                    colorBr: node.premultipliedColorBr,
                                    texture: texture,
                                    textureOptions: node.props.textureOptions,
                                    textureCoords: node.renderTextureCoords,
                                    zIndex: node.zIndex,
                                    shader: shader,
                                    alpha: node.worldAlpha,
                                    clippingRect: clippingRect,
                                    tx: tx,
                                    ty: ty,
                                    ta: ta,
                                    tb: tb,
                                    tc: tc,
                                    td: td,
                                    renderCoords: node.renderCoords,
                                    rtt: node.props.rtt,
                                    parentHasRenderTexture: node.parentHasRenderTexture,
                                    framebufferDimensions: node.parentHasRenderTexture ? node.parentFramebufferDimensions : null
                                };
                                shader.render(ctx, quad, renderContext);
                                renderContext = null;
                            } else {
                                this.renderContext(node);
                            }
                            if (saveAndRestore) {
                                ctx.restore();
                            }
                        }
                    }, {
                        key: "renderContext",
                        value: function renderContext(node) {
                            var color = node.premultipliedColorTl;
                            var texture = node.renderTexture;
                            var textureType = texture.type;
                            var tx = node.globalTransform.tx;
                            var ty = node.globalTransform.ty;
                            var width = node.props.w;
                            var height = node.props.h;
                            if (textureType !== TextureType.color) {
                                var _tintColor$a2;
                                var tintColor = parseColor(color);
                                if (textureType !== TextureType.subTexture) {
                                    var _tintColor$a;
                                    var _image = texture.ctxTexture.getImage(tintColor);
                                    this.context.globalAlpha = (_tintColor$a = tintColor.a) !== null && _tintColor$a !== void 0 ? _tintColor$a : node.worldAlpha;
                                    this.context.drawImage(_image, tx, ty, width, height);
                                    this.context.globalAlpha = 1;
                                    return;
                                }
                                var image = texture.parentTexture.ctxTexture.getImage(tintColor);
                                var _props = texture.props;
                                this.context.globalAlpha = (_tintColor$a2 = tintColor.a) !== null && _tintColor$a2 !== void 0 ? _tintColor$a2 : node.worldAlpha;
                                this.context.drawImage(image, _props.x, _props.y, _props.w, _props.h, tx, ty, width, height);
                                this.context.globalAlpha = 1;
                                return;
                            }
                            var hasGradient = node.premultipliedColorTl !== node.premultipliedColorTr || node.premultipliedColorTl !== node.premultipliedColorBr;
                            if (hasGradient === true) {
                                var endX = tx;
                                var endY = ty;
                                var endColor;
                                if (node.premultipliedColorTl === node.premultipliedColorTr) {
                                    endX = tx;
                                    endY = ty + height;
                                    endColor = node.premultipliedColorBr;
                                } else {
                                    endX = tx + width;
                                    endY = ty;
                                    endColor = node.premultipliedColorTr;
                                }
                                var gradient = this.context.createLinearGradient(tx, ty, endX, endY);
                                gradient.addColorStop(0, normalizeCanvasColor(color));
                                gradient.addColorStop(1, normalizeCanvasColor(endColor));
                                this.context.fillStyle = gradient;
                                this.context.fillRect(tx, ty, width, height);
                            } else {
                                this.context.fillStyle = normalizeCanvasColor(color);
                                this.context.fillRect(tx, ty, width, height);
                            }
                        }
                    }, {
                        key: "createShaderNode",
                        value: function createShaderNode(shaderKey, shaderType, props) {
                            return new CanvasShaderNode(shaderKey, shaderType, this.stage, props);
                        }
                    }, {
                        key: "createShaderProgram",
                        value: function createShaderProgram(shaderConfig) {
                            return null;
                        }
                    }, {
                        key: "supportsShaderType",
                        value: function supportsShaderType(shaderType) {
                            return shaderType.render !== undefined;
                        }
                    }, {
                        key: "createCtxTexture",
                        value: function createCtxTexture(textureSource) {
                            return new CanvasTexture(this.stage.txMemManager, textureSource);
                        }
                    }, {
                        key: "renderRTTNodes",
                        value: function renderRTTNodes() {}
                    }, {
                        key: "removeRTTNode",
                        value: function removeRTTNode(node) {}
                    }, {
                        key: "renderToTexture",
                        value: function renderToTexture(node) {}
                    }, {
                        key: "getBufferInfo",
                        value: function getBufferInfo() {
                            return null;
                        }
                    }, {
                        key: "getQuadCount",
                        value: function getQuadCount() {
                            return null;
                        }
                    }, {
                        key: "updateClearColor",
                        value: function updateClearColor(color) {
                            this.clearColor = normalizeCanvasColor(color);
                        }
                    }, {
                        key: "updateViewport",
                        value: function updateViewport() {}
                    }, {
                        key: "getDefaultShaderNode",
                        value: function getDefaultShaderNode() {
                            return null;
                        }
                    } ]);
                }(CoreRenderer);
                var _createSignal19 = createSignal([]), _createSignal20 = _slicedToArray(_createSignal19, 2), focusPath = _createSignal20[0], setFocusPath = _createSignal20[1];
                var useFocusManager = function useFocusManager(userKeyMap, keyHoldOptions) {
                    var owner = getOwner();
                    var ownerContext = runWithOwner.bind(void 0, owner);
                    Config.setActiveElement = function(activeElm) {
                        return ownerContext(function() {
                            return setActiveElement(activeElm);
                        });
                    };
                    var _useFocusManager$ = useFocusManager$1({
                        userKeyMap: userKeyMap,
                        keyHoldOptions: keyHoldOptions,
                        ownerContext: ownerContext
                    }), cleanup = _useFocusManager$.cleanup, focusPathCore = _useFocusManager$.focusPath;
                    createEffect(on(activeElement, function() {
                        setFocusPath(_toConsumableArray(focusPathCore()));
                    }, {
                        defer: true
                    }));
                    onCleanup(cleanup);
                };
                var ARIA_PARENT_ID = "aria-parent";
                var ariaLabelPhrases = [];
                function flattenStrings() {
                    var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                    var flattenedSeries = [];
                    var i;
                    for (i = 0; i < series.length; i++) {
                        var s = series[i];
                        if (typeof s === "string" && !s.includes("PAUSE-")) {
                            flattenedSeries.push(series[i]);
                        } else {
                            break;
                        }
                    }
                    return [ flattenedSeries.join(",\b ") ].concat(series.slice(i));
                }
                function delay(pause) {
                    return new Promise(function(resolve) {
                        setTimeout(resolve, pause);
                    });
                }
                function addChildrenToAriaDiv(phrase) {
                    var _phrase$text;
                    if ((phrase === null || phrase === void 0 || (_phrase$text = phrase.text) === null || _phrase$text === void 0 ? void 0 : _phrase$text.trim().length) === 0) return;
                    ariaLabelPhrases.push(phrase);
                }
                function focusElementForAria() {
                    var element = createAriaElement();
                    if (!element) {
                        console.error("ARIA div not found: ".concat(ARIA_PARENT_ID));
                        return;
                    }
                    for (var _i22 = 0, _ariaLabelPhrases = ariaLabelPhrases; _i22 < _ariaLabelPhrases.length; _i22++) {
                        var object = _ariaLabelPhrases[_i22];
                        var span = document.createElement("span");
                        span.setAttribute("lang", object.lang);
                        span.setAttribute("aria-label", object.text);
                        element.appendChild(span);
                    }
                    setTimeout(function() {
                        ariaLabelPhrases = [];
                        cleanAriaLabelParent();
                        focusCanvas();
                    }, 100);
                }
                function cleanAriaLabelParent() {
                    var parentTag = document.getElementById(ARIA_PARENT_ID);
                    if (parentTag) {
                        while (parentTag.firstChild) {
                            parentTag.removeChild(parentTag.firstChild);
                        }
                    }
                }
                function focusCanvas() {
                    var _document$getElementB;
                    var canvas = (_document$getElementB = document.getElementById("app")) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.firstChild;
                    canvas === null || canvas === void 0 || canvas.focus();
                }
                function createAriaElement() {
                    var aria_container = document.getElementById(ARIA_PARENT_ID);
                    if (!aria_container) {
                        var element = document.createElement("div");
                        element.setAttribute("id", ARIA_PARENT_ID);
                        element.setAttribute("aria-live", "assertive");
                        element.setAttribute("tabindex", "0");
                        document.body.appendChild(element);
                        return element;
                    }
                    return aria_container;
                }
                function speak(phrase, utterances) {
                    var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en-US";
                    var voiceName = arguments.length > 3 ? arguments[3] : undefined;
                    var synth = window.speechSynthesis;
                    return new Promise(function(resolve, reject) {
                        var selectedVoice;
                        if (voiceName) {
                            var availableVoices = synth.getVoices();
                            selectedVoice = availableVoices.find(function(v) {
                                return v.name === voiceName;
                            }) || availableVoices[0];
                        }
                        var utterance = new SpeechSynthesisUtterance(phrase);
                        utterance.lang = lang;
                        if (selectedVoice) {
                            utterance.voice = selectedVoice;
                        }
                        utterance.onend = function() {
                            resolve();
                        };
                        utterance.onerror = function(e) {
                            reject(e);
                        };
                        utterances.push(utterance);
                        synth.speak(utterance);
                    });
                }
                function speakSeries(series, aria, lang, voice) {
                    var root = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
                    var synth = window.speechSynthesis;
                    var remainingPhrases = flattenStrings(Array.isArray(series) ? series : [ series ]);
                    var nestedSeriesResults = [];
                    var utterances = [];
                    var active = true;
                    var seriesChain = _asyncToGenerator(_regenerator().m(function _callee27() {
                        var phrase, pause, totalRetries, retriesLeft, _totalRetries, _retriesLeft, text, objectLang, objectVoice, seriesResult, _seriesResult, _t9, _t0;
                        return _regenerator().w(function(_context27) {
                            while (1) switch (_context27.p = _context27.n) {
                              case 0:
                                _context27.p = 0;

                              case 1:
                                if (!(active && remainingPhrases.length)) {
                                    _context27.n = 37;
                                    break;
                                }
                                _context27.n = 2;
                                return Promise.resolve(remainingPhrases.shift());

                              case 2:
                                phrase = _context27.v;
                                if (active) {
                                    _context27.n = 3;
                                    break;
                                }
                                return _context27.a(3, 37);

                              case 3:
                                if (!(typeof phrase === "string" && phrase.includes("PAUSE-"))) {
                                    _context27.n = 5;
                                    break;
                                }
                                pause = Number(phrase.split("PAUSE-")[1]) * 1e3;
                                if (isNaN(pause)) {
                                    _context27.n = 4;
                                    break;
                                }
                                _context27.n = 4;
                                return delay(pause);

                              case 4:
                                _context27.n = 36;
                                break;

                              case 5:
                                if (!(typeof phrase === "string")) {
                                    _context27.n = 19;
                                    break;
                                }
                                if (phrase) {
                                    _context27.n = 6;
                                    break;
                                }
                                return _context27.a(3, 1);

                              case 6:
                                totalRetries = 3;
                                retriesLeft = totalRetries;

                              case 7:
                                if (!(active && retriesLeft > 0)) {
                                    _context27.n = 18;
                                    break;
                                }
                                _context27.p = 8;
                                if (!aria) {
                                    _context27.n = 9;
                                    break;
                                }
                                addChildrenToAriaDiv({
                                    text: phrase,
                                    lang: lang
                                });
                                _context27.n = 10;
                                break;

                              case 9:
                                _context27.n = 10;
                                return speak(phrase, utterances, lang, voice);

                              case 10:
                                retriesLeft = 0;
                                _context27.n = 17;
                                break;

                              case 11:
                                _context27.p = 11;
                                _t9 = _context27.v;
                                if (!(_t9 instanceof SpeechSynthesisErrorEvent)) {
                                    _context27.n = 16;
                                    break;
                                }
                                if (!(_t9.error === "network")) {
                                    _context27.n = 13;
                                    break;
                                }
                                retriesLeft--;
                                console.warn("Speech synthesis network error. Retries left: ".concat(retriesLeft));
                                _context27.n = 12;
                                return delay(500 * (totalRetries - retriesLeft));

                              case 12:
                                _context27.n = 15;
                                break;

                              case 13:
                                if (!(_t9.error === "canceled" || _t9.error === "interrupted")) {
                                    _context27.n = 14;
                                    break;
                                }
                                retriesLeft = 0;
                                _context27.n = 15;
                                break;

                              case 14:
                                throw new Error("SpeechSynthesisErrorEvent: ".concat(_t9.error));

                              case 15:
                                _context27.n = 17;
                                break;

                              case 16:
                                throw _t9;

                              case 17:
                                _context27.n = 7;
                                break;

                              case 18:
                                _context27.n = 36;
                                break;

                              case 19:
                                if (!(phrase instanceof SpeechSynthesisUtterance)) {
                                    _context27.n = 33;
                                    break;
                                }
                                _totalRetries = 3;
                                _retriesLeft = _totalRetries;
                                text = phrase.text;
                                objectLang = phrase === null || phrase === void 0 ? void 0 : phrase.lang;
                                objectVoice = phrase === null || phrase === void 0 ? void 0 : phrase.voice;

                              case 20:
                                if (!(active && _retriesLeft > 0)) {
                                    _context27.n = 32;
                                    break;
                                }
                                _context27.p = 21;
                                if (!text) {
                                    _context27.n = 24;
                                    break;
                                }
                                if (!aria) {
                                    _context27.n = 22;
                                    break;
                                }
                                addChildrenToAriaDiv({
                                    text: text,
                                    lang: objectLang
                                });
                                _context27.n = 23;
                                break;

                              case 22:
                                _context27.n = 23;
                                return speak(text, utterances, objectLang, objectVoice === null || objectVoice === void 0 ? void 0 : objectVoice.name);

                              case 23:
                                _retriesLeft = 0;

                              case 24:
                                _context27.n = 31;
                                break;

                              case 25:
                                _context27.p = 25;
                                _t0 = _context27.v;
                                if (!(_t0 instanceof SpeechSynthesisErrorEvent)) {
                                    _context27.n = 30;
                                    break;
                                }
                                if (!(_t0.error === "network")) {
                                    _context27.n = 27;
                                    break;
                                }
                                _retriesLeft--;
                                console.warn("Speech synthesis network error. Retries left: ".concat(_retriesLeft));
                                _context27.n = 26;
                                return delay(500 * (_totalRetries - _retriesLeft));

                              case 26:
                                _context27.n = 29;
                                break;

                              case 27:
                                if (!(_t0.error === "canceled" || _t0.error === "interrupted")) {
                                    _context27.n = 28;
                                    break;
                                }
                                _retriesLeft = 0;
                                _context27.n = 29;
                                break;

                              case 28:
                                throw new Error("SpeechSynthesisErrorEvent: ".concat(_t0.error));

                              case 29:
                                _context27.n = 31;
                                break;

                              case 30:
                                throw _t0;

                              case 31:
                                _context27.n = 20;
                                break;

                              case 32:
                                _context27.n = 36;
                                break;

                              case 33:
                                if (!(typeof phrase === "function")) {
                                    _context27.n = 35;
                                    break;
                                }
                                seriesResult = speakSeries(phrase(), aria, lang, voice, false);
                                nestedSeriesResults.push(seriesResult);
                                _context27.n = 34;
                                return seriesResult.series;

                              case 34:
                                _context27.n = 36;
                                break;

                              case 35:
                                if (!Array.isArray(phrase)) {
                                    _context27.n = 36;
                                    break;
                                }
                                _seriesResult = speakSeries(phrase, aria, lang, voice, false);
                                nestedSeriesResults.push(_seriesResult);
                                _context27.n = 36;
                                return _seriesResult.series;

                              case 36:
                                _context27.n = 1;
                                break;

                              case 37:
                                _context27.p = 37;
                                active = false;
                                if (root && aria) {
                                    focusElementForAria();
                                }
                                return _context27.f(37);

                              case 38:
                                return _context27.a(2);
                            }
                        }, _callee27, null, [ [ 21, 25 ], [ 8, 11 ], [ 0, , 37, 38 ] ]);
                    }))();
                    return {
                        series: seriesChain,
                        get active() {
                            return active;
                        },
                        append: function append(toSpeak) {
                            remainingPhrases.push(toSpeak);
                        },
                        cancel: function cancel() {
                            if (!active) {
                                return;
                            }
                            if (root) {
                                if (aria) {
                                    var element = createAriaElement();
                                    if (element) {
                                        ariaLabelPhrases = [];
                                        cleanAriaLabelParent();
                                        element.focus();
                                        focusCanvas();
                                    }
                                    return;
                                }
                                synth.cancel();
                            }
                            nestedSeriesResults.forEach(function(nestedSeriesResult) {
                                nestedSeriesResult.cancel();
                            });
                            active = false;
                        }
                    };
                }
                var currentSeries;
                function SpeechEngine(toSpeak, aria) {
                    var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en-US";
                    var voice = arguments.length > 3 ? arguments[3] : undefined;
                    currentSeries && currentSeries.cancel();
                    currentSeries = speakSeries(toSpeak, aria, lang, voice);
                    return currentSeries;
                }
                var voidFn = function voidFn() {
                    return undefined;
                };
                var isServer = false;
                var debounce = exports("v", function(callback, wait) {
                    var timeoutId;
                    var clear = function clear() {
                        return clearTimeout(timeoutId);
                    };
                    if (getOwner()) onCleanup(clear);
                    var debounced = function debounced() {
                        for (var _len6 = arguments.length, args = new Array(_len6), _key11 = 0; _key11 < _len6; _key11++) {
                            args[_key11] = arguments[_key11];
                        }
                        if (timeoutId !== undefined) clear();
                        timeoutId = setTimeout(function() {
                            return callback.apply(void 0, args);
                        }, wait);
                    };
                    return Object.assign(debounced, {
                        clear: clear
                    });
                });
                var throttle = function throttle(callback, wait) {
                    var isThrottled = false, timeoutId, lastArgs;
                    var throttled = function throttled() {
                        for (var _len7 = arguments.length, args = new Array(_len7), _key12 = 0; _key12 < _len7; _key12++) {
                            args[_key12] = arguments[_key12];
                        }
                        lastArgs = args;
                        if (isThrottled) return;
                        isThrottled = true;
                        timeoutId = setTimeout(function() {
                            callback.apply(void 0, _toConsumableArray(lastArgs));
                            isThrottled = false;
                        }, wait);
                    };
                    var clear = function clear() {
                        clearTimeout(timeoutId);
                        isThrottled = false;
                    };
                    if (getOwner()) onCleanup(clear);
                    return Object.assign(throttled, {
                        clear: clear
                    });
                };
                function createScheduled(schedule) {
                    var listeners = 0;
                    var isDirty = false;
                    var _createSignal21 = createSignal(void 0, {
                        equals: false
                    }), _createSignal22 = _slicedToArray(_createSignal21, 2), track = _createSignal22[0], dirty = _createSignal22[1];
                    var call = schedule(function() {
                        isDirty = true;
                        dirty();
                    });
                    return function() {
                        if (!isDirty) call(), track();
                        if (isDirty) {
                            isDirty = !!listeners;
                            return true;
                        }
                        if (getListener()) {
                            listeners++;
                            onCleanup(function() {
                                return listeners--;
                            });
                        }
                        return false;
                    };
                }
                var resetFocusPathTimer;
                var prevFocusPath = [];
                var currentlySpeaking;
                var voiceOutDisabled = false;
                var fiveMinutes = 3e5;
                function debounceWithFlush(callback, time) {
                    var trigger = debounce(callback, time);
                    var scopedValue;
                    var debounced = function debounced(newValue) {
                        scopedValue = newValue;
                        trigger(newValue);
                    };
                    debounced.flush = function() {
                        trigger.clear();
                        callback(scopedValue);
                    };
                    debounced.clear = trigger.clear;
                    return debounced;
                }
                function getElmName(elm) {
                    return elm.id || elm.name;
                }
                function onFocusChangeCore() {
                    var focusPath2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                    if (!Announcer.onFocusChange || !Announcer.enabled) {
                        return;
                    }
                    var loaded = focusPath2.every(function(elm) {
                        return !elm.loading;
                    });
                    var focusDiff = focusPath2.filter(function(elm) {
                        return !prevFocusPath.includes(elm);
                    });
                    resetFocusPathTimer();
                    if (!loaded && Announcer.onFocusChange) {
                        Announcer.onFocusChange([]);
                        return;
                    }
                    prevFocusPath = focusPath2.slice(0);
                    var toAnnounceText = [];
                    var toAnnounce = focusDiff.reverse().reduce(function(acc, elm) {
                        if (elm.announce) {
                            acc.push([ getElmName(elm), "Announce", elm.announce ]);
                            toAnnounceText.push(elm.announce);
                        } else if (elm.title) {
                            acc.push([ getElmName(elm), "Title", elm.title ]);
                            toAnnounceText.push(elm.title);
                        } else {
                            acc.push([ getElmName(elm), "No Announce", "" ]);
                        }
                        return acc;
                    }, []);
                    focusDiff.reverse().reduce(function(acc, elm) {
                        if (elm.announceContext) {
                            acc.push([ getElmName(elm), "Context", elm.announceContext ]);
                            toAnnounceText.push(elm.announceContext);
                        } else {
                            acc.push([ getElmName(elm), "No Context", "" ]);
                        }
                        return acc;
                    }, toAnnounce);
                    if (Announcer.debug) {
                        console.table(toAnnounce);
                    }
                    if (toAnnounceText.length) {
                        return Announcer.speak(toAnnounceText.reduce(function(acc, val) {
                            return acc.concat(val);
                        }, []));
                    }
                }
                function textToSpeech(toSpeak, aria, lang, voice) {
                    if (voiceOutDisabled) {
                        return;
                    }
                    return currentlySpeaking = SpeechEngine(toSpeak, aria, lang, voice);
                }
                var Announcer = exports("A", {
                    debug: false,
                    enabled: true,
                    lang: "en-US",
                    aria: false,
                    cancel: function cancel() {
                        currentlySpeaking && currentlySpeaking.cancel();
                    },
                    clearPrevFocus: function clearPrevFocus() {
                        var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                        prevFocusPath = prevFocusPath.slice(0, depth);
                        resetFocusPathTimer();
                    },
                    speak: function speak(text) {
                        var _ref66 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref66$append = _ref66.append, append = _ref66$append === void 0 ? false : _ref66$append, _ref66$notification = _ref66.notification, notification = _ref66$notification === void 0 ? false : _ref66$notification;
                        if (Announcer.onFocusChange && Announcer.enabled) {
                            if (append && currentlySpeaking && currentlySpeaking.active) {
                                currentlySpeaking.append(text);
                            } else {
                                Announcer.cancel();
                                textToSpeech(text, Announcer.aria, Announcer.lang, Announcer.voice);
                            }
                            if (notification) {
                                var _currentlySpeaking;
                                voiceOutDisabled = true;
                                (_currentlySpeaking = currentlySpeaking) === null || _currentlySpeaking === void 0 || _currentlySpeaking.series.finally(function() {
                                    voiceOutDisabled = false;
                                    Announcer.refresh();
                                }).catch(console.error);
                            }
                        }
                        return currentlySpeaking;
                    },
                    refresh: function refresh() {
                        var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                        Announcer.clearPrevFocus(depth);
                        Announcer.onFocusChange && Announcer.onFocusChange(untrack(function() {
                            return focusPath();
                        }));
                    },
                    setupTimers: function setupTimers() {
                        var _ref67 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref67$focusDebounce = _ref67.focusDebounce, focusDebounce = _ref67$focusDebounce === void 0 ? 400 : _ref67$focusDebounce, _ref67$focusChangeTim = _ref67.focusChangeTimeout, focusChangeTimeout = _ref67$focusChangeTim === void 0 ? fiveMinutes : _ref67$focusChangeTim;
                        Announcer.onFocusChange = debounceWithFlush(onFocusChangeCore, focusDebounce);
                        resetFocusPathTimer = debounceWithFlush(function() {
                            prevFocusPath = [];
                        }, focusChangeTimeout);
                    }
                });
                var doOnce = false;
                var useAnnouncer = function useAnnouncer(options) {
                    if (doOnce) {
                        return Announcer;
                    }
                    doOnce = true;
                    Announcer.setupTimers(options);
                    createEffect(on(focusPath, Announcer.onFocusChange, {
                        defer: true
                    }));
                    return Announcer;
                };
                function isObject(value) {
                    return value !== null && (_typeof(value) === "object" || typeof value === "function");
                }
                function accessWith(valueOrFn) {
                    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key13 = 1; _key13 < _len8; _key13++) {
                        args[_key13 - 1] = arguments[_key13];
                    }
                    return typeof valueOrFn === "function" ? valueOrFn.apply(void 0, args) : valueOrFn;
                }
                var tryOnCleanup = onCleanup;
                var createCallbackStack = function createCallbackStack() {
                    var stack = [];
                    var clear = function clear() {
                        return stack = [];
                    };
                    return {
                        push: function push() {
                            var _stack;
                            return (_stack = stack).push.apply(_stack, arguments);
                        },
                        execute: function execute(arg0, arg1, arg2, arg3) {
                            stack.forEach(function(cb) {
                                return cb(arg0, arg1, arg2, arg3);
                            });
                            clear();
                        },
                        clear: clear
                    };
                };
                function makeEventListener(target, type, handler, options) {
                    target.addEventListener(type, handler, options);
                    return tryOnCleanup(target.removeEventListener.bind(target, type, handler, options));
                }
                function makeEventListenerStack(target, options) {
                    var _createCallbackStack = createCallbackStack(), push = _createCallbackStack.push, execute = _createCallbackStack.execute;
                    return [ function(type, handler, overwriteOptions) {
                        var clear = makeEventListener(target, type, handler, overwriteOptions !== null && overwriteOptions !== void 0 ? overwriteOptions : options);
                        push(clear);
                        return clear;
                    }, onCleanup(execute) ];
                }
                var PASSIVE = {
                    passive: true
                };
                var DEFAULT_MOUSE_POSITION = {
                    x: 0,
                    y: 0,
                    isInside: false,
                    sourceType: null
                };
                function makeMousePositionListener() {
                    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
                    var callback = arguments.length > 1 ? arguments[1] : undefined;
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var _options$touch = options.touch, touch = _options$touch === void 0 ? true : _options$touch, _options$followTouch = options.followTouch, followTouch = _options$followTouch === void 0 ? true : _options$followTouch;
                    var _makeEventListenerSta = makeEventListenerStack(target, PASSIVE), _makeEventListenerSta2 = _slicedToArray(_makeEventListenerSta, 2), listen = _makeEventListenerSta2[0], clear = _makeEventListenerSta2[1];
                    var handleMouse = function handleMouse(e) {
                        return callback({
                            x: e.pageX,
                            y: e.pageY,
                            sourceType: "mouse"
                        });
                    };
                    listen("mousemove", handleMouse);
                    listen("dragover", handleMouse);
                    if (touch) {
                        var handleTouch = function handleTouch(e) {
                            if (e.touches.length) callback({
                                x: e.touches[0].clientX,
                                y: e.touches[0].clientY,
                                sourceType: "touch"
                            });
                        };
                        listen("touchstart", handleTouch);
                        if (followTouch) listen("touchmove", handleTouch);
                    }
                    return clear;
                }
                function makeMouseInsideListener() {
                    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
                    var callback = arguments.length > 1 ? arguments[1] : undefined;
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var _options$touch2 = options.touch, touch = _options$touch2 === void 0 ? true : _options$touch2;
                    var _makeEventListenerSta3 = makeEventListenerStack(target, PASSIVE), _makeEventListenerSta4 = _slicedToArray(_makeEventListenerSta3, 2), listen = _makeEventListenerSta4[0], clear = _makeEventListenerSta4[1];
                    var mouseIn = false;
                    var touchIn = !touch;
                    function handleChange(isInside) {
                        this === "mouse" ? mouseIn = isInside : touchIn = isInside;
                        callback(mouseIn || touchIn);
                    }
                    listen("mouseover", handleChange.bind("mouse", true));
                    listen("mouseout", handleChange.bind("mouse", false));
                    listen("mousemove", handleChange.bind("mouse", true), {
                        passive: true,
                        once: true
                    });
                    if (touch) {
                        listen("touchstart", handleChange.bind("touch", true));
                        listen("touchend", handleChange.bind("touch", false));
                    }
                    return clear;
                }
                function createSingletonRoot(factory) {
                    var detachedOwner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getOwner();
                    var listeners = 0, value, disposeRoot;
                    return function() {
                        listeners++;
                        onCleanup(function() {
                            listeners--;
                            queueMicrotask(function() {
                                if (!listeners && disposeRoot) {
                                    disposeRoot();
                                    disposeRoot = value = undefined;
                                }
                            });
                        });
                        if (!disposeRoot) {
                            createRoot(function(dispose) {
                                return value = factory(disposeRoot = dispose);
                            }, detachedOwner);
                        }
                        return value;
                    };
                }
                function createHydratableSingletonRoot(factory) {
                    var owner = getOwner();
                    var singleton = createSingletonRoot(factory, owner);
                    return function() {
                        return sharedConfig.context ? createRoot(factory, owner) : singleton();
                    };
                }
                function createStaticStore(init) {
                    var copy = _objectSpread({}, init), store = _objectSpread({}, init), cache = {};
                    var getValue = function getValue(key) {
                        var signal = cache[key];
                        if (!signal) {
                            if (!getListener()) return copy[key];
                            cache[key] = signal = createSignal(copy[key], {
                                internal: true
                            });
                            delete copy[key];
                        }
                        return signal[0]();
                    };
                    var _loop9 = function _loop9(key) {
                        Object.defineProperty(store, key, {
                            get: function get() {
                                return getValue(key);
                            },
                            enumerable: true
                        });
                    };
                    for (var key in init) {
                        _loop9(key);
                    }
                    var setValue = function setValue(key, value) {
                        var signal = cache[key];
                        if (signal) return signal[1](value);
                        if (key in copy) copy[key] = accessWith(value, copy[key]);
                    };
                    return [ store, function(a, b) {
                        if (isObject(a)) {
                            var entries = untrack(function() {
                                return Object.entries(accessWith(a, store));
                            });
                            batch(function() {
                                var _iterator33 = _createForOfIteratorHelper(entries), _step33;
                                try {
                                    var _loop0 = function _loop0() {
                                        var _step33$value = _slicedToArray(_step33.value, 2), key = _step33$value[0], value = _step33$value[1];
                                        setValue(key, function() {
                                            return value;
                                        });
                                    };
                                    for (_iterator33.s(); !(_step33 = _iterator33.n()).done; ) {
                                        _loop0();
                                    }
                                } catch (err) {
                                    _iterator33.e(err);
                                } finally {
                                    _iterator33.f();
                                }
                            });
                        } else setValue(a, b);
                        return store;
                    } ];
                }
                function createMousePosition(target) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    var fallback = _objectSpread(_objectSpread({}, DEFAULT_MOUSE_POSITION), options.initialValue);
                    var _createStaticStore = createStaticStore(fallback), _createStaticStore2 = _slicedToArray(_createStaticStore, 2), state = _createStaticStore2[0], setState = _createStaticStore2[1];
                    var attachListeners = function attachListeners(el) {
                        makeMousePositionListener(el, setState, options);
                        makeMouseInsideListener(el, setState.bind(void 0, "isInside"), options);
                    };
                    if (typeof target !== "function") attachListeners(target); else createEffect(function() {
                        return attachListeners(target());
                    });
                    return state;
                }
                var useMousePosition = createHydratableSingletonRoot(createMousePosition.bind(void 0, void 0, void 0));
                function addCustomStateToElement(element, state) {
                    var _element$states;
                    (_element$states = element.states) === null || _element$states === void 0 || _element$states.add(state);
                }
                function removeCustomStateFromElement(element, state) {
                    var _element$states2;
                    element === null || element === void 0 || (_element$states2 = element.states) === null || _element$states2 === void 0 || _element$states2.remove(state);
                }
                function hasCustomState(element, state) {
                    var _element$states3;
                    return (_element$states3 = element.states) === null || _element$states3 === void 0 ? void 0 : _element$states3.has(state);
                }
                function createKeyboardEvent(key, keyCode) {
                    var eventName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "keydown";
                    return new KeyboardEvent(eventName, {
                        key: key,
                        keyCode: keyCode,
                        which: keyCode,
                        ctrlKey: false,
                        altKey: false,
                        shiftKey: false,
                        metaKey: false,
                        bubbles: true
                    });
                }
                var scrollTimeout;
                var handleScroll = throttle(function(e) {
                    var deltaY = e.deltaY;
                    if (deltaY < 0) {
                        document.body.dispatchEvent(createKeyboardEvent("ArrowUp", 38));
                    } else if (deltaY > 0) {
                        document.body.dispatchEvent(createKeyboardEvent("ArrowDown", 40));
                    }
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(function() {
                        document.body.dispatchEvent(createKeyboardEvent("ArrowUp", 38, "keyup"));
                        document.body.dispatchEvent(createKeyboardEvent("ArrowDown", 40, "keyup"));
                    }, 250);
                }, 250);
                function findElementWithCustomState(myApp, x, y, customState) {
                    var result = getChildrenByPosition(myApp, x, y).filter(function(el) {
                        return hasCustomState(el, customState);
                    });
                    if (result.length === 0) {
                        return void 0;
                    }
                    var element = result[result.length - 1];
                    while (element) {
                        var elmParent = element.parent;
                        if (elmParent !== null && elmParent !== void 0 && elmParent.forwardStates && hasCustomState(elmParent, customState)) {
                            element = elmParent;
                        } else {
                            break;
                        }
                    }
                    return element;
                }
                function findElementByActiveElement(e) {
                    var _Config$rendererOptio4;
                    var active = activeElement();
                    var precision = ((_Config$rendererOptio4 = Config.rendererOptions) === null || _Config$rendererOptio4 === void 0 ? void 0 : _Config$rendererOptio4.deviceLogicalPixelRatio) || 1;
                    if (active instanceof ElementNode && testCollision(e.clientX, e.clientY, (active.lng.absX || 0) * precision, (active.lng.absY || 0) * precision, (active.width || 0) * precision, (active.height || 0) * precision)) {
                        return active;
                    }
                    var parent = active === null || active === void 0 ? void 0 : active.parent;
                    while (parent) {
                        if (isFunc(parent.onMouseClick) && active && testCollision(e.clientX, e.clientY, (parent.lng.absX || 0) * precision, (parent.lng.absY || 0) * precision, (parent.width || 0) * precision, (parent.height || 0) * precision)) {
                            return parent;
                        }
                        parent = parent.parent;
                    }
                    return null;
                }
                function applyPressedState(element, pressedState) {
                    addCustomStateToElement(element, pressedState);
                }
                function handleElementClick(clickedElement, e, customStates, pressedElementRef) {
                    if (customStates !== null && customStates !== void 0 && customStates.pressedState && pressedElementRef !== null && pressedElementRef !== void 0 && pressedElementRef.current) {
                        removeCustomStateFromElement(pressedElementRef.current, customStates.pressedState);
                        pressedElementRef.current = null;
                    }
                    if (isFunc(clickedElement.onMouseClick)) {
                        clickedElement.onMouseClick(e, clickedElement);
                        return;
                    } else if (isFunc(clickedElement.onEnter)) {
                        clickedElement.onEnter();
                        return;
                    }
                    clickedElement.setFocus();
                    setTimeout(function() {
                        document.dispatchEvent(createKeyboardEvent("Enter", 13));
                        setTimeout(function() {
                            return document.body.dispatchEvent(createKeyboardEvent("Enter", 13, "keyup"));
                        }, 1);
                    }, 1);
                }
                function createHandleClick(myApp, customStates, pressedElementRef) {
                    return function(e) {
                        var clickedElement = customStates ? findElementWithCustomState(myApp, e.clientX, e.clientY, customStates.hoverState) : findElementByActiveElement(e);
                        if (!clickedElement) {
                            return;
                        }
                        handleElementClick(clickedElement, e, customStates, pressedElementRef);
                    };
                }
                function createHandleMouseDown(myApp, customStates, pressedElementRef) {
                    return function(e) {
                        if (!customStates) {
                            return;
                        }
                        var pressedElement = findElementWithCustomState(myApp, e.clientX, e.clientY, customStates.hoverState);
                        if (!pressedElement) {
                            return;
                        }
                        applyPressedState(pressedElement, customStates.pressedState);
                        if (pressedElementRef) {
                            pressedElementRef.current = pressedElement;
                        }
                    };
                }
                function testCollision(px, py, cx, cy) {
                    var cw = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                    var ch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                    return px >= cx && px <= cx + cw && py >= cy && py <= cy + ch;
                }
                function isNodeAtPosition(node, x, y, precision) {
                    if (!isElementNode(node)) {
                        return false;
                    }
                    return node.alpha !== 0 && !node.skipFocus && testCollision(x, y, (node.lng.absX || 0) * precision, (node.lng.absY || 0) * precision, (node.width || 0) * precision, (node.height || 0) * precision);
                }
                function findHighestZIndexNode(nodes) {
                    if (nodes.length === 0) {
                        return void 0;
                    }
                    if (nodes.length === 1) {
                        return nodes[0];
                    }
                    var maxZIndex = -1;
                    var highestNode = void 0;
                    var _iterator34 = _createForOfIteratorHelper(nodes), _step34;
                    try {
                        for (_iterator34.s(); !(_step34 = _iterator34.n()).done; ) {
                            var _node$zIndex;
                            var node = _step34.value;
                            var zIndex = (_node$zIndex = node.zIndex) !== null && _node$zIndex !== void 0 ? _node$zIndex : -1;
                            if (zIndex >= maxZIndex) {
                                maxZIndex = zIndex;
                                highestNode = node;
                            }
                        }
                    } catch (err) {
                        _iterator34.e(err);
                    } finally {
                        _iterator34.f();
                    }
                    return highestNode;
                }
                function getChildrenByPosition(node, x, y) {
                    var _Config$rendererOptio5;
                    var result = [];
                    var precision = ((_Config$rendererOptio5 = Config.rendererOptions) === null || _Config$rendererOptio5 === void 0 ? void 0 : _Config$rendererOptio5.deviceLogicalPixelRatio) || 1;
                    var queue = [ node ];
                    while (queue.length > 0) {
                        var currentLevelNodes = queue.filter(function(currentNode) {
                            return isNodeAtPosition(currentNode, x, y, precision);
                        });
                        if (currentLevelNodes.length === 0) {
                            break;
                        }
                        var highestZIndexNode = findHighestZIndexNode(currentLevelNodes);
                        if (!highestZIndexNode || isTextNode(highestZIndexNode)) {
                            break;
                        }
                        result.push(highestZIndexNode);
                        queue = highestZIndexNode.children;
                    }
                    return result;
                }
                function useMouse() {
                    var myApp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : rootNode;
                    var throttleBy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
                    var options = arguments.length > 2 ? arguments[2] : undefined;
                    var pos = useMousePosition();
                    var scheduled = createScheduled(function(fn) {
                        return throttle(fn, throttleBy);
                    });
                    var previousElement = null;
                    var pressedElementRef = {
                        current: null
                    };
                    var customStates = options === null || options === void 0 ? void 0 : options.customStates;
                    var hoverState = customStates === null || customStates === void 0 ? void 0 : customStates.hoverState;
                    var handleClick = createHandleClick(myApp, customStates, pressedElementRef);
                    var handleMouseDown = createHandleMouseDown(myApp, customStates, pressedElementRef);
                    var owner = getOwner();
                    var handleClickContext = function handleClickContext(e) {
                        runWithOwner(owner, function() {
                            return handleClick(e);
                        });
                    };
                    var handleMouseDownContext = function handleMouseDownContext(e) {
                        runWithOwner(owner, function() {
                            return handleMouseDown(e);
                        });
                    };
                    makeEventListener(window, "wheel", handleScroll);
                    makeEventListener(window, "click", handleClickContext);
                    makeEventListener(window, "mousedown", handleMouseDownContext);
                    createEffect(function() {
                        if (scheduled()) {
                            var result = getChildrenByPosition(myApp, pos.x, pos.y).filter(function(el) {
                                return !!(el.onEnter || el.onMouseClick || el.onFocus || el[Config.focusStateKey] || el[hoverState]);
                            });
                            if (result.length) {
                                var activeElm = result[result.length - 1];
                                while (activeElm) {
                                    var elmParent = activeElm.parent;
                                    if (elmParent !== null && elmParent !== void 0 && elmParent.forwardStates) {
                                        activeElm = elmParent;
                                    } else {
                                        break;
                                    }
                                }
                                if (!activeElm) {
                                    return;
                                }
                                var activeElmParent = activeElm.parent;
                                if ((activeElmParent === null || activeElmParent === void 0 ? void 0 : activeElmParent.selected) !== void 0) {
                                    activeElmParent.selected = activeElmParent.children.indexOf(activeElm);
                                }
                                if (previousElement && previousElement !== activeElm && hoverState) {
                                    removeCustomStateFromElement(previousElement, hoverState);
                                }
                                {
                                    addCustomStateToElement(activeElm, hoverState);
                                }
                                previousElement = activeElm;
                            } else if (previousElement && hoverState) {
                                removeCustomStateFromElement(previousElement, hoverState);
                                previousElement = null;
                            }
                        }
                    });
                }
                function createLazy(component, props, keyHandler) {
                    var _createSignal23 = createSignal(props.sync ? props.upCount : 0), _createSignal24 = _slicedToArray(_createSignal23, 2), offset = _createSignal24[0], setOffset = _createSignal24[1];
                    var timeoutId = null;
                    var viewRef;
                    var itemLength = 0;
                    var buffer = createMemo(function() {
                        var _props$style;
                        if (typeof props.buffer === "number") {
                            return props.buffer;
                        }
                        var scroll = props.scroll || ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.scroll);
                        if (!scroll || scroll === "auto" || scroll === "always" || scroll === "bounded") return props.upCount + 1;
                        if (scroll === "center") return Math.ceil(props.upCount / 2) + 1;
                        return 2;
                    });
                    createRenderEffect(function() {
                        return setOffset(function(offset2) {
                            return Math.max(offset2, (props.selected || 0) + buffer());
                        });
                    });
                    if (!props.sync || props.eagerLoad) {
                        createEffect(function() {
                            if (props.each) {
                                var _loadItems = function loadItems() {
                                    var count = untrack(offset);
                                    if (count < props.upCount) {
                                        setOffset(count + 1);
                                        timeoutId = setTimeout(_loadItems, 16);
                                        count++;
                                    } else if (props.eagerLoad) {
                                        var maxOffset = props.each ? props.each.length : 0;
                                        if (count >= maxOffset) return;
                                        setOffset(function(prev) {
                                            return Math.min(prev + 1, maxOffset);
                                        });
                                        scheduleTask(_loadItems);
                                    }
                                };
                                _loadItems();
                            }
                        });
                    }
                    var items = createMemo(function() {
                        if (Array.isArray(props.each)) {
                            if (itemLength != props.each.length) {
                                itemLength = props.each.length;
                                if (viewRef && !viewRef.noRefocus && hasFocus(viewRef)) {
                                    queueMicrotask(viewRef.setFocus);
                                }
                            }
                            return props.each.slice(0, offset());
                        }
                        itemLength = 0;
                        return [];
                    });
                    function lazyScrollToIndex(index) {
                        setOffset(Math.max(index, 0) + buffer());
                        queueMicrotask(function() {
                            return viewRef.scrollToIndex(index);
                        });
                    }
                    var updateOffset = function updateOffset(_event, container) {
                        var _props$delay;
                        var maxOffset = props.each ? props.each.length : 0;
                        var selected = container.selected || 0;
                        var numChildren = container.children.length;
                        if (offset() >= maxOffset || selected < numChildren - buffer()) return;
                        if (!props.delay) {
                            setOffset(function(prev) {
                                return Math.min(prev + 1, maxOffset);
                            });
                            return;
                        }
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                            setOffset(function(prev) {
                                return Math.min(prev + 1, maxOffset);
                            });
                        }
                        timeoutId = setTimeout(function() {
                            setOffset(function(prev) {
                                return Math.min(prev + 1, maxOffset);
                            });
                            timeoutId = null;
                        }, (_props$delay = props.delay) !== null && _props$delay !== void 0 ? _props$delay : 0);
                    };
                    var handler = keyHandler(updateOffset);
                    return createComponent(Dynamic, mergeProps(props, {
                        component: component
                    }, handler, {
                        lazyScrollToIndex: lazyScrollToIndex,
                        ref: function ref(r$) {
                            var _ref$ = chainRefs(function(el) {
                                viewRef = el;
                            }, props.ref);
                            typeof _ref$ === "function" && _ref$(r$);
                        },
                        get children() {
                            return createComponent(Index, {
                                get each() {
                                    return items();
                                },
                                get children() {
                                    return props.children;
                                }
                            });
                        }
                    }));
                }
                function LazyRow(props) {
                    return createLazy(Row, props, function(updateOffset) {
                        return {
                            onRight: updateOffset
                        };
                    });
                }
                function LazyColumn(props) {
                    return createLazy(Column, props, function(updateOffset) {
                        return {
                            onDown: updateOffset
                        };
                    });
                }
                var Image$1 = function Image$1(props) {
                    var _createSignal25 = createSignal(null), _createSignal26 = _slicedToArray(_createSignal25, 2), texture = _createSignal26[0], setTexture = _createSignal26[1];
                    var _createSignal27 = createSignal(props.placeholder || null), _createSignal28 = _slicedToArray(_createSignal27, 2), src = _createSignal28[0], setSrc = _createSignal28[1];
                    createRenderEffect(function() {
                        var srcTexture = renderer$2.createTexture("ImageTexture", props);
                        if (props.fallback) {
                            srcTexture.once("failed", function() {
                                if (props.fallback === props.placeholder) {
                                    return;
                                }
                                setSrc(props.fallback);
                            });
                        }
                        srcTexture.getTextureData().then(function(resp) {
                            if (resp.data) setTexture(srcTexture);
                        });
                    });
                    return function() {
                        var _el$ = createElement("view");
                        spread(_el$, mergeProps(props, {
                            get src() {
                                return src();
                            },
                            get color() {
                                return props.color || 4294967295;
                            },
                            get texture() {
                                return texture();
                            }
                        }), false);
                        return _el$;
                    }();
                };
                function createBeforeLeave() {
                    var listeners = new Set;
                    function subscribe(listener) {
                        listeners.add(listener);
                        return function() {
                            return listeners.delete(listener);
                        };
                    }
                    var ignore = false;
                    function confirm(to, options) {
                        if (ignore) return !(ignore = false);
                        var e = {
                            to: to,
                            options: options,
                            defaultPrevented: false,
                            preventDefault: function preventDefault() {
                                return e.defaultPrevented = true;
                            }
                        };
                        var _iterator35 = _createForOfIteratorHelper(listeners), _step35;
                        try {
                            var _loop1 = function _loop1() {
                                var l = _step35.value;
                                l.listener(_objectSpread(_objectSpread({}, e), {}, {
                                    from: l.location,
                                    retry: function retry(force) {
                                        force && (ignore = true);
                                        l.navigate(to, _objectSpread(_objectSpread({}, options), {}, {
                                            resolve: false
                                        }));
                                    }
                                }));
                            };
                            for (_iterator35.s(); !(_step35 = _iterator35.n()).done; ) {
                                _loop1();
                            }
                        } catch (err) {
                            _iterator35.e(err);
                        } finally {
                            _iterator35.f();
                        }
                        return !e.defaultPrevented;
                    }
                    return {
                        subscribe: subscribe,
                        confirm: confirm
                    };
                }
                var depth;
                function saveCurrentDepth() {
                    if (!window.history.state || window.history.state._depth == null) {
                        window.history.replaceState(_objectSpread(_objectSpread({}, window.history.state), {}, {
                            _depth: window.history.length - 1
                        }), "");
                    }
                    depth = window.history.state._depth;
                }
                {
                    saveCurrentDepth();
                }
                function keepDepth(state) {
                    return _objectSpread(_objectSpread({}, state), {}, {
                        _depth: window.history.state && window.history.state._depth
                    });
                }
                function notifyIfNotBlocked(notify, block) {
                    var ignore = false;
                    return function() {
                        var prevDepth = depth;
                        saveCurrentDepth();
                        var delta = prevDepth == null ? null : depth - prevDepth;
                        if (ignore) {
                            ignore = false;
                            return;
                        }
                        if (delta && block(delta)) {
                            ignore = true;
                            window.history.go(-delta);
                        } else {
                            notify();
                        }
                    };
                }
                var hasSchemeRegex = /^(?:[a-z0-9]+:)?\/\//i;
                var trimPathRegex = /^\/+|(\/)\/+$/g;
                var mockBase = "http://sr";
                function normalizePath(path) {
                    var omitSlash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var s = path.replace(trimPathRegex, "$1");
                    return s ? omitSlash || /^[?#]/.test(s) ? s : "/" + s : "";
                }
                function _resolvePath(base, path, from) {
                    if (hasSchemeRegex.test(path)) {
                        return undefined;
                    }
                    var basePath = normalizePath(base);
                    var fromPath = from && normalizePath(from);
                    var result = "";
                    if (!fromPath || path.startsWith("/")) {
                        result = basePath;
                    } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {
                        result = basePath + fromPath;
                    } else {
                        result = fromPath;
                    }
                    return (result || "/") + normalizePath(path, !result);
                }
                function invariant(value, message) {
                    if (value == null) {
                        throw new Error(message);
                    }
                    return value;
                }
                function joinPaths(from, to) {
                    return normalizePath(from).replace(/\/*(\*.*)?$/g, "") + normalizePath(to);
                }
                function extractSearchParams(url) {
                    var params = {};
                    url.searchParams.forEach(function(value, key) {
                        if (key in params) {
                            if (Array.isArray(params[key])) params[key].push(value); else params[key] = [ params[key], value ];
                        } else params[key] = value;
                    });
                    return params;
                }
                function createMatcher(path, partial, matchFilters) {
                    var _path$split = path.split("/*", 2), _path$split2 = _slicedToArray(_path$split, 2), pattern = _path$split2[0], splat = _path$split2[1];
                    var segments = pattern.split("/").filter(Boolean);
                    var len = segments.length;
                    return function(location) {
                        var locSegments = location.split("/").filter(Boolean);
                        var lenDiff = locSegments.length - len;
                        if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {
                            return null;
                        }
                        var match = {
                            path: len ? "" : "/",
                            params: {}
                        };
                        var matchFilter = function matchFilter(s) {
                            return matchFilters === undefined ? undefined : matchFilters[s];
                        };
                        for (var i = 0; i < len; i++) {
                            var segment = segments[i];
                            var dynamic = segment[0] === ":";
                            var locSegment = dynamic ? locSegments[i] : locSegments[i].toLowerCase();
                            var key = dynamic ? segment.slice(1) : segment.toLowerCase();
                            if (dynamic && matchSegment(locSegment, matchFilter(key))) {
                                match.params[key] = locSegment;
                            } else if (dynamic || !matchSegment(locSegment, key)) {
                                return null;
                            }
                            match.path += "/".concat(locSegment);
                        }
                        if (splat) {
                            var remainder = lenDiff ? locSegments.slice(-lenDiff).join("/") : "";
                            if (matchSegment(remainder, matchFilter(splat))) {
                                match.params[splat] = remainder;
                            } else {
                                return null;
                            }
                        }
                        return match;
                    };
                }
                function matchSegment(input, filter) {
                    var isEqual = function isEqual(s) {
                        return s === input;
                    };
                    if (filter === undefined) {
                        return true;
                    } else if (typeof filter === "string") {
                        return isEqual(filter);
                    } else if (typeof filter === "function") {
                        return filter(input);
                    } else if (Array.isArray(filter)) {
                        return filter.some(isEqual);
                    } else if (filter instanceof RegExp) {
                        return filter.test(input);
                    }
                    return false;
                }
                function scoreRoute(route) {
                    var _route$pattern$split = route.pattern.split("/*", 2), _route$pattern$split2 = _slicedToArray(_route$pattern$split, 2), pattern = _route$pattern$split2[0], splat = _route$pattern$split2[1];
                    var segments = pattern.split("/").filter(Boolean);
                    return segments.reduce(function(score, segment) {
                        return score + (segment.startsWith(":") ? 2 : 3);
                    }, segments.length - (splat === undefined ? 0 : 1));
                }
                function createMemoObject(fn) {
                    var map = new Map;
                    var owner = getOwner();
                    return new Proxy({}, {
                        get: function get(_, property) {
                            if (!map.has(property)) {
                                runWithOwner(owner, function() {
                                    return map.set(property, createMemo(function() {
                                        return fn()[property];
                                    }));
                                });
                            }
                            return map.get(property)();
                        },
                        getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
                            return {
                                enumerable: true,
                                configurable: true
                            };
                        },
                        ownKeys: function ownKeys() {
                            return Reflect.ownKeys(fn());
                        }
                    });
                }
                function expandOptionals(pattern) {
                    var match = /(\/?\:[^\/]+)\?/.exec(pattern);
                    if (!match) return [ pattern ];
                    var prefix = pattern.slice(0, match.index);
                    var suffix = pattern.slice(match.index + match[0].length);
                    var prefixes = [ prefix, prefix += match[1] ];
                    while (match = /^(\/\:[^\/]+)\?/.exec(suffix)) {
                        prefixes.push(prefix += match[1]);
                        suffix = suffix.slice(match[0].length);
                    }
                    return expandOptionals(suffix).reduce(function(results, expansion) {
                        return [].concat(_toConsumableArray(results), _toConsumableArray(prefixes.map(function(p) {
                            return p + expansion;
                        })));
                    }, []);
                }
                var MAX_REDIRECTS = 100;
                var RouterContextObj = createContext();
                var RouteContextObj = createContext();
                var useRouter = function useRouter() {
                    return invariant(useContext(RouterContextObj), "<A> and 'use' router primitives can be only used inside a Route.");
                };
                var useNavigate = exports("u", function() {
                    return useRouter().navigatorFactory();
                });
                var useLocation = function useLocation() {
                    return useRouter().location;
                };
                var usePreloadRoute = function usePreloadRoute() {
                    var pre = useRouter().preloadRoute;
                    return function(url) {
                        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                        return pre(url instanceof URL ? url : new URL(url, mockBase), options.preloadData);
                    };
                };
                var useMatch = function useMatch(path, matchFilters) {
                    var location = useLocation();
                    var matchers = createMemo(function() {
                        return expandOptionals(path()).map(function(path) {
                            return createMatcher(path, undefined, matchFilters);
                        });
                    });
                    return createMemo(function() {
                        var _iterator36 = _createForOfIteratorHelper(matchers()), _step36;
                        try {
                            for (_iterator36.s(); !(_step36 = _iterator36.n()).done; ) {
                                var matcher = _step36.value;
                                var match = matcher(location.pathname);
                                if (match) return match;
                            }
                        } catch (err) {
                            _iterator36.e(err);
                        } finally {
                            _iterator36.f();
                        }
                    });
                };
                var useParams = exports("_", function() {
                    return useRouter().params;
                });
                function createRoutes(routeDef) {
                    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
                    var component = routeDef.component, preload = routeDef.preload, load = routeDef.load, children = routeDef.children, info = routeDef.info;
                    var isLeaf = !children || Array.isArray(children) && !children.length;
                    var shared = {
                        key: routeDef,
                        component: component,
                        preload: preload || load,
                        info: info
                    };
                    return asArray(routeDef.path).reduce(function(acc, originalPath) {
                        var _iterator37 = _createForOfIteratorHelper(expandOptionals(originalPath)), _step37;
                        try {
                            for (_iterator37.s(); !(_step37 = _iterator37.n()).done; ) {
                                var expandedPath = _step37.value;
                                var path = joinPaths(base, expandedPath);
                                var pattern = isLeaf ? path : path.split("/*", 1)[0];
                                pattern = pattern.split("/").map(function(s) {
                                    return s.startsWith(":") || s.startsWith("*") ? s : encodeURIComponent(s);
                                }).join("/");
                                acc.push(_objectSpread(_objectSpread({}, shared), {}, {
                                    originalPath: originalPath,
                                    pattern: pattern,
                                    matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)
                                }));
                            }
                        } catch (err) {
                            _iterator37.e(err);
                        } finally {
                            _iterator37.f();
                        }
                        return acc;
                    }, []);
                }
                function createBranch(routes) {
                    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    return {
                        routes: routes,
                        score: scoreRoute(routes[routes.length - 1]) * 1e4 - index,
                        matcher: function matcher(location) {
                            var matches = [];
                            for (var i = routes.length - 1; i >= 0; i--) {
                                var route = routes[i];
                                var match = route.matcher(location);
                                if (!match) {
                                    return null;
                                }
                                matches.unshift(_objectSpread(_objectSpread({}, match), {}, {
                                    route: route
                                }));
                            }
                            return matches;
                        }
                    };
                }
                function asArray(value) {
                    return Array.isArray(value) ? value : [ value ];
                }
                function createBranches(routeDef) {
                    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
                    var stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
                    var branches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
                    var routeDefs = asArray(routeDef);
                    for (var i = 0, len = routeDefs.length; i < len; i++) {
                        var def = routeDefs[i];
                        if (def && _typeof(def) === "object") {
                            if (!def.hasOwnProperty("path")) def.path = "";
                            var routes = createRoutes(def, base);
                            var _iterator38 = _createForOfIteratorHelper(routes), _step38;
                            try {
                                for (_iterator38.s(); !(_step38 = _iterator38.n()).done; ) {
                                    var route = _step38.value;
                                    stack.push(route);
                                    var isEmptyArray = Array.isArray(def.children) && def.children.length === 0;
                                    if (def.children && !isEmptyArray) {
                                        createBranches(def.children, route.pattern, stack, branches);
                                    } else {
                                        var branch = createBranch(_toConsumableArray(stack), branches.length);
                                        branches.push(branch);
                                    }
                                    stack.pop();
                                }
                            } catch (err) {
                                _iterator38.e(err);
                            } finally {
                                _iterator38.f();
                            }
                        }
                    }
                    return stack.length ? branches : branches.sort(function(a, b) {
                        return b.score - a.score;
                    });
                }
                function getRouteMatches(branches, location) {
                    for (var i = 0, len = branches.length; i < len; i++) {
                        var match = branches[i].matcher(location);
                        if (match) {
                            return match;
                        }
                    }
                    return [];
                }
                function createLocation(path, state, queryWrapper) {
                    var origin = new URL(mockBase);
                    var url = createMemo(function(prev) {
                        var path_ = path();
                        try {
                            return new URL(path_, origin);
                        } catch (err) {
                            console.error("Invalid path ".concat(path_));
                            return prev;
                        }
                    }, origin, {
                        equals: function equals(a, b) {
                            return a.href === b.href;
                        }
                    });
                    var pathname = createMemo(function() {
                        return url().pathname;
                    });
                    var search = createMemo(function() {
                        return url().search;
                    }, true);
                    var hash = createMemo(function() {
                        return url().hash;
                    });
                    var key = function key() {
                        return "";
                    };
                    var queryFn = on(search, function() {
                        return extractSearchParams(url());
                    });
                    return {
                        get pathname() {
                            return pathname();
                        },
                        get search() {
                            return search();
                        },
                        get hash() {
                            return hash();
                        },
                        get state() {
                            return state();
                        },
                        get key() {
                            return key();
                        },
                        query: queryWrapper ? queryWrapper(queryFn) : createMemoObject(queryFn)
                    };
                }
                var intent;
                function getIntent() {
                    return intent;
                }
                function setInPreloadFn(value) {}
                function createRouterContext(integration, branches, getContext) {
                    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
                    var _integration$signal = _slicedToArray(integration.signal, 2), source = _integration$signal[0], setSource = _integration$signal[1], _integration$utils = integration.utils, utils = _integration$utils === void 0 ? {} : _integration$utils;
                    var parsePath = utils.parsePath || function(p) {
                        return p;
                    };
                    var renderPath = utils.renderPath || function(p) {
                        return p;
                    };
                    var beforeLeave = utils.beforeLeave || createBeforeLeave();
                    var basePath = _resolvePath("", options.base || "");
                    if (basePath === undefined) {
                        throw new Error("".concat(basePath, " is not a valid base path"));
                    } else if (basePath && !source().value) {
                        setSource({
                            value: basePath,
                            replace: true,
                            scroll: false
                        });
                    }
                    var _createSignal29 = createSignal(false), _createSignal30 = _slicedToArray(_createSignal29, 2), isRouting = _createSignal30[0], setIsRouting = _createSignal30[1];
                    var lastTransitionTarget;
                    var transition = function transition(newIntent, newTarget) {
                        if (newTarget.value === reference() && newTarget.state === state()) return;
                        if (lastTransitionTarget === undefined) setIsRouting(true);
                        intent = newIntent;
                        lastTransitionTarget = newTarget;
                        startTransition(function() {
                            if (lastTransitionTarget !== newTarget) return;
                            setReference(lastTransitionTarget.value);
                            setState(lastTransitionTarget.state);
                            submissions[1](function(subs) {
                                return subs.filter(function(s) {
                                    return s.pending;
                                });
                            });
                        }).finally(function() {
                            if (lastTransitionTarget !== newTarget) return;
                            batch(function() {
                                intent = undefined;
                                if (newIntent === "navigate") navigateEnd(lastTransitionTarget);
                                setIsRouting(false);
                                lastTransitionTarget = undefined;
                            });
                        });
                    };
                    var _createSignal31 = createSignal(source().value), _createSignal32 = _slicedToArray(_createSignal31, 2), reference = _createSignal32[0], setReference = _createSignal32[1];
                    var _createSignal33 = createSignal(source().state), _createSignal34 = _slicedToArray(_createSignal33, 2), state = _createSignal34[0], setState = _createSignal34[1];
                    var location = createLocation(reference, state, utils.queryWrapper);
                    var referrers = [];
                    var submissions = createSignal([]);
                    var matches = createMemo(function() {
                        if (typeof options.transformUrl === "function") {
                            return getRouteMatches(branches(), options.transformUrl(location.pathname));
                        }
                        return getRouteMatches(branches(), location.pathname);
                    });
                    var buildParams = function buildParams() {
                        var m = matches();
                        var params = {};
                        for (var i = 0; i < m.length; i++) {
                            Object.assign(params, m[i].params);
                        }
                        return params;
                    };
                    var params = utils.paramsWrapper ? utils.paramsWrapper(buildParams, branches) : createMemoObject(buildParams);
                    var baseRoute = {
                        pattern: basePath,
                        path: function path() {
                            return basePath;
                        },
                        outlet: function outlet() {
                            return null;
                        },
                        resolvePath: function resolvePath(to) {
                            return _resolvePath(basePath, to);
                        }
                    };
                    createRenderEffect(on(source, function(source) {
                        return transition("native", source);
                    }, {
                        defer: true
                    }));
                    return {
                        base: baseRoute,
                        location: location,
                        params: params,
                        isRouting: isRouting,
                        renderPath: renderPath,
                        parsePath: parsePath,
                        navigatorFactory: navigatorFactory,
                        matches: matches,
                        beforeLeave: beforeLeave,
                        preloadRoute: preloadRoute,
                        singleFlight: options.singleFlight === undefined ? true : options.singleFlight,
                        submissions: submissions
                    };
                    function navigateFromRoute(route, to, options) {
                        untrack(function() {
                            if (typeof to === "number") {
                                if (!to) {} else if (utils.go) {
                                    utils.go(to);
                                } else {
                                    console.warn("Router integration does not support relative routing");
                                }
                                return;
                            }
                            var queryOnly = !to || to[0] === "?";
                            var _replace$resolve$scro = _objectSpread({
                                replace: false,
                                resolve: !queryOnly,
                                scroll: true
                            }, options), replace = _replace$resolve$scro.replace, resolve = _replace$resolve$scro.resolve, scroll = _replace$resolve$scro.scroll, nextState = _replace$resolve$scro.state;
                            var resolvedTo = resolve ? route.resolvePath(to) : _resolvePath(queryOnly && location.pathname || "", to);
                            if (resolvedTo === undefined) {
                                throw new Error("Path '".concat(to, "' is not a routable path"));
                            } else if (referrers.length >= MAX_REDIRECTS) {
                                throw new Error("Too many redirects");
                            }
                            var current = reference();
                            if (resolvedTo !== current || nextState !== state()) {
                                if (isServer) ; else if (beforeLeave.confirm(resolvedTo, options)) {
                                    referrers.push({
                                        value: current,
                                        replace: replace,
                                        scroll: scroll,
                                        state: state()
                                    });
                                    transition("navigate", {
                                        value: resolvedTo,
                                        state: nextState
                                    });
                                }
                            }
                        });
                    }
                    function navigatorFactory(route) {
                        route = route || useContext(RouteContextObj) || baseRoute;
                        return function(to, options) {
                            return navigateFromRoute(route, to, options);
                        };
                    }
                    function navigateEnd(next) {
                        var first = referrers[0];
                        if (first) {
                            setSource(_objectSpread(_objectSpread({}, next), {}, {
                                replace: first.replace,
                                scroll: first.scroll
                            }));
                            referrers.length = 0;
                        }
                    }
                    function preloadRoute(url, preloadData) {
                        var matches = getRouteMatches(branches(), url.pathname);
                        var prevIntent = intent;
                        intent = "preload";
                        var _loop10 = function _loop10() {
                            var _matches$match = matches[match], route = _matches$match.route, params = _matches$match.params;
                            route.component && route.component.preload && route.component.preload();
                            var preload = route.preload;
                            preloadData && preload && runWithOwner(getContext(), function() {
                                return preload({
                                    params: params,
                                    location: {
                                        pathname: url.pathname,
                                        search: url.search,
                                        hash: url.hash,
                                        query: extractSearchParams(url),
                                        state: null,
                                        key: ""
                                    },
                                    intent: "preload"
                                });
                            });
                        };
                        for (var match in matches) {
                            _loop10();
                        }
                        intent = prevIntent;
                    }
                }
                function createRouteContext(router, parent, _outlet, match) {
                    var base = router.base, location = router.location, params = router.params;
                    var _match$route = match().route, pattern = _match$route.pattern, component = _match$route.component, preload = _match$route.preload;
                    var path = createMemo(function() {
                        return match().path;
                    });
                    component && component.preload && component.preload();
                    var data = preload ? preload({
                        params: params,
                        location: location,
                        intent: intent || "initial"
                    }) : undefined;
                    var route = {
                        parent: parent,
                        pattern: pattern,
                        path: path,
                        outlet: function outlet() {
                            return component ? createComponent$1(component, {
                                params: params,
                                location: location,
                                data: data,
                                get children() {
                                    return _outlet();
                                }
                            }) : _outlet();
                        },
                        resolvePath: function resolvePath(to) {
                            return _resolvePath(base.path(), to, path());
                        }
                    };
                    return route;
                }
                var createRouterComponent = function createRouterComponent(router) {
                    return function(props) {
                        var base = props.base;
                        var routeDefs = children(function() {
                            return props.children;
                        });
                        var branches = createMemo(function() {
                            return createBranches(routeDefs(), props.base || "");
                        });
                        var context;
                        var routerState = createRouterContext(router, branches, function() {
                            return context;
                        }, {
                            base: base,
                            singleFlight: props.singleFlight,
                            transformUrl: props.transformUrl
                        });
                        router.create && router.create(routerState);
                        return createComponent(RouterContextObj.Provider, {
                            value: routerState,
                            get children() {
                                return createComponent(Root, {
                                    routerState: routerState,
                                    get root() {
                                        return props.root;
                                    },
                                    get preload() {
                                        return props.rootPreload || props.rootLoad;
                                    },
                                    get children() {
                                        return [ memo(function() {
                                            return (context = getOwner()) && null;
                                        }), createComponent(Routes, {
                                            routerState: routerState,
                                            get branches() {
                                                return branches();
                                            }
                                        }) ];
                                    }
                                });
                            }
                        });
                    };
                };
                function Root(props) {
                    var location = props.routerState.location;
                    var params = props.routerState.params;
                    var data = createMemo(function() {
                        return props.preload && untrack(function() {
                            setInPreloadFn(true);
                            props.preload({
                                params: params,
                                location: location,
                                intent: getIntent() || "initial"
                            });
                            setInPreloadFn(false);
                        });
                    });
                    return createComponent(Show, {
                        get when() {
                            return props.root;
                        },
                        keyed: true,
                        get fallback() {
                            return props.children;
                        },
                        children: function children(Root2) {
                            return createComponent(Root2, {
                                params: params,
                                location: location,
                                get data() {
                                    return data();
                                },
                                get children() {
                                    return props.children;
                                }
                            });
                        }
                    });
                }
                function Routes(props) {
                    var disposers = [];
                    var root;
                    var routeStates = createMemo(on(props.routerState.matches, function(nextMatches, prevMatches, prev) {
                        var equal = prevMatches && nextMatches.length === prevMatches.length;
                        var next = [];
                        var _loop11 = function _loop11(i) {
                            var prevMatch = prevMatches && prevMatches[i];
                            var nextMatch = nextMatches[i];
                            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {
                                next[i] = prev[i];
                            } else {
                                equal = false;
                                if (disposers[i]) {
                                    disposers[i]();
                                }
                                createRoot(function(dispose) {
                                    disposers[i] = dispose;
                                    next[i] = createRouteContext(props.routerState, next[i - 1] || props.routerState.base, createOutlet(function() {
                                        return routeStates()[i + 1];
                                    }), function() {
                                        return props.routerState.matches()[i];
                                    });
                                });
                            }
                        };
                        for (var i = 0, len = nextMatches.length; i < len; i++) {
                            _loop11(i);
                        }
                        disposers.splice(nextMatches.length).forEach(function(dispose) {
                            return dispose();
                        });
                        if (prev && equal) {
                            return prev;
                        }
                        root = next[0];
                        return next;
                    }));
                    return createOutlet(function() {
                        return routeStates() && root;
                    })();
                }
                var createOutlet = function createOutlet(child) {
                    return function() {
                        return createComponent(Show, {
                            get when() {
                                return child();
                            },
                            keyed: true,
                            children: function children(child2) {
                                return createComponent(RouteContextObj.Provider, {
                                    value: child2,
                                    get children() {
                                        return child2.outlet();
                                    }
                                });
                            }
                        });
                    };
                };
                var Route = function Route(props) {
                    var childRoutes = children(function() {
                        return props.children;
                    });
                    return mergeProps$1(props, {
                        get children() {
                            return childRoutes();
                        }
                    });
                };
                function intercept(_ref68, get, set) {
                    var _ref69 = _slicedToArray(_ref68, 2), value = _ref69[0], setValue = _ref69[1];
                    return [ value, set ? function(v) {
                        return setValue(set(v));
                    } : setValue ];
                }
                function createRouter(config) {
                    var ignore = false;
                    var wrap = function wrap(value) {
                        return typeof value === "string" ? {
                            value: value
                        } : value;
                    };
                    var signal = intercept(createSignal(wrap(config.get()), {
                        equals: function equals(a, b) {
                            return a.value === b.value && a.state === b.state;
                        }
                    }), undefined, function(next) {
                        !ignore && config.set(next);
                        if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = true;
                        return next;
                    });
                    config.init && onCleanup(config.init(function() {
                        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get();
                        ignore = true;
                        signal[1](wrap(value));
                        ignore = false;
                    }));
                    return createRouterComponent({
                        signal: signal,
                        create: config.create,
                        utils: config.utils
                    });
                }
                function Navigate(props) {
                    var navigate = useNavigate();
                    var location = useLocation();
                    var href = props.href, state = props.state;
                    var path = typeof href === "function" ? href({
                        navigate: navigate,
                        location: location
                    }) : href;
                    navigate(path, {
                        replace: true,
                        state: state
                    });
                    return null;
                }
                function hashParser(str) {
                    var to = str.replace(/^.*?#/, "");
                    if (!to.startsWith("/")) {
                        var _window$location$hash = window.location.hash.split("#", 2), _window$location$hash2 = _slicedToArray(_window$location$hash, 2), _window$location$hash3 = _window$location$hash2[1], path = _window$location$hash3 === void 0 ? "/" : _window$location$hash3;
                        return "".concat(path, "#").concat(to);
                    }
                    return to;
                }
                function bindEvent(target, type, handler) {
                    target.addEventListener(type, handler);
                    return function() {
                        return target.removeEventListener(type, handler);
                    };
                }
                function HashRouter(props) {
                    var getSource = function getSource() {
                        return window.location.hash.slice(1);
                    };
                    var beforeLeave = createBeforeLeave();
                    return createRouter({
                        get: getSource,
                        set: function set(_ref70) {
                            var value = _ref70.value, replace = _ref70.replace, state = _ref70.state;
                            if (replace) {
                                window.history.replaceState(keepDepth(state), "", "#" + value);
                            } else {
                                window.history.pushState(state, "", "#" + value);
                            }
                            saveCurrentDepth();
                        },
                        init: function init(notify) {
                            return bindEvent(window, "hashchange", notifyIfNotBlocked(notify, function(delta) {
                                return !beforeLeave.confirm(delta && delta < 0 ? delta : getSource());
                            }));
                        },
                        utils: {
                            go: function go(delta) {
                                return window.history.go(delta);
                            },
                            renderPath: function renderPath(path) {
                                return "#".concat(path);
                            },
                            parsePath: hashParser,
                            beforeLeave: beforeLeave,
                            queryWrapper: props.forceProxy || !SUPPORTS_PROXY ? function(getQuery) {
                                return createMemoWithoutProxy(getQuery, props.queryParams);
                            } : void 0,
                            paramsWrapper: props.forceProxy || !SUPPORTS_PROXY ? function(buildParams, branches) {
                                return createMemoWithoutProxy(buildParams, collectDynamicParams(branches()));
                            } : void 0
                        }
                    })(props);
                }
                var SUPPORTS_PROXY = typeof Proxy === "function";
                function createMemoWithoutProxy(fn, allKeys) {
                    var map = new Map;
                    var owner = getOwner();
                    var target = {};
                    var handler = function handler(property) {
                        if (!map.has(property)) {
                            runWithOwner(owner, function() {
                                return map.set(property, createMemo(function() {
                                    return fn()[property];
                                }));
                            });
                        }
                        return map.get(property)();
                    };
                    var keys = allKeys ? allKeys : Object.keys(fn());
                    keys.forEach(function(key) {
                        Object.defineProperty(target, key, {
                            get: function get() {
                                return handler(key);
                            },
                            enumerable: true,
                            configurable: true
                        });
                    });
                    return target;
                }
                var collectDynamicParams = function collectDynamicParams(branches) {
                    var dynamicParams = [];
                    branches.forEach(function(branch) {
                        branch.routes.forEach(function(route) {
                            if (route.pattern) {
                                var matches = route.pattern.match(/:(\w+)/g);
                                if (matches) {
                                    matches.forEach(function(param) {
                                        var p = param.slice(1);
                                        if (!dynamicParams.includes(p)) dynamicParams.push(p);
                                    });
                                }
                            }
                        });
                    });
                    return dynamicParams;
                };
                function idxInArray(idx, arr) {
                    return idx >= 0 && idx < arr.length;
                }
                function findFirstFocusableChildIdx(el) {
                    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                    for (var i = from; ;i += delta) {
                        var _el$children$i;
                        if (!idxInArray(i, el.children)) {
                            if (el.wrap) {
                                i = (i + el.children.length) % el.children.length;
                            } else break;
                        }
                        if (!((_el$children$i = el.children[i]) !== null && _el$children$i !== void 0 && _el$children$i.skipFocus)) {
                            return i;
                        }
                    }
                    return -1;
                }
                function selectChild(el, index) {
                    var _el$onSelectedChanged;
                    var child = el.children[index];
                    if (child == null || child.skipFocus) {
                        el.selected = -1;
                        return false;
                    }
                    var lastSelected = el.selected;
                    el.selected = index;
                    if (!isFocused(child)) {
                        child.setFocus();
                    }
                    (_el$onSelectedChanged = el.onSelectedChanged) === null || _el$onSelectedChanged === void 0 || _el$onSelectedChanged.call(el, index, el, child, lastSelected);
                    return true;
                }
                var navigableForwardFocus = function navigableForwardFocus() {
                    var navigable = this;
                    var selected = Math.max(navigable.selected, 0);
                    if (selected !== 0) {
                        selected = clamp(selected, 0, Math.max(0, this.children.length - 1));
                        while (!idxInArray(selected, this.children)) {
                            selected--;
                        }
                    }
                    selected = findFirstFocusableChildIdx(navigable, selected);
                    navigable.selected = selected;
                    return selectChild(navigable, selected);
                };
                function handleNavigation(direction) {
                    return function() {
                        return moveSelection(this, direction === "up" || direction === "left" ? -1 : 1);
                    };
                }
                var navigableHandleNavigation = function navigableHandleNavigation(e) {
                    return moveSelection(this, e.key === "ArrowUp" || e.key === "ArrowLeft" ? -1 : 1);
                };
                function moveSelection(el, delta) {
                    var selected = findFirstFocusableChildIdx(el, el.selected + delta, delta);
                    if (selected === -1) {
                        var _el$children$el$selec;
                        if (!idxInArray(el.selected, el.children) || (_el$children$el$selec = el.children[el.selected]) !== null && _el$children$el$selec !== void 0 && _el$children$el$selec.skipFocus || isFocused(el.children[el.selected])) {
                            return false;
                        }
                        selected = el.selected;
                    }
                    var active = el.children[selected];
                    if (el.plinko) {
                        var lastSelectedChild = el.children[el.selected];
                        var num = lastSelectedChild.selected || 0;
                        active.selected = num < active.children.length ? num : active.children.length - 1;
                    }
                    return selectChild(el, selected);
                }
                var InViewPort = 8;
                var isNotShown = function isNotShown(node) {
                    return node.lng.renderState !== InViewPort;
                };
                function withScrolling(isRow) {
                    var dimension = isRow ? "width" : "height";
                    var axis = isRow ? "x" : "y";
                    return function(selected, component, selectedElement, lastSelected) {
                        var _componentRef$_target, _componentRef$offset2, _selectedElement$axis, _selectedElement$dime, _ref71, _selectedElement$scal, _selectedElement$styl, _componentRef$dimensi, _componentRef$endOffs2;
                        var componentRef = component;
                        if (typeof selected !== "number") {
                            componentRef = selected;
                            selected = componentRef.selected || 0;
                        }
                        if (!componentRef || componentRef.scroll === "none" || selected === lastSelected || !componentRef.children.length) return;
                        if (componentRef._initialPosition === void 0) {
                            componentRef._initialPosition = componentRef[axis];
                        }
                        var lng = componentRef.lng;
                        var screenSize = isRow ? lng.stage.root.w : lng.stage.root.h;
                        var isIncrementing = lastSelected === void 0 || lastSelected - 1 !== selected;
                        if (componentRef._screenOffset === void 0) {
                            var _componentRef$offset;
                            if (componentRef.parent.clipping) {
                                var _componentRef$endOffs;
                                var p = componentRef.parent;
                                componentRef.endOffset = (_componentRef$endOffs = componentRef.endOffset) !== null && _componentRef$endOffs !== void 0 ? _componentRef$endOffs : screenSize - ((isRow ? p.absX : p.absY) || 0) - p[dimension];
                            }
                            componentRef._screenOffset = (_componentRef$offset = componentRef.offset) !== null && _componentRef$offset !== void 0 ? _componentRef$offset : (isRow ? lng.absX : lng.absY) - componentRef[axis];
                        }
                        var screenOffset = componentRef._screenOffset;
                        var gap = componentRef.gap || 0;
                        var scroll = componentRef.scroll || (lastSelected === void 0 ? componentRef.scrollIndex ? "center" : "always" : "auto");
                        var targetPosition = (_componentRef$_target = componentRef._targetPosition) !== null && _componentRef$_target !== void 0 ? _componentRef$_target : componentRef[axis];
                        var rootPosition = isIncrementing ? Math.min(targetPosition, componentRef[axis]) : Math.max(targetPosition, componentRef[axis]);
                        componentRef.offset = (_componentRef$offset2 = componentRef.offset) !== null && _componentRef$offset2 !== void 0 ? _componentRef$offset2 : rootPosition;
                        var offset = componentRef.offset;
                        selectedElement = selectedElement || componentRef.children[selected];
                        if (!selectedElement) {
                            return;
                        }
                        var selectedPosition = (_selectedElement$axis = selectedElement[axis]) !== null && _selectedElement$axis !== void 0 ? _selectedElement$axis : 0;
                        var selectedSize = (_selectedElement$dime = selectedElement[dimension]) !== null && _selectedElement$dime !== void 0 ? _selectedElement$dime : 0;
                        var selectedScale = (_ref71 = (_selectedElement$scal = selectedElement.scale) !== null && _selectedElement$scal !== void 0 ? _selectedElement$scal : (_selectedElement$styl = selectedElement.style) === null || _selectedElement$styl === void 0 || (_selectedElement$styl = _selectedElement$styl.focus) === null || _selectedElement$styl === void 0 ? void 0 : _selectedElement$styl.scale) !== null && _ref71 !== void 0 ? _ref71 : 1;
                        var selectedSizeScaled = selectedSize * selectedScale;
                        var containerSize = (_componentRef$dimensi = componentRef[dimension]) !== null && _componentRef$dimensi !== void 0 ? _componentRef$dimensi : 0;
                        var maxOffset = Math.min(screenSize - containerSize - screenOffset - ((_componentRef$endOffs2 = componentRef.endOffset) !== null && _componentRef$endOffs2 !== void 0 ? _componentRef$endOffs2 : 2 * gap), offset);
                        var nextIndex = isIncrementing ? selected + 1 : selected - 1;
                        var nextElement = componentRef.children[nextIndex] || null;
                        var nextPosition = rootPosition;
                        if (selectedElement.centerScroll) {
                            nextPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2;
                        } else if (scroll === "always") {
                            nextPosition = -selectedPosition + offset;
                        } else if (scroll === "bounded") {
                            var totalItems = componentRef.children.length;
                            var upCount = componentRef.upCount || 6;
                            var nonScrollableZoneStart = Math.max(0, totalItems - upCount);
                            var isInNonScrollableZone = selected >= nonScrollableZoneStart;
                            var isFirstOfNonScrollableZone = selected === nonScrollableZoneStart;
                            var isEnteringZone = isFirstOfNonScrollableZone && lastSelected !== void 0 && lastSelected < nonScrollableZoneStart;
                            if (!isInNonScrollableZone) {
                                nextPosition = -selectedPosition + offset;
                            } else if (isIncrementing) {
                                if (isEnteringZone) {
                                    var _firstOfZoneElement$a;
                                    var firstOfZoneElement = componentRef.children[nonScrollableZoneStart];
                                    var firstOfZonePosition = (_firstOfZoneElement$a = firstOfZoneElement === null || firstOfZoneElement === void 0 ? void 0 : firstOfZoneElement[axis]) !== null && _firstOfZoneElement$a !== void 0 ? _firstOfZoneElement$a : 0;
                                    nextPosition = firstOfZoneElement ? -firstOfZonePosition + offset : rootPosition;
                                } else {
                                    nextPosition = rootPosition;
                                }
                            } else if (isFirstOfNonScrollableZone) {
                                nextPosition = -selectedPosition + offset;
                            } else {
                                nextPosition = rootPosition;
                            }
                        } else if (scroll === "center") {
                            var centerPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2 - screenOffset;
                            nextPosition = Math.min(Math.max(centerPosition, maxOffset), offset);
                        } else if (!nextElement) {
                            nextPosition = isIncrementing ? maxOffset : offset;
                        } else if (scroll === "auto") {
                            if (componentRef.scrollIndex && componentRef.scrollIndex > 0) {
                                var _totalItems = componentRef.children.length;
                                var nearEndIndex = _totalItems - componentRef.scrollIndex;
                                if (isIncrementing && componentRef.selected >= componentRef.scrollIndex) {
                                    nextPosition = rootPosition - selectedSize - gap;
                                } else if (!isIncrementing && componentRef.selected < nearEndIndex) {
                                    nextPosition = rootPosition + selectedSize + gap;
                                }
                            } else if (isIncrementing) {
                                nextPosition = rootPosition - selectedSize - gap;
                            } else {
                                nextPosition = rootPosition + selectedSize + gap;
                            }
                        } else if (isIncrementing && isNotShown(nextElement)) {
                            nextPosition = rootPosition - selectedSize - gap;
                        } else if (isNotShown(nextElement)) {
                            nextPosition = -selectedPosition + offset;
                        }
                        nextPosition = isIncrementing && scroll !== "always" && scroll !== "bounded" ? Math.max(nextPosition, maxOffset) : Math.min(nextPosition, offset);
                        if (componentRef[axis] !== nextPosition) {
                            if (componentRef.onScrolled) {
                                var isInitial = nextPosition === componentRef._initialPosition;
                                componentRef.onScrolled(componentRef, nextPosition, isInitial);
                            }
                            componentRef[axis] = nextPosition;
                            componentRef._targetPosition = nextPosition;
                        }
                    };
                }
                var scrollRow = withScrolling(true);
                var scrollColumn = withScrolling(false);
                function chainFunctions() {
                    for (var _len9 = arguments.length, fns = new Array(_len9), _key14 = 0; _key14 < _len9; _key14++) {
                        fns[_key14] = arguments[_key14];
                    }
                    var onlyFunctions = fns.filter(function(func) {
                        return typeof func === "function";
                    });
                    if (onlyFunctions.length === 0) {
                        return void 0;
                    }
                    if (onlyFunctions.length === 1) {
                        return onlyFunctions[0];
                    }
                    return function() {
                        var result;
                        for (var _len0 = arguments.length, innerArgs = new Array(_len0), _key15 = 0; _key15 < _len0; _key15++) {
                            innerArgs[_key15] = arguments[_key15];
                        }
                        var _iterator39 = _createForOfIteratorHelper(onlyFunctions), _step39;
                        try {
                            for (_iterator39.s(); !(_step39 = _iterator39.n()).done; ) {
                                var func = _step39.value;
                                result = func.apply(this, innerArgs);
                                if (result === true) {
                                    return result;
                                }
                            }
                        } catch (err) {
                            _iterator39.e(err);
                        } finally {
                            _iterator39.f();
                        }
                        return result;
                    };
                }
                var chainRefs = exports("n", chainFunctions);
                var ColumnStyles = {
                    display: "flex",
                    flexDirection: "column",
                    gap: 30,
                    transition: {
                        y: {
                            duration: 250,
                            easing: "ease-in-out"
                        }
                    }
                };
                function scrollToIndex$1(index) {
                    var _this$children$index;
                    this.selected = index;
                    scrollColumn(index, this);
                    (_this$children$index = this.children[index]) === null || _this$children$index === void 0 || _this$children$index.setFocus();
                }
                var onUp = handleNavigation("up");
                var onDown = handleNavigation("down");
                var Column = exports("C", function(props) {
                    return function() {
                        var _el$ = createElement("view");
                        spread(_el$, mergeProps(props, {
                            onUp: chainFunctions(props.onUp, onUp),
                            onDown: chainFunctions(props.onDown, onDown),
                            get selected() {
                                return props.selected || 0;
                            },
                            scrollToIndex: scrollToIndex$1,
                            forwardFocus: navigableForwardFocus,
                            onLayout: props.selected ? chainFunctions(props.onLayout, scrollColumn) : props.onLayout,
                            onSelectedChanged: chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scrollColumn : void 0),
                            style: combineStyles(props.style, ColumnStyles)
                        }), false);
                        return _el$;
                    }();
                });
                var RowStyles = {
                    display: "flex",
                    gap: 30,
                    transition: {
                        x: {
                            duration: 250,
                            easing: "ease-in-out"
                        }
                    }
                };
                function scrollToIndex(index) {
                    var _this$children$index2;
                    this.selected = index;
                    scrollRow(index, this);
                    (_this$children$index2 = this.children[index]) === null || _this$children$index2 === void 0 || _this$children$index2.setFocus();
                }
                var onLeft = handleNavigation("left");
                var onRight = handleNavigation("right");
                var Row = exports("R", function(props) {
                    return function() {
                        var _el$ = createElement("view");
                        spread(_el$, mergeProps(props, {
                            get selected() {
                                return props.selected || 0;
                            },
                            onLeft: chainFunctions(props.onLeft, onLeft),
                            onRight: chainFunctions(props.onRight, onRight),
                            forwardFocus: navigableForwardFocus,
                            scrollToIndex: scrollToIndex,
                            onLayout: props.selected ? chainFunctions(props.onLayout, scrollRow) : props.onLayout,
                            onSelectedChanged: chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scrollRow : void 0),
                            style: combineStyles(props.style, RowStyles)
                        }), false);
                        return _el$;
                    }();
                });
                var fpsStyle = {
                    color: 255,
                    height: 192,
                    width: 330,
                    x: 1900,
                    y: 6,
                    mountX: 1,
                    alpha: 1,
                    zIndex: 100
                };
                var fpsLabel = {
                    x: 10,
                    fontSize: 20,
                    textColor: 4143380223
                };
                var fpsValue = {
                    fontSize: 22,
                    textColor: 4143380223
                };
                var _createSignal35 = createSignal(0), _createSignal36 = _slicedToArray(_createSignal35, 2), fps = _createSignal36[0], setFps = _createSignal36[1];
                var _createSignal37 = createSignal(0), _createSignal38 = _slicedToArray(_createSignal37, 2), avgFps = _createSignal38[0], setAvgFps = _createSignal38[1];
                var _createSignal39 = createSignal(99), _createSignal40 = _slicedToArray(_createSignal39, 2), minFps = _createSignal40[0], setMinFps = _createSignal40[1];
                var _createSignal41 = createSignal(0), _createSignal42 = _slicedToArray(_createSignal41, 2), maxFps = _createSignal42[0], setMaxFps = _createSignal42[1];
                var _createSignal43 = createSignal(0), _createSignal44 = _slicedToArray(_createSignal43, 2), quads = _createSignal44[0], setQuads = _createSignal44[1];
                var _createSignal45 = createSignal(""), _createSignal46 = _slicedToArray(_createSignal45, 2), criticalThresholdSignal = _createSignal46[0], setCriticalThresholdSignal = _createSignal46[1];
                var _createSignal47 = createSignal(""), _createSignal48 = _slicedToArray(_createSignal47, 2), targetThresholdSignal = _createSignal48[0], setTargetThresholdSignal = _createSignal48[1];
                var _createSignal49 = createSignal(""), _createSignal50 = _slicedToArray(_createSignal49, 2), renderableMemUsedSignal = _createSignal50[0], setRenderableMemUsedSignal = _createSignal50[1];
                var _createSignal51 = createSignal(""), _createSignal52 = _slicedToArray(_createSignal51, 2), memUsedSignal = _createSignal52[0], setMemUsedSignal = _createSignal52[1];
                var _createSignal53 = createSignal(0), _createSignal54 = _slicedToArray(_createSignal53, 2), renderableTexturesLoadedSignal = _createSignal54[0], setRenderableTexturesLoadedSignal = _createSignal54[1];
                var _createSignal55 = createSignal(0), _createSignal56 = _slicedToArray(_createSignal55, 2), loadedTexturesSignal = _createSignal56[0], setLoadedTexturesSignal = _createSignal56[1];
                var count = 0;
                var totalFps = 0;
                var infoFontSize = 14;
                function bytesToMb(bytes) {
                    return (bytes / 1024 / 1024).toFixed(2) + " Mb";
                }
                var calcFps = function calcFps(fps2) {
                    if (!fps2) return;
                    setFps(fps2);
                    setMinFps(function(prev) {
                        return Math.min(fps2, prev);
                    });
                    setMaxFps(function(prev) {
                        return Math.max(fps2, prev);
                    });
                    totalFps += fps2;
                    count++;
                    setAvgFps(Math.round(totalFps / count));
                };
                function updateMemoryInfo(stage) {
                    var memInfo = stage.txMemManager.getMemoryInfo();
                    setCriticalThresholdSignal(bytesToMb(memInfo.criticalThreshold));
                    setTargetThresholdSignal(bytesToMb(memInfo.targetThreshold));
                    setRenderableMemUsedSignal(bytesToMb(memInfo.renderableMemUsed));
                    setMemUsedSignal(bytesToMb(memInfo.memUsed));
                    setRenderableTexturesLoadedSignal(memInfo.renderableTexturesLoaded);
                    setLoadedTexturesSignal(memInfo.loadedTextures);
                }
                var frameCount = 0;
                function setupFPS(root) {
                    root.renderer.on("fpsUpdate", function(target, fpsData) {
                        var fps2 = typeof fpsData === "number" ? fpsData : fpsData.fps;
                        if (fps2 > 5) {
                            calcFps(fps2);
                            if (frameCount % 10 === 0) {
                                updateMemoryInfo(target.stage);
                                frameCount = 0;
                            }
                            frameCount++;
                        }
                    });
                    root.renderer.on("quadsUpdate", function(target, quadsData) {
                        setQuads(quadsData.quads);
                    });
                }
                var FPSCounter = function FPSCounter(props) {
                    return function() {
                        var _el$ = createElement("view"), _el$2 = createElement("view"), _el$3 = createElement("text"), _el$5 = createElement("text"), _el$6 = createElement("view"), _el$7 = createElement("text"), _el$9 = createElement("text"), _el$0 = createElement("view"), _el$1 = createElement("text"), _el$11 = createElement("text"), _el$12 = createElement("view"), _el$13 = createElement("text"), _el$15 = createElement("text"), _el$16 = createElement("view"), _el$17 = createElement("view"), _el$18 = createElement("text"), _el$20 = createElement("text"), _el$21 = createElement("view"), _el$22 = createElement("text"), _el$24 = createElement("text"), _el$25 = createElement("view"), _el$26 = createElement("text"), _el$28 = createElement("text"), _el$29 = createElement("view"), _el$30 = createElement("text"), _el$32 = createElement("text"), _el$33 = createElement("view"), _el$34 = createElement("text"), _el$36 = createElement("text"), _el$37 = createElement("view"), _el$38 = createElement("text"), _el$40 = createElement("text"), _el$41 = createElement("view"), _el$42 = createElement("text"), _el$44 = createElement("text");
                        insertNode(_el$, _el$2);
                        insertNode(_el$, _el$6);
                        insertNode(_el$, _el$0);
                        insertNode(_el$, _el$12);
                        insertNode(_el$, _el$16);
                        spread(_el$, mergeProps(props, {
                            style: fpsStyle
                        }), true);
                        insertNode(_el$2, _el$3);
                        insertNode(_el$2, _el$5);
                        setProp(_el$2, "y", 6);
                        insertNode(_el$3, createTextNode("FPS:"));
                        setProp(_el$3, "style", fpsLabel);
                        setProp(_el$5, "style", fpsValue);
                        setProp(_el$5, "x", 90);
                        insert(_el$5, function() {
                            return fps().toString();
                        });
                        insertNode(_el$6, _el$7);
                        insertNode(_el$6, _el$9);
                        setProp(_el$6, "y", 6);
                        setProp(_el$6, "x", 160);
                        insertNode(_el$7, createTextNode("AVG:"));
                        setProp(_el$7, "style", fpsLabel);
                        setProp(_el$9, "style", fpsValue);
                        setProp(_el$9, "x", 100);
                        insert(_el$9, function() {
                            return avgFps().toString();
                        });
                        insertNode(_el$0, _el$1);
                        insertNode(_el$0, _el$11);
                        setProp(_el$0, "x", 0);
                        setProp(_el$0, "y", 26);
                        insertNode(_el$1, createTextNode("MIN:"));
                        setProp(_el$1, "style", fpsLabel);
                        setProp(_el$11, "style", fpsValue);
                        setProp(_el$11, "x", 90);
                        insert(_el$11, function() {
                            return minFps().toString();
                        });
                        insertNode(_el$12, _el$13);
                        insertNode(_el$12, _el$15);
                        setProp(_el$12, "x", 160);
                        setProp(_el$12, "y", 26);
                        insertNode(_el$13, createTextNode("MAX:"));
                        setProp(_el$13, "style", fpsLabel);
                        setProp(_el$15, "style", fpsValue);
                        setProp(_el$15, "x", 100);
                        insert(_el$15, function() {
                            return maxFps().toString();
                        });
                        insertNode(_el$16, _el$17);
                        insertNode(_el$16, _el$21);
                        insertNode(_el$16, _el$25);
                        insertNode(_el$16, _el$29);
                        insertNode(_el$16, _el$33);
                        insertNode(_el$16, _el$37);
                        insertNode(_el$16, _el$41);
                        setProp(_el$16, "display", "flex");
                        setProp(_el$16, "flexDirection", "column");
                        setProp(_el$16, "y", 58);
                        setProp(_el$16, "gap", 4);
                        insertNode(_el$17, _el$18);
                        insertNode(_el$17, _el$20);
                        setProp(_el$17, "height", infoFontSize);
                        insertNode(_el$18, createTextNode("criticalThreshold:"));
                        setProp(_el$18, "fontSize", infoFontSize);
                        setProp(_el$18, "style", fpsLabel);
                        setProp(_el$20, "fontSize", infoFontSize);
                        setProp(_el$20, "style", fpsLabel);
                        setProp(_el$20, "x", 230);
                        insert(_el$20, criticalThresholdSignal);
                        insertNode(_el$21, _el$22);
                        insertNode(_el$21, _el$24);
                        setProp(_el$21, "height", infoFontSize);
                        insertNode(_el$22, createTextNode("targetThreshold:"));
                        setProp(_el$22, "fontSize", infoFontSize);
                        setProp(_el$22, "style", fpsLabel);
                        setProp(_el$24, "fontSize", infoFontSize);
                        setProp(_el$24, "style", fpsLabel);
                        setProp(_el$24, "x", 230);
                        insert(_el$24, targetThresholdSignal);
                        insertNode(_el$25, _el$26);
                        insertNode(_el$25, _el$28);
                        setProp(_el$25, "height", infoFontSize);
                        insertNode(_el$26, createTextNode("renderableMemUsed:"));
                        setProp(_el$26, "fontSize", infoFontSize);
                        setProp(_el$26, "style", fpsLabel);
                        setProp(_el$28, "fontSize", infoFontSize);
                        setProp(_el$28, "style", fpsLabel);
                        setProp(_el$28, "x", 230);
                        insert(_el$28, renderableMemUsedSignal);
                        insertNode(_el$29, _el$30);
                        insertNode(_el$29, _el$32);
                        setProp(_el$29, "height", infoFontSize);
                        insertNode(_el$30, createTextNode("memUsed:"));
                        setProp(_el$30, "fontSize", infoFontSize);
                        setProp(_el$30, "style", fpsLabel);
                        setProp(_el$32, "fontSize", infoFontSize);
                        setProp(_el$32, "style", fpsLabel);
                        setProp(_el$32, "x", 230);
                        insert(_el$32, memUsedSignal);
                        insertNode(_el$33, _el$34);
                        insertNode(_el$33, _el$36);
                        setProp(_el$33, "height", infoFontSize);
                        insertNode(_el$34, createTextNode("renderableTexturesLoaded:"));
                        setProp(_el$34, "fontSize", infoFontSize);
                        setProp(_el$34, "style", fpsLabel);
                        setProp(_el$36, "fontSize", infoFontSize);
                        setProp(_el$36, "style", fpsLabel);
                        setProp(_el$36, "x", 230);
                        insert(_el$36, function() {
                            return renderableTexturesLoadedSignal().toString();
                        });
                        insertNode(_el$37, _el$38);
                        insertNode(_el$37, _el$40);
                        setProp(_el$37, "height", infoFontSize);
                        insertNode(_el$38, createTextNode("loadedTextures:"));
                        setProp(_el$38, "fontSize", infoFontSize);
                        setProp(_el$38, "style", fpsLabel);
                        setProp(_el$40, "fontSize", infoFontSize);
                        setProp(_el$40, "style", fpsLabel);
                        setProp(_el$40, "x", 230);
                        insert(_el$40, function() {
                            return loadedTexturesSignal().toString();
                        });
                        insertNode(_el$41, _el$42);
                        insertNode(_el$41, _el$44);
                        setProp(_el$41, "height", infoFontSize);
                        insertNode(_el$42, createTextNode("quads:"));
                        setProp(_el$42, "fontSize", infoFontSize);
                        setProp(_el$42, "style", fpsLabel);
                        setProp(_el$44, "fontSize", infoFontSize);
                        setProp(_el$44, "style", fpsLabel);
                        setProp(_el$44, "x", 230);
                        insert(_el$44, function() {
                            return quads().toString();
                        });
                        return _el$;
                    }();
                };
                var SAFETY_MARGIN = 10;
                function MarqueeText(props) {
                    var speed = createMemo(function() {
                        return props.speed || 200;
                    });
                    var delay = createMemo(function() {
                        var _props$delay2;
                        return (_props$delay2 = props.delay) !== null && _props$delay2 !== void 0 ? _props$delay2 : 1e3;
                    });
                    var scrollGap = createMemo(function() {
                        var _props$scrollGap;
                        return (_props$scrollGap = props.scrollGap) !== null && _props$scrollGap !== void 0 ? _props$scrollGap : props.clipWidth * .5;
                    });
                    var _createSignal57 = createSignal(0), _createSignal58 = _slicedToArray(_createSignal57, 2), textWidth = _createSignal58[0], setTextWidth = _createSignal58[1];
                    var isTextOverflowing = createMemo(function() {
                        return textWidth() > props.clipWidth - SAFETY_MARGIN;
                    });
                    var shouldScroll = createMemo(function() {
                        return props.marquee && isTextOverflowing();
                    });
                    var wasFocusedBefore = createMemo(function(p) {
                        return p || props.marquee;
                    }, false);
                    createEffect(function() {
                        if (shouldScroll()) {
                            var options = {
                                duration: (textWidth() + scrollGap()) / speed() * 1e3,
                                delay: delay(),
                                loop: true,
                                easing: props.easing
                            };
                            text1.lng.x = 0;
                            text2.lng.x = textWidth() + scrollGap();
                            var a1 = text1.lng.animate({
                                x: -textWidth() - scrollGap()
                            }, options).start();
                            var a2 = text2.lng.animate({
                                x: 0
                            }, options).start();
                            onCleanup(function() {
                                a1.stop();
                                a2.stop();
                            });
                        }
                    });
                    var events = {
                        loaded: function loaded(el) {
                            setTextWidth(el.width);
                        }
                    };
                    var text1;
                    var text2;
                    return [ memo(function() {
                        return memo(function() {
                            return !!wasFocusedBefore();
                        })() && [ function() {
                            var _el$2 = createElement("text");
                            var _ref$ = text1;
                            typeof _ref$ === "function" ? use(_ref$, _el$2) : text1 = _el$2;
                            spread(_el$2, mergeProps(props, {
                                get hidden() {
                                    return !shouldScroll();
                                },
                                rtt: true,
                                maxLines: 1,
                                onEvent: events
                            }), false);
                            return _el$2;
                        }(), function() {
                            var _el$3 = createElement("text");
                            var _ref$2 = text2;
                            typeof _ref$2 === "function" ? use(_ref$2, _el$3) : text2 = _el$3;
                            spread(_el$3, mergeProps(props, {
                                get hidden() {
                                    return !shouldScroll();
                                },
                                rtt: true,
                                maxLines: 1
                            }), false);
                            return _el$3;
                        }() ];
                    }), function() {
                        var _el$ = createElement("text");
                        spread(_el$, mergeProps(props, {
                            maxLines: 1,
                            get hidden() {
                                return shouldScroll();
                            },
                            contain: "width"
                        }), false);
                        return _el$;
                    }() ];
                }
                function Marquee(props) {
                    var _createSignal59 = createSignal(props.width || 0), _createSignal60 = _slicedToArray(_createSignal59, 2), clipWidth = _createSignal60[0], setClipWidth = _createSignal60[1];
                    var clipHeight = createMemo(function() {
                        var _props$textProps, _props$textProps2;
                        return props.height || ((_props$textProps = props.textProps) === null || _props$textProps === void 0 ? void 0 : _props$textProps.lineHeight) || (((_props$textProps2 = props.textProps) === null || _props$textProps2 === void 0 ? void 0 : _props$textProps2.fontSize) || 16) * 1.5;
                    });
                    return function() {
                        var _el$4 = createElement("view");
                        spread(_el$4, mergeProps(props, {
                            get height() {
                                return clipHeight();
                            },
                            onLayout: chainFunctions(props.onLayout, function(e) {
                                return setClipWidth(e.width);
                            }),
                            get clipping() {
                                return props.marquee;
                            }
                        }), true);
                        insert(_el$4, createComponent(MarqueeText, mergeProps(function() {
                            return props.textProps;
                        }, {
                            get marquee() {
                                return props.marquee;
                            },
                            get clipWidth() {
                                return clipWidth();
                            },
                            get speed() {
                                return props.speed;
                            },
                            get delay() {
                                return props.delay;
                            },
                            get scrollGap() {
                                return props.scrollGap;
                            },
                            get easing() {
                                return props.easing;
                            },
                            get children() {
                                return props.children;
                            }
                        })));
                        return _el$4;
                    }();
                }
                var FocusStackContext = createContext(void 0);
                function FocusStackProvider(props) {
                    var _createSignal61 = createSignal([]), _createSignal62 = _slicedToArray(_createSignal61, 2), _focusStack = _createSignal62[0], setFocusStack = _createSignal62[1];
                    function storeFocus(element, prevElement) {
                        var elm = prevElement || element;
                        if (elm) {
                            setFocusStack(function(stack) {
                                return [].concat(_toConsumableArray(stack), [ elm ]);
                            });
                        }
                    }
                    function restoreFocus() {
                        var wasFocused = false;
                        setFocusStack(function(stack) {
                            var prevElement = stack.pop();
                            if (prevElement && typeof prevElement.setFocus === "function") {
                                prevElement.setFocus();
                                wasFocused = true;
                            }
                            return _toConsumableArray(stack);
                        });
                        return wasFocused;
                    }
                    function clearFocusStack() {
                        setFocusStack([]);
                    }
                    return createComponent(FocusStackContext.Provider, {
                        value: {
                            storeFocus: storeFocus,
                            restoreFocus: restoreFocus,
                            clearFocusStack: clearFocusStack
                        },
                        get children() {
                            return props.children;
                        }
                    });
                }
                function useFocusStack() {
                    var autoClear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                    var context = useContext(FocusStackContext);
                    if (!context) {
                        throw new Error("useFocusStack must be used within a FocusStackProvider");
                    }
                    if (autoClear) {
                        onCleanup(function() {
                            setTimeout(function() {
                                return context.clearFocusStack();
                            }, 5);
                        });
                    }
                    return context;
                }
                var keepAliveElements = new Map;
                var storeKeepAlive = function storeKeepAlive(element) {
                    if (keepAliveElements.has(element.id)) {
                        console.warn('[KeepAlive] Element with id "'.concat(element.id, '" already in cache. Recreating.'));
                        return element;
                    }
                    keepAliveElements.set(element.id, element);
                    return element;
                };
                function wrapChildren(props) {
                    var onRemove = props.onRemove || function(elm) {
                        elm.alpha = 0;
                    };
                    var onRender = props.onRender || function(elm) {
                        elm.alpha = 1;
                    };
                    var transition = props.transition || {
                        alpha: true
                    };
                    return function() {
                        var _el$ = createElement("view");
                        setProp(_el$, "preserve", true);
                        setProp(_el$, "onRemove", onRemove);
                        setProp(_el$, "onRender", onRender);
                        setProp(_el$, "forwardFocus", 0);
                        setProp(_el$, "transition", transition);
                        spread(_el$, props, false);
                        return _el$;
                    }();
                }
                var KeepAlive = function KeepAlive(props) {
                    var _props$shouldDispose;
                    var existing = keepAliveElements.get(props.id);
                    if (existing && (_props$shouldDispose = props.shouldDispose) !== null && _props$shouldDispose !== void 0 && _props$shouldDispose.call(props, props.id)) {
                        existing.dispose();
                        keepAliveElements.delete(props.id);
                        existing = void 0;
                    }
                    if (!existing) {
                        return createRoot(function(dispose) {
                            var children = wrapChildren(props);
                            storeKeepAlive({
                                id: props.id,
                                owner: getOwner(),
                                children: children,
                                dispose: dispose
                            });
                            return children;
                        });
                    } else if (existing && !existing.children) {
                        existing.children = runWithOwner(existing.owner, function() {
                            return wrapChildren(props);
                        });
                    }
                    return existing.children;
                };
                var KeepAliveRoute = function KeepAliveRoute(props) {
                    var key = props.id || props.path;
                    var preload = props.preload ? function(preloadProps) {
                        var _props$shouldDispose2;
                        var existing = keepAliveElements.get(key);
                        if (existing && (_props$shouldDispose2 = props.shouldDispose) !== null && _props$shouldDispose2 !== void 0 && _props$shouldDispose2.call(props, key)) {
                            existing.dispose();
                            keepAliveElements.delete(key);
                            existing = void 0;
                        }
                        if (!existing) {
                            return createRoot(function(dispose) {
                                storeKeepAlive({
                                    id: key,
                                    owner: getOwner(),
                                    dispose: dispose,
                                    children: null
                                });
                                return props.preload(preloadProps);
                            });
                        } else if (existing.children) {
                            var _existing$children;
                            (_existing$children = existing.children) === null || _existing$children === void 0 || _existing$children.setFocus();
                        }
                    } : void 0;
                    return createComponent(Route, mergeProps(props, {
                        preload: preload,
                        component: function component(childProps) {
                            return createComponent(KeepAlive, {
                                id: key,
                                get onRemove() {
                                    return props.onRemove;
                                },
                                get onRender() {
                                    return props.onRender;
                                },
                                get transition() {
                                    return props.transition;
                                },
                                get children() {
                                    return props.component(childProps);
                                }
                            });
                        }
                    }));
                };
                function disposeList(list) {
                    for (var i = 0; i < list.length; i++) {
                        var _list$i;
                        (_list$i = list[i]) === null || _list$i === void 0 || _list$i.disposer();
                    }
                }
                function listArray(list, mapFn) {
                    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
                    var items = [];
                    var mapped = [], unusedItems, i, j, item, oldValue, oldIndex, newValue, fallback, fallbackDisposer;
                    onCleanup(function() {
                        var _fallbackDisposer;
                        (_fallbackDisposer = fallbackDisposer) === null || _fallbackDisposer === void 0 || _fallbackDisposer();
                        fallbackDisposer = undefined;
                        disposeList(items);
                    });
                    return function() {
                        var newItems = list() || [];
                        newItems[$TRACK];
                        return untrack(function() {
                            if (newItems.length > 0 && fallbackDisposer) {
                                fallbackDisposer();
                                fallbackDisposer = undefined;
                                fallback = undefined;
                            }
                            var temp = new Array(newItems.length);
                            unusedItems = items.length;
                            for (j = unusedItems - 1; j >= 0; --j) {
                                item = items[j];
                                oldIndex = item.index;
                                if (oldIndex < newItems.length && newItems[oldIndex] === item.value) {
                                    temp[oldIndex] = mapped[oldIndex];
                                    if (--unusedItems !== j) {
                                        items[j] = items[unusedItems];
                                        items[unusedItems] = item;
                                    }
                                }
                            }
                            var matcher = new Map;
                            var matchedItems = new Uint8Array(unusedItems);
                            for (j = unusedItems - 1; j >= 0; --j) {
                                var _matcher$get$push, _matcher$get;
                                oldValue = items[j].value;
                                (_matcher$get$push = (_matcher$get = matcher.get(oldValue)) === null || _matcher$get === void 0 ? void 0 : _matcher$get.push(j)) !== null && _matcher$get$push !== void 0 ? _matcher$get$push : matcher.set(oldValue, [ j ]);
                            }
                            for (i = 0; i < newItems.length; ++i) {
                                var _matcher$get$pop, _matcher$get2;
                                if (i in temp) continue;
                                newValue = newItems[i];
                                j = (_matcher$get$pop = (_matcher$get2 = matcher.get(newValue)) === null || _matcher$get2 === void 0 ? void 0 : _matcher$get2.pop()) !== null && _matcher$get$pop !== void 0 ? _matcher$get$pop : -1;
                                if (j >= 0) {
                                    var _item$indexSetter, _item;
                                    item = items[j];
                                    oldIndex = item.index;
                                    temp[i] = mapped[oldIndex];
                                    item.index = i;
                                    (_item$indexSetter = (_item = item).indexSetter) === null || _item$indexSetter === void 0 || _item$indexSetter.call(_item, i);
                                    matchedItems[j] = 1;
                                }
                            }
                            for (j = matchedItems.length - 1; j >= 0; --j) {
                                if (matchedItems[j] && --unusedItems !== j) {
                                    item = items[j];
                                    items[j] = items[unusedItems];
                                    items[unusedItems] = item;
                                }
                            }
                            for (j = unusedItems - 1; j >= 0; --j) {
                                item = items[j];
                                oldIndex = item.index;
                                if (!(oldIndex in temp) && oldIndex < newItems.length) {
                                    var _item$valueSetter, _item2;
                                    temp[oldIndex] = mapped[oldIndex];
                                    newValue = newItems[oldIndex];
                                    item.value = newValue;
                                    (_item$valueSetter = (_item2 = item).valueSetter) === null || _item$valueSetter === void 0 || _item$valueSetter.call(_item2, newValueGetter);
                                    if (--unusedItems !== j) {
                                        items[j] = items[unusedItems];
                                        items[unusedItems] = item;
                                    }
                                }
                            }
                            for (i = 0; i < newItems.length; ++i) {
                                if (i in temp) continue;
                                newValue = newItems[i];
                                if (unusedItems > 0) {
                                    item = items[--unusedItems];
                                    temp[i] = mapped[item.index];
                                    batch(changeBoth);
                                } else {
                                    temp[i] = createRoot(mapper);
                                }
                            }
                            disposeList(items.splice(0, unusedItems));
                            if (newItems.length === 0 && options.fallback) {
                                if (!fallbackDisposer) {
                                    fallback = [ createRoot(function(d) {
                                        fallbackDisposer = d;
                                        return options.fallback();
                                    }) ];
                                }
                                return fallback;
                            }
                            return mapped = temp;
                        });
                    };
                    function newValueGetter() {
                        return newValue;
                    }
                    function changeBoth() {
                        var _item$indexSetter2, _item3, _item$valueSetter2, _item4;
                        item.index = i;
                        (_item$indexSetter2 = (_item3 = item).indexSetter) === null || _item$indexSetter2 === void 0 || _item$indexSetter2.call(_item3, i);
                        item.value = newValue;
                        (_item$valueSetter2 = (_item4 = item).valueSetter) === null || _item$valueSetter2 === void 0 || _item$valueSetter2.call(_item4, newValueGetter);
                    }
                    function mapper(disposer) {
                        var t = {
                            value: newValue,
                            index: i,
                            disposer: disposer
                        };
                        items.push(t);
                        var _sV = function sV() {
                            var _createSignal63 = createSignal(t.value);
                            var _createSignal64 = _slicedToArray(_createSignal63, 2);
                            _sV = _createSignal64[0];
                            t.valueSetter = _createSignal64[1];
                            return _sV();
                        }, _sI = function sI() {
                            var _createSignal65 = createSignal(t.index);
                            var _createSignal66 = _slicedToArray(_createSignal65, 2);
                            _sI = _createSignal66[0];
                            t.indexSetter = _createSignal66[1];
                            return _sI();
                        };
                        return mapFn(function() {
                            return _sV();
                        }, function() {
                            return _sI();
                        });
                    }
                }
                function List(props) {
                    var fallback = "fallback" in props && {
                        fallback: function fallback() {
                            return props.fallback;
                        }
                    };
                    return createMemo(listArray(function() {
                        return props.each;
                    }, props.children, fallback || undefined));
                }
                var columnScroll = withScrolling(false);
                var rowStyles = {
                    display: "flex",
                    flexWrap: "wrap",
                    transition: {
                        y: true
                    }
                };
                function VirtualGrid(props) {
                    var _props$selected;
                    var bufferSize = function bufferSize() {
                        var _props$buffer;
                        return (_props$buffer = props.buffer) !== null && _props$buffer !== void 0 ? _props$buffer : 2;
                    };
                    var _createSignal67 = createSignal((_props$selected = props.selected) !== null && _props$selected !== void 0 ? _props$selected : 0), _createSignal68 = _slicedToArray(_createSignal67, 2), cursor = _createSignal68[0], setCursor = _createSignal68[1];
                    var items = createMemo(function() {
                        return props.each || [];
                    });
                    var itemCount = function itemCount() {
                        return items().length;
                    };
                    var itemsPerRow = function itemsPerRow() {
                        return props.columns;
                    };
                    var numberOfRows = function numberOfRows() {
                        var _props$rows;
                        return (_props$rows = props.rows) !== null && _props$rows !== void 0 ? _props$rows : 1;
                    };
                    var totalVisibleItems = function totalVisibleItems() {
                        return itemsPerRow() * numberOfRows();
                    };
                    var start = createMemo(function() {
                        var perRow = itemsPerRow();
                        var newRowIndex = Math.floor(cursor() / perRow);
                        var rawStart = newRowIndex * perRow - bufferSize() * perRow;
                        return Math.max(0, rawStart);
                    });
                    var end = createMemo(function() {
                        var perRow = itemsPerRow();
                        var newRowIndex = Math.floor(cursor() / perRow);
                        var rawEnd = (newRowIndex + bufferSize()) * perRow + totalVisibleItems();
                        return Math.min(items().length, rawEnd);
                    });
                    var _createSignal69 = createSignal(items().slice(start(), end())), _createSignal70 = _slicedToArray(_createSignal69, 2), slice = _createSignal70[0], setSlice = _createSignal70[1];
                    var viewRef;
                    function onVerticalNav(dir) {
                        return function() {
                            var perRow = itemsPerRow();
                            var currentRowIndex = Math.floor(cursor() / perRow);
                            var maxRows = Math.floor(items().length / perRow);
                            if (currentRowIndex === 0 && dir === -1 || currentRowIndex === maxRows && dir === 1) return;
                            var selected = this.selected || 0;
                            var offset = dir * perRow;
                            var newIndex = clamp(selected + offset, 0, items().length - 1);
                            var lastIdx = selected;
                            this.selected = newIndex;
                            var active = this.children[this.selected];
                            if (active instanceof ElementNode) {
                                active.setFocus();
                                chainedOnSelectedChanged.call(this, this.selected, this, active, lastIdx);
                                return true;
                            }
                        };
                    }
                    var onUp = onVerticalNav(-1);
                    var onDown = onVerticalNav(1);
                    var onSelectedChanged = function onSelectedChanged(_idx, elm, active, _lastIdx) {
                        var _this47 = this;
                        var idx = _idx;
                        var lastIdx = _lastIdx;
                        var perRow = itemsPerRow();
                        var newRowIndex = Math.floor(idx / perRow);
                        var prevRowIndex = Math.floor((lastIdx || 0) / perRow);
                        var prevStart = start();
                        setCursor(prevStart + idx);
                        if (newRowIndex === prevRowIndex) return;
                        setSlice(items().slice(start(), end()));
                        var idxCorrection = prevStart - start();
                        if (lastIdx) lastIdx += idxCorrection;
                        idx += idxCorrection;
                        this.selected += idxCorrection;
                        if (props.onEndReachedThreshold !== void 0 && cursor() >= items().length - props.onEndReachedThreshold) {
                            var _props$onEndReached;
                            (_props$onEndReached = props.onEndReached) === null || _props$onEndReached === void 0 || _props$onEndReached.call(props);
                        }
                        queueMicrotask(function() {
                            var prevRowY = _this47.y + active.y;
                            _this47.updateLayout();
                            _this47.lng.y = prevRowY - active.y;
                            columnScroll(idx, elm, active, lastIdx);
                        });
                    };
                    var chainedOnSelectedChanged = chainFunctions(props.onSelectedChanged, onSelectedChanged);
                    var cachedSelected;
                    var updateSelected = function updateSelected(_ref72) {
                        var _ref73 = _slicedToArray(_ref72, 2), selected = _ref73[0], _items = _ref73[1];
                        if (!viewRef || selected == null) return;
                        if (cachedSelected !== void 0) {
                            selected = cachedSelected;
                            cachedSelected = void 0;
                        }
                        if (selected >= items().length && props.onEndReached) {
                            var _props$onEndReached2;
                            (_props$onEndReached2 = props.onEndReached) === null || _props$onEndReached2 === void 0 || _props$onEndReached2.call(props);
                            cachedSelected = selected;
                            return;
                        }
                        var item = items()[selected];
                        var active = viewRef.children.find(function(x) {
                            return x.item === item;
                        });
                        var lastSelected = viewRef.selected;
                        if (active instanceof ElementNode) {
                            viewRef.selected = viewRef.children.indexOf(active);
                            if (hasFocus(viewRef)) {
                                active.setFocus();
                            }
                            chainedOnSelectedChanged.call(viewRef, viewRef.selected, viewRef, active, lastSelected);
                        } else {
                            setCursor(selected);
                            setSlice(items().slice(start(), end()));
                            queueMicrotask(function() {
                                viewRef.updateLayout();
                                active = viewRef.children.find(function(x) {
                                    return x.item === item;
                                });
                                if (active instanceof ElementNode) {
                                    viewRef.selected = viewRef.children.indexOf(active);
                                    if (hasFocus(viewRef)) {
                                        active.setFocus();
                                    }
                                    chainedOnSelectedChanged.call(viewRef, viewRef.selected, viewRef, active, lastSelected);
                                }
                            });
                        }
                    };
                    var scrollToIndex = function scrollToIndex(index) {
                        untrack(function() {
                            return updateSelected([ index ]);
                        });
                    };
                    createEffect(on([ function() {
                        return props.selected;
                    }, items ], updateSelected));
                    createEffect(on(items, function(gridItems, _prevGridItems, prevSize) {
                        if (!viewRef) return;
                        if (cachedSelected !== void 0) {
                            updateSelected([ cachedSelected ]);
                            return gridItems.length;
                        }
                        if (gridItems.length === 0) {
                            setCursor(0);
                            cachedSelected = void 0;
                            setSlice([]);
                        } else if (cursor() >= itemCount()) {
                            updateSelected([ Math.max(0, itemCount() - 1) ]);
                        } else if (prevSize === 0) {
                            updateSelected([ 0 ]);
                        } else {
                            setSlice(items().slice(start(), end()));
                        }
                        return gridItems.length;
                    }, {
                        defer: true
                    }));
                    return function() {
                        var _el$ = createElement("view");
                        var _ref$ = chainRefs(function(el) {
                            viewRef = el;
                        }, props.ref);
                        typeof _ref$ === "function" && use(_ref$, _el$);
                        spread(_el$, mergeProps(props, {
                            get scroll() {
                                return props.scroll || "always";
                            },
                            get selected() {
                                return props.selected || 0;
                            },
                            get cursor() {
                                return cursor();
                            },
                            onLeft: chainFunctions(props.onLeft, navigableHandleNavigation),
                            onRight: chainFunctions(props.onRight, navigableHandleNavigation),
                            onUp: chainFunctions(props.onUp, onUp),
                            onDown: chainFunctions(props.onDown, onDown),
                            forwardFocus: navigableForwardFocus,
                            onCreate: props.selected ? chainFunctions(props.onCreate, columnScroll) : props.onCreate,
                            scrollToIndex: scrollToIndex,
                            onSelectedChanged: chainedOnSelectedChanged,
                            style: combineStyles(props.style, rowStyles)
                        }), true);
                        insert(_el$, createComponent(List, {
                            get each() {
                                return slice();
                            },
                            get children() {
                                return props.children;
                            }
                        }));
                        return _el$;
                    }();
                }
                function createVirtual(component, props, keyHandlers) {
                    var _props$selected2;
                    var isRow = component === Row;
                    var axis = isRow ? "x" : "y";
                    var _createSignal71 = createSignal((_props$selected2 = props.selected) !== null && _props$selected2 !== void 0 ? _props$selected2 : 0), _createSignal72 = _slicedToArray(_createSignal71, 2), cursor = _createSignal72[0], setCursor = _createSignal72[1];
                    var bufferSize = createMemo(function() {
                        return props.bufferSize || 2;
                    });
                    var scrollIndex = createMemo(function() {
                        return props.scrollIndex || 0;
                    });
                    var items = createMemo(function() {
                        return props.each || [];
                    });
                    var itemCount = createMemo(function() {
                        return items().length;
                    });
                    var scrollType = createMemo(function() {
                        return props.scroll || "auto";
                    });
                    var selected = function selected() {
                        if (props.wrap) {
                            return Math.max(bufferSize(), scrollIndex());
                        }
                        return props.selected || 0;
                    };
                    var cachedScaledSize;
                    var targetPosition;
                    var cachedAnimationController;
                    var uniformSize = createMemo(function() {
                        return props.uniformSize !== false;
                    });
                    var _createSignal73 = createSignal({
                        start: 0,
                        slice: [],
                        selected: 0,
                        delta: 0,
                        shiftBy: 0,
                        atStart: true
                    }), _createSignal74 = _slicedToArray(_createSignal73, 2), slice = _createSignal74[0], setSlice = _createSignal74[1];
                    function normalizeDeltaForWindow(delta, windowLen) {
                        if (!windowLen) return 0;
                        var half = windowLen / 2;
                        if (delta > half) return delta - windowLen;
                        if (delta < -half) return delta + windowLen;
                        return delta;
                    }
                    function computeSize() {
                        var selected2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                        if (uniformSize() && cachedScaledSize) {
                            return cachedScaledSize;
                        } else if (viewRef) {
                            var gap = viewRef.gap || 0;
                            var dimension = isRow ? "width" : "height";
                            var prevSelectedChild = viewRef.children[selected2];
                            if (prevSelectedChild instanceof ElementNode) {
                                var _prevSelectedChild$st, _ref74, _focusStyle$scale;
                                var itemSize = prevSelectedChild[dimension] || 0;
                                var focusStyle = (_prevSelectedChild$st = prevSelectedChild.style) === null || _prevSelectedChild$st === void 0 ? void 0 : _prevSelectedChild$st.focus;
                                var scale = (_ref74 = (_focusStyle$scale = focusStyle === null || focusStyle === void 0 ? void 0 : focusStyle.scale) !== null && _focusStyle$scale !== void 0 ? _focusStyle$scale : prevSelectedChild.scale) !== null && _ref74 !== void 0 ? _ref74 : 1;
                                var scaledSize = itemSize * (props.factorScale ? scale : 1) + gap;
                                cachedScaledSize = scaledSize;
                                return scaledSize;
                            }
                        }
                        return 0;
                    }
                    function computeSlice(c, delta, prev) {
                        var total = itemCount();
                        if (total === 0) return {
                            start: 0,
                            slice: [],
                            selected: 0,
                            delta: delta,
                            shiftBy: 0,
                            atStart: true
                        };
                        var length = props.displaySize + bufferSize();
                        var start = prev.start;
                        var selected2 = prev.selected;
                        var atStart = prev.atStart;
                        var shiftBy = -delta;
                        switch (scrollType()) {
                          case "always":
                            if (props.wrap) {
                                start = mod(c - 1, total);
                                selected2 = 1;
                            } else {
                                start = clamp(c - bufferSize(), 0, Math.max(0, total - props.displaySize - bufferSize()));
                                if (delta === 0 && c > 3) {
                                    shiftBy = c < 3 ? -c : -2;
                                    selected2 = 2;
                                } else {
                                    selected2 = c < bufferSize() ? c : c >= total - props.displaySize ? c - (total - props.displaySize) + bufferSize() : bufferSize();
                                }
                            }
                            break;

                          case "auto":
                            if (props.wrap) {
                                if (delta === 0) {
                                    selected2 = scrollIndex() || 1;
                                    start = mod(c - (scrollIndex() || 1), total);
                                } else {
                                    start = mod(c - (prev.selected || 1), total);
                                }
                            } else {
                                if (delta < 0) {
                                    if (prev.start > 0 && prev.selected >= props.displaySize) {
                                        start = prev.start;
                                        selected2 = prev.selected - 1;
                                    } else if (prev.start > 0) {
                                        start = prev.start - 1;
                                        selected2 = prev.selected;
                                    } else if (prev.start === 0 && !prev.atStart) {
                                        start = 0;
                                        selected2 = prev.selected - 1;
                                        atStart = true;
                                    } else if (selected2 >= props.displaySize - 1) {
                                        start = 0;
                                        selected2 = prev.selected - 1;
                                    } else {
                                        start = 0;
                                        selected2 = prev.selected - 1;
                                        shiftBy = 0;
                                    }
                                } else if (delta > 0) {
                                    if (prev.selected < scrollIndex()) {
                                        start = prev.start;
                                        selected2 = prev.selected + 1;
                                        shiftBy = 0;
                                    } else if (prev.selected === scrollIndex() || atStart) {
                                        start = prev.start;
                                        selected2 = prev.selected + 1;
                                        atStart = false;
                                    } else if (prev.start === 0 && prev.selected === 0) {
                                        start = 0;
                                        selected2 = 1;
                                        atStart = false;
                                    } else if (prev.start >= total - props.displaySize) {
                                        start = prev.start;
                                        selected2 = c - start;
                                        shiftBy = 0;
                                    } else {
                                        start = prev.start + 1;
                                        selected2 = Math.max(prev.selected, scrollIndex() + 1);
                                    }
                                } else {
                                    if (c > 0) {
                                        start = Math.min(c - (scrollIndex() || 1), total - props.displaySize - bufferSize());
                                        selected2 = Math.max(scrollIndex() || 1, c - start);
                                        shiftBy = total - c < 3 ? c - total : -1;
                                        atStart = false;
                                    } else {
                                        if (Math.abs(c - prev.start) > 1) {
                                            start = c;
                                            if (c === 0) {
                                                atStart = true;
                                                selected2 = 0;
                                            }
                                        } else {
                                            start = prev.start;
                                            selected2 = prev.selected;
                                        }
                                    }
                                }
                            }
                            break;

                          case "edge":
                            var startScrolling = Math.max(1, props.displaySize + (atStart ? -1 : 0));
                            if (props.wrap) {
                                if (delta > 0) {
                                    if (prev.selected < startScrolling) {
                                        selected2 = prev.selected + 1;
                                        shiftBy = 0;
                                    } else if (prev.selected === startScrolling && atStart) {
                                        selected2 = prev.selected + 1;
                                        atStart = false;
                                    } else {
                                        start = mod(prev.start + 1, total);
                                        selected2 = prev.selected;
                                    }
                                } else if (delta < 0) {
                                    if (prev.selected > 1) {
                                        selected2 = prev.selected - 1;
                                        shiftBy = 0;
                                    } else {
                                        start = mod(prev.start - 1, total);
                                        selected2 = 1;
                                    }
                                } else {
                                    start = mod(c - 1, total);
                                    selected2 = 1;
                                    shiftBy = -1;
                                    atStart = false;
                                }
                            } else {
                                if (delta === 0 && c > 0) {
                                    selected2 = c > startScrolling ? startScrolling : c;
                                    start = Math.max(0, c - startScrolling + 1);
                                    shiftBy = c > startScrolling ? -1 : 0;
                                    atStart = c < startScrolling;
                                } else if (delta > 0) {
                                    if (prev.selected < startScrolling) {
                                        selected2 = prev.selected + 1;
                                        shiftBy = 0;
                                    } else if (prev.selected === startScrolling && atStart) {
                                        selected2 = prev.selected + 1;
                                        atStart = false;
                                    } else {
                                        start = prev.start + 1;
                                        selected2 = prev.selected;
                                        atStart = false;
                                    }
                                } else if (delta < 0) {
                                    if (prev.selected > 1) {
                                        selected2 = prev.selected - 1;
                                        shiftBy = 0;
                                    } else if (c > 1) {
                                        start = Math.max(0, c - 1);
                                        selected2 = 1;
                                    } else if (c === 1) {
                                        start = 0;
                                        selected2 = 1;
                                    } else {
                                        start = 0;
                                        selected2 = 0;
                                        shiftBy = atStart ? 0 : shiftBy;
                                        atStart = true;
                                    }
                                }
                            }
                            break;

                          case "none":
                          default:
                            start = 0;
                            selected2 = c;
                            shiftBy = 0;
                            break;
                        }
                        var newSlice = prev.slice;
                        if (start !== prev.start || newSlice.length === 0) {
                            newSlice = props.wrap ? Array.from({
                                length: length
                            }, function(_, i) {
                                return items()[mod(start + i, total)];
                            }) : items().slice(start, start + length);
                        }
                        var state = {
                            start: start,
                            slice: newSlice,
                            selected: selected2,
                            delta: delta,
                            shiftBy: shiftBy,
                            atStart: atStart
                        };
                        if (props.debugInfo) {
                            console.log("[Virtual]", {
                                cursor: c,
                                delta: delta,
                                start: start,
                                selected: selected2,
                                shiftBy: shiftBy,
                                slice: state.slice
                            });
                        }
                        return state;
                    }
                    var viewRef;
                    function scrollToIndex(index) {
                        untrack(function() {
                            if (itemCount() === 0) return;
                            lastNavTime = performance.now();
                            if (originalPosition !== void 0) {
                                viewRef.lng[axis] = originalPosition;
                                targetPosition = originalPosition;
                            }
                            if (!hasFocus(viewRef)) {
                                viewRef.setFocus();
                            }
                            updateSelected([ clamp(index, 0, itemCount() - 1) ]);
                        });
                    }
                    var lastNavTime = 0;
                    function getAdaptiveDuration() {
                        var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
                        var now = performance.now();
                        var delta = now - lastNavTime;
                        lastNavTime = now;
                        if (delta < duration) return delta;
                        return duration;
                    }
                    var originalPosition;
                    var onSelectedChanged = function onSelectedChanged(_idx, elm, _active, _lastIdx) {
                        var _elm$children$length, _elm$children, _this48 = this;
                        var idx = _idx;
                        var lastIdx = _lastIdx || 0;
                        var active = _active;
                        var noChange = idx === lastIdx;
                        var total = itemCount();
                        originalPosition = originalPosition !== null && originalPosition !== void 0 ? originalPosition : elm[axis];
                        if (props.onSelectedChanged) {
                            props.onSelectedChanged.call(this, idx, this, active, lastIdx);
                        }
                        if (noChange) return;
                        var rawDelta = idx - (lastIdx !== null && lastIdx !== void 0 ? lastIdx : 0);
                        var windowLen = (_elm$children$length = elm === null || elm === void 0 || (_elm$children = elm.children) === null || _elm$children === void 0 ? void 0 : _elm$children.length) !== null && _elm$children$length !== void 0 ? _elm$children$length : props.displaySize + bufferSize();
                        var delta = props.wrap ? normalizeDeltaForWindow(rawDelta, windowLen) : rawDelta;
                        setCursor(function(c) {
                            var next = c + delta;
                            return props.wrap ? mod(next, total) : clamp(next, 0, total - 1);
                        });
                        var newState = computeSlice(cursor(), delta, slice());
                        setSlice(newState);
                        elm.selected = newState.selected;
                        if (props.onEndReachedThreshold !== void 0 && cursor() >= itemCount() - props.onEndReachedThreshold) {
                            var _props$onEndReached3;
                            (_props$onEndReached3 = props.onEndReached) === null || _props$onEndReached3 === void 0 || _props$onEndReached3.call(props);
                        }
                        if (newState.shiftBy === 0) return;
                        var prevChildPos = (targetPosition !== null && targetPosition !== void 0 ? targetPosition : this[axis]) + active[axis];
                        queueMicrotask(function() {
                            elm.updateLayout();
                            var childSize = computeSize(slice().selected);
                            if (cachedAnimationController && cachedAnimationController.state === "running") {
                                cachedAnimationController.stop();
                            }
                            if (Config.animationsEnabled) {
                                var _this48$animationSett;
                                _this48.lng[axis] = prevChildPos - active[axis];
                                targetPosition = _this48.lng[axis] + childSize * slice().shiftBy;
                                cachedAnimationController = _this48.animate(_defineProperty({}, axis, targetPosition), _objectSpread(_objectSpread({}, _this48.animationSettings), {}, {
                                    duration: getAdaptiveDuration((_this48$animationSett = _this48.animationSettings) === null || _this48$animationSett === void 0 ? void 0 : _this48$animationSett.duration)
                                })).start();
                            } else {
                                _this48.lng[axis] = _this48.lng[axis] + childSize * slice().shiftBy;
                            }
                        });
                    };
                    var updateSelected = function updateSelected(_ref75) {
                        var _ref76 = _slicedToArray(_ref75, 2), sel = _ref76[0], _items = _ref76[1];
                        if (!viewRef || sel === void 0 || itemCount() === 0) return;
                        var item = items()[sel];
                        setCursor(sel);
                        var newState = computeSlice(cursor(), 0, slice());
                        setSlice(newState);
                        queueMicrotask(function() {
                            viewRef.updateLayout();
                            var activeIndex = viewRef.children.findIndex(function(x) {
                                return x.item === item;
                            });
                            if (activeIndex === -1) return;
                            viewRef.selected = activeIndex;
                            if (hasFocus(viewRef)) {
                                var _viewRef$children$act;
                                (_viewRef$children$act = viewRef.children[activeIndex]) === null || _viewRef$children$act === void 0 || _viewRef$children$act.setFocus();
                            }
                        });
                    };
                    var doOnce = false;
                    createEffect(on([ function() {
                        return props.wrap;
                    }, items ], function() {
                        if (!viewRef || itemCount() === 0 || !props.wrap || doOnce) return;
                        doOnce = true;
                        queueMicrotask(function() {
                            var childSize = computeSize(slice().selected);
                            viewRef.lng[axis] = (viewRef.lng[axis] || 0) + childSize * -1;
                            originalPosition = viewRef.lng[axis];
                            targetPosition = viewRef.lng[axis];
                        });
                    }));
                    createEffect(on([ function() {
                        return props.selected;
                    }, items ], updateSelected));
                    createEffect(on(items, function() {
                        if (!viewRef) return;
                        if (cursor() >= itemCount()) {
                            setCursor(Math.max(0, itemCount() - 1));
                        }
                        var newState = computeSlice(cursor(), 0, slice());
                        setSlice(newState);
                        viewRef.selected = newState.selected;
                    }));
                    return function() {
                        var _el$ = createElement("view");
                        var _ref$ = chainRefs(function(el) {
                            viewRef = el;
                        }, props.ref);
                        typeof _ref$ === "function" && use(_ref$, _el$);
                        spread(_el$, mergeProps(props, keyHandlers, {
                            get selected() {
                                return selected();
                            },
                            get cursor() {
                                return cursor();
                            },
                            forwardFocus: navigableForwardFocus,
                            scrollToIndex: scrollToIndex,
                            onSelectedChanged: onSelectedChanged,
                            style: combineStyles(props.style, component === Row ? {
                                display: "flex",
                                gap: 30,
                                transition: {
                                    x: {
                                        duration: 250,
                                        easing: "ease-out"
                                    }
                                }
                            } : {
                                display: "flex",
                                flexDirection: "column",
                                gap: 30,
                                transition: {
                                    y: {
                                        duration: 250,
                                        easing: "ease-out"
                                    }
                                }
                            })
                        }), true);
                        insert(_el$, createComponent(List, {
                            get each() {
                                return slice().slice;
                            },
                            get children() {
                                return props.children;
                            }
                        }));
                        return _el$;
                    }();
                }
                function VirtualRow(props) {
                    return createVirtual(Row, props, {
                        onLeft: chainFunctions(props.onLeft, handleNavigation("left")),
                        onRight: chainFunctions(props.onRight, handleNavigation("right"))
                    });
                }
                function createSpriteMap(src, subTextures) {
                    var spriteMapTexture = renderer$2.createTexture("ImageTexture", {
                        src: src
                    });
                    return subTextures.reduce(function(acc, t) {
                        var x = t.x, y = t.y, width = t.width, height = t.height;
                        acc[t.name] = renderer$2.createTexture("SubTexture", {
                            texture: spriteMapTexture,
                            x: x,
                            y: y,
                            w: width,
                            h: height
                        });
                        return acc;
                    }, {});
                }
                var App = function App(props) {
                    useFocusManager({
                        Announcer: [ "a" ],
                        Menu: [ "m" ],
                        Escape: [ "Escape", 27 ],
                        Backspace: [ "Backspace", 8 ],
                        Back: [ "b" ],
                        Left: [ "ArrowLeft", 37 ],
                        Right: [ "ArrowRight", 39 ],
                        Up: [ "ArrowUp", 38 ],
                        Down: [ "ArrowDown", 40 ],
                        Enter: [ "Enter", 13 ]
                    }, {
                        userKeyHoldMap: {
                            EnterHold: [ "Enter", 13 ],
                            BackHold: [ "b", 66 ]
                        },
                        holdThreshold: 1e3
                    });
                    useMouse(void 0, 100, {
                        customStates: {
                            hoverState: "$hover",
                            pressedState: "$pressed",
                            pressedStateDuration: 150
                        }
                    });
                    return props.children;
                };
                var theme = exports("t", {
                    primary: 743406847,
                    primaryLight: 1249628415,
                    textPrimary: 3874024447,
                    textSecondary: 2139393535,
                    layout: {
                        gutterX: 20,
                        marginX: 150,
                        screenW: 1920
                    },
                    typography: {
                        display2: {
                            fontFamily: "Arial",
                            fontSize: 50,
                            lineHeight: 60,
                            fontWeight: 400,
                            verticalAlign: "middle",
                            textBaseline: "bottom"
                        },
                        body1: {
                            fontFamily: "Arial",
                            fontSize: 25,
                            fontWeight: 400,
                            lineHeight: 40,
                            verticalAlign: "middle",
                            textBaseline: "bottom"
                        },
                        body2: {
                            fontFamily: "Arial",
                            fontSize: 22,
                            fontWeight: 400,
                            lineHeight: 32,
                            verticalAlign: "middle",
                            textBaseline: "bottom"
                        }
                    },
                    color: {
                        materialBrand: 13311
                    }
                });
                var params = new URLSearchParams(window.location.search);
                var roundPoster = params.get("roundPoster") !== "false";
                var styles$1 = exports("D", {
                    itemsContainer: {
                        width: theme.layout.screenW,
                        height: 800,
                        y: 560,
                        x: 0,
                        zIndex: 2
                    },
                    Thumbnail: {
                        width: 185,
                        height: 278,
                        scale: 1,
                        zIndex: 2,
                        transition: {
                            scale: {
                                duration: 250,
                                easing: "linear"
                            },
                            border: {
                                duration: 250,
                                easing: "linear"
                            }
                        },
                        borderRadius: roundPoster ? 16 : 0,
                        border: {
                            width: 0,
                            color: 0
                        },
                        $focus: {
                            scale: 1.1,
                            border: {
                                color: theme.primaryLight,
                                width: 6,
                                gap: 0
                            }
                        },
                        $hover: {
                            scale: 1.07,
                            border: {
                                color: theme.primaryLight,
                                width: 3
                            }
                        },
                        $pressed: {
                            scale: 1.05,
                            border: {
                                color: theme.primary,
                                width: 6
                            }
                        }
                    },
                    RowTitle: {
                        height: 44,
                        width: 300,
                        marginBottom: -54,
                        fontSize: 26,
                        color: 4042322175,
                        zIndex: 2
                    },
                    Row: {
                        display: "flex",
                        justifyContent: "spaceBetween",
                        height: 300
                    },
                    Column: {
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "flexStart",
                        flexBoundary: "contain",
                        gap: 64,
                        width: theme.layout.screenW - 2 * theme.layout.marginX,
                        x: theme.layout.marginX + theme.layout.gutterX,
                        y: 48,
                        transition: {
                            y: {
                                duration: 250,
                                easing: "ease-in-out"
                            }
                        },
                        zIndex: 2
                    },
                    peopleBio: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
                        fontFamily: "Roboto",
                        fontWeight: "normal",
                        contain: "both",
                        width: 780,
                        height: 340
                    })
                });
                var Button$1 = {
                    width: 300,
                    height: 90,
                    color: theme.primary,
                    borderRadius: 12,
                    $focus: {
                        color: theme.primaryLight
                    }
                };
                ({
                    width: Button$1.width + 8
                });
                var ButtonText = {
                    fontSize: 26,
                    lineHeight: Button$1.height,
                    contain: "width",
                    textAlign: "center",
                    height: Button$1.height,
                    width: Button$1.width,
                    color: theme.textPrimary
                };
                var buttonStyles = {
                    container: Button$1,
                    text: ButtonText
                };
                var MaterialButton = {
                    width: 386,
                    height: 136
                };
                var MaterialButtonText = exports("U", {
                    fontSize: 32,
                    contain: "width",
                    textAlign: "center",
                    mountY: -.35,
                    color: 4294967295,
                    height: MaterialButton.height,
                    width: MaterialButton.width,
                    $focus: {
                        fontSize: 40
                    },
                    $disabled: {
                        color: 2425393407
                    }
                });
                function Thumbnail(props) {
                    return createComponent(Image$1, mergeProps(props, {
                        id: "thumbnail",
                        get src() {
                            return props.item.src;
                        },
                        placeholder: "./assets/fallback.png",
                        get item() {
                            return props.item;
                        },
                        get announce() {
                            return [ props.item.title, "PAUSE-1", props.item.overview ];
                        },
                        get style() {
                            return styles$1.Thumbnail;
                        }
                    }));
                }
                function TileRow(props) {
                    return createComponent(Row, mergeProps(props, {
                        get style() {
                            return styles$1.Row;
                        },
                        get children() {
                            return createComponent(Index, {
                                get each() {
                                    return props.items;
                                },
                                children: function children(item, index) {
                                    return createComponent(Thumbnail, {
                                        get item() {
                                            return item();
                                        },
                                        get announceContext() {
                                            return "".concat(index + 1, " of ").concat(props.items.length);
                                        }
                                    });
                                }
                            });
                        }
                    }));
                }
                function Button(props) {
                    return createComponent(View, mergeProps(props, {
                        get announce() {
                            return [ props.children, "button" ];
                        },
                        forwardStates: true,
                        get style() {
                            return buttonStyles.container;
                        },
                        get children() {
                            return createComponent(Text, {
                                get style() {
                                    return buttonStyles.text;
                                },
                                get children() {
                                    return props.children || props.title;
                                }
                            });
                        }
                    }));
                }
                function AssetPanel(props) {
                    var panelRef, actionRef;
                    createEffect(function() {
                        if (props.open) {
                            panelRef.animate({
                                x: 1470
                            }, {
                                duration: 400,
                                easing: "ease-in-out"
                            }).start();
                            actionRef.setFocus();
                        } else if (panelRef.rendered) {
                            panelRef.animate({
                                x: 1920
                            }, {
                                duration: 400,
                                easing: "ease-in-out"
                            }).start();
                        }
                    });
                    return createComponent(View, mergeProps(props, {
                        x: 1920,
                        ref: function ref(r$) {
                            var _ref$ = panelRef;
                            typeof _ref$ === "function" ? _ref$(r$) : panelRef = r$;
                        },
                        color: 255,
                        width: 450,
                        height: 1080,
                        zIndex: 5,
                        get children() {
                            return [ createComponent(Text, {
                                x: 75,
                                y: 50,
                                fontSize: 32,
                                get children() {
                                    var _props$item;
                                    return (_props$item = props.item) === null || _props$item === void 0 ? void 0 : _props$item.title;
                                }
                            }), createComponent(Column, {
                                ref: function ref(r$) {
                                    var _ref$2 = actionRef;
                                    typeof _ref$2 === "function" ? _ref$2(r$) : actionRef = r$;
                                },
                                get onLeft() {
                                    return props.close;
                                },
                                get onBack() {
                                    return props.close;
                                },
                                x: 75,
                                y: 200,
                                get children() {
                                    return [ createComponent(Button, {
                                        get onEnter() {
                                            return props.close;
                                        },
                                        children: "Record"
                                    }), createComponent(Button, {
                                        get onEnter() {
                                            return props.close;
                                        },
                                        children: "Watch"
                                    }), createComponent(Button, {
                                        get onEnter() {
                                            return props.close;
                                        },
                                        children: "Close"
                                    }) ];
                                }
                            }) ];
                        }
                    }));
                }
                var heroTransition = {
                    duration: 300,
                    easing: "cubic-bezier(0.20, 1.00, 0.80, 1.00)"
                };
                var titleRowStyles = {
                    fontFamily: "Raleway",
                    fontSize: 24,
                    height: 32,
                    lineHeight: 32
                };
                function TitleRow(props) {
                    return createComponent(View, {
                        get height() {
                            return props.height;
                        },
                        forwardFocus: 1,
                        marginTop: 30,
                        get children() {
                            return [ createComponent(Text, {
                                skipFocus: true,
                                style: titleRowStyles,
                                get children() {
                                    return props.title;
                                }
                            }), createComponent(VirtualRow, {
                                gap: 20,
                                displaySize: 8,
                                bufferSize: 3,
                                get each() {
                                    return props.items;
                                },
                                y: 50,
                                get scroll() {
                                    return props.scroll;
                                },
                                get wrap() {
                                    return props.wrap;
                                },
                                children: function children(item, index) {
                                    return createComponent(Dynamic, {
                                        get component() {
                                            return typeToComponent[props.row.type];
                                        },
                                        get index() {
                                            return index();
                                        },
                                        get item() {
                                            return item();
                                        }
                                    });
                                }
                            }) ];
                        }
                    });
                }
                var posterStyles = {
                    width: 185,
                    height: 278,
                    scale: 1,
                    zIndex: 2,
                    color: 2964369663,
                    transition: {
                        scale: {
                            duration: 200,
                            easing: "linear"
                        }
                    },
                    $focus: {
                        scale: 1.1,
                        color: 4294967295
                    }
                };
                function Poster(props) {
                    return createComponent(View, mergeProps({
                        get src() {
                            var _props$item2;
                            return (_props$item2 = props.item) === null || _props$item2 === void 0 ? void 0 : _props$item2.src;
                        },
                        get title() {
                            var _props$item3;
                            return (_props$item3 = props.item) === null || _props$item3 === void 0 ? void 0 : _props$item3.shortTitle;
                        },
                        get backdrop() {
                            var _props$item4;
                            return (_props$item4 = props.item) === null || _props$item4 === void 0 ? void 0 : _props$item4.backdrop;
                        }
                    }, props, {
                        onFail: function onFail(node) {
                            return node.src = "failback.png";
                        },
                        style: posterStyles
                    }));
                }
                var posterTitleStyles = {
                    fontFamily: "Raleway",
                    fontSize: 22,
                    lineHeight: 22,
                    height: 22,
                    x: 10,
                    y: 278,
                    contain: "width",
                    width: 185,
                    maxLines: 2,
                    alpha: 0,
                    $focus: {
                        alpha: 1,
                        y: 288
                    },
                    transition: {
                        y: heroTransition,
                        alpha: heroTransition
                    }
                };
                function PosterTitle(props) {
                    return createComponent(View, mergeProps({
                        get src() {
                            var _props$item5;
                            return (_props$item5 = props.item) === null || _props$item5 === void 0 ? void 0 : _props$item5.src;
                        },
                        get backdrop() {
                            var _props$item6;
                            return (_props$item6 = props.item) === null || _props$item6 === void 0 ? void 0 : _props$item6.backdrop;
                        }
                    }, props, {
                        onFail: function onFail(node) {
                            return node.src = "failback.png";
                        },
                        style: posterStyles,
                        forwardStates: true,
                        get children() {
                            return createComponent(Text, {
                                style: posterTitleStyles,
                                get children() {
                                    var _props$item7;
                                    return (_props$item7 = props.item) === null || _props$item7 === void 0 ? void 0 : _props$item7.title;
                                }
                            });
                        }
                    }));
                }
                var heroStyles = {
                    width: 1280,
                    height: 720,
                    scale: 1,
                    zIndex: 2,
                    colorTop: 4294967295,
                    colorBottom: 255,
                    transition: {
                        scale: heroTransition
                    },
                    $focus: {
                        scale: 1.05
                    }
                };
                var heroTextStyles = {
                    fontFamily: "Raleway",
                    contain: "width"
                };
                function Hero(props) {
                    var _createSignal75 = createSignal(false), _createSignal76 = _slicedToArray(_createSignal75, 2), hasFocus = _createSignal76[0], setHasFocus = _createSignal76[1];
                    return createComponent(View, mergeProps(props, {
                        get src() {
                            return props.item.backdrop;
                        },
                        style: heroStyles,
                        onFocusChanged: setHasFocus,
                        forwardStates: true,
                        get children() {
                            return createComponent(View, {
                                transition: {
                                    alpha: heroTransition
                                },
                                get alpha() {
                                    return hasFocus() ? 1 : 0;
                                },
                                get children() {
                                    return [ createComponent(View, {
                                        width: 185,
                                        height: 278,
                                        x: 54,
                                        y: 220,
                                        get src() {
                                            return props.item.src;
                                        }
                                    }), createComponent(Text, {
                                        y: 520,
                                        x: 54,
                                        fontSize: 64,
                                        width: 1e3,
                                        maxLines: 1,
                                        style: heroTextStyles,
                                        get children() {
                                            return props.item.title;
                                        }
                                    }), createComponent(Text, {
                                        y: 620,
                                        x: 60,
                                        fontSize: 21,
                                        width: 1e3,
                                        maxLines: 2,
                                        lineHeight: 36,
                                        color: 3435973887,
                                        style: heroTextStyles,
                                        get children() {
                                            return props.item.overview;
                                        }
                                    }) ];
                                }
                            });
                        }
                    }));
                }
                var typeToComponent = {
                    Poster: Poster,
                    Hero: Hero,
                    PosterTitle: PosterTitle
                };
                var BlockStyle = {
                    alpha: .85,
                    border: {
                        width: 0,
                        color: 255
                    },
                    $focus: {
                        border: {
                            width: 4,
                            color: 4294967295
                        },
                        alpha: 1
                    }
                };
                function Block(props) {
                    return createComponent(View, mergeProps(props, {
                        width: 100,
                        height: 100,
                        style: BlockStyle,
                        get color() {
                            return props.color || 3772834047;
                        }
                    }));
                }
                var _createSignal77 = createSignal(""), _createSignal78 = _slicedToArray(_createSignal77, 2), globalBackground = _createSignal78[0], setGlobalBackground = _createSignal78[1];
                exports("s", setGlobalBackground);
                function createInfiniteScroll(fetcher) {
                    var _createSignal79 = createSignal([]), _createSignal80 = _slicedToArray(_createSignal79, 2), pages = _createSignal80[0], setPages = _createSignal80[1];
                    var _createSignal81 = createSignal(1), _createSignal82 = _slicedToArray(_createSignal81, 2), page = _createSignal82[0], setPage = _createSignal82[1];
                    var _createSignal83 = createSignal(false), _createSignal84 = _slicedToArray(_createSignal83, 2), end = _createSignal84[0], setEnd = _createSignal84[1];
                    var _createResource3 = createResource(page, fetcher), _createResource4 = _slicedToArray(_createResource3, 1), contents = _createResource4[0];
                    createComputed(function() {
                        var content = contents();
                        if (!content) return;
                        batch(function() {
                            if (content.length === 0) setEnd(true);
                            setPages(function(p) {
                                return [].concat(_toConsumableArray(p), _toConsumableArray(content));
                            });
                        });
                    });
                    return {
                        pages: pages,
                        page: page,
                        setPage: setPage,
                        setPages: setPages,
                        end: end,
                        setEnd: setEnd
                    };
                }
                var blockWidth = 900;
                var ContentBlockStyle = {
                    display: "flex",
                    flexDirection: "column",
                    flexBoundary: "fixed",
                    width: blockWidth,
                    height: 220,
                    gap: 16
                };
                var HeadlineStyles = _objectSpread(_objectSpread({}, theme.typography.display2), {}, {
                    fontFamily: "Roboto",
                    fontWeight: 700,
                    maxLines: 1,
                    width: blockWidth
                });
                var Headline = function Headline(props) {
                    return createComponent(Marquee, mergeProps(props, {
                        textProps: HeadlineStyles
                    }));
                };
                var DescriptionStyles = _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
                    fontFamily: "Roboto",
                    fontWeight: 400,
                    lineHeight: 32,
                    width: blockWidth,
                    maxLines: 3,
                    contain: "width"
                });
                var BadgeStyle = {
                    fontSize: 16,
                    lineHeight: 20,
                    marginLeft: 13,
                    marginRight: 13
                };
                var Description = function Description(props) {
                    return createComponent(Text, mergeProps(props, {
                        style: DescriptionStyles,
                        get children() {
                            return props.children;
                        }
                    }));
                };
                var Badge = function Badge(props) {
                    return createComponent(View, mergeProps(props, {
                        style: {
                            color: "0x00000099",
                            borderRadius: 8,
                            border: {
                                width: 2,
                                color: "0xffffffff"
                            },
                            display: "flex",
                            height: 36
                        },
                        get children() {
                            return createComponent(Text, {
                                lineHeight: 36,
                                style: BadgeStyle,
                                get children() {
                                    return props.children;
                                }
                            });
                        }
                    }));
                };
                var MetaTextStyle = _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
                    fontFamily: "Roboto",
                    fontWeight: 400
                });
                var Metadata = function Metadata(props) {
                    return createComponent(View, {
                        style: {
                            display: "flex",
                            flexDirection: "row",
                            gap: 18,
                            width: blockWidth,
                            height: 48
                        },
                        get children() {
                            return [ createComponent(View, {
                                y: -4,
                                src: "./assets/stars.png",
                                width: 188,
                                height: 31
                            }), createComponent(View, {
                                y: -4,
                                flexItem: false,
                                clipping: true,
                                get width() {
                                    return 188 * props.voteAverage / 10;
                                },
                                height: 31,
                                get children() {
                                    return createComponent(View, {
                                        src: "./assets/stars-full.png",
                                        width: 188,
                                        height: 31
                                    });
                                }
                            }), createComponent(Text, {
                                style: MetaTextStyle,
                                get children() {
                                    return [ memo(function() {
                                        return props.voteCount;
                                    }), " reviews" ];
                                }
                            }), createComponent(Text, {
                                style: MetaTextStyle,
                                get children() {
                                    return props.metaText;
                                }
                            }), createComponent(For, {
                                get each() {
                                    return props.badges;
                                },
                                children: function children(item) {
                                    return createComponent(Badge, {
                                        y: -5,
                                        children: item
                                    });
                                }
                            }) ];
                        }
                    });
                };
                var ContentBlock = exports("x", function(props) {
                    return createComponent(View, mergeProps({
                        id: "contentBlock",
                        style: ContentBlockStyle
                    }, props, {
                        get children() {
                            return [ createComponent(Headline, {
                                get marquee() {
                                    return props.marquee;
                                },
                                get children() {
                                    return props.content.title;
                                }
                            }), createComponent(Description, {
                                get children() {
                                    return props.content.description;
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return props.content.voteCount;
                                },
                                get children() {
                                    return createComponent(Metadata, {
                                        get metaText() {
                                            return props.content.metaText;
                                        },
                                        get badges() {
                                            return props.content.badges;
                                        },
                                        get voteCount() {
                                            return props.content.voteCount;
                                        },
                                        get voteAverage() {
                                            return props.content.voteAverage;
                                        }
                                    });
                                }
                            }) ];
                        }
                    }));
                });
                var Browse = function Browse(props) {
                    usePreloadRoute();
                    var _createSignal85 = createSignal({}), _createSignal86 = _slicedToArray(_createSignal85, 2), heroContent = _createSignal86[0], setHeroContent = _createSignal86[1];
                    var navigate = useNavigate();
                    var firstRun = true;
                    var vgRef;
                    onCleanup(function() {
                        console.log("cleanup");
                    });
                    var provider = createMemo(function() {
                        return createInfiniteScroll(props.data());
                    });
                    var delayedBackgrounds = debounce(function(img) {
                        return setGlobalBackground(img);
                    }, 800);
                    var delayedHero = debounce(function(content) {
                        return setHeroContent(content || {});
                    }, 600);
                    function updateContentBlock(_index, _col, elm) {
                        if (!elm) return;
                        var item = elm.item || {};
                        if (firstRun) {
                            if (item.backdrop) {
                                setGlobalBackground(item.backdrop);
                            }
                            if (item.heroContent) {
                                setHeroContent(item.heroContent);
                            }
                            firstRun = false;
                            return;
                        }
                        if (item.href) ;
                        if (item.backdrop) {
                            delayedBackgrounds(item.backdrop);
                        }
                        if (item.heroContent) {
                            delayedHero(item.heroContent);
                        }
                    }
                    function onEndReached() {
                        provider().setPage(function(p) {
                            return p + 1;
                        });
                    }
                    function onEnter() {
                        var _entity$item;
                        this.display = "flex";
                        var entity = this.children.find(function(c) {
                            return c.states.has("focus");
                        });
                        assertTruthy(entity && ((_entity$item = entity.item) === null || _entity$item === void 0 ? void 0 : _entity$item.href));
                        navigate(entity.item.href);
                        return true;
                    }
                    return createComponent(Show, {
                        get when() {
                            return provider().pages().length;
                        },
                        get children() {
                            return [ createComponent(ContentBlock, {
                                y: 360,
                                x: 162,
                                get content() {
                                    return heroContent();
                                },
                                forwardFocus: function forwardFocus() {
                                    return vgRef.setFocus();
                                }
                            }), createComponent(View, {
                                clipping: true,
                                get style() {
                                    return styles$1.itemsContainer;
                                },
                                get children() {
                                    return createComponent(VirtualGrid, {
                                        y: 24,
                                        x: 160,
                                        id: "BrowseGrid",
                                        ref: function ref(r$) {
                                            var _ref$ = vgRef;
                                            typeof _ref$ === "function" ? _ref$(r$) : vgRef = r$;
                                        },
                                        scroll: "always",
                                        get announce() {
                                            return "All Trending ".concat(props.params.filter);
                                        },
                                        onEnter: onEnter,
                                        columns: 7,
                                        gap: 50,
                                        rows: 2,
                                        buffer: 2,
                                        onSelectedChanged: updateContentBlock,
                                        onEndReached: onEndReached,
                                        onEndReachedThreshold: 22,
                                        width: 1620,
                                        autofocus: true,
                                        get each() {
                                            return provider().pages();
                                        },
                                        children: function children(item) {
                                            return createComponent(Thumbnail, {
                                                get item() {
                                                    return item();
                                                }
                                            });
                                        }
                                    });
                                }
                            }) ];
                        }
                    });
                };
                var TMDB = function TMDB(props) {
                    var _createSignal87 = createSignal({}), _createSignal88 = _slicedToArray(_createSignal87, 2), heroContent = _createSignal88[0], setHeroContent = _createSignal88[1];
                    var _createSignal89 = createSignal(false), _createSignal90 = _slicedToArray(_createSignal89, 2), openPanel = _createSignal90[0], setOpenPanel = _createSignal90[1];
                    var _useFocusStack = useFocusStack(), storeFocus = _useFocusStack.storeFocus, restoreFocus = _useFocusStack.restoreFocus;
                    var contentBlock, solidLogo, firstRun = true;
                    var delayedBackgrounds = debounce(setGlobalBackground, 800);
                    var delayedHero = debounce(function(content) {
                        return setHeroContent(content || {});
                    }, 600);
                    createEffect(on(activeElement, function(elm) {
                        if (!elm) return;
                        var item = elm.item || {};
                        if (firstRun) {
                            item.backdrop && setGlobalBackground(item.backdrop);
                            item.heroContent && setHeroContent(item.heroContent);
                            firstRun = false;
                        } else {
                            item.backdrop && delayedBackgrounds(item.backdrop);
                            item.heroContent && delayedHero(item.heroContent);
                        }
                    }, {
                        defer: true
                    }));
                    function onRowChanged(selectedIndex, column, row, lastIndex) {
                        if (selectedIndex === lastIndex) return;
                        var values = selectedIndex === 0 ? {
                            y: 300,
                            alpha: 1
                        } : {
                            y: 200,
                            alpha: 0
                        };
                        contentBlock.animate(values, {
                            duration: 300,
                            easing: "ease-in-out"
                        }).start();
                        var values2 = selectedIndex === 0 ? {
                            y: 80,
                            alpha: 1
                        } : {
                            y: 0,
                            alpha: 0
                        };
                        solidLogo.animate(values2, {
                            duration: 300,
                            easing: "ease-in-out"
                        }).start();
                    }
                    return createComponent(View, {
                        forwardFocus: 2,
                        get children() {
                            return [ createComponent(View, {
                                ref: function ref(r$) {
                                    var _ref$ = solidLogo;
                                    typeof _ref$ === "function" ? _ref$(r$) : solidLogo = r$;
                                },
                                width: 300,
                                height: 150,
                                x: 162,
                                y: 80,
                                zIndex: 105,
                                get children() {
                                    return [ createComponent(Text, {
                                        x: 80,
                                        fontSize: 28,
                                        color: 4143380121,
                                        children: "Built With:"
                                    }), createComponent(View, {
                                        y: 32,
                                        src: "./assets/solidWord.png",
                                        width: 280,
                                        height: 52,
                                        textureOptions: {
                                            transparency: true
                                        }
                                    }), createComponent(View, {
                                        x: 0,
                                        y: 110,
                                        src: "./assets/tmdb.png",
                                        width: 80,
                                        height: 41,
                                        textureOptions: {
                                            transparency: true
                                        }
                                    }), createComponent(Text, {
                                        x: 90,
                                        y: 110,
                                        contain: "width",
                                        width: 160,
                                        fontSize: 12,
                                        color: 4143380121,
                                        children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
                                    }) ];
                                }
                            }), createComponent(ContentBlock, {
                                ref: function ref(r$) {
                                    var _ref$2 = contentBlock;
                                    typeof _ref$2 === "function" ? _ref$2(r$) : contentBlock = r$;
                                },
                                y: 300,
                                x: 162,
                                get content() {
                                    return heroContent();
                                }
                            }), createComponent(LazyColumn, {
                                y: 500,
                                upCount: 3,
                                get each() {
                                    return props.data.rows;
                                },
                                id: "BrowseColumn",
                                onSelectedChanged: onRowChanged,
                                onEnter: function onEnter() {
                                    return setOpenPanel(true);
                                },
                                get autofocus() {
                                    return props.data.rows[0].items();
                                },
                                gap: 40,
                                throttleInput: 250,
                                transition: {
                                    y: {
                                        duration: 300,
                                        easing: "ease-in-out"
                                    }
                                },
                                get style() {
                                    return styles$1.Column;
                                },
                                children: function children(row) {
                                    return row().type === "Hero" ? createComponent(VirtualRow, {
                                        gap: 80,
                                        displaySize: 3,
                                        bufferSize: 1,
                                        scroll: "center",
                                        centerScroll: true,
                                        get each() {
                                            return row().items();
                                        },
                                        y: 50,
                                        get height() {
                                            return row().height;
                                        },
                                        children: function children(item) {
                                            return createComponent(Hero, {
                                                get item() {
                                                    return item();
                                                }
                                            });
                                        }
                                    }) : createComponent(TitleRow, {
                                        get row() {
                                            return row();
                                        },
                                        get title() {
                                            return row().title;
                                        },
                                        get height() {
                                            return row().height;
                                        },
                                        get items() {
                                            return row().items();
                                        }
                                    });
                                }
                            }), createComponent(AssetPanel, {
                                onFocus: storeFocus,
                                close: function close() {
                                    setOpenPanel(false);
                                    restoreFocus();
                                    return true;
                                },
                                get open() {
                                    return openPanel();
                                },
                                get item() {
                                    return heroContent();
                                }
                            }) ];
                        }
                    });
                };
                var Destroy = function Destroy(props) {
                    var _createSignal91 = createSignal(), _createSignal92 = _slicedToArray(_createSignal91, 2), heroContent = _createSignal92[0], setHeroContent = _createSignal92[1];
                    var _createSignal93 = createSignal(0), _createSignal94 = _slicedToArray(_createSignal93, 2), heroIndex = _createSignal94[0], setHeroIndex = _createSignal94[1];
                    onMount(function() {
                        return setGlobalBackground(858993663);
                    });
                    createEffect(on([ props.data.heroRow.items, heroIndex ], function(_ref77) {
                        var _ref78 = _slicedToArray(_ref77, 2), heros = _ref78[0], index = _ref78[1];
                        if (heros) setHeroContent(heros[index]);
                        if (heros && index < heros.length - 1) {
                            var img = new Image;
                            img.crossOrigin = "anonymous";
                            img.src = heros[index + 1].backdrop;
                        }
                    }));
                    function onDown() {
                        if (heroIndex() >= 19) return false;
                        setHeroIndex(function(p) {
                            return p + 1;
                        });
                    }
                    function onUp() {
                        if (heroIndex() === 0) return false;
                        setHeroIndex(function(p) {
                            return p - 1;
                        });
                        return true;
                    }
                    function animateOut(node) {
                        return node.animate({
                            y: 200,
                            alpha: 0
                        }, {
                            duration: 500,
                            easing: "ease-in-out"
                        }).start().waitUntilStopped();
                    }
                    function animateIn(node) {
                        node.alpha = 0;
                        node.y = -100;
                        return node.animate({
                            y: 0,
                            alpha: 1
                        }, {
                            duration: 500,
                            easing: "ease-in-out"
                        }).start().waitUntilStopped();
                    }
                    return createComponent(View, {
                        x: 300,
                        y: 200,
                        onDown: onDown,
                        onUp: onUp,
                        get children() {
                            return [ createComponent(View, {
                                src: "assets/up.svg",
                                width: 350,
                                height: 200,
                                x: 450,
                                y: -200,
                                get rotation() {
                                    return Math.PI;
                                }
                            }), createComponent(Show, {
                                get when() {
                                    return heroContent();
                                },
                                keyed: true,
                                get children() {
                                    return createComponent(Hero, {
                                        id: "Hero",
                                        autofocus: true,
                                        onDestroy: animateOut,
                                        onCreate: animateIn,
                                        get item() {
                                            return heroContent();
                                        },
                                        get title() {
                                            return heroContent().title;
                                        }
                                    });
                                }
                            }) ];
                        }
                    });
                };
                var API_KEY_V4 = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZDE4YjEwMTA0YjdiZTlkNjFiMWYwYjVlMGEwNzM2OCIsInN1YiI6IjYwZTVjMTdlNGNhNjc2MDA3NTA4Njc3MSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.D_nqH9kd-bhhWzeVsTDPYhHnsUaNAuyAa6YATmKHqsA";
                var API_BASE = "https://api.themoviedb.org/3";
                var tmdbConfig;
                var baseImageUrl;
                var urlParams$1 = new URLSearchParams(window.location.search);
                var basePosterSize = urlParams$1.get("posterSize") || "w185";
                var defaultFetchParams = {
                    headers: {
                        "Content-Type": "application/json",
                        Authorization: "Bearer " + API_KEY_V4
                    }
                };
                function getImageUrl(path) {
                    var posterSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : basePosterSize;
                    return baseImageUrl + posterSize + path;
                }
                function get(path) {
                    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    if (tmdbConfig) {
                        return _get(path, params);
                    } else {
                        return loadConfig().then(function() {
                            return _get(path, params);
                        });
                    }
                }
                function _get(path) {
                    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    return fetch(API_BASE + path, _objectSpread(_objectSpread({}, defaultFetchParams), params)).then(function(r) {
                        return r.json();
                    });
                }
                function loadConfig() {
                    return _get("/configuration").then(function(data) {
                        var _data$images;
                        tmdbConfig = data;
                        baseImageUrl = (_data$images = data.images) === null || _data$images === void 0 ? void 0 : _data$images.secure_base_url;
                        return data;
                    });
                }
                var api = exports("X", {
                    get: get,
                    loadConfig: loadConfig
                });
                function truncateString(str, maxLength) {
                    if (str.length > maxLength) {
                        return str.substring(0, maxLength - 3) + "...";
                    }
                    return str;
                }
                function convertItemsToTiles() {
                    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                    return items.map(function(item, i) {
                        return {
                            src: getImageUrl(item.poster_path || item.profile_path),
                            tileSrc: getImageUrl(item.backdrop_path || item.profile_path, "w300"),
                            backdrop: getImageUrl(item.backdrop_path, "w1280"),
                            href: "/entity/".concat(item.media_type || "people", "/").concat(item.id),
                            shortTitle: truncateString(item.title || item.name, 30),
                            title: item.title || item.name,
                            overview: item.overview,
                            absIndex: i,
                            item: item,
                            entityInfo: {
                                type: item.media_type || "people",
                                id: item.id
                            },
                            heroContent: {
                                title: item.title || item.name,
                                description: item.overview
                            }
                        };
                    });
                }
                var handleResults = function handleResults(response) {
                    return response.then(function(_ref79) {
                        var results = _ref79.results;
                        var filteredItems = results.filter(function(r) {
                            return !r.adult;
                        });
                        return convertItemsToTiles(filteredItems);
                    });
                };
                var fetchPopular = function fetchPopular(type) {
                    return handleResults(api.get("/".concat(type, "/popular")));
                };
                var genreListCache;
                var fetchGenreMovies = function fetchGenreMovies(genres) {
                    var genreList = genreListCache || (genreListCache = api.get("/genre/movie/list"));
                    var targetGenre = Array.isArray(genres) ? genres : [ genres ];
                    return genreList.then(function(_ref80) {
                        var genres2 = _ref80.genres;
                        var targetGenreIds = [];
                        genres2.forEach(function(item) {
                            if (targetGenre.includes(item.name)) targetGenreIds.push(item.id);
                        });
                        return handleResults(api.get("/discover/movie?with_genres=".concat(targetGenreIds.join())));
                    });
                };
                function destroyData() {
                    var heroRow = {
                        title: "Best Adventure and Action movies",
                        items: createResource(function() {
                            return fetchGenreMovies([ "adventure", "action" ]);
                        })[0],
                        type: "Hero",
                        height: 800
                    };
                    return {
                        heroRow: heroRow
                    };
                }
                function tmdbData() {
                    var rows = [];
                    var popularMovies = createResource(function() {
                        return fetchPopular("movie");
                    });
                    rows.push({
                        title: "Popular Movies",
                        items: popularMovies[0],
                        setItems: popularMovies[1].mutate,
                        type: "Poster",
                        height: 328
                    });
                    rows.push({
                        title: "Best Western movies",
                        items: createResource(function() {
                            return fetchGenreMovies([ "Western" ]);
                        })[0],
                        type: "Hero",
                        height: 720
                    });
                    rows.push({
                        title: "Best Comedy movies",
                        items: createResource(function() {
                            return fetchGenreMovies([ "Comedy" ]);
                        })[0],
                        type: "PosterTitle",
                        height: 400
                    });
                    rows.push({
                        title: "Popular TV shows",
                        items: createResource(function() {
                            return fetchPopular("tv");
                        })[0],
                        type: "PosterTitle",
                        height: 400
                    });
                    var heroRow = {
                        title: "Best Adventure and Action movies",
                        items: createResource(function() {
                            return fetchGenreMovies([ "adventure", "action" ]);
                        })[0],
                        type: "Hero",
                        height: 720
                    };
                    rows.push(heroRow);
                    rows.push({
                        title: "Best Animations",
                        items: createResource(function() {
                            return fetchGenreMovies("Animation");
                        })[0],
                        type: "PosterTitle",
                        height: 400
                    });
                    rows.push({
                        title: "Best TV Movie Movies",
                        items: createResource(function() {
                            return fetchGenreMovies("TV Movie");
                        })[0],
                        type: "PosterTitle",
                        height: 400
                    });
                    rows.push({
                        title: "Best Science Fiction movies",
                        items: createResource(function() {
                            return fetchGenreMovies("Science Fiction");
                        })[0],
                        type: "Hero",
                        height: 720
                    });
                    rows.push({
                        title: "Best War Movies",
                        items: createResource(function() {
                            return fetchGenreMovies("War");
                        })[0],
                        type: "PosterTitle",
                        height: 400
                    });
                    return {
                        rows: rows
                    };
                }
                var NotFound = function NotFound() {
                    return function() {
                        var _el$ = createElement("node");
                        setProp(_el$, "style", {
                            width: 1920,
                            height: 1080,
                            color: 868483072
                        });
                        return _el$;
                    }();
                };
                var basePath$1 = "/solid-demo-app/v2/";
                var fonts = [ {
                    type: "msdf",
                    fontFamily: "Roboto",
                    atlasDataUrl: basePath$1 + "fonts/Roboto-Regular.msdf.json",
                    atlasUrl: basePath$1 + "fonts/Roboto-Regular.msdf.png"
                }, {
                    type: "msdf",
                    fontFamily: "Roboto700",
                    atlasDataUrl: basePath$1 + "fonts/Roboto-Bold.msdf.json",
                    atlasUrl: basePath$1 + "fonts/Roboto-Bold.msdf.png"
                }, {
                    type: "msdf",
                    fontFamily: "Arial",
                    atlasDataUrl: basePath$1 + "fonts/Roboto-Regular.msdf.json",
                    atlasUrl: basePath$1 + "fonts/Roboto-Regular.msdf.png"
                }, {
                    type: "msdf",
                    fontFamily: "Raleway",
                    atlasDataUrl: basePath$1 + "fonts/Raleway-ExtraBold.msdf.json",
                    atlasUrl: basePath$1 + "fonts/Raleway-ExtraBold.msdf.png"
                }, {
                    fontFamily: "Roboto400",
                    fontUrl: basePath$1 + "fonts/Roboto-Regular.ttf"
                } ];
                var cache = new Map;
                function browseProvider(filter) {
                    return function(pageIndex) {
                        var url = "/trending/".concat(filter, "/week?page=").concat(pageIndex);
                        if (cache.has(url)) {
                            return cache.get(url);
                        }
                        var result = api.get(url).then(function(trending) {
                            var results = trending.results.filter(function(r) {
                                return !r.adult;
                            });
                            var tiles = convertItemsToTiles(results);
                            return tiles;
                        });
                        cache.set(url, result);
                        return result;
                    };
                }
                function browsePreload(props) {
                    var lastFilter = null;
                    return createMemo(function(p) {
                        var params = props.params;
                        if (p && (!params.filter || lastFilter === params.filter)) {
                            return p;
                        }
                        var provider = browseProvider(params.filter || "all");
                        provider(1);
                        lastFilter = params.filter || lastFilter;
                        return provider;
                    });
                }
                function minutesToHMM(minutes) {
                    var hours = Math.floor(minutes / 60);
                    var remainingMinutes = minutes % 60;
                    return hours + "h " + (remainingMinutes < 10 ? "0" : "") + remainingMinutes + "min";
                }
                function formatDate(dateString) {
                    var parts = dateString.split("-");
                    return parts[1] + "/" + parts[2] + "/" + parts[0];
                }
                function justYear(dateString) {
                    var parts = (dateString === null || dateString === void 0 ? void 0 : dateString.split("-")) || [];
                    return parts[0] || "";
                }
                function ensureItems(items, minCount) {
                    var remainingCount = minCount - items.length;
                    if (remainingCount > 0) {
                        return items.concat(Array(remainingCount).fill({}));
                    }
                    return items;
                }
                function getRecommendations(_ref81) {
                    var type = _ref81.type, id = _ref81.id;
                    return api.get("/".concat(type, "/").concat(id, "/recommendations")).then(function(_ref82) {
                        var results = _ref82.results;
                        if (results.length) {
                            return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
                        }
                        return api.get("/trending/".concat(type, "/week?page=1")).then(function(_ref83) {
                            var results = _ref83.results;
                            return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
                        });
                    });
                }
                function getCredits(_ref84) {
                    var type = _ref84.type, id = _ref84.id;
                    return api.get("/".concat(type, "/").concat(id, "/credits")).then(function(_ref85) {
                        var cast = _ref85.cast;
                        return ensureItems(convertItemsToTiles(cast.slice(0, 7)), 7);
                    });
                }
                function getInfo(_ref86) {
                    var type = _ref86.type, id = _ref86.id;
                    var rt = type === "movie" ? {
                        rtCrit: 86,
                        rtFan: 92
                    } : {};
                    return api.get("/".concat(type, "/").concat(id)).then(function(data) {
                        return _objectSpread({
                            backgroundImage: getImageUrl(data.backdrop_path, "w1280"),
                            heroContent: {
                                title: data.title || data.name,
                                description: data.overview,
                                badges: [ "HD", "CC" ],
                                voteAverage: data.vote_average,
                                voteCount: data.vote_count,
                                metaText: type === "movie" ? minutesToHMM(data.runtime) + "   " + formatDate(data.release_date) : "".concat(justYear(data.first_air_date), " - ").concat(justYear(data.last_air_date)),
                                reviews: rt
                            }
                        }, data);
                    });
                }
                function entityPreload(_ref87) {
                    var params = _ref87.params, intent = _ref87.intent;
                    var _createResource5 = createResource(function() {
                        return _objectSpread({}, params);
                    }, getInfo), _createResource6 = _slicedToArray(_createResource5, 1), entity = _createResource6[0];
                    if (intent === "preload") {
                        return;
                    }
                    var _createResource7 = createResource(function() {
                        return _objectSpread({}, params);
                    }, getCredits), _createResource8 = _slicedToArray(_createResource7, 1), credits = _createResource8[0];
                    var _createResource9 = createResource(function() {
                        return _objectSpread({}, params);
                    }, getRecommendations), _createResource0 = _slicedToArray(_createResource9, 1), recommendations = _createResource0[0];
                    return {
                        entity: entity,
                        credits: credits,
                        recommendations: recommendations
                    };
                }
                function Background() {
                    var params = new URLSearchParams(window.location.search);
                    var disableBG = params.get("disableBG") === "true";
                    var bg1, bg2, heroMask;
                    var active = 0;
                    var alpha = 1;
                    var animationSettings = {
                        duration: 550,
                        easing: "ease-in-out"
                    };
                    var bgStyles = {
                        alpha: alpha,
                        color: 4294967295
                    };
                    onMount(function() {
                        if (disableBG) {
                            heroMask.src = "";
                            heroMask.colorLeft = 255;
                            heroMask.colorRight = 0;
                            return;
                        }
                    });
                    function changeBackgrounds(img) {
                        if (disableBG) {
                            heroMask.src = "";
                            heroMask.colorLeft = 255;
                            heroMask.colorRight = 0;
                            return;
                        }
                        if (typeof img !== "string") {
                            bg1.color = img;
                            bg1.src = "";
                            bg1.alpha = 1;
                            active = 1;
                            bg2.alpha = 0;
                            heroMask.alpha = 0;
                            return;
                        } else {
                            bg1.color = 4294967295;
                            heroMask.alpha = 1;
                        }
                        var currentBg = active === 1 ? bg2 : bg1;
                        var nextBg = active === 1 ? bg1 : bg2;
                        currentBg.src = img;
                        if (active === 0) {
                            currentBg.alpha = 1;
                        } else {
                            currentBg.alpha = .01;
                            currentBg.animate({
                                alpha: 1
                            }, animationSettings).start();
                        }
                        nextBg.animate({
                            alpha: .01
                        }, animationSettings).start();
                        active = active === 1 ? 2 : 1;
                    }
                    createEffect(on(globalBackground, function(img) {
                        changeBackgrounds(img);
                    }, {
                        defer: true
                    }));
                    return createComponent(View, {
                        width: 1920,
                        height: 1080,
                        zIndex: -5,
                        get children() {
                            return [ createComponent(View, {
                                ref: function ref(r$) {
                                    var _ref$ = bg1;
                                    typeof _ref$ === "function" ? _ref$(r$) : bg1 = r$;
                                },
                                style: bgStyles
                            }), createComponent(View, {
                                ref: function ref(r$) {
                                    var _ref$2 = bg2;
                                    typeof _ref$2 === "function" ? _ref$2(r$) : bg2 = r$;
                                },
                                style: bgStyles,
                                alpha: 0
                            }), createComponent(View, {
                                ref: function ref(r$) {
                                    var _ref$3 = heroMask;
                                    typeof _ref$3 === "function" ? _ref$3(r$) : heroMask = r$;
                                },
                                src: "./assets/hero-mask-inverted.png",
                                get color() {
                                    return hexColor(theme.color.materialBrand);
                                },
                                width: 1920,
                                height: 1080,
                                textureOptions: {
                                    enableAlphaChannel: true
                                }
                            }) ];
                        }
                    });
                }
                var styles = {
                    Column: {
                        flexDirection: "column",
                        display: "flex",
                        width: 140,
                        height: 600,
                        y: 360,
                        gap: 20,
                        zIndex: 101,
                        transition: {
                            x: {
                                duration: 250,
                                easing: "ease-in-out"
                            }
                        },
                        x: 24,
                        $focus: {
                            width: 500
                        }
                    },
                    Gradient: {
                        zIndex: 99,
                        color: 255,
                        src: "./assets/sidenav.png",
                        alpha: 0,
                        width: 200,
                        height: 1080,
                        textureOptions: {
                            enableAlphaChannel: true
                        },
                        $focus: {
                            alpha: 1,
                            width: 1600
                        },
                        transition: {
                            alpha: true,
                            width: true
                        }
                    },
                    NavButton: {
                        zIndex: 102,
                        height: 70,
                        width: 100,
                        borderRadius: 0,
                        color: 0,
                        $focus: {
                            color: theme.primaryLight,
                            borderRadius: 8
                        },
                        $active: {
                            width: 328,
                            height: 70
                        }
                    }
                };
                var basePath = "/solid-demo-app/v2/";
                var icons = [ {
                    name: "experiment",
                    width: 81,
                    height: 100,
                    x: 0,
                    y: 0
                }, {
                    name: "trending",
                    width: 99,
                    height: 56,
                    x: 81,
                    y: 0
                }, {
                    name: "tv",
                    width: 100,
                    height: 68,
                    x: 181,
                    y: 0
                }, {
                    name: "movie",
                    width: 94,
                    height: 100,
                    x: 282,
                    y: 0
                } ];
                var sprite;
                function Icon(props) {
                    sprite = sprite || createSpriteMap(basePath + "assets/icons_white.png", icons);
                    return createComponent(View, mergeProps(props, {
                        get texture() {
                            return sprite[props.name];
                        },
                        get width() {
                            return sprite[props.name].props.w;
                        },
                        get height() {
                            return sprite[props.name].props.h;
                        },
                        get x() {
                            return (100 - (sprite[props.name].props.w || 0)) / 2;
                        },
                        get y() {
                            return (100 - (sprite[props.name].props.h || 0)) / 2;
                        }
                    }));
                }
                var NavButtonTextStyles = {
                    fontSize: 38,
                    x: 116,
                    y: 18,
                    height: 50,
                    alpha: 0,
                    color: theme.textPrimary,
                    $active: {
                        alpha: 1
                    }
                };
                function NavButton(props) {
                    return createComponent(View, mergeProps(props, {
                        forwardStates: true,
                        get style() {
                            return styles.NavButton;
                        },
                        get children() {
                            return [ createComponent(View, {
                                y: -16,
                                get children() {
                                    return createComponent(Icon, {
                                        get color() {
                                            return props.iconColor;
                                        },
                                        scale: .5,
                                        get name() {
                                            return props.icon;
                                        }
                                    });
                                }
                            }), createComponent(Text, {
                                style: NavButtonTextStyles,
                                get children() {
                                    return props.children;
                                }
                            }) ];
                        }
                    }));
                }
                function NavDrawer(props) {
                    var backdrop;
                    var navigate = useNavigate();
                    function onFocus() {
                        backdrop.states.add("$focus");
                        this.children.forEach(function(c) {
                            return c.states.add("$active");
                        });
                        this.children[this.selected || 0].setFocus();
                    }
                    function onBlur() {
                        backdrop.states.remove("$focus");
                        this.selected = 0;
                        this.children.forEach(function(c) {
                            return c.states.remove("$active");
                        });
                    }
                    function handleNavigate(page) {
                        var isOnPage = useMatch(function() {
                            return page;
                        });
                        if (isOnPage()) {
                            return props.focusPage();
                        }
                        navigate(page);
                    }
                    var selectedButton = createMemo(function() {
                        if (useMatch(function() {
                            return "/browse/all";
                        })()) return 366;
                        if (useMatch(function() {
                            return "/browse/movie";
                        })()) return 462;
                        if (useMatch(function() {
                            return "/browse/tv";
                        })()) return 548;
                        if (useMatch(function() {
                            return "/examples";
                        })()) return 638;
                        return 366;
                    });
                    return [ createComponent(View, {
                        id: "NavDrawer",
                        flexItem: false,
                        width: 300,
                        height: 150,
                        x: 30,
                        y: 15,
                        zIndex: 105,
                        get alpha() {
                            return props.showWidgets ? 1 : 0;
                        },
                        get children() {
                            return [ createComponent(Text, {
                                y: 8,
                                x: 80,
                                fontSize: 28,
                                get color() {
                                    return theme.textSecondary;
                                },
                                children: "Built With:"
                            }), createComponent(View, {
                                y: 10,
                                src: "./assets/solidWord.png",
                                width: 280,
                                height: 52,
                                textureOptions: {
                                    enableAlphaChannel: true
                                }
                            }), createComponent(View, {
                                x: 0,
                                y: 100,
                                src: "./assets/tmdb.png",
                                width: 80,
                                height: 41,
                                textureOptions: {
                                    enableAlphaChannel: true
                                }
                            }), createComponent(Text, {
                                x: 90,
                                y: 104,
                                contain: "width",
                                width: 160,
                                fontSize: 12,
                                get color() {
                                    return theme.textSecondary;
                                },
                                children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
                            }) ];
                        }
                    }), createComponent(Column, mergeProps(props, {
                        onFocus: onFocus,
                        onBlur: onBlur,
                        get style() {
                            return styles.Column;
                        },
                        announce: "Main Menu",
                        scroll: "none",
                        get children() {
                            return [ createComponent(NavButton, {
                                onEnter: function onEnter() {
                                    return handleNavigate("/browse/all");
                                },
                                iconColor: 4294967295,
                                announce: [ "Trending Browse", "button" ],
                                icon: "trending",
                                children: "Trending"
                            }), createComponent(NavButton, {
                                icon: "movie",
                                iconColor: 4294967295,
                                announce: [ "Movies Browse", "button" ],
                                onEnter: function onEnter() {
                                    return handleNavigate("/browse/movie");
                                },
                                children: "Movies"
                            }), createComponent(NavButton, {
                                icon: "tv",
                                iconColor: 4294967295,
                                announce: [ "TV Browse", "button" ],
                                onEnter: function onEnter() {
                                    return handleNavigate("/browse/tv");
                                },
                                children: "TV"
                            }), createComponent(NavButton, {
                                icon: "experiment",
                                iconColor: 4294967295,
                                announce: [ "Examples", "button" ],
                                onEnter: function onEnter() {
                                    return handleNavigate("/examples");
                                },
                                children: "Examples"
                            }) ];
                        }
                    })), createComponent(View, {
                        skipFocus: true,
                        ref: function ref(r$) {
                            var _ref$ = backdrop;
                            typeof _ref$ === "function" ? _ref$(r$) : backdrop = r$;
                        },
                        get style() {
                            return styles.Gradient;
                        }
                    }), createComponent(View, {
                        width: 4,
                        height: 56,
                        color: 4294967295,
                        x: 22,
                        get y() {
                            return selectedButton();
                        },
                        zIndex: 100
                    }) ];
                }
                var LeftNavWrapper = function LeftNavWrapper(props) {
                    var navigate = useNavigate();
                    var announcer = useAnnouncer();
                    announcer.debug = true;
                    announcer.enabled = false;
                    var navDrawer, lastFocused;
                    setupFPS({
                        renderer: renderer$2
                    });
                    function focusNavDrawer() {
                        if (navDrawer.states.has("focus")) {
                            return false;
                        }
                        lastFocused = activeElement();
                        return navDrawer.setFocus();
                    }
                    var _createSignal95 = createSignal(true), _createSignal96 = _slicedToArray(_createSignal95, 2), showWidgets = _createSignal96[0], setShowWidgets = _createSignal96[1];
                    var location = useLocation();
                    var showOnPaths = [ "/browse", "/entity" ];
                    createEffect(function() {
                        var currentPath = location.pathname;
                        var matchesPartial = showOnPaths.some(function(path) {
                            return currentPath.startsWith(path);
                        });
                        if (currentPath === "/") {
                            matchesPartial = true;
                        }
                        setShowWidgets(matchesPartial);
                    });
                    var _createSignal97 = createSignal("Last key: undefined"), _createSignal98 = _slicedToArray(_createSignal97, 2), lastKey = _createSignal98[0], setLastKey = _createSignal98[1];
                    var _createSignal99 = createSignal(), _createSignal100 = _slicedToArray(_createSignal99, 2), lastError = _createSignal100[0], setLastError = _createSignal100[1];
                    var keyPressHandler = function keyPressHandler(e) {
                        setLastKey("Last key: ".concat(e.key, ", Code: ").concat(e.keyCode));
                    };
                    document.addEventListener("keydown", keyPressHandler);
                    var displayError = function displayError(e) {
                        setLastError(function(p) {
                            return (p || "") + "\n" + e.message;
                        });
                    };
                    document.addEventListener("onerror", displayError);
                    var windowSize = "".concat(window.innerWidth, "x").concat(window.innerHeight);
                    onCleanup(function() {
                        document.removeEventListener("onerror", displayError);
                        document.removeEventListener("keydown", keyPressHandler);
                    });
                    var pageContainer;
                    return createComponent(View, {
                        ref: function ref(r$) {
                            var _ref$ = window.APP;
                            typeof _ref$ === "function" ? _ref$(r$) : window.APP = r$;
                        },
                        onAnnouncer: function onAnnouncer() {
                            return announcer.enabled = !announcer.enabled;
                        },
                        onLast: function onLast() {
                            return history.back();
                        },
                        onMenu: function onMenu() {
                            return navigate("/");
                        },
                        onBack: function onBack() {
                            return navigate(-1);
                        },
                        style: {
                            width: 1920,
                            height: 1080
                        },
                        onBackspace: focusNavDrawer,
                        onLeft: focusNavDrawer,
                        onRight: function onRight() {
                            return navDrawer.states.has("focus") && (lastFocused || pageContainer).setFocus();
                        },
                        get children() {
                            return [ createComponent(Background, {}), createComponent(FPSCounter, {
                                mountX: 1,
                                x: 1910,
                                y: 10,
                                alpha: 1
                            }), createComponent(View, {
                                mountX: 1,
                                display: "flex",
                                flexDirection: "column",
                                width: 330,
                                height: 50,
                                x: 1910,
                                y: 202,
                                color: 255,
                                get hidden() {
                                    return !showWidgets();
                                },
                                get children() {
                                    return [ createComponent(Text, {
                                        x: 8,
                                        fontSize: 15,
                                        get children() {
                                            return [ "Window Size: ", windowSize ];
                                        }
                                    }), createComponent(Text, {
                                        x: 8,
                                        fontSize: 15,
                                        get children() {
                                            return lastKey();
                                        }
                                    }) ];
                                }
                            }), createComponent(Text, {
                                x: 270,
                                y: 20,
                                fontSize: 24,
                                contain: "width",
                                width: 800,
                                get children() {
                                    return lastError();
                                }
                            }), createComponent(NavDrawer, {
                                ref: function ref(r$) {
                                    var _ref$2 = navDrawer;
                                    typeof _ref$2 === "function" ? _ref$2(r$) : navDrawer = r$;
                                },
                                focusPage: function focusPage() {
                                    return lastFocused.setFocus();
                                },
                                get showWidgets() {
                                    return showWidgets();
                                }
                            }), createComponent(View, {
                                id: "pageContainer",
                                ref: function ref(r$) {
                                    var _ref$3 = pageContainer;
                                    typeof _ref$3 === "function" ? _ref$3(r$) : pageContainer = r$;
                                },
                                forwardFocus: 0,
                                get children() {
                                    return props.children;
                                }
                            }) ];
                        }
                    });
                };
                function calcFactoredRadiusArray(radius, width, height) {
                    var out = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [ 0, 0, 0, 0 ];
                    var _radius = _slicedToArray(radius, 4);
                    out[0] = _radius[0];
                    out[1] = _radius[1];
                    out[2] = _radius[2];
                    out[3] = _radius[3];
                    var factor = Math.min(width / Math.max(width, radius[0] + radius[1]), width / Math.max(width, radius[2] + radius[3]), height / Math.max(height, radius[0] + radius[3]), height / Math.max(height, radius[1] + radius[2]), 1);
                    out[0] *= factor;
                    out[1] *= factor;
                    out[2] *= factor;
                    out[3] *= factor;
                    return out;
                }
                function toValidVec4(value) {
                    if (typeof value === "number") {
                        return [ value, value, value, value ];
                    }
                    if (Array.isArray(value)) {
                        switch (value.length) {
                          default:
                          case 4:
                            return value;

                          case 3:
                            return [ value[0], value[1], value[2], value[0] ];

                          case 2:
                            return [ value[0], value[1], value[0], value[1] ];

                          case 1:
                            return [ value[0], value[0], value[0], value[0] ];

                          case 0:
                            break;
                        }
                    }
                    return [ 0, 0, 0, 0 ];
                }
                var RoundedWithBorderTemplate = {
                    props: {
                        radius: {
                            default: [ 0, 0, 0, 0 ],
                            resolve: function resolve(value) {
                                return toValidVec4(value);
                            }
                        },
                        "top-left": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[0] = value;
                            },
                            get: function get(props) {
                                return props.radius[0];
                            }
                        },
                        "top-right": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[1] = value;
                            },
                            get: function get(props) {
                                return props.radius[1];
                            }
                        },
                        "bottom-right": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[2] = value;
                            },
                            get: function get(props) {
                                return props.radius[2];
                            }
                        },
                        "bottom-left": {
                            default: 0,
                            set: function set(value, props) {
                                props.radius[3] = value;
                            },
                            get: function get(props) {
                                return props.radius[3];
                            }
                        },
                        "border-w": {
                            default: [ 0, 0, 0, 0 ],
                            resolve: function resolve(value) {
                                return toValidVec4(value);
                            }
                        },
                        "border-color": 4294967295,
                        "border-gap": 0,
                        "border-gapColor": 0,
                        "border-top": {
                            default: 0,
                            set: function set(value, props) {
                                props["border-w"][0] = value;
                            },
                            get: function get(props) {
                                return props["border-w"][0];
                            }
                        },
                        "border-right": {
                            default: 0,
                            set: function set(value, props) {
                                props["border-w"][1] = value;
                            },
                            get: function get(props) {
                                return props["border-w"][1];
                            }
                        },
                        "border-bottom": {
                            default: 0,
                            set: function set(value, props) {
                                props["border-w"][2] = value;
                            },
                            get: function get(props) {
                                return props["border-w"][2];
                            }
                        },
                        "border-left": {
                            default: 0,
                            set: function set(value, props) {
                                props["border-w"][3] = value;
                            },
                            get: function get(props) {
                                return props["border-w"][3];
                            }
                        }
                    }
                };
                var RoundedWithBorder = {
                    props: RoundedWithBorderTemplate.props,
                    update: function update(node) {
                        var props = this.props;
                        var borderWidth = props["border-w"];
                        var borderGap = props["border-gap"] || 0;
                        this.uniformRGBA("u_borderColor", props["border-color"]);
                        this.uniform4fa("u_borderWidth", borderWidth);
                        this.uniform1f("u_borderGap", borderGap);
                        this.uniformRGBA("u_borderGapColor", props["border-gapColor"]);
                        var origWidth = node.w;
                        var origHeight = node.h;
                        this.uniform2f("u_dimensions_orig", origWidth, origHeight);
                        var expandedWidth = origWidth + borderWidth[3] + borderWidth[1] + borderGap * 2;
                        var expandedHeight = origHeight + borderWidth[0] + borderWidth[2] + borderGap * 2;
                        this.uniform2f("u_dimensions", expandedWidth, expandedHeight);
                        var contentRadius = calcFactoredRadiusArray(this.props.radius, origWidth, origHeight);
                        var bTop = borderWidth[0], bRight = borderWidth[1], bBottom = borderWidth[2], bLeft = borderWidth[3];
                        var outerRadius = [ Math.max(0, contentRadius[0] + borderGap + Math.max(bTop, bLeft)), Math.max(0, contentRadius[1] + borderGap + Math.max(bTop, bRight)), Math.max(0, contentRadius[2] + borderGap + Math.max(bBottom, bRight)), Math.max(0, contentRadius[3] + borderGap + Math.max(bBottom, bLeft)) ];
                        this.uniform4fa("u_radius", calcFactoredRadiusArray(outerRadius, expandedWidth, expandedHeight));
                    },
                    vertex: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_position;\n    attribute vec2 a_textureCoords;\n    attribute vec4 a_color;\n    attribute vec2 a_nodeCoords;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform vec2 u_dimensions;\n    uniform vec2 u_dimensions_orig;\n\n    uniform vec4 u_radius;\n    uniform vec4 u_borderWidth;\n    uniform float u_borderGap;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n    varying vec4 v_borderEndRadius;\n    varying vec2 v_borderEndSize;\n\n    varying vec4 v_innerRadius;\n    varying vec2 v_innerSize;\n    varying vec2 v_halfDimensions;\n    varying float v_borderZero;\n\n    void main() {\n      vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);\n\n      v_color = a_color;\n      v_nodeCoords = a_nodeCoords;\n\n      float bTop = u_borderWidth.x;\n      float bRight = u_borderWidth.y;\n      float bBottom = u_borderWidth.z;\n      float bLeft = u_borderWidth.w;\n      float gap = u_borderGap;\n\n      // Calculate the offset to expand the quad for border and gap\n      vec2 expansionOffset = vec2(0.0);\n      if (a_nodeCoords.x == 0.0) { // Left edge vertex\n          expansionOffset.x = -(bLeft + gap);\n      } else { // Right edge vertex (a_nodeCoords.x == 1.0)\n          expansionOffset.x = (bRight + gap);\n      }\n      if (a_nodeCoords.y == 0.0) { // Top edge vertex\n          expansionOffset.y = -(bTop + gap);\n      } else { // Bottom edge vertex (a_nodeCoords.y == 1.0)\n          expansionOffset.y = (bBottom + gap);\n      }\n\n      vec2 expanded_a_position = a_position + expansionOffset;\n      vec2 normalized = expanded_a_position * u_pixelRatio;\n\n      // u_dimensions is expanded, u_dimensions_orig is original content size\n      v_textureCoords.x = (a_textureCoords.x * u_dimensions.x - (bLeft + gap)) / u_dimensions_orig.x;\n      v_textureCoords.y = (a_textureCoords.y * u_dimensions.y - (bTop + gap)) / u_dimensions_orig.y;\n\n      v_borderZero = (u_borderWidth.x == 0.0 && u_borderWidth.y == 0.0 && u_borderWidth.z == 0.0 && u_borderWidth.w == 0.0) ? 1.0 : 0.0;\n      // If there's no border, there's no gap from the border logic perspective\n      // The Rounded shader itself would handle radius if borderZero is true.\n      v_halfDimensions = u_dimensions * 0.5; // u_dimensions is now expanded_dimensions\n      if(v_borderZero == 0.0) {\n        // Calculate radius and size for the inner edge of the border (where the gap begins)\n        v_borderEndRadius = vec4(\n          max(0.0, u_radius.x - max(bTop, bLeft) - 0.5),\n          max(0.0, u_radius.y - max(bTop, bRight) - 0.5),\n          max(0.0, u_radius.z - max(bBottom, bRight) - 0.5),\n          max(0.0, u_radius.w - max(bBottom, bLeft) - 0.5)\n        );\n        v_borderEndSize = vec2(\n            (u_dimensions.x - (bLeft + bRight) - 1.0),\n            (u_dimensions.y - (bTop + bBottom) - 1.0)\n        ) * 0.5;\n\n        // Calculate radius and size for the content area (after the gap)\n        v_innerRadius = vec4(\n          max(0.0, u_radius.x - max(bTop, bLeft) - u_borderGap - 0.5),\n          max(0.0, u_radius.y - max(bTop, bRight) - u_borderGap - 0.5),\n          max(0.0, u_radius.z - max(bBottom, bRight) - u_borderGap - 0.5),\n          max(0.0, u_radius.w - max(bBottom, bLeft) - u_borderGap - 0.5)\n        );\n        v_innerSize = vec2(\n            (u_dimensions.x - (bLeft + bRight) - (u_borderGap * 2.0) - 1.0),\n            (u_dimensions.y - (bTop + bBottom) - (u_borderGap * 2.0) - 1.0)\n        ) * 0.5;\n      }\n\n      gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);\n      gl_Position.y = -sign(screenSpace.y) * gl_Position.y;\n    }\n  ",
                    fragment: "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n    uniform float u_alpha;\n    uniform vec2 u_dimensions;\n    uniform sampler2D u_texture;\n\n    uniform vec4 u_radius;\n\n    uniform vec4 u_borderWidth;\n    uniform vec4 u_borderColor;\n    uniform vec4 u_borderGapColor;\n\n    varying vec4 v_borderEndRadius;\n    varying vec2 v_borderEndSize;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoords;\n    varying vec2 v_nodeCoords;\n\n    varying vec2 v_halfDimensions;\n    varying vec4 v_innerRadius;\n    varying vec2 v_innerSize;\n    varying float v_borderZero;\n\n    float roundedBox(vec2 p, vec2 s, vec4 r) {\n      r.xy = (p.x > 0.0) ? r.yz : r.xw;\n      r.x = (p.y > 0.0) ? r.y : r.x;\n      vec2 q = abs(p) - s + r.x;\n      return (min(max(q.x, q.y), 0.0) + length(max(q, 0.0))) - r.x;\n    }\n\n    void main() {\n      vec4 contentTexColor = texture2D(u_texture, v_textureCoords) * v_color;\n\n      vec2 boxUv = v_nodeCoords.xy * u_dimensions - v_halfDimensions;\n      float outerShapeDist = roundedBox(boxUv, v_halfDimensions, u_radius);\n\n      float edgeWidth = 1.0 / u_pixelRatio;\n      float outerShapeAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, outerShapeDist);\n\n      if(v_borderZero == 1.0) { // No border, effectively no gap from border logic\n        gl_FragColor = mix(vec4(0.0), contentTexColor, outerShapeAlpha) * u_alpha;\n        return;\n      }\n\n      // Adjust boxUv for non-uniform borders\n      vec2 adjustedBoxUv = boxUv;\n      adjustedBoxUv.x += (u_borderWidth.y - u_borderWidth.w) * 0.5;\n      adjustedBoxUv.y += (u_borderWidth.z - u_borderWidth.x) * 0.5;\n\n      // Inner Border Edge (Gap starts here)\n      float borderEndDist = roundedBox(adjustedBoxUv, v_borderEndSize, v_borderEndRadius);\n      float borderEndAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, borderEndDist);\n\n      // Content Area (Gap ends here)\n      float contentDist = roundedBox(adjustedBoxUv, v_innerSize, v_innerRadius);\n      float contentAlpha = 1.0 - smoothstep(-0.5 * edgeWidth, 0.5 * edgeWidth, contentDist);\n\n      // Calculate Masks for mutually exclusive regions based on priority (Border Top, Gap Middle, Content Bottom)\n      float borderMask = clamp(outerShapeAlpha - borderEndAlpha, 0.0, 1.0);\n      float gapMask = clamp(borderEndAlpha - contentAlpha, 0.0, 1.0);\n\n      // Composite Layers\n      // 1. Content\n      vec4 composite = mix(vec4(0.0), contentTexColor, contentAlpha);\n      // 2. Gap\n      composite = mix(composite, u_borderGapColor, gapMask);\n      // 3. Border\n      composite = mix(composite, u_borderColor, borderMask);\n\n      gl_FragColor = composite * u_alpha;\n    }\n  "
                };
                var Player = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Player-legacy-BJA9EfeW.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var Grid = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Grid-legacy-D-dlp3--.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var Loops = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Loops-legacy-SQUmqRi1.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var Infinite = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Infinite-legacy-BgIRFrhj.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var TMDBGrid = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./TMDBGrid-legacy-Ch4ky6_C.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var Portal = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Portal-legacy-Gr0C941j.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var MatrixPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Matrix-legacy-DnydQTKr.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var TextPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Text-legacy-Dl59MSpH.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var TextPosterPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./TextPoster-legacy-B2S5Me_f.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var CreatePage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Create-legacy-SxmfsFQt.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var ViewportPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Viewport-legacy-BHfbiwhk.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var PositioningPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Positioning-legacy-BRwYiGej.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var LayoutPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Layout-legacy-DpBJGG98.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FocusBasicsPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FocusBasics-legacy-8_DP3gLF.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var KeyHandlingPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./KeyHandling-legacy-D552zVyU.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var TransitionsPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Transitions-legacy-iicAAu66.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var ComponentsPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Components-legacy-BpoMtYqt.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FocusHandlingPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FocusHandling-legacy-Dym1jUQl.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var GradientsPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Gradients-legacy-BHCrgk0p.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Flex-legacy-B8znVjfI.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexGrowPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FlexGrow-legacy-C6DLLoOj.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexMenuPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FlexMenu-legacy-B4CsvnGr.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexSizePage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FlexSize-legacy-94wlyy-M.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexColumnSizePage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FlexColumnSize-legacy-CjikGir7.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FlexColumnPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./FlexColumn-legacy-BXAjTM1N.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var ButtonsMaterialPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./ButtonsMaterial-legacy-CAhJ95_K.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var SuperFlexPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./SuperFlex-legacy-CxWmwraV.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var Entity = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Entity-legacy-BLpltNw5.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var People = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./People-legacy-Bdlw2xkB.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var FireboltPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Firebolt-legacy-evQGozvO.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var LoginPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Login-legacy-CA6vr_1U.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var VirtualPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Virtual-legacy-jxwAlYcc.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var TagsPage = lazy(function() {
                    return __vitePreload(function() {
                        return module.import("./Tags-legacy-nzbn_6g2.js");
                    }, false ? __VITE_PRELOAD__ : void 0);
                });
                var numImageWorkers = 4;
                var urlParams = new URLSearchParams(window.location.search);
                var numWorkers = urlParams.get("numImageWorkers");
                var screenSize = urlParams.get("size") || "default";
                var rendererMode = urlParams.get("mode") || "webgl";
                var animationsEnabled = urlParams.get("animate") || "true";
                if (numWorkers) {
                    numImageWorkers = parseInt(numWorkers);
                }
                var deviceLogicalPixelRatio = {
                    720: .666667,
                    medium: .8,
                    1080: 1,
                    "4k": 2,
                    default: window.innerHeight / 1080
                }[screenSize];
                Config.debug = false;
                Config.animationsEnabled = animationsEnabled === "true";
                Config.simpleAnimationsEnabled = true;
                Config.fontSettings.fontFamily = "Roboto";
                Config.fontSettings.color = theme.textPrimary;
                Config.fontSettings.fontSize = 32;
                Config.domRendererEnabled = false;
                Config.rendererOptions = {
                    fpsUpdateInterval: 1e3,
                    textureMemory: {
                        criticalThreshold: 2e8,
                        targetThresholdLevel: .8
                    },
                    numImageWorkers: numImageWorkers,
                    deviceLogicalPixelRatio: deviceLogicalPixelRatio,
                    devicePhysicalPixelRatio: 1,
                    createImageBitmapSupport: "auto",
                    targetFPS: 0,
                    enableClear: false,
                    enableAlphaChannel: false,
                    textureEnableAlphaFormats: [ "png" ]
                };
                if (rendererMode === "canvas") {
                    Config.rendererOptions.fontEngines = [ CanvasTextRenderer ];
                    Config.rendererOptions.renderEngine = CanvasRenderer;
                } else {
                    Config.rendererOptions.fontEngines = [ SdfTextRenderer ];
                    Config.rendererOptions.renderEngine = WebGlRenderer;
                }
                var _createRenderer = createRenderer(), renderer = _createRenderer.renderer, render = _createRenderer.render;
                loadFonts(fonts);
                var shManager = renderer.stage.shManager;
                shManager.registerShaderType("rounded", Rounded);
                shManager.registerShaderType("roundedWithBorder", RoundedWithBorder);
                shManager.registerShaderType("roundedWithShadow", RoundedWithShadow);
                shManager.registerShaderType("roundedWithBorderWithShadow", RoundedWithBorderAndShadow);
                shManager.registerShaderType("radialGradient", RadialGradient);
                shManager.registerShaderType("linearGradient", LinearGradient);
                shManager.registerShaderType("holePunch", HolePunch);
                render(function() {
                    return createComponent(FocusStackProvider, {
                        get children() {
                            return createComponent(HashRouter, {
                                root: function root(props) {
                                    return createComponent(App, props);
                                },
                                get children() {
                                    return [ createComponent(Route, {
                                        path: "",
                                        component: LeftNavWrapper,
                                        get children() {
                                            return [ createComponent(Route, {
                                                path: "",
                                                component: function component() {
                                                    return createComponent(Navigate, {
                                                        href: "/browse/all"
                                                    });
                                                }
                                            }), createComponent(Route, {
                                                path: "examples",
                                                component: Portal,
                                                get children() {
                                                    return [ createComponent(Route, {
                                                        path: "/"
                                                    }), createComponent(Route, {
                                                        path: "tmdb",
                                                        component: TMDB,
                                                        preload: tmdbData
                                                    }) ];
                                                }
                                            }), createComponent(KeepAliveRoute, {
                                                id: "browse",
                                                path: "browse/:filter",
                                                component: Browse,
                                                preload: browsePreload
                                            }), createComponent(Route, {
                                                path: "loops",
                                                component: Loops,
                                                preload: tmdbData
                                            }), createComponent(Route, {
                                                path: "infinite",
                                                component: Infinite,
                                                preload: tmdbData
                                            }), createComponent(Route, {
                                                path: "tmdbgrid",
                                                component: TMDBGrid,
                                                preload: tmdbData
                                            }), createComponent(Route, {
                                                path: "virtual",
                                                component: VirtualPage,
                                                preload: tmdbData
                                            }), createComponent(Route, {
                                                path: "destroy",
                                                component: Destroy,
                                                preload: destroyData
                                            }), createComponent(Route, {
                                                path: "grid",
                                                component: Grid
                                            }), createComponent(Route, {
                                                path: "matrix",
                                                component: MatrixPage
                                            }), createComponent(Route, {
                                                path: "text",
                                                component: TextPage
                                            }), createComponent(Route, {
                                                path: "firebolt",
                                                component: FireboltPage
                                            }), createComponent(Route, {
                                                path: "login",
                                                component: LoginPage
                                            }), createComponent(Route, {
                                                path: "nested",
                                                get component() {
                                                    return lazy(function() {
                                                        return __vitePreload(function() {
                                                            return module.import("./Nested-legacy-CcR0oHS8.js");
                                                        }, false ? __VITE_PRELOAD__ : void 0);
                                                    });
                                                }
                                            }), createComponent(Route, {
                                                path: "textposter",
                                                component: TextPosterPage
                                            }), createComponent(Route, {
                                                path: "positioning",
                                                component: PositioningPage
                                            }), createComponent(Route, {
                                                path: "layout",
                                                component: LayoutPage
                                            }), createComponent(Route, {
                                                path: "focusbasics",
                                                component: FocusBasicsPage
                                            }), createComponent(Route, {
                                                path: "transitions",
                                                component: TransitionsPage
                                            }), createComponent(Route, {
                                                path: "components",
                                                component: ComponentsPage
                                            }), createComponent(Route, {
                                                path: "focushandling",
                                                component: FocusHandlingPage
                                            }), createComponent(Route, {
                                                path: "keyhandling",
                                                component: KeyHandlingPage
                                            }), createComponent(Route, {
                                                path: "gradients",
                                                component: GradientsPage
                                            }), createComponent(Route, {
                                                path: "flex",
                                                component: FlexPage
                                            }), createComponent(Route, {
                                                path: "create",
                                                component: CreatePage
                                            }), createComponent(Route, {
                                                path: "viewport",
                                                component: ViewportPage
                                            }), createComponent(Route, {
                                                path: "flexsize",
                                                component: FlexSizePage
                                            }), createComponent(Route, {
                                                path: "flexmenu",
                                                component: FlexMenuPage
                                            }), createComponent(Route, {
                                                path: "flexcolumnsize",
                                                component: FlexColumnSizePage
                                            }), createComponent(Route, {
                                                path: "flexcolumn",
                                                component: FlexColumnPage
                                            }), createComponent(Route, {
                                                path: "flexgrow",
                                                component: FlexGrowPage
                                            }), createComponent(Route, {
                                                path: "keepalive",
                                                get component() {
                                                    return lazy(function() {
                                                        return __vitePreload(function() {
                                                            return module.import("./KeepAlive-legacy-DRzt0b9E.js");
                                                        }, false ? __VITE_PRELOAD__ : void 0);
                                                    });
                                                }
                                            }), createComponent(Route, {
                                                path: "suspense",
                                                get component() {
                                                    return lazy(function() {
                                                        return __vitePreload(function() {
                                                            return module.import("./suspense-legacy-a8V8a7wB.js");
                                                        }, false ? __VITE_PRELOAD__ : void 0);
                                                    });
                                                }
                                            }), createComponent(Route, {
                                                path: "superflex",
                                                component: SuperFlexPage
                                            }), createComponent(Route, {
                                                path: "tags",
                                                component: TagsPage
                                            }), createComponent(Route, {
                                                path: "buttonsmaterial",
                                                component: ButtonsMaterialPage
                                            }), createComponent(Route, {
                                                path: "entity/people/:id",
                                                component: People
                                            }), createComponent(Route, {
                                                path: "entity/:type/:id",
                                                component: Entity,
                                                preload: entityPreload
                                            }), createComponent(Route, {
                                                path: "*all",
                                                component: NotFound
                                            }) ];
                                        }
                                    }), createComponent(Route, {
                                        path: "player",
                                        get children() {
                                            return createComponent(Route, {
                                                path: ":id",
                                                component: Player
                                            });
                                        }
                                    }) ];
                                }
                            });
                        }
                    });
                });
            }
        };
    });
})();
