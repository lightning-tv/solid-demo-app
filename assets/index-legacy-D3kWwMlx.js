;
(function () {
  var _excluded = ["defaultTone"],
    _excluded2 = ["defaultTone"],
    _excluded3 = ["defaultTone"],
    _excluded4 = ["surfaceDefaultTone"],
    _excluded5 = ["defaultTone"],
    _excluded6 = ["defaultTone"],
    _excluded7 = ["defaultTone"],
    _excluded8 = ["defaultTone"],
    _excluded9 = ["defaultTone"],
    _excluded10 = ["defaultTone"],
    _excluded11 = ["defaultTone"],
    _excluded12 = ["defaultTone"],
    _excluded13 = ["defaultTone"],
    _excluded14 = ["defaultTone"],
    _excluded15 = ["defaultTone"],
    _excluded16 = ["defaultTone"];
  function _objectDestructuringEmpty(t) { if (null == t) throw new TypeError("Cannot destructure " + t); }
  function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
  function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
  function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
  function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
  function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  function _superPropGet(t, o, e, r) { var p = _get2(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _get2() { return _get2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get2.apply(null, arguments); }
  function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
  function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
  function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
  function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
  function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n3 = 0, F = function F() {}; return { s: F, n: function n() { return _n3 >= r.length ? { done: !0 } : { done: !1, value: r[_n3++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  System.register([], function (exports, module) {
    'use strict';

    return {
      execute: function execute() {
        var _LinearGradientEffect, _RadialGradientEffect, _resolvedGlobal$docum;
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = "html,\nbody,\n* {\n  padding: 0;\n  margin: 0;\n}\nhtml,\nbody {\n  height: 100%;\n  overflow: hidden;\n}\nvideo {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2;\n  outline: none;\n}\n.center-element {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        exports({
          A: children,
          B: Block,
          D: Dynamic,
          F: For,
          H: Button,
          I: Index,
          J: TileRow,
          L: convertItemsToTiles,
          N: getImageUrl,
          P: Poster,
          S: Show,
          a: createResource,
          b: createComputed,
          c: createSignal,
          d: batch,
          e: createSelector,
          f: createEffect,
          g: onMount,
          i: splitProps,
          j: createMemo,
          k: onCleanup,
          l: createRoot,
          o: on,
          u: untrack,
          w: assertTruthy,
          x: hexColor,
          z: combineStyles
        });
        false && function polyfill() {
          var relList = document.createElement("link").relList;
          if (relList && relList.supports && relList.supports("modulepreload")) {
            return;
          }
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll('link[rel="modulepreload"]')),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(function (mutations) {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== "childList") {
                  continue;
                }
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var node = _step3.value;
                    if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            var fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";else fetchOpts.credentials = "same-origin";
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();
        var scriptRel = 'modulepreload';
        var assetsURL = function assetsURL(dep) {
          return "/solid-demo-app/" + dep;
        };
        var seen = {};
        var __vitePreload = function preload(baseModule, deps, importerUrl) {
          var promise = Promise.resolve();
          if (false && deps && deps.length > 0) {
            document.getElementsByTagName("link");
            var cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
            var cspNonce = (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.getAttribute("nonce"));
            promise = Promise.allSettled(deps.map(function (dep) {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              var isCss = dep.endsWith(".css");
              var cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector("link[href=\"".concat(dep, "\"]").concat(cssSelector))) {
                return;
              }
              var link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise(function (res, rej) {
                  link.addEventListener("load", res);
                  link.addEventListener("error", function () {
                    return rej(new Error("Unable to preload CSS for ".concat(dep)));
                  });
                });
              }
            }));
          }
          function handlePreloadError(err) {
            var e = new Event("vite:preloadError", {
              cancelable: true
            });
            e.payload = err;
            window.dispatchEvent(e);
            if (!e.defaultPrevented) {
              throw err;
            }
          }
          return promise.then(function (res) {
            var _iterator4 = _createForOfIteratorHelper(res || []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var item = _step4.value;
                if (item.status !== "rejected") continue;
                handlePreloadError(item.reason);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            return baseModule().catch(handlePreloadError);
          });
        };
        ({
          "BASE_URL": "/solid-demo-app/",
          "DEV": false,
          "LEGACY": true,
          "MODE": "production",
          "PROD": true,
          "SSR": false
        });
        function createWebGLContext(canvas) {
          var forceWebGL2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var contextSpy = arguments.length > 2 ? arguments[2] : undefined;
          var config = {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: true,
            desynchronized: false,
            // Disabled because it prevents Visual Regression Tests from working
            // failIfMajorPerformanceCaveat: true,
            powerPreference: "high-performance",
            premultipliedAlpha: true,
            preserveDrawingBuffer: false
          };
          var gl =
          // TODO: Remove this assertion once this issue is fixed in TypeScript
          // https://github.com/microsoft/TypeScript/issues/53614
          canvas.getContext(forceWebGL2 ? "webgl2" : "webgl", config) || canvas.getContext("experimental-webgl", config);
          if (!gl) {
            throw new Error("Unable to create WebGL context");
          }
          if (contextSpy) {
            return new Proxy(gl, {
              get: function get(target, prop) {
                var value = target[prop];
                if (typeof value === "function") {
                  contextSpy.increment(String(prop));
                  return value.bind(target);
                }
                return value;
              }
            });
          }
          return gl;
        }
        function assertTruthy(condition, message) {
          return;
        }
        function mergeColorProgress(rgba1, rgba2, p) {
          var r1 = Math.trunc(rgba1 >>> 24);
          var g1 = Math.trunc(rgba1 >>> 16 & 255);
          var b1 = Math.trunc(rgba1 >>> 8 & 255);
          var a1 = Math.trunc(rgba1 & 255);
          var r2 = Math.trunc(rgba2 >>> 24);
          var g2 = Math.trunc(rgba2 >>> 16 & 255);
          var b2 = Math.trunc(rgba2 >>> 8 & 255);
          var a2 = Math.trunc(rgba2 & 255);
          var r = Math.round(r2 * p + r1 * (1 - p));
          var g = Math.round(g2 * p + g1 * (1 - p));
          var b = Math.round(b2 * p + b1 * (1 - p));
          var a = Math.round(a2 * p + a1 * (1 - p));
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        function mergeColorAlpha(rgba, alpha) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 255;
          var b = rgba >>> 8 & 255;
          var a = Math.trunc((rgba & 255) * alpha);
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        var premultiplyRGB = true;
        function setPremultiplyMode(mode) {
          premultiplyRGB = mode === "webgl";
        }
        function mergeColorAlphaPremultiplied(rgba, alpha) {
          var flipEndianess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var newAlpha = (rgba & 255) / 255 * alpha;
          var rgbAlpha = premultiplyRGB ? newAlpha : 1;
          var r = Math.trunc((rgba >>> 24) * rgbAlpha);
          var g = Math.trunc((rgba >>> 16 & 255) * rgbAlpha);
          var b = Math.trunc((rgba >>> 8 & 255) * rgbAlpha);
          var a = Math.trunc(newAlpha * 255);
          if (flipEndianess) {
            return (a << 24 | b << 16 | g << 8 | r) >>> 0;
          }
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        function hasOwn(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        function isProductionEnvironment() {
          return true;
        }
        var nextId = 1;
        function getNewId() {
          return nextId++;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * EventEmitter base class
         */
        var EventEmitter = /*#__PURE__*/function () {
          function EventEmitter() {
            _classCallCheck(this, EventEmitter);
            _defineProperty(this, "eventListeners", {});
          }
          return _createClass(EventEmitter, [{
            key: "on",
            value: function on(event, listener) {
              var listeners = this.eventListeners[event];
              if (!listeners) {
                listeners = [];
              }
              listeners.push(listener);
              this.eventListeners[event] = listeners;
            }
          }, {
            key: "off",
            value: function off(event, listener) {
              var listeners = this.eventListeners[event];
              if (!listeners) {
                return;
              }
              if (!listener) {
                delete this.eventListeners[event];
                return;
              }
              var index = listeners.indexOf(listener);
              if (index >= 0) {
                listeners.splice(index, 1);
              }
            }
          }, {
            key: "once",
            value: function once(event, listener) {
              var _this = this;
              var _onceListener = function onceListener(target, data) {
                _this.off(event, _onceListener);
                listener(target, data);
              };
              this.on(event, _onceListener);
            }
          }, {
            key: "emit",
            value: function emit(event, data) {
              var _this2 = this;
              var listeners = this.eventListeners[event];
              if (!listeners) {
                return;
              }
              _toConsumableArray(listeners).forEach(function (listener) {
                listener(_this2, data);
              });
            }
          }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
              this.eventListeners = {};
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TextureType;
        (function (TextureType) {
          TextureType[TextureType["generic"] = 0] = "generic";
          TextureType[TextureType["color"] = 1] = "color";
          TextureType[TextureType["image"] = 2] = "image";
          TextureType[TextureType["noise"] = 3] = "noise";
          TextureType[TextureType["renderToTexture"] = 4] = "renderToTexture";
          TextureType[TextureType["subTexture"] = 5] = "subTexture";
        })(TextureType || (TextureType = {}));
        /**
         * Represents a source of texture data for a CoreContextTexture.
         *
         * @remarks
         * Texture sources are used to populate a CoreContextTexture when that texture
         * is loaded. Texture data retrieved by the CoreContextTexture by the
         * `getTextureData` method. It's the responsibility of the concerete `Texture`
         * subclass to implement this method appropriately.
         */
        var Texture = /*#__PURE__*/function (_EventEmitter2) {
          function Texture(txManager) {
            var _this3;
            _classCallCheck(this, Texture);
            _this3 = _callSuper(this, Texture);
            _defineProperty(_this3, "txManager", void 0);
            /**
             * The dimensions of the texture
             *
             * @remarks
             * Until the texture data is loaded for the first time the value will be
             * `null`.
             */
            _defineProperty(_this3, "dimensions", null);
            _defineProperty(_this3, "error", null);
            // aggregate state
            _defineProperty(_this3, "state", 'initial');
            _defineProperty(_this3, "renderableOwners", new Set());
            _defineProperty(_this3, "renderable", false);
            _defineProperty(_this3, "type", TextureType.generic);
            _defineProperty(_this3, "preventCleanup", false);
            _defineProperty(_this3, "ctxTexture", void 0);
            _defineProperty(_this3, "textureData", null);
            _this3.txManager = txManager;
            return _this3;
          }
          /**
           * Add/remove an owner to/from the Texture based on its renderability.
           *
           * @remarks
           * Any object can own a texture, be it a CoreNode or even the state object
           * from a Text Renderer.
           *
           * When the reference to the texture that an owner object holds is replaced
           * or cleared it must call this with `renderable=false` to release the owner
           * association.
           *
           * @param owner
           * @param renderable
           */
          _inherits(Texture, _EventEmitter2);
          return _createClass(Texture, [{
            key: "setRenderableOwner",
            value: function setRenderableOwner(owner, renderable) {
              var oldSize = this.renderableOwners.size;
              if (renderable === true) {
                if (this.renderableOwners.has(owner) === false) {
                  // Add the owner to the set
                  this.renderableOwners.add(owner);
                }
                var newSize = this.renderableOwners.size;
                if (newSize > oldSize && newSize === 1) {
                  var _this$onChangeIsRende;
                  this.renderable = true;
                  (_this$onChangeIsRende = this.onChangeIsRenderable) === null || _this$onChangeIsRende === void 0 || _this$onChangeIsRende.call(this, true);
                  this.load();
                }
              } else {
                this.renderableOwners.delete(owner);
                var _newSize = this.renderableOwners.size;
                if (_newSize < oldSize && _newSize === 0) {
                  var _this$onChangeIsRende2;
                  this.renderable = false;
                  (_this$onChangeIsRende2 = this.onChangeIsRenderable) === null || _this$onChangeIsRende2 === void 0 || _this$onChangeIsRende2.call(this, false);
                  this.txManager.orphanTexture(this);
                }
              }
            }
          }, {
            key: "load",
            value: function load() {
              this.txManager.loadTexture(this);
            }
            /**
             * Load the core context texture for this Texture.
             * The ctxTexture is created by the renderer and lives on the GPU.
             *
             * @returns
             */
          }, {
            key: "loadCtxTexture",
            value: function loadCtxTexture() {
              if (this.ctxTexture === undefined) {
                this.ctxTexture = this.txManager.renderer.createCtxTexture(this);
              }
              return this.ctxTexture;
            }
            /**
             * Free the core context texture for this Texture.
             *
             * @remarks
             * The ctxTexture is created by the renderer and lives on the GPU.
             */
          }, {
            key: "free",
            value: function free() {
              var _this$ctxTexture;
              (_this$ctxTexture = this.ctxTexture) === null || _this$ctxTexture === void 0 || _this$ctxTexture.free();
            }
            /**
             * Free the source texture data for this Texture.
             *
             * @remarks
             * The texture data is the source data that is used to populate the CoreContextTexture.
             * e.g. ImageData that is downloaded from a URL.
             */
          }, {
            key: "freeTextureData",
            value: function freeTextureData() {
              this.textureData = null;
            }
          }, {
            key: "setState",
            value: function setState(state, errorOrDimensions) {
              if (this.state === state) {
                return;
              }
              var payload = null;
              if (state === 'loaded') {
                this.dimensions = errorOrDimensions;
                payload = this.dimensions;
              } else if (state === 'failed') {
                this.error = errorOrDimensions;
                payload = this.error;
              }
              // emit the new state
              this.state = state;
              this.emit(state, payload);
            }
            /**
             * Get the texture data for this texture.
             *
             * @remarks
             * This method is called by the CoreContextTexture when the texture is loaded.
             * The texture data is then used to populate the CoreContextTexture.
             *
             * @returns
             * The texture data for this texture.
             */
          }, {
            key: "getTextureData",
            value: (function () {
              var _getTextureData = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      if (!(this.textureData === null)) {
                        _context.next = 4;
                        break;
                      }
                      _context.next = 3;
                      return this.getTextureSource();
                    case 3:
                      this.textureData = _context.sent;
                    case 4:
                      return _context.abrupt("return", this.textureData);
                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }, _callee, this);
              }));
              function getTextureData() {
                return _getTextureData.apply(this, arguments);
              }
              return getTextureData;
            }()
            /**
             * Make a cache key for this texture.
             *
             * @remarks
             * Each concrete `Texture` subclass must implement this method to provide an
             * appropriate cache key for the texture type including the texture's
             * properties that uniquely identify a copy of the texture. If the texture
             * type does not support caching, then this method should return `false`.
             *
             * @param props
             * @returns
             * A cache key for this texture or `false` if the texture type does not
             * support caching.
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            )
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              return false;
            }
            /**
             * Resolve the default values for the texture's properties.
             *
             * @remarks
             * Each concrete `Texture` subclass must implement this method to provide
             * default values for the texture's optional properties.
             *
             * @param props
             * @returns
             * The default values for the texture's properties.
             */
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            props) {
              return {};
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var PROTOCOL_REGEX = /^(data|ftps?|https?):/;
        var getNormalizedRgbaComponents = function getNormalizedRgbaComponents(rgba) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 0xff;
          var b = rgba >>> 8 & 0xff;
          var a = rgba & 0xff;
          return [r / 255, g / 255, b / 255, a / 255];
        };
        var getRgbaComponents = function getRgbaComponents(rgba) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 0xff;
          var b = rgba >>> 8 & 0xff;
          var a = rgba & 0xff;
          return [r, g, b, a];
        };
        function getNormalizedAlphaComponent(rgba) {
          return (rgba & 0xff) / 255.0;
        }
        /**
         * Get a CSS color string from a RGBA color
         *
         * @param color
         * @returns
         */
        function getRgbaString(color) {
          var r = Math.floor(color[0] * 255.0);
          var g = Math.floor(color[1] * 255.0);
          var b = Math.floor(color[2] * 255.0);
          var a = Math.floor(color[3] * 255.0);
          return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a.toFixed(4), ")");
        }
        function createBound(x1, y1, x2, y2, out) {
          if (out) {
            out.x1 = x1;
            out.y1 = y1;
            out.x2 = x2;
            out.y2 = y2;
            return out;
          }
          return {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          };
        }
        function boundsOverlap(a, b) {
          return a.x1 < b.x2 && a.x2 > b.x1 && a.y1 < b.y2 && a.y2 > b.y1;
        }
        function convertBoundToRect(bound, out) {
          {
            out.x = bound.x1;
            out.y = bound.y1;
            out.width = bound.x2 - bound.x1;
            out.height = bound.y2 - bound.y1;
            return out;
          }
        }
        function intersectRect(a, b, out) {
          var x = Math.max(a.x, b.x);
          var y = Math.max(a.y, b.y);
          var width = Math.min(a.x + a.width, b.x + b.width) - x;
          var height = Math.min(a.y + a.height, b.y + b.height) - y;
          if (width > 0 && height > 0) {
            if (out) {
              out.x = x;
              out.y = y;
              out.width = width;
              out.height = height;
              return out;
            }
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          }
          if (out) {
            out.x = 0;
            out.y = 0;
            out.width = 0;
            out.height = 0;
            return out;
          }
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        function copyRect(a, out) {
          if (out) {
            out.x = a.x;
            out.y = a.y;
            out.width = a.width;
            out.height = a.height;
            return out;
          }
          return {
            x: a.x,
            y: a.y,
            width: a.width,
            height: a.height
          };
        }
        function compareRect(a, b) {
          if (a === b) {
            return true;
          }
          if (a === null || b === null) {
            return false;
          }
          return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
        }
        function boundInsideBound(bound1, bound2) {
          return bound1.x1 <= bound2.x2 && bound1.y1 <= bound2.y2 && bound1.x2 >= bound2.x1 && bound1.y2 >= bound2.y1;
        }
        function boundLargeThanBound(bound1, bound2) {
          return bound1.x1 < bound2.x1 && bound1.x2 > bound2.x2 && bound1.y1 < bound2.y1 && bound1.y2 > bound2.y2;
        }
        function isBoundPositive(bound) {
          return bound.x1 < bound.x2 && bound.y1 < bound.y2;
        }
        /**
         * Create a preload bounds from a strict bound
         *
         * @param strictBound The strict boundary of the node
         * @param boundsMargin Boundary margin to apply to the strictBound
         * @returns
         */
        function createPreloadBounds(strictBound, boundsMargin) {
          return createBound(strictBound.x1 - boundsMargin[3], strictBound.y1 - boundsMargin[0], strictBound.x2 + boundsMargin[1], strictBound.y2 + boundsMargin[2]);
        }
        function convertUrlToAbsolute(url) {
          // handle local file imports if the url isn't remote resource or data blob
          if (self.location.protocol === 'file:' && !PROTOCOL_REGEX.test(url)) {
            var path = self.location.pathname.split('/');
            path.pop();
            var _basePath = path.join('/');
            var baseUrl = self.location.protocol + '//' + _basePath;
            // check if url has a leading dot
            if (url.charAt(0) === '.') {
              url = url.slice(1);
            }
            // check if url has a leading slash
            if (url.charAt(0) === '/') {
              url = url.slice(1);
            }
            return baseUrl + '/' + url;
          }
          var absoluteUrl = new URL(url, self.location.href);
          return absoluteUrl.href;
        }
        function isBase64Image(src) {
          return src.startsWith('data:') === true;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * A 3D matrix representing a 2D graphics transformation
         *
         * @remarks
         * For convenience, entries in the first two rows can be accessed by the following
         * properties:
         * | ta tb tx |
         * | tc td ty |
         * | 0  0  1  |
         *
         * This matrix is optimized for 2D transformations and hence the last row will
         * always be considered [0, 0 ,1].
         *
         * To access a column major array for WebGL, use the {@link getFloatArr} method.
         */
        var Matrix3d = /*#__PURE__*/function () {
          /**
           * Creates a new 3x3 matrix.
           *
           * @param entries Row-major 3x3 matrix
           */
          function Matrix3d() {
            _classCallCheck(this, Matrix3d);
            _defineProperty(this, "ta", void 0);
            _defineProperty(this, "tb", void 0);
            _defineProperty(this, "tx", void 0);
            _defineProperty(this, "tc", void 0);
            _defineProperty(this, "td", void 0);
            _defineProperty(this, "ty", void 0);
            _defineProperty(this, "_floatArr", null);
            /**
             * Potential Mutation Flag
             *
             * @remarks
             * This flag is set to true whenever the matrix is potentially modified.
             * We don't waste CPU trying to identify if each operation actually modifies
             * the matrix. Instead, we set this flag to true whenever we think the matrix
             * is modified. This signals that the `floatArr` should to be updated.
             */
            _defineProperty(this, "mutation", void 0);
            this.ta = 0;
            this.tb = 0;
            this.tx = 0;
            this.tc = 0;
            this.td = 0;
            this.ty = 0;
            this.mutation = true;
          }
          /**
           * Returns a temporary matrix that can be used for calculations.
           *
           * @remarks
           * This is useful for avoiding allocations in tight loops.
           *
           * The matrix is not guaranteed to be the same between calls.
           *
           * @returns
           */
          return _createClass(Matrix3d, [{
            key: "translate",
            value: function translate(x, y) {
              this.tx = this.ta * x + this.tb * y + this.tx;
              this.ty = this.tc * x + this.td * y + this.ty;
              this.mutation = true;
              return this;
            }
          }, {
            key: "scale",
            value: function scale(sx, sy) {
              this.ta = this.ta * sx;
              this.tb = this.tb * sy;
              this.tc = this.tc * sx;
              this.td = this.td * sy;
              this.mutation = true;
              return this;
            }
          }, {
            key: "rotate",
            value: function rotate(angle) {
              if (angle === 0 || !(angle % Math.PI * 2)) {
                return this;
              }
              var cos = Math.cos(angle);
              var sin = Math.sin(angle);
              var e0 = this.ta * cos + this.tb * sin;
              var e1 = this.tb * cos - this.ta * sin;
              var e3 = this.tc * cos + this.td * sin;
              var e4 = this.td * cos - this.tc * sin;
              this.ta = e0;
              this.tb = e1;
              this.tc = e3;
              this.td = e4;
              this.mutation = true;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(other) {
              return Matrix3d.multiply(this, other, this);
            }
            /**
             * Returns the matrix as a Float32Array in column-major order.
             *
             * @remarks
             * This method is optimized to avoid unnecessary allocations. The same array
             * is returned every time this method is called, and is updated in place.
             *
             * WARNING: Use the array only for passing directly to a WebGL shader uniform
             * during a frame render. Do not modify or hold onto the array for longer than
             * a frame.
             */
          }, {
            key: "getFloatArr",
            value: function getFloatArr() {
              if (!this._floatArr) {
                this._floatArr = new Float32Array(9);
              }
              if (this.mutation) {
                this._floatArr[0] = this.ta;
                this._floatArr[1] = this.tc;
                this._floatArr[2] = 0;
                this._floatArr[3] = this.tb;
                this._floatArr[4] = this.td;
                this._floatArr[5] = 0;
                this._floatArr[6] = this.tx;
                this._floatArr[7] = this.ty;
                this._floatArr[8] = 1;
                this.mutation = false;
              }
              return this._floatArr;
            }
          }], [{
            key: "temp",
            get: function get() {
              return tempMatrix;
            }
          }, {
            key: "multiply",
            value: function multiply(a, b, out) {
              var e0 = a.ta * b.ta + a.tb * b.tc;
              var e1 = a.ta * b.tb + a.tb * b.td;
              var e2 = a.ta * b.tx + a.tb * b.ty + a.tx;
              var e3 = a.tc * b.ta + a.td * b.tc;
              var e4 = a.tc * b.tb + a.td * b.td;
              var e5 = a.tc * b.tx + a.td * b.ty + a.ty;
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = e0;
              out.tb = e1;
              out.tx = e2;
              out.tc = e3;
              out.td = e4;
              out.ty = e5;
              out.mutation = true;
              return out;
            }
          }, {
            key: "identity",
            value: function identity(out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = 1;
              out.tb = 0;
              out.tx = 0;
              out.tc = 0;
              out.td = 1;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "translate",
            value: function translate(x, y, out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = 1;
              out.tb = 0;
              out.tx = x;
              out.tc = 0;
              out.td = 1;
              out.ty = y;
              out.mutation = true;
              return out;
            }
          }, {
            key: "scale",
            value: function scale(sx, sy, out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = sx;
              out.tb = 0;
              out.tx = 0;
              out.tc = 0;
              out.td = sy;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "rotate",
            value: function rotate(angle, out) {
              var cos = Math.cos(angle);
              var sin = Math.sin(angle);
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = cos;
              out.tb = -sin;
              out.tx = 0;
              out.tc = sin;
              out.td = cos;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "copy",
            value: function copy(src, dst) {
              if (!dst) {
                dst = new Matrix3d();
              }
              dst.ta = src.ta;
              dst.tc = src.tc;
              dst.tb = src.tb;
              dst.td = src.td;
              dst.tx = src.tx;
              dst.ty = src.ty;
              dst.mutation = true;
              return dst;
            }
          }]);
        }();
        var tempMatrix = new Matrix3d();
        var rx1 = 0;
        var rx2 = 2;
        var rx3 = 4;
        var rx4 = 6;
        var ry1 = 1;
        var ry2 = 3;
        var ry3 = 5;
        var ry4 = 7;
        var RenderCoords = /*#__PURE__*/function () {
          function RenderCoords(entries) {
            _classCallCheck(this, RenderCoords);
            _defineProperty(this, "data", void 0);
            this.data = new Float32Array(8);
            if (entries) {
              this.data[rx1] = entries[rx1];
              this.data[rx2] = entries[rx2];
              this.data[rx3] = entries[rx3];
              this.data[rx4] = entries[rx4];
              this.data[ry1] = entries[ry1];
              this.data[ry2] = entries[ry2];
              this.data[ry3] = entries[ry3];
              this.data[ry4] = entries[ry4];
            }
          }
          return _createClass(RenderCoords, [{
            key: "x1",
            get: function get() {
              return this.data[rx1];
            }
          }, {
            key: "x2",
            get: function get() {
              return this.data[rx2];
            }
          }, {
            key: "x3",
            get: function get() {
              return this.data[rx3];
            }
          }, {
            key: "x4",
            get: function get() {
              return this.data[rx4];
            }
          }, {
            key: "y1",
            get: function get() {
              return this.data[ry1];
            }
          }, {
            key: "y2",
            get: function get() {
              return this.data[ry2];
            }
          }, {
            key: "y3",
            get: function get() {
              return this.data[ry3];
            }
          }, {
            key: "y4",
            get: function get() {
              return this.data[ry4];
            }
          }], [{
            key: "translate",
            value: function translate(x1, y1, x2, y2, x3, y3, x4, y4, out) {
              if (!out) {
                out = new RenderCoords();
              }
              out.data[rx1] = x1;
              out.data[rx2] = x2;
              out.data[rx3] = x3;
              out.data[rx4] = x4;
              out.data[ry1] = y1;
              out.data[ry2] = y2;
              out.data[ry3] = y3;
              out.data[ry4] = y4;
              return out;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Core Utility Functions
         *
         * @module
         */
        var getTimingBezier = function getTimingBezier(a, b, c, d) {
          var xc = 3.0 * a;
          var xb = 3.0 * (c - a) - xc;
          var xa = 1.0 - xc - xb;
          var yc = 3.0 * b;
          var yb = 3.0 * (d - b) - yc;
          var ya = 1.0 - yc - yb;
          return function (time) {
            if (time >= 1.0) {
              return 1;
            }
            if (time <= 0) {
              return 0;
            }
            var t = 0.5,
              cbx,
              cbxd,
              dx;
            for (var it = 0; it < 20; it++) {
              cbx = t * (t * (t * xa + xb) + xc);
              dx = time - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                return t * (t * (t * ya + yb) + yc);
              }
              // Cubic bezier derivative.
              cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
              if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
              }
              t += dx / cbxd;
            }
            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            var minT = 0;
            var maxT = 1;
            for (var _it = 0; _it < 20; _it++) {
              t = 0.5 * (minT + maxT);
              cbx = t * (t * (t * xa + xb) + xc);
              dx = time - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc);
              }
              if (dx < 0) {
                maxT = t;
              } else {
                minT = t;
              }
            }
          };
        };
        var timingMapping = {};
        var timingLookup = {
          ease: [0.25, 0.1, 0.25, 1.0],
          'ease-in': [0.42, 0, 1.0, 1.0],
          'ease-out': [0, 0, 0.58, 1.0],
          'ease-in-out': [0.42, 0, 0.58, 1.0],
          'ease-in-sine': [0.12, 0, 0.39, 0],
          'ease-out-sine': [0.12, 0, 0.39, 0],
          'ease-in-out-sine': [0.37, 0, 0.63, 1],
          'ease-in-cubic': [0.32, 0, 0.67, 0],
          'ease-out-cubic': [0.33, 1, 0.68, 1],
          'ease-in-out-cubic': [0.65, 0, 0.35, 1],
          'ease-in-circ': [0.55, 0, 1, 0.45],
          'ease-out-circ': [0, 0.55, 0.45, 1],
          'ease-in-out-circ': [0.85, 0, 0.15, 1],
          'ease-in-back': [0.36, 0, 0.66, -0.56],
          'ease-out-back': [0.34, 1.56, 0.64, 1],
          'ease-in-out-back': [0.68, -0.6, 0.32, 1.6]
        };
        var defaultTiming = function defaultTiming(t) {
          return t;
        };
        var parseCubicBezier = function parseCubicBezier(str) {
          //cubic-bezier(0.84, 0.52, 0.56, 0.6)
          var regex = /-?\d*\.?\d+/g;
          var match = str.match(regex);
          if (match) {
            var _match = _slicedToArray(match, 4),
              num1 = _match[0],
              num2 = _match[1],
              num3 = _match[2],
              num4 = _match[3];
            var a = parseFloat(num1 || '0.42');
            var b = parseFloat(num2 || '0');
            var c = parseFloat(num3 || '1');
            var d = parseFloat(num4 || '1');
            var timing = getTimingBezier(a, b, c, d);
            timingMapping[str] = timing;
            return timing;
          }
          // parse failed, return linear
          console.warn('Unknown cubic-bezier timing: ' + str);
          return defaultTiming;
        };
        var getTimingFunction = function getTimingFunction(str) {
          if (str === 'linear') {
            return defaultTiming;
          }
          if (timingMapping[str] !== undefined) {
            return timingMapping[str] || defaultTiming;
          }
          if (str === 'step-start') {
            return function () {
              return 1;
            };
          }
          if (str === 'step-end') {
            return function (time) {
              return time === 1 ? 1 : 0;
            };
          }
          var lookup = timingLookup[str];
          if (lookup !== undefined) {
            var _lookup = _slicedToArray(lookup, 4),
              a = _lookup[0],
              b = _lookup[1],
              c = _lookup[2],
              d = _lookup[3];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - TS doesn't understand that we've checked for undefined
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            var timing = getTimingBezier(a, b, c, d);
            timingMapping[str] = timing;
            return timing;
          }
          if (str.startsWith('cubic-bezier')) {
            return parseCubicBezier(str);
          }
          console.warn('Unknown timing function: ' + str);
          return defaultTiming;
        };
        /**
         * Convert bytes to string of megabytes with 2 decimal points
         *
         * @param bytes
         * @returns
         */
        function bytesToMb$1(bytes) {
          return (bytes / 1024 / 1024).toFixed(2);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreAnimation = /*#__PURE__*/function (_EventEmitter3) {
          function CoreAnimation(node, props, settings) {
            var _settings$delay, _settings$duration, _settings$loop, _settings$repeat, _settings$repeatDelay, _settings$stopMethod;
            var _this4;
            _classCallCheck(this, CoreAnimation);
            _this4 = _callSuper(this, CoreAnimation);
            _defineProperty(_this4, "node", void 0);
            _defineProperty(_this4, "props", void 0);
            _defineProperty(_this4, "settings", void 0);
            _defineProperty(_this4, "progress", 0);
            _defineProperty(_this4, "delayFor", 0);
            _defineProperty(_this4, "delay", 0);
            _defineProperty(_this4, "timingFunction", void 0);
            _defineProperty(_this4, "propValuesMap", {});
            _defineProperty(_this4, "dynPropValuesMap", undefined);
            _this4.node = node;
            _this4.props = props;
            for (var _key2 in props) {
              if (_key2 !== 'shaderProps') {
                if (_this4.propValuesMap['props'] === undefined) {
                  _this4.propValuesMap['props'] = {};
                }
                _this4.propValuesMap['props'][_key2] = {
                  start: node[_key2] || 0,
                  target: props[_key2]
                };
              } else if (node.shader.type !== 'DynamicShader') {
                _this4.propValuesMap['shaderProps'] = {};
                for (var _key3 in props.shaderProps) {
                  _this4.propValuesMap['shaderProps'][_key3] = {
                    start: node.shader.props[_key3],
                    target: props.shaderProps[_key3]
                  };
                }
              } else {
                var shaderPropKeys = Object.keys(props.shaderProps);
                var spLength = shaderPropKeys.length;
                _this4.dynPropValuesMap = {};
                for (var j = 0; j < spLength; j++) {
                  var effectName = shaderPropKeys[j];
                  var _effect = props.shaderProps[effectName];
                  _this4.dynPropValuesMap[effectName] = {};
                  var effectProps = Object.entries(_effect);
                  var eLength = effectProps.length;
                  for (var k = 0; k < eLength; k++) {
                    var _effectProps$k = _slicedToArray(effectProps[k], 2),
                      _key4 = _effectProps$k[0],
                      value = _effectProps$k[1];
                    _this4.dynPropValuesMap[effectName][_key4] = {
                      start: node.shader.props[effectName][_key4],
                      target: value
                    };
                  }
                }
              }
            }
            var easing = settings.easing || 'linear';
            var delay = (_settings$delay = settings.delay) !== null && _settings$delay !== void 0 ? _settings$delay : 0;
            _this4.settings = {
              duration: (_settings$duration = settings.duration) !== null && _settings$duration !== void 0 ? _settings$duration : 0,
              delay: delay,
              easing: easing,
              loop: (_settings$loop = settings.loop) !== null && _settings$loop !== void 0 ? _settings$loop : false,
              repeat: (_settings$repeat = settings.repeat) !== null && _settings$repeat !== void 0 ? _settings$repeat : 0,
              repeatDelay: (_settings$repeatDelay = settings.repeatDelay) !== null && _settings$repeatDelay !== void 0 ? _settings$repeatDelay : 0,
              stopMethod: (_settings$stopMethod = settings.stopMethod) !== null && _settings$stopMethod !== void 0 ? _settings$stopMethod : false
            };
            _this4.timingFunction = getTimingFunction(easing);
            _this4.delayFor = delay;
            _this4.delay = delay;
            return _this4;
          }
          _inherits(CoreAnimation, _EventEmitter3);
          return _createClass(CoreAnimation, [{
            key: "reset",
            value: function reset() {
              this.progress = 0;
              this.delayFor = this.settings.delay || 0;
              this.update(0);
            }
          }, {
            key: "restoreValues",
            value: function restoreValues(target, valueMap) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i = _slicedToArray(entries[i], 2),
                  _key5 = _entries$i[0],
                  value = _entries$i[1];
                target[_key5] = value.start;
              }
            }
          }, {
            key: "restore",
            value: function restore() {
              this.reset();
              if (this.propValuesMap['props'] !== undefined) {
                this.restoreValues(this.node, this.propValuesMap['props']);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.restoreValues(this.node.shader.props, this.propValuesMap['shaderProps']);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var _key6 = dynEntries[i];
                    this.restoreValues(this.node.shader.props[_key6], this.dynPropValuesMap[_key6]);
                  }
                }
              }
            }
          }, {
            key: "reverseValues",
            value: function reverseValues(valueMap) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i2 = _slicedToArray(entries[i], 2),
                  _key7 = _entries$i2[0],
                  value = _entries$i2[1];
                valueMap[_key7] = {
                  start: value.target,
                  target: value.start
                };
              }
            }
          }, {
            key: "reverse",
            value: function reverse() {
              this.progress = 0;
              if (this.propValuesMap['props'] !== undefined) {
                this.reverseValues(this.propValuesMap['props']);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.reverseValues(this.propValuesMap['shaderProps']);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var _key8 = dynEntries[i];
                    this.reverseValues(this.dynPropValuesMap[_key8]);
                  }
                }
              }
              // restore stop method if we are not looping
              if (!this.settings.loop) {
                this.settings.stopMethod = false;
              }
            }
          }, {
            key: "applyEasing",
            value: function applyEasing(p, s, e) {
              return (this.timingFunction(p) || p) * (e - s) + s;
            }
          }, {
            key: "updateValue",
            value: function updateValue(propName, propValue, startValue, easing) {
              if (this.progress === 1) {
                return propValue;
              }
              if (this.progress === 0) {
                return startValue;
              }
              var endValue = propValue;
              if (propName.indexOf('color') !== -1) {
                if (startValue === endValue) {
                  return startValue;
                }
                if (easing) {
                  var easingProgressValue = this.timingFunction(this.progress) || this.progress;
                  return mergeColorProgress(startValue, endValue, easingProgressValue);
                }
                return mergeColorProgress(startValue, endValue, this.progress);
              }
              if (easing) {
                return this.applyEasing(this.progress, startValue, endValue);
              }
              return startValue + (endValue - startValue) * this.progress;
            }
          }, {
            key: "updateValues",
            value: function updateValues(target, valueMap, easing) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i3 = _slicedToArray(entries[i], 2),
                  _key9 = _entries$i3[0],
                  value = _entries$i3[1];
                target[_key9] = this.updateValue(_key9, value.target, value.start, easing);
              }
            }
          }, {
            key: "update",
            value: function update(dt) {
              var _this$settings = this.settings,
                duration = _this$settings.duration,
                loop = _this$settings.loop,
                easing = _this$settings.easing,
                stopMethod = _this$settings.stopMethod;
              var delayFor = this.delayFor;
              if (duration === 0 && delayFor === 0) {
                this.emit('finished', {});
                return;
              }
              if (this.delayFor > 0) {
                this.delayFor -= dt;
                if (this.delayFor >= 0) {
                  // Either no or more delay left. Exit.
                  return;
                } else {
                  // We went beyond the delay time, add it back to dt so we can continue
                  // with the animation.
                  dt = -this.delayFor;
                  this.delayFor = 0;
                }
              }
              if (duration === 0) {
                // No duration, we are done.
                this.emit('finished', {});
                return;
              }
              if (this.progress === 0) {
                // Progress is 0, we are starting the post-delay part of the animation.
                this.emit('animating', {});
              }
              this.progress += dt / duration;
              if (this.progress > 1) {
                this.progress = loop ? 0 : 1;
                this.delayFor = this.delay;
                if (stopMethod) {
                  // If there's a stop method emit finished so the stop method can be applied.
                  // TODO: We should probably reevaluate how stopMethod is implemented as currently
                  // stop method 'reset' does not work when looping.
                  this.emit('finished', {});
                  return;
                }
              }
              if (this.propValuesMap['props'] !== undefined) {
                this.updateValues(this.node, this.propValuesMap['props'], easing);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.updateValues(this.node.shader.props, this.propValuesMap['shaderProps'], easing);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var _key10 = dynEntries[i];
                    this.updateValues(this.node.shader.props[_key10], this.dynPropValuesMap[_key10], easing);
                  }
                }
              }
              if (this.progress < 1) {
                this.emit('tick', {
                  progress: this.progress
                });
              }
              if (this.progress === 1) {
                this.emit('finished', {});
              }
            }
          }]);
        }(EventEmitter);
        /* eslint-disable @typescript-eslint/unbound-method */
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreAnimationController = /*#__PURE__*/function (_EventEmitter4) {
          function CoreAnimationController(manager, animation) {
            var _this5;
            _classCallCheck(this, CoreAnimationController);
            _this5 = _callSuper(this, CoreAnimationController);
            _defineProperty(_this5, "manager", void 0);
            _defineProperty(_this5, "animation", void 0);
            _defineProperty(_this5, "stoppedPromise", void 0);
            /**
             * If this is null, then the animation is in a finished / stopped state.
             */
            _defineProperty(_this5, "stoppedResolve", null);
            _defineProperty(_this5, "state", void 0);
            _this5.manager = manager;
            _this5.animation = animation;
            _this5.state = 'stopped';
            // Initial stopped promise is resolved (since the animation is stopped)
            _this5.stoppedPromise = Promise.resolve();
            // Bind event handlers
            _this5.onAnimating = _this5.onAnimating.bind(_this5);
            _this5.onFinished = _this5.onFinished.bind(_this5);
            _this5.onTick = _this5.onTick.bind(_this5);
            return _this5;
          }
          _inherits(CoreAnimationController, _EventEmitter4);
          return _createClass(CoreAnimationController, [{
            key: "start",
            value: function start() {
              if (this.state !== 'running' && this.state !== 'scheduled') {
                this.makeStoppedPromise();
                this.registerAnimation();
                this.state = 'scheduled';
              }
              return this;
            }
          }, {
            key: "stop",
            value: function stop() {
              this.unregisterAnimation();
              if (this.stoppedResolve !== null) {
                this.stoppedResolve();
                this.stoppedResolve = null;
                this.emit('stopped', this);
              }
              this.animation.reset();
              this.state = 'stopped';
              return this;
            }
          }, {
            key: "pause",
            value: function pause() {
              this.unregisterAnimation();
              this.state = 'paused';
              return this;
            }
          }, {
            key: "restore",
            value: function restore() {
              this.stoppedResolve = null;
              this.animation.restore();
              return this;
            }
          }, {
            key: "waitUntilStopped",
            value: function waitUntilStopped() {
              return this.stoppedPromise;
            }
          }, {
            key: "registerAnimation",
            value: function registerAnimation() {
              // Hook up event listeners
              this.animation.once('finished', this.onFinished);
              this.animation.on('animating', this.onAnimating);
              this.animation.on('tick', this.onTick);
              // Then register the animation
              this.manager.registerAnimation(this.animation);
            }
          }, {
            key: "unregisterAnimation",
            value: function unregisterAnimation() {
              // First unregister the animation
              this.manager.unregisterAnimation(this.animation);
              // Then unhook event listeners
              this.animation.off('finished', this.onFinished);
              this.animation.off('animating', this.onAnimating);
              this.animation.off('tick', this.onTick);
            }
          }, {
            key: "makeStoppedPromise",
            value: function makeStoppedPromise() {
              var _this6 = this;
              if (this.stoppedResolve === null) {
                this.stoppedPromise = new Promise(function (resolve) {
                  _this6.stoppedResolve = resolve;
                });
              }
            }
          }, {
            key: "onFinished",
            value: function onFinished() {
              assertTruthy(this.stoppedResolve);
              // If the animation is looping, then we need to restart it.
              var _this$animation$setti = this.animation.settings,
                loop = _this$animation$setti.loop,
                stopMethod = _this$animation$setti.stopMethod;
              if (stopMethod === 'reverse') {
                this.animation.once('finished', this.onFinished);
                this.animation.reverse();
                return;
              }
              if (loop) {
                return;
              }
              // unregister animation
              this.unregisterAnimation();
              // resolve promise
              this.stoppedResolve();
              this.stoppedResolve = null;
              this.emit('stopped', this);
              this.state = 'stopped';
            }
          }, {
            key: "onAnimating",
            value: function onAnimating() {
              this.state = 'running';
              this.emit('animating', this);
            }
          }, {
            key: "onTick",
            value: function onTick(_animation, data) {
              this.emit('tick', data);
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreNodeRenderState;
        (function (CoreNodeRenderState) {
          CoreNodeRenderState[CoreNodeRenderState["Init"] = 0] = "Init";
          CoreNodeRenderState[CoreNodeRenderState["OutOfBounds"] = 2] = "OutOfBounds";
          CoreNodeRenderState[CoreNodeRenderState["InBounds"] = 4] = "InBounds";
          CoreNodeRenderState[CoreNodeRenderState["InViewport"] = 8] = "InViewport";
        })(CoreNodeRenderState || (CoreNodeRenderState = {}));
        var CoreNodeRenderStateMap = new Map();
        CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, 'init');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, 'outOfBounds');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, 'inBounds');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, 'inViewport');
        var UpdateType;
        (function (UpdateType) {
          /**
           * Child updates
           */
          UpdateType[UpdateType["Children"] = 1] = "Children";
          /**
           * Scale/Rotate transform update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `scaleRotateTransform`
           */
          UpdateType[UpdateType["ScaleRotate"] = 2] = "ScaleRotate";
          /**
           * Translate transform update (x/y/width/height/pivot/mount)
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `localTransform`
           */
          UpdateType[UpdateType["Local"] = 4] = "Local";
          /**
           * Global Transform update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `globalTransform`
           * - `renderCoords`
           * - `renderBound`
           */
          UpdateType[UpdateType["Global"] = 8] = "Global";
          /**
           * Clipping rect update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `clippingRect`
           */
          UpdateType[UpdateType["Clipping"] = 16] = "Clipping";
          /**
           * Calculated ZIndex update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `calcZIndex`
           */
          UpdateType[UpdateType["CalculatedZIndex"] = 32] = "CalculatedZIndex";
          /**
           * Z-Index Sorted Children update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `children` (sorts children by their `calcZIndex`)
           */
          UpdateType[UpdateType["ZIndexSortedChildren"] = 64] = "ZIndexSortedChildren";
          /**
           * Premultiplied Colors update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `premultipliedColorTl`
           * - `premultipliedColorTr`
           * - `premultipliedColorBl`
           * - `premultipliedColorBr`
           */
          UpdateType[UpdateType["PremultipliedColors"] = 128] = "PremultipliedColors";
          /**
           * World Alpha update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `worldAlpha` = `parent.worldAlpha` * `alpha`
           */
          UpdateType[UpdateType["WorldAlpha"] = 256] = "WorldAlpha";
          /**
           * Render State update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `renderState`
           */
          UpdateType[UpdateType["RenderState"] = 512] = "RenderState";
          /**
           * Is Renderable update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `isRenderable`
           */
          UpdateType[UpdateType["IsRenderable"] = 1024] = "IsRenderable";
          /**
           * Render Texture update
           */
          UpdateType[UpdateType["RenderTexture"] = 2048] = "RenderTexture";
          /**
           * Track if parent has render texture
           */
          UpdateType[UpdateType["ParentRenderTexture"] = 4096] = "ParentRenderTexture";
          /**
           * Render Bounds update
           */
          UpdateType[UpdateType["RenderBounds"] = 8192] = "RenderBounds";
          /**
           * None
           */
          UpdateType[UpdateType["None"] = 0] = "None";
          /**
           * All
           */
          UpdateType[UpdateType["All"] = 14335] = "All";
        })(UpdateType || (UpdateType = {}));
        /**
         * A visual Node in the Renderer scene graph.
         *
         * @remarks
         * CoreNode is an internally used class that represents a Renderer Node in the
         * scene graph. See INode.ts for the public APIs exposed to Renderer users
         * that include generic types for Shaders.
         */
        var CoreNode = /*#__PURE__*/function (_EventEmitter5) {
          function CoreNode(stage, props) {
            var _this7;
            _classCallCheck(this, CoreNode);
            _this7 = _callSuper(this, CoreNode);
            _defineProperty(_this7, "stage", void 0);
            _defineProperty(_this7, "children", []);
            _defineProperty(_this7, "_id", getNewId());
            _defineProperty(_this7, "props", void 0);
            _defineProperty(_this7, "updateType", UpdateType.All);
            _defineProperty(_this7, "childUpdateType", UpdateType.None);
            _defineProperty(_this7, "globalTransform", void 0);
            _defineProperty(_this7, "scaleRotateTransform", void 0);
            _defineProperty(_this7, "localTransform", void 0);
            _defineProperty(_this7, "sceneGlobalTransform", void 0);
            _defineProperty(_this7, "renderCoords", void 0);
            _defineProperty(_this7, "sceneRenderCoords", void 0);
            _defineProperty(_this7, "renderBound", void 0);
            _defineProperty(_this7, "strictBound", void 0);
            _defineProperty(_this7, "preloadBound", void 0);
            _defineProperty(_this7, "clippingRect", {
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              valid: false
            });
            _defineProperty(_this7, "isRenderable", false);
            _defineProperty(_this7, "renderState", CoreNodeRenderState.Init);
            _defineProperty(_this7, "worldAlpha", 1);
            _defineProperty(_this7, "premultipliedColorTl", 0);
            _defineProperty(_this7, "premultipliedColorTr", 0);
            _defineProperty(_this7, "premultipliedColorBl", 0);
            _defineProperty(_this7, "premultipliedColorBr", 0);
            _defineProperty(_this7, "calcZIndex", 0);
            _defineProperty(_this7, "hasRTTupdates", false);
            _defineProperty(_this7, "parentHasRenderTexture", false);
            _defineProperty(_this7, "rttParent", null);
            _defineProperty(_this7, "onTextureLoaded", function (_, dimensions) {
              var _this7$props$textureO;
              _this7.autosizeNode(dimensions);
              _this7.setUpdateType(UpdateType.IsRenderable);
              // Texture was loaded. In case the RAF loop has already stopped, we request
              // a render to ensure the texture is rendered.
              _this7.stage.requestRender();
              // If parent has a render texture, flag that we need to update
              if (_this7.parentHasRenderTexture) {
                _this7.notifyParentRTTOfUpdate();
              }
              // ignore 1x1 pixel textures
              if (dimensions.width > 1 && dimensions.height > 1) {
                _this7.emit('loaded', {
                  type: 'texture',
                  dimensions: dimensions
                });
              }
              // Trigger a local update if the texture is loaded and the resizeMode is 'contain'
              if (((_this7$props$textureO = _this7.props.textureOptions) === null || _this7$props$textureO === void 0 || (_this7$props$textureO = _this7$props$textureO.resizeMode) === null || _this7$props$textureO === void 0 ? void 0 : _this7$props$textureO.type) === 'contain') {
                _this7.setUpdateType(UpdateType.Local);
              }
            });
            _defineProperty(_this7, "onTextureFailed", function (_, error) {
              _this7.setUpdateType(UpdateType.IsRenderable);
              // If parent has a render texture, flag that we need to update
              if (_this7.parentHasRenderTexture) {
                _this7.notifyParentRTTOfUpdate();
              }
              _this7.emit('failed', {
                type: 'texture',
                error: error
              });
            });
            _defineProperty(_this7, "onTextureFreed", function () {
              _this7.setUpdateType(UpdateType.IsRenderable);
              // If parent has a render texture, flag that we need to update
              if (_this7.parentHasRenderTexture) {
                _this7.notifyParentRTTOfUpdate();
              }
              _this7.emit('freed', {
                type: 'texture'
              });
            });
            _this7.stage = stage;
            _this7.props = _objectSpread(_objectSpread({}, props), {}, {
              parent: null,
              texture: null,
              src: null,
              rtt: false
            });
            // Assign props to instance
            _this7.parent = props.parent;
            _this7.texture = props.texture;
            _this7.src = props.src;
            _this7.rtt = props.rtt;
            if (props.boundsMargin) {
              _this7.boundsMargin = Array.isArray(props.boundsMargin) ? props.boundsMargin : [props.boundsMargin, props.boundsMargin, props.boundsMargin, props.boundsMargin];
            }
            _this7.setUpdateType(UpdateType.ScaleRotate | UpdateType.Local | UpdateType.RenderBounds | UpdateType.RenderState);
            // if the default texture isn't loaded yet, wait for it to load
            // this only happens when the node is created before the stage is ready
            if (_this7.stage.defaultTexture && _this7.stage.defaultTexture.state !== 'loaded') {
              _this7.stage.defaultTexture.once('loaded', function () {
                _this7.setUpdateType(UpdateType.IsRenderable);
              });
            }
            return _this7;
          }
          //#region Textures
          _inherits(CoreNode, _EventEmitter5);
          return _createClass(CoreNode, [{
            key: "loadTexture",
            value: function loadTexture() {
              var _this8 = this;
              var texture = this.props.texture;
              // If texture is already loaded / failed, trigger loaded event manually
              // so that users get a consistent event experience.
              // We do this in a microtask to allow listeners to be attached in the same
              // synchronous task after calling loadTexture()
              queueMicrotask(function () {
                var _this8$props$textureO, _this8$props$textureO2;
                if (_this8.textureOptions.preload === true) {
                  _this8.stage.txManager.loadTexture(texture);
                }
                texture.preventCleanup = (_this8$props$textureO = (_this8$props$textureO2 = _this8.props.textureOptions) === null || _this8$props$textureO2 === void 0 ? void 0 : _this8$props$textureO2.preventCleanup) !== null && _this8$props$textureO !== void 0 ? _this8$props$textureO : false;
                texture.on('loaded', _this8.onTextureLoaded);
                texture.on('failed', _this8.onTextureFailed);
                texture.on('freed', _this8.onTextureFreed);
                // If the parent is a render texture, the initial texture status
                // will be set to freed until the texture is processed by the
                // Render RTT nodes. So we only need to listen fo changes and
                // no need to check the texture.state until we restructure how
                // textures are being processed.
                if (_this8.parentHasRenderTexture) {
                  _this8.notifyParentRTTOfUpdate();
                  return;
                }
                if (texture.state === 'loaded') {
                  assertTruthy(texture.dimensions);
                  _this8.onTextureLoaded(texture, texture.dimensions);
                } else if (texture.state === 'failed') {
                  assertTruthy(texture.error);
                  _this8.onTextureFailed(texture, texture.error);
                } else if (texture.state === 'freed') {
                  _this8.onTextureFreed(texture);
                }
              });
            }
          }, {
            key: "unloadTexture",
            value: function unloadTexture() {
              if (this.texture !== null) {
                this.texture.off('loaded', this.onTextureLoaded);
                this.texture.off('failed', this.onTextureFailed);
                this.texture.off('freed', this.onTextureFreed);
                this.texture.setRenderableOwner(this, false);
              }
            }
          }, {
            key: "autosizeNode",
            value: function autosizeNode(dimensions) {
              if (this.autosize) {
                this.width = dimensions.width;
                this.height = dimensions.height;
              }
            }
          }, {
            key: "setUpdateType",
            value:
            //#endregion Textures
            /**
             * Change types types is used to determine the scope of the changes being applied
             *
             * @remarks
             * See {@link UpdateType} for more information on each type
             *
             * @param type
             */
            function setUpdateType(type) {
              this.updateType |= type;
              var parent = this.props.parent;
              if (!parent) return;
              if ((parent.updateType & UpdateType.Children) === 0) {
                // Inform the parent if it doesnt already have a child update
                parent.setUpdateType(UpdateType.Children);
              }
            }
          }, {
            key: "sortChildren",
            value: function sortChildren() {
              this.children.sort(function (a, b) {
                return a.calcZIndex - b.calcZIndex;
              });
            }
          }, {
            key: "updateScaleRotateTransform",
            value: function updateScaleRotateTransform() {
              var _this$props = this.props,
                rotation = _this$props.rotation,
                scaleX = _this$props.scaleX,
                scaleY = _this$props.scaleY;
              // optimize simple translation cases
              if (rotation === 0 && scaleX === 1 && scaleY === 1) {
                this.scaleRotateTransform = undefined;
                return;
              }
              this.scaleRotateTransform = Matrix3d.rotate(rotation, this.scaleRotateTransform).scale(scaleX, scaleY);
            }
          }, {
            key: "updateLocalTransform",
            value: function updateLocalTransform() {
              var _this$props$textureOp;
              var _this$props2 = this.props,
                x = _this$props2.x,
                y = _this$props2.y,
                width = _this$props2.width,
                height = _this$props2.height;
              var mountTranslateX = this.props.mountX * width;
              var mountTranslateY = this.props.mountY * height;
              if (this.scaleRotateTransform) {
                var pivotTranslateX = this.props.pivotX * width;
                var pivotTranslateY = this.props.pivotY * height;
                this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(this.scaleRotateTransform).translate(-pivotTranslateX, -pivotTranslateY);
              } else {
                this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
              }
              // Handle 'contain' resize mode
              var texture = this.props.texture;
              if (texture && texture.dimensions && ((_this$props$textureOp = this.props.textureOptions) === null || _this$props$textureOp === void 0 || (_this$props$textureOp = _this$props$textureOp.resizeMode) === null || _this$props$textureOp === void 0 ? void 0 : _this$props$textureOp.type) === 'contain') {
                var resizeModeScaleX = 1;
                var resizeModeScaleY = 1;
                var extraX = 0;
                var extraY = 0;
                var _texture$dimensions = texture.dimensions,
                  tw = _texture$dimensions.width,
                  th = _texture$dimensions.height;
                var txAspectRatio = tw / th;
                var nodeAspectRatio = width / height;
                if (txAspectRatio > nodeAspectRatio) {
                  // Texture is wider than node
                  // Center the node vertically (shift down by extraY)
                  // Scale the node vertically to maintain original aspect ratio
                  var scaleX = width / tw;
                  var scaledTxHeight = th * scaleX;
                  extraY = (height - scaledTxHeight) / 2;
                  resizeModeScaleY = scaledTxHeight / height;
                } else {
                  // Texture is taller than node (or equal)
                  // Center the node horizontally (shift right by extraX)
                  // Scale the node horizontally to maintain original aspect ratio
                  var scaleY = height / th;
                  var scaledTxWidth = tw * scaleY;
                  extraX = (width - scaledTxWidth) / 2;
                  resizeModeScaleX = scaledTxWidth / width;
                }
                // Apply the extra translation and scale to the local transform
                this.localTransform.translate(extraX, extraY).scale(resizeModeScaleX, resizeModeScaleY);
              }
              this.setUpdateType(UpdateType.Global);
            }
            /**
             * @todo: test for correct calculation flag
             * @param delta
             */
          }, {
            key: "update",
            value: function update(delta, parentClippingRect) {
              if (this.updateType & UpdateType.ScaleRotate) {
                this.updateScaleRotateTransform();
                this.setUpdateType(UpdateType.Local);
              }
              if (this.updateType & UpdateType.Local) {
                this.updateLocalTransform();
                this.setUpdateType(UpdateType.Global);
              }
              var parent = this.props.parent;
              var renderState = null;
              // Handle specific RTT updates at this node level
              if (this.updateType & UpdateType.RenderTexture && this.rtt) {
                this.hasRTTupdates = true;
              }
              if (this.updateType & UpdateType.Global) {
                assertTruthy(this.localTransform);
                if (this.parentHasRenderTexture === true && (parent === null || parent === void 0 ? void 0 : parent.rtt) === true) {
                  // we are at the start of the RTT chain, so we need to reset the globalTransform
                  // for correct RTT rendering
                  this.globalTransform = Matrix3d.identity();
                  // Maintain a full scene global transform for bounds detection
                  this.sceneGlobalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || Matrix3d.identity()).multiply(this.localTransform);
                } else if (this.parentHasRenderTexture === true && (parent === null || parent === void 0 ? void 0 : parent.rtt) === false) {
                  // we're part of an RTT chain but our parent is not the main RTT node
                  // so we need to propogate the sceneGlobalTransform of the parent
                  // to maintain a full scene global transform for bounds detection
                  this.sceneGlobalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.sceneGlobalTransform) || this.localTransform).multiply(this.localTransform);
                  this.globalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
                } else {
                  this.globalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
                }
                if (parent !== null) {
                  this.globalTransform.multiply(this.localTransform);
                }
                this.calculateRenderCoords();
                this.updateBoundingRect();
                this.setUpdateType(UpdateType.RenderState | UpdateType.Children);
                this.childUpdateType |= UpdateType.Global;
                if (this.clipping === true) {
                  this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds);
                  this.childUpdateType |= UpdateType.RenderBounds;
                }
              }
              if (this.updateType & UpdateType.RenderBounds) {
                this.createRenderBounds();
                this.setUpdateType(UpdateType.RenderState);
                this.setUpdateType(UpdateType.Children);
                this.childUpdateType |= UpdateType.RenderBounds;
              }
              if (this.updateType & UpdateType.RenderState) {
                renderState = this.checkRenderBounds();
                this.setUpdateType(UpdateType.IsRenderable);
                // if we're not going out of bounds, update the render state
                // this is done so the update loop can finish before we mark a node
                // as out of bounds
                if (renderState !== CoreNodeRenderState.OutOfBounds) {
                  this.updateRenderState(renderState);
                }
              }
              if (this.updateType & UpdateType.WorldAlpha) {
                if (parent) {
                  this.worldAlpha = parent.worldAlpha * this.props.alpha;
                } else {
                  this.worldAlpha = this.props.alpha;
                }
                this.setUpdateType(UpdateType.Children | UpdateType.PremultipliedColors | UpdateType.IsRenderable);
                this.childUpdateType |= UpdateType.WorldAlpha;
              }
              if (this.updateType & UpdateType.IsRenderable) {
                this.updateIsRenderable();
              }
              if (this.updateType & UpdateType.Clipping) {
                this.calculateClippingRect(parentClippingRect);
                this.setUpdateType(UpdateType.Children);
                this.childUpdateType |= UpdateType.Clipping;
                this.childUpdateType |= UpdateType.RenderBounds;
              }
              if (this.updateType & UpdateType.PremultipliedColors) {
                this.premultipliedColorTl = mergeColorAlphaPremultiplied(this.props.colorTl, this.worldAlpha, true);
                // If all the colors are the same just sent them all to the same value
                if (this.props.colorTl === this.props.colorTr && this.props.colorBl === this.props.colorBr && this.props.colorTl === this.props.colorBl) {
                  this.premultipliedColorTr = this.premultipliedColorBl = this.premultipliedColorBr = this.premultipliedColorTl;
                } else {
                  this.premultipliedColorTr = mergeColorAlphaPremultiplied(this.props.colorTr, this.worldAlpha, true);
                  this.premultipliedColorBl = mergeColorAlphaPremultiplied(this.props.colorBl, this.worldAlpha, true);
                  this.premultipliedColorBr = mergeColorAlphaPremultiplied(this.props.colorBr, this.worldAlpha, true);
                }
              }
              // No need to update zIndex if there is no parent
              if (parent !== null && this.updateType & UpdateType.CalculatedZIndex) {
                this.calculateZIndex();
                // Tell parent to re-sort children
                parent.setUpdateType(UpdateType.ZIndexSortedChildren);
              }
              if (this.props.strictBounds === true && this.renderState === CoreNodeRenderState.OutOfBounds) {
                this.updateType &= ~UpdateType.RenderBounds; // remove render bounds update
                return;
              }
              if (this.updateType & UpdateType.Children && this.children.length > 0) {
                for (var i = 0, length = this.children.length; i < length; i++) {
                  var child = this.children[i];
                  child.setUpdateType(this.childUpdateType);
                  if (child.updateType === 0) {
                    continue;
                  }
                  var childClippingRect = this.clippingRect;
                  if (this.rtt === true) {
                    childClippingRect = {
                      x: 0,
                      y: 0,
                      width: 0,
                      height: 0,
                      valid: false
                    };
                  }
                  child.update(delta, childClippingRect);
                }
              }
              // If the node has an RTT parent and requires a texture re-render, inform the RTT parent
              // if (this.parentHasRenderTexture && this.updateType & UpdateType.RenderTexture) {
              // @TODO have a more scoped down updateType for RTT updates
              if (this.parentHasRenderTexture && this.updateType > 0) {
                this.notifyParentRTTOfUpdate();
              }
              // Sorting children MUST happen after children have been updated so
              // that they have the oppotunity to update their calculated zIndex.
              if (this.updateType & UpdateType.ZIndexSortedChildren) {
                // reorder z-index
                this.sortChildren();
              }
              // If we're out of bounds, apply the render state now
              // this is done so nodes can finish their entire update loop before
              // being marked as out of bounds
              if (renderState === CoreNodeRenderState.OutOfBounds) {
                this.updateRenderState(renderState);
                this.updateIsRenderable();
                if (this.rtt === true && renderState === CoreNodeRenderState.OutOfBounds) {
                  // notify children that we are going out of bounds
                  // we have to do this now before we stop processing the render tree
                  this.notifyChildrenRTTOfUpdate(renderState);
                  // this.childUpdateType |= UpdateType.RenderState;
                }
              }
              // reset update type
              this.updateType = 0;
              this.childUpdateType = 0;
            }
          }, {
            key: "findParentRTTNode",
            value: function findParentRTTNode() {
              var rttNode = this.parent;
              while (rttNode && !rttNode.rtt) {
                rttNode = rttNode.parent;
              }
              return rttNode;
            }
          }, {
            key: "getRTTParentRenderState",
            value: function getRTTParentRenderState() {
              var rttNode = this.rttParent || this.findParentRTTNode();
              if (!rttNode) {
                return null;
              }
              return rttNode.renderState;
            }
          }, {
            key: "notifyChildrenRTTOfUpdate",
            value: function notifyChildrenRTTOfUpdate(renderState) {
              var _iterator5 = _createForOfIteratorHelper(this.children),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var child = _step5.value;
                  // force child to update render state
                  child.updateRenderState(renderState);
                  child.updateIsRenderable();
                  child.notifyChildrenRTTOfUpdate(renderState);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            }
          }, {
            key: "notifyParentRTTOfUpdate",
            value: function notifyParentRTTOfUpdate() {
              if (this.parent === null) {
                return;
              }
              var rttNode = this.rttParent || this.findParentRTTNode();
              if (!rttNode) {
                return;
              }
              // If an RTT node is found, mark it for re-rendering
              rttNode.hasRTTupdates = true;
              rttNode.setUpdateType(UpdateType.RenderTexture);
              // if rttNode is nested, also make it update its RTT parent
              if (rttNode.parentHasRenderTexture === true) {
                rttNode.notifyParentRTTOfUpdate();
              }
            }
          }, {
            key: "checkRenderBounds",
            value: function checkRenderBounds() {
              assertTruthy(this.renderBound);
              assertTruthy(this.strictBound);
              assertTruthy(this.preloadBound);
              if (boundInsideBound(this.renderBound, this.strictBound)) {
                return CoreNodeRenderState.InViewport;
              }
              if (boundInsideBound(this.renderBound, this.preloadBound)) {
                return CoreNodeRenderState.InBounds;
              }
              // check if we're larger then our parent, we're definitely in the viewport
              if (boundLargeThanBound(this.renderBound, this.strictBound)) {
                return CoreNodeRenderState.InViewport;
              }
              // check if we dont have dimensions, take our parent's render state
              if (this.parent !== null && (this.props.width === 0 || this.props.height === 0)) {
                return this.parent.renderState;
              }
              return CoreNodeRenderState.OutOfBounds;
            }
          }, {
            key: "updateBoundingRect",
            value: function updateBoundingRect() {
              var transform = this.sceneGlobalTransform || this.globalTransform;
              var renderCoords = this.sceneRenderCoords || this.renderCoords;
              var tb = transform.tb,
                tc = transform.tc;
              var x1 = renderCoords.x1,
                y1 = renderCoords.y1,
                x3 = renderCoords.x3,
                y3 = renderCoords.y3;
              if (tb === 0 || tc === 0) {
                this.renderBound = createBound(x1, y1, x3, y3, this.renderBound);
              } else {
                var x2 = renderCoords.x2,
                  x4 = renderCoords.x4,
                  y2 = renderCoords.y2,
                  y4 = renderCoords.y4;
                this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
              }
            }
          }, {
            key: "createRenderBounds",
            value: function createRenderBounds() {
              assertTruthy(this.stage);
              if (this.parent !== null && this.parent.strictBound !== undefined) {
                // we have a parent with a valid bound, copy it
                var parentBound = this.parent.strictBound;
                this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
                this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
              } else {
                // no parent or parent does not have a bound, take the stage boundaries
                this.strictBound = this.stage.strictBound;
                this.preloadBound = this.stage.preloadBound;
              }
              // if clipping is disabled, we're done
              if (this.props.clipping === false) {
                return;
              }
              // only create local clipping bounds if node itself is in bounds
              // this can only be done if we have a render bound already
              if (this.renderBound === undefined) {
                return;
              }
              // if we're out of bounds, we're done
              if (boundInsideBound(this.renderBound, this.strictBound) === false) {
                return;
              }
              // clipping is enabled and we are in bounds create our own bounds
              var _this$props3 = this.props,
                x = _this$props3.x,
                y = _this$props3.y,
                width = _this$props3.width,
                height = _this$props3.height;
              // Pick the global transform if available, otherwise use the local transform
              // global transform is only available if the node in an RTT chain
              var _ref = this.sceneGlobalTransform || this.globalTransform || {},
                tx = _ref.tx,
                ty = _ref.ty;
              var _x = tx !== null && tx !== void 0 ? tx : x;
              var _y = ty !== null && ty !== void 0 ? ty : y;
              this.strictBound = createBound(_x, _y, _x + width, _y + height, this.strictBound);
              this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
            }
          }, {
            key: "updateRenderState",
            value: function updateRenderState(renderState) {
              if (renderState === this.renderState) {
                return;
              }
              var previous = this.renderState;
              this.renderState = renderState;
              var event = CoreNodeRenderStateMap.get(renderState);
              this.emit(event, {
                previous: previous,
                current: renderState
              });
            }
            /**
             * Updates the `isRenderable` property based on various conditions.
             */
          }, {
            key: "updateIsRenderable",
            value: function updateIsRenderable() {
              var newIsRenderable = false;
              var needsTextureOwnership = false;
              // If the node is out of bounds or has an alpha of 0, it is not renderable
              if (this.checkBasicRenderability() === false) {
                this.updateTextureOwnership(false);
                this.setRenderable(false);
                return;
              }
              if (this.texture !== null) {
                needsTextureOwnership = true;
                // we're only renderable if the texture state is loaded
                newIsRenderable = this.texture.state === 'loaded';
              } else if ((this.hasShader() || this.hasColorProperties() === true) && this.hasDimensions() === true) {
                // This mean we have dimensions and a color set, so we can render a ColorTexture
                if (this.stage.defaultTexture && this.stage.defaultTexture.state === 'loaded') {
                  newIsRenderable = true;
                }
              }
              this.updateTextureOwnership(needsTextureOwnership);
              this.setRenderable(newIsRenderable);
            }
            /**
             * Checks if the node is renderable based on world alpha, dimensions and out of bounds status.
             */
          }, {
            key: "checkBasicRenderability",
            value: function checkBasicRenderability() {
              if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
                return false;
              } else {
                return true;
              }
            }
            /**
             * Sets the renderable state and triggers changes if necessary.
             * @param isRenderable - The new renderable state
             */
          }, {
            key: "setRenderable",
            value: function setRenderable(isRenderable) {
              this.isRenderable = isRenderable;
            }
            /**
             * Changes the renderable state of the node.
             */
          }, {
            key: "updateTextureOwnership",
            value: function updateTextureOwnership(isRenderable) {
              var _this$texture;
              (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.setRenderableOwner(this, isRenderable);
            }
            /**
             * Checks if the node is out of the viewport bounds.
             */
          }, {
            key: "isOutOfBounds",
            value: function isOutOfBounds() {
              return this.renderState <= CoreNodeRenderState.OutOfBounds;
            }
            /**
             * Checks if the node has dimensions (width/height)
             */
          }, {
            key: "hasDimensions",
            value: function hasDimensions() {
              return this.props.width !== 0 && this.props.height !== 0;
            }
            /**
             * Checks if the node has any color properties set.
             */
          }, {
            key: "hasColorProperties",
            value: function hasColorProperties() {
              return this.props.color !== 0 || this.props.colorTop !== 0 || this.props.colorBottom !== 0 || this.props.colorLeft !== 0 || this.props.colorRight !== 0 || this.props.colorTl !== 0 || this.props.colorTr !== 0 || this.props.colorBl !== 0 || this.props.colorBr !== 0;
            }
          }, {
            key: "hasShader",
            value: function hasShader() {
              return this.props.shader !== null;
            }
          }, {
            key: "calculateRenderCoords",
            value: function calculateRenderCoords() {
              var width = this.width,
                height = this.height;
              var _this$globalTransform = this.globalTransform,
                tx = _this$globalTransform.tx,
                ty = _this$globalTransform.ty,
                ta = _this$globalTransform.ta,
                tb = _this$globalTransform.tb,
                tc = _this$globalTransform.tc,
                td = _this$globalTransform.td;
              if (tb === 0 && tc === 0) {
                var minX = tx;
                var maxX = tx + width * ta;
                var minY = ty;
                var maxY = ty + height * td;
                this.renderCoords = RenderCoords.translate(
                //top-left
                minX, minY,
                //top-right
                maxX, minY,
                //bottom-right
                maxX, maxY,
                //bottom-left
                minX, maxY, this.renderCoords);
              } else {
                this.renderCoords = RenderCoords.translate(
                //top-left
                tx, ty,
                //top-right
                tx + width * ta, ty + width * tc,
                //bottom-right
                tx + width * ta + height * tb, ty + width * tc + height * td,
                //bottom-left
                tx + height * tb, ty + height * td, this.renderCoords);
              }
              if (this.sceneGlobalTransform === undefined) {
                return;
              }
              var _this$sceneGlobalTran = this.sceneGlobalTransform,
                stx = _this$sceneGlobalTran.tx,
                sty = _this$sceneGlobalTran.ty,
                sta = _this$sceneGlobalTran.ta,
                stb = _this$sceneGlobalTran.tb,
                stc = _this$sceneGlobalTran.tc,
                std = _this$sceneGlobalTran.td;
              if (stb === 0 && stc === 0) {
                var _minX = stx;
                var _maxX = stx + width * sta;
                var _minY = sty;
                var _maxY = sty + height * std;
                this.sceneRenderCoords = RenderCoords.translate(
                //top-left
                _minX, _minY,
                //top-right
                _maxX, _minY,
                //bottom-right
                _maxX, _maxY,
                //bottom-left
                _minX, _maxY, this.sceneRenderCoords);
              } else {
                this.sceneRenderCoords = RenderCoords.translate(
                //top-left
                stx, sty,
                //top-right
                stx + width * sta, sty + width * stc,
                //bottom-right
                stx + width * sta + height * stb, sty + width * stc + height * std,
                //bottom-left
                stx + height * stb, sty + height * std, this.sceneRenderCoords);
              }
            }
            /**
             * This function calculates the clipping rectangle for a node.
             *
             * The function then checks if the node is rotated. If the node requires clipping and is not rotated, a new clipping rectangle is created based on the node's global transform and dimensions.
             * If a parent clipping rectangle exists, it is intersected with the node's clipping rectangle (if it exists), or replaces the node's clipping rectangle.
             *
             * Finally, the node's parentClippingRect and clippingRect properties are updated.
             */
          }, {
            key: "calculateClippingRect",
            value: function calculateClippingRect(parentClippingRect) {
              assertTruthy(this.globalTransform);
              var clippingRect = this.clippingRect,
                props = this.props,
                gt = this.globalTransform;
              var clipping = props.clipping;
              var isRotated = gt.tb !== 0 || gt.tc !== 0;
              if (clipping === true && isRotated === false) {
                clippingRect.x = gt.tx;
                clippingRect.y = gt.ty;
                clippingRect.width = this.width * gt.ta;
                clippingRect.height = this.height * gt.td;
                clippingRect.valid = true;
              } else {
                clippingRect.valid = false;
              }
              if (parentClippingRect.valid === true && clippingRect.valid === true) {
                // Intersect parent clipping rect with node clipping rect
                intersectRect(parentClippingRect, clippingRect, clippingRect);
              } else if (parentClippingRect.valid === true) {
                // Copy parent clipping rect
                copyRect(parentClippingRect, clippingRect);
                clippingRect.valid = true;
              }
            }
          }, {
            key: "calculateZIndex",
            value: function calculateZIndex() {
              var _props$parent, _props$parent2;
              var props = this.props;
              var z = props.zIndex || 0;
              var p = ((_props$parent = props.parent) === null || _props$parent === void 0 ? void 0 : _props$parent.zIndex) || 0;
              var zIndex = z;
              if ((_props$parent2 = props.parent) !== null && _props$parent2 !== void 0 && _props$parent2.zIndexLocked) {
                zIndex = z < p ? z : p;
              }
              this.calcZIndex = zIndex;
            }
            /**
             * Destroy the node and cleanup all resources
             */
          }, {
            key: "destroy",
            value: function destroy() {
              this.unloadTexture();
              this.clippingRect.valid = false;
              this.isRenderable = false;
              this.renderCoords = undefined;
              this.renderBound = undefined;
              this.strictBound = undefined;
              this.preloadBound = undefined;
              this.globalTransform = undefined;
              this.scaleRotateTransform = undefined;
              this.localTransform = undefined;
              this.props.texture = null;
              this.props.shader = this.stage.defShaderCtr;
              while (this.children.length > 0) {
                var _this$children$;
                (_this$children$ = this.children[0]) === null || _this$children$ === void 0 || _this$children$.destroy();
              }
              // This very action will also remove the node from the parent's children array
              this.parent = null;
              if (this.rtt) {
                this.stage.renderer.removeRTTNode(this);
              }
              this.removeAllListeners();
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(renderer) {
              // Prevent quad rendering if parent has a render texture
              // and renderer is not currently rendering to a texture
              if (this.parentHasRenderTexture) {
                if (!renderer.renderToTextureActive) {
                  return;
                }
                // Prevent quad rendering if parent render texture is not the active render texture
                if (this.parentRenderTexture !== renderer.activeRttNode) {
                  return;
                }
              }
              assertTruthy(this.globalTransform);
              assertTruthy(this.renderCoords);
              // add to list of renderables to be sorted before rendering
              renderer.addQuad({
                width: this.props.width,
                height: this.props.height,
                colorTl: this.premultipliedColorTl,
                colorTr: this.premultipliedColorTr,
                colorBl: this.premultipliedColorBl,
                colorBr: this.premultipliedColorBr,
                // if we do not have a texture, use the default texture
                // this assumes any renderable node is either a distinct texture or a ColorTexture
                texture: this.texture || this.stage.defaultTexture,
                textureOptions: this.textureOptions,
                zIndex: this.zIndex,
                shader: this.shader.shader,
                shaderProps: this.shader.getResolvedProps(),
                alpha: this.worldAlpha,
                clippingRect: this.clippingRect,
                tx: this.globalTransform.tx,
                ty: this.globalTransform.ty,
                ta: this.globalTransform.ta,
                tb: this.globalTransform.tb,
                tc: this.globalTransform.tc,
                td: this.globalTransform.td,
                renderCoords: this.renderCoords,
                rtt: this.rtt,
                parentHasRenderTexture: this.parentHasRenderTexture,
                framebufferDimensions: this.framebufferDimensions
              });
            }
            //#region Properties
          }, {
            key: "id",
            get: function get() {
              return this._id;
            }
          }, {
            key: "data",
            get: function get() {
              return this.props.data;
            },
            set: function set(d) {
              this.props.data = d;
            }
          }, {
            key: "x",
            get: function get() {
              return this.props.x;
            },
            set: function set(value) {
              if (this.props.x !== value) {
                this.props.x = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "absX",
            get: function get() {
              var _this$props$parent, _this$props$parent2;
              return this.props.x + -this.props.width * this.props.mountX + (((_this$props$parent = this.props.parent) === null || _this$props$parent === void 0 ? void 0 : _this$props$parent.absX) || ((_this$props$parent2 = this.props.parent) === null || _this$props$parent2 === void 0 || (_this$props$parent2 = _this$props$parent2.globalTransform) === null || _this$props$parent2 === void 0 ? void 0 : _this$props$parent2.tx) || 0);
            }
          }, {
            key: "absY",
            get: function get() {
              var _this$props$parent$ab, _this$props$parent3;
              return this.props.y + -this.props.height * this.props.mountY + ((_this$props$parent$ab = (_this$props$parent3 = this.props.parent) === null || _this$props$parent3 === void 0 ? void 0 : _this$props$parent3.absY) !== null && _this$props$parent$ab !== void 0 ? _this$props$parent$ab : 0);
            }
          }, {
            key: "y",
            get: function get() {
              return this.props.y;
            },
            set: function set(value) {
              if (this.props.y !== value) {
                this.props.y = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              if (this.props.width !== value) {
                this.props.width = value;
                this.setUpdateType(UpdateType.Local);
                if (this.props.rtt) {
                  this.texture = this.stage.txManager.createTexture('RenderTexture', {
                    width: this.width,
                    height: this.height
                  });
                  this.setUpdateType(UpdateType.RenderTexture);
                }
              }
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              if (this.props.height !== value) {
                this.props.height = value;
                this.setUpdateType(UpdateType.Local);
                if (this.props.rtt) {
                  this.texture = this.stage.txManager.createTexture('RenderTexture', {
                    width: this.width,
                    height: this.height
                  });
                  this.setUpdateType(UpdateType.RenderTexture);
                }
              }
            }
          }, {
            key: "scale",
            get: function get() {
              // The CoreNode `scale` property is only used by Animations.
              // Unlike INode, `null` should never be possibility for Animations.
              return this.scaleX;
            },
            set: function set(value) {
              // The CoreNode `scale` property is only used by Animations.
              // Unlike INode, `null` should never be possibility for Animations.
              this.scaleX = value;
              this.scaleY = value;
            }
          }, {
            key: "scaleX",
            get: function get() {
              return this.props.scaleX;
            },
            set: function set(value) {
              if (this.props.scaleX !== value) {
                this.props.scaleX = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "scaleY",
            get: function get() {
              return this.props.scaleY;
            },
            set: function set(value) {
              if (this.props.scaleY !== value) {
                this.props.scaleY = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "mount",
            get: function get() {
              return this.props.mount;
            },
            set: function set(value) {
              if (this.props.mountX !== value || this.props.mountY !== value) {
                this.props.mountX = value;
                this.props.mountY = value;
                this.props.mount = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "mountX",
            get: function get() {
              return this.props.mountX;
            },
            set: function set(value) {
              if (this.props.mountX !== value) {
                this.props.mountX = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "mountY",
            get: function get() {
              return this.props.mountY;
            },
            set: function set(value) {
              if (this.props.mountY !== value) {
                this.props.mountY = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivot",
            get: function get() {
              return this.props.pivot;
            },
            set: function set(value) {
              if (this.props.pivotX !== value || this.props.pivotY !== value) {
                this.props.pivotX = value;
                this.props.pivotY = value;
                this.props.pivot = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivotX",
            get: function get() {
              return this.props.pivotX;
            },
            set: function set(value) {
              if (this.props.pivotX !== value) {
                this.props.pivotX = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivotY",
            get: function get() {
              return this.props.pivotY;
            },
            set: function set(value) {
              if (this.props.pivotY !== value) {
                this.props.pivotY = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "rotation",
            get: function get() {
              return this.props.rotation;
            },
            set: function set(value) {
              if (this.props.rotation !== value) {
                this.props.rotation = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "alpha",
            get: function get() {
              return this.props.alpha;
            },
            set: function set(value) {
              this.props.alpha = value;
              this.setUpdateType(UpdateType.PremultipliedColors | UpdateType.WorldAlpha | UpdateType.Children | UpdateType.IsRenderable);
              this.childUpdateType |= UpdateType.WorldAlpha;
            }
          }, {
            key: "autosize",
            get: function get() {
              return this.props.autosize;
            },
            set: function set(value) {
              this.props.autosize = value;
            }
          }, {
            key: "boundsMargin",
            get: function get() {
              var _ref2, _this$props$boundsMar, _this$parent;
              return (_ref2 = (_this$props$boundsMar = this.props.boundsMargin) !== null && _this$props$boundsMar !== void 0 ? _this$props$boundsMar : (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.boundsMargin) !== null && _ref2 !== void 0 ? _ref2 : this.stage.boundsMargin;
            },
            set: function set(value) {
              if (value === this.props.boundsMargin) {
                return;
              }
              if (value === null) {
                this.props.boundsMargin = value;
              } else {
                var bm = Array.isArray(value) ? value : [value, value, value, value];
                this.props.boundsMargin = bm;
              }
              this.setUpdateType(UpdateType.RenderBounds);
            }
          }, {
            key: "clipping",
            get: function get() {
              return this.props.clipping;
            },
            set: function set(value) {
              this.props.clipping = value;
              this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
              this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
            }
          }, {
            key: "color",
            get: function get() {
              return this.props.color;
            },
            set: function set(value) {
              this.colorTop = value;
              this.colorBottom = value;
              this.colorLeft = value;
              this.colorRight = value;
              this.props.color = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTop",
            get: function get() {
              return this.props.colorTop;
            },
            set: function set(value) {
              if (this.props.colorTl !== value || this.props.colorTr !== value) {
                this.colorTl = value;
                this.colorTr = value;
              }
              this.props.colorTop = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBottom",
            get: function get() {
              return this.props.colorBottom;
            },
            set: function set(value) {
              if (this.props.colorBl !== value || this.props.colorBr !== value) {
                this.colorBl = value;
                this.colorBr = value;
              }
              this.props.colorBottom = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorLeft",
            get: function get() {
              return this.props.colorLeft;
            },
            set: function set(value) {
              if (this.props.colorTl !== value || this.props.colorBl !== value) {
                this.colorTl = value;
                this.colorBl = value;
              }
              this.props.colorLeft = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorRight",
            get: function get() {
              return this.props.colorRight;
            },
            set: function set(value) {
              if (this.props.colorTr !== value || this.props.colorBr !== value) {
                this.colorTr = value;
                this.colorBr = value;
              }
              this.props.colorRight = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTl",
            get: function get() {
              return this.props.colorTl;
            },
            set: function set(value) {
              this.props.colorTl = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTr",
            get: function get() {
              return this.props.colorTr;
            },
            set: function set(value) {
              this.props.colorTr = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBl",
            get: function get() {
              return this.props.colorBl;
            },
            set: function set(value) {
              this.props.colorBl = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBr",
            get: function get() {
              return this.props.colorBr;
            },
            set: function set(value) {
              this.props.colorBr = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
            // we're only interested in parent zIndex to test
            // if we should use node zIndex is higher then parent zIndex
          }, {
            key: "zIndexLocked",
            get: function get() {
              return this.props.zIndexLocked || 0;
            },
            set: function set(value) {
              this.props.zIndexLocked = value;
              this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
              for (var i = 0, length = this.children.length; i < length; i++) {
                this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
              }
            }
          }, {
            key: "zIndex",
            get: function get() {
              return this.props.zIndex;
            },
            set: function set(value) {
              this.props.zIndex = value;
              this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
              for (var i = 0, length = this.children.length; i < length; i++) {
                this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
              }
            }
          }, {
            key: "parent",
            get: function get() {
              return this.props.parent;
            },
            set: function set(newParent) {
              var oldParent = this.props.parent;
              if (oldParent === newParent) {
                return;
              }
              this.props.parent = newParent;
              if (oldParent) {
                var index = oldParent.children.indexOf(this);
                oldParent.children.splice(index, 1);
                oldParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
              }
              if (newParent) {
                newParent.children.push(this);
                // Since this node has a new parent, to be safe, have it do a full update.
                this.setUpdateType(UpdateType.All);
                // Tell parent that it's children need to be updated and sorted.
                newParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
                // If the new parent has an RTT enabled, apply RTT inheritance
                if (newParent.rtt || newParent.parentHasRenderTexture) {
                  this.applyRTTInheritance(newParent);
                }
              }
              this.updateScaleRotateTransform();
              // fetch render bounds from parent
              this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
            }
          }, {
            key: "preventCleanup",
            get: function get() {
              return this.props.textureOptions.preventCleanup || false;
            },
            set: function set(value) {
              this.props.textureOptions.preventCleanup = value;
            }
          }, {
            key: "rtt",
            get: function get() {
              return this.props.rtt;
            },
            set: function set(value) {
              if (this.props.rtt === value) {
                return;
              }
              this.props.rtt = value;
              if (value === true) {
                this.initRenderTexture();
                this.markChildrenWithRTT();
              } else {
                this.cleanupRenderTexture();
              }
              this.setUpdateType(UpdateType.RenderTexture);
              if (this.parentHasRenderTexture === true) {
                this.notifyParentRTTOfUpdate();
              }
            }
          }, {
            key: "initRenderTexture",
            value: function initRenderTexture() {
              this.texture = this.stage.txManager.createTexture('RenderTexture', {
                width: this.width,
                height: this.height
              });
              this.stage.renderer.renderToTexture(this);
            }
          }, {
            key: "cleanupRenderTexture",
            value: function cleanupRenderTexture() {
              this.unloadTexture();
              this.clearRTTInheritance();
              this.hasRTTupdates = false;
              this.texture = null;
            }
          }, {
            key: "markChildrenWithRTT",
            value: function markChildrenWithRTT() {
              var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              var parent = node || this;
              var _iterator6 = _createForOfIteratorHelper(parent.children),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var child = _step6.value;
                  child.setUpdateType(UpdateType.All);
                  child.parentHasRenderTexture = true;
                  child.markChildrenWithRTT();
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            }
            // Apply RTT inheritance when a node has an RTT-enabled parent
          }, {
            key: "applyRTTInheritance",
            value: function applyRTTInheritance(parent) {
              if (parent.rtt) {
                // Only the RTT node should be added to `renderToTexture`
                parent.setUpdateType(UpdateType.RenderTexture);
              }
              // Propagate `parentHasRenderTexture` downwards
              this.markChildrenWithRTT(parent);
            }
            // Clear RTT inheritance when detaching from an RTT chain
          }, {
            key: "clearRTTInheritance",
            value: function clearRTTInheritance() {
              // if this node is RTT itself stop the propagation important for nested RTT nodes
              // for the initial RTT node this is already handled in `set rtt`
              if (this.rtt) {
                return;
              }
              var _iterator7 = _createForOfIteratorHelper(this.children),
                _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var child = _step7.value;
                  // force child to update everything as the RTT inheritance has changed
                  child.parentHasRenderTexture = false;
                  child.rttParent = null;
                  child.setUpdateType(UpdateType.All);
                  child.clearRTTInheritance();
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          }, {
            key: "shader",
            get: function get() {
              return this.props.shader;
            },
            set: function set(value) {
              if (this.props.shader === value) {
                return;
              }
              this.props.shader = value;
              this.setUpdateType(UpdateType.IsRenderable);
            }
          }, {
            key: "src",
            get: function get() {
              return this.props.src;
            },
            set: function set(imageUrl) {
              if (this.props.src === imageUrl) {
                return;
              }
              this.props.src = imageUrl;
              if (!imageUrl) {
                this.texture = null;
                return;
              }
              this.texture = this.stage.txManager.createTexture('ImageTexture', {
                src: imageUrl,
                width: this.props.width,
                height: this.props.height,
                type: this.props.imageType,
                sx: this.props.srcX,
                sy: this.props.srcY,
                sw: this.props.srcWidth,
                sh: this.props.srcHeight
              });
            }
          }, {
            key: "imageType",
            get: function get() {
              return this.props.imageType || null;
            },
            set: function set(type) {
              if (this.props.imageType === type) {
                return;
              }
              this.props.imageType = type;
            }
          }, {
            key: "srcHeight",
            get: function get() {
              return this.props.srcHeight;
            },
            set: function set(value) {
              this.props.srcHeight = value;
            }
          }, {
            key: "srcWidth",
            get: function get() {
              return this.props.srcWidth;
            },
            set: function set(value) {
              this.props.srcWidth = value;
            }
          }, {
            key: "srcX",
            get: function get() {
              return this.props.srcX;
            },
            set: function set(value) {
              this.props.srcX = value;
            }
          }, {
            key: "srcY",
            get: function get() {
              return this.props.srcY;
            },
            set: function set(value) {
              this.props.srcY = value;
            }
            /**
             * Returns the framebuffer dimensions of the node.
             * If the node has a render texture, the dimensions are the same as the node's dimensions.
             * If the node does not have a render texture, the dimensions are inherited from the parent.
             * If the node parent has a render texture and the node is a render texture, the nodes dimensions are used.
             */
          }, {
            key: "framebufferDimensions",
            get: function get() {
              if (this.parentHasRenderTexture && !this.rtt && this.parent) {
                return this.parent.framebufferDimensions;
              }
              return {
                width: this.width,
                height: this.height
              };
            }
            /**
             * Returns the parent render texture node if it exists.
             */
          }, {
            key: "parentRenderTexture",
            get: function get() {
              var parent = this.parent;
              while (parent) {
                if (parent.rtt) {
                  return parent;
                }
                parent = parent.parent;
              }
              return null;
            }
          }, {
            key: "texture",
            get: function get() {
              return this.props.texture;
            },
            set: function set(value) {
              if (this.props.texture === value) {
                return;
              }
              var oldTexture = this.props.texture;
              if (oldTexture) {
                oldTexture.setRenderableOwner(this, false);
                this.unloadTexture();
              }
              this.props.texture = value;
              if (value !== null) {
                value.setRenderableOwner(this, this.isRenderable);
                this.loadTexture();
              }
              this.setUpdateType(UpdateType.IsRenderable);
            }
          }, {
            key: "textureOptions",
            get: function get() {
              return this.props.textureOptions;
            },
            set: function set(value) {
              this.props.textureOptions = value;
            }
          }, {
            key: "strictBounds",
            get: function get() {
              return this.props.strictBounds;
            },
            set: function set(v) {
              if (v === this.props.strictBounds) {
                return;
              }
              this.props.strictBounds = v;
              this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
              this.childUpdateType |= UpdateType.RenderBounds | UpdateType.Children;
            }
          }, {
            key: "animate",
            value: function animate(props, settings) {
              var animation = new CoreAnimation(this, props, settings);
              var controller = new CoreAnimationController(this.stage.animationManager, animation);
              return controller;
            }
          }, {
            key: "flush",
            value: function flush() {
              // no-op
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Platform render loop initiator
         */
        var startLoop = function startLoop(stage) {
          var isIdle = false;
          var _runLoop = function runLoop() {
            stage.updateFrameTime();
            stage.updateAnimations();
            if (!stage.hasSceneUpdates()) {
              // We still need to calculate the fps else it looks like the app is frozen
              stage.calculateFps();
              setTimeout(_runLoop, 16.666666666666668);
              if (!isIdle) {
                stage.eventBus.emit('idle');
                isIdle = true;
              }
              if (stage.txMemManager.checkCleanup() === true) {
                stage.txMemManager.cleanup(false);
              }
              stage.flushFrameEvents();
              return;
            }
            isIdle = false;
            stage.drawFrame();
            stage.flushFrameEvents();
            requestAnimationFrame(_runLoop);
          };
          requestAnimationFrame(_runLoop);
        };
        /**
         * Return unix timestamp
         * @return {number}
         */
        var getTimeStamp = function getTimeStamp() {
          return performance ? performance.now() : Date.now();
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var AnimationManager = /*#__PURE__*/function () {
          function AnimationManager() {
            _classCallCheck(this, AnimationManager);
            _defineProperty(this, "activeAnimations", new Set());
          }
          return _createClass(AnimationManager, [{
            key: "registerAnimation",
            value: function registerAnimation(animation) {
              this.activeAnimations.add(animation);
            }
          }, {
            key: "unregisterAnimation",
            value: function unregisterAnimation(animation) {
              this.activeAnimations.delete(animation);
            }
          }, {
            key: "update",
            value: function update(dt) {
              this.activeAnimations.forEach(function (animation) {
                animation.update(dt);
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Note that, within the createImageWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
         *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
         *
         * The createImageWorker function is a web worker that fetches an image from a URL and returns an ImageBitmap object.
         * The eslint @typescript rule is disabled for the entire function because the function is converted to a blob and used as the
         * js of the web worker thread, so the typescript syntax is not valid in this context.
         */
        /* eslint-disable */
        function createImageWorker() {
          function hasAlphaChannel(mimeType) {
            return mimeType.indexOf('image/png') !== -1;
          }
          function getImage(src, premultiplyAlpha, x, y, width, height, options) {
            return new Promise(function (resolve, reject) {
              var supportsOptionsCreateImageBitmap = options.supportsOptionsCreateImageBitmap;
              var supportsFullCreateImageBitmap = options.supportsFullCreateImageBitmap;
              var xhr = new XMLHttpRequest();
              xhr.open('GET', src, true);
              xhr.responseType = 'blob';
              xhr.onload = function () {
                // On most devices like WebOS and Tizen, the file protocol returns 0 while http(s) protocol returns 200
                if (xhr.status !== 200 && xhr.status !== 0) {
                  return reject(new Error('Failed to load image: ' + xhr.statusText));
                }
                var blob = xhr.response;
                var withAlphaChannel = premultiplyAlpha !== undefined ? premultiplyAlpha : hasAlphaChannel(blob.type);
                // createImageBitmap with crop and options
                if (supportsFullCreateImageBitmap === true && width !== null && height !== null) {
                  createImageBitmap(blob, x || 0, y || 0, width, height, {
                    premultiplyAlpha: withAlphaChannel ? 'premultiply' : 'none',
                    colorSpaceConversion: 'none',
                    imageOrientation: 'none'
                  }).then(function (data) {
                    resolve({
                      data: data,
                      premultiplyAlpha: premultiplyAlpha
                    });
                  }).catch(function (error) {
                    reject(error);
                  });
                  return;
                } else if (supportsOptionsCreateImageBitmap === false && supportsOptionsCreateImageBitmap === false) {
                  // Fallback for browsers that do not support createImageBitmap with options
                  // this is supported for Chrome v50 to v52/54 that doesn't support options
                  createImageBitmap(blob).then(function (data) {
                    resolve({
                      data: data,
                      premultiplyAlpha: premultiplyAlpha
                    });
                  }).catch(function (error) {
                    reject(error);
                  });
                } else {
                  createImageBitmap(blob, {
                    premultiplyAlpha: withAlphaChannel ? 'premultiply' : 'none',
                    colorSpaceConversion: 'none',
                    imageOrientation: 'none'
                  }).then(function (data) {
                    resolve({
                      data: data,
                      premultiplyAlpha: premultiplyAlpha
                    });
                  }).catch(function (error) {
                    reject(error);
                  });
                }
              };
              xhr.onerror = function () {
                reject(new Error('Network error occurred while trying to fetch the image.'));
              };
              xhr.send();
            });
          }
          self.onmessage = function (event) {
            var src = event.data.src;
            var id = event.data.id;
            var premultiplyAlpha = event.data.premultiplyAlpha;
            var x = event.data.sx;
            var y = event.data.sy;
            var width = event.data.sw;
            var height = event.data.sh;
            // these will be set to true if the browser supports the createImageBitmap options or full
            var supportsOptionsCreateImageBitmap = false;
            var supportsFullCreateImageBitmap = false;
            getImage(src, premultiplyAlpha, x, y, width, height, {
              supportsOptionsCreateImageBitmap: supportsOptionsCreateImageBitmap,
              supportsFullCreateImageBitmap: supportsFullCreateImageBitmap
            }).then(function (data) {
              self.postMessage({
                id: id,
                src: src,
                data: data
              });
            }).catch(function (error) {
              self.postMessage({
                id: id,
                src: src,
                error: error.message
              });
            });
          };
        }
        /* eslint-enable */
        var ImageWorkerManager = /*#__PURE__*/function () {
          function ImageWorkerManager(numImageWorkers, createImageBitmapSupport) {
            var _this9 = this;
            _classCallCheck(this, ImageWorkerManager);
            _defineProperty(this, "imageWorkersEnabled", true);
            _defineProperty(this, "messageManager", {});
            _defineProperty(this, "workers", []);
            _defineProperty(this, "workerIndex", 0);
            _defineProperty(this, "nextId", 0);
            this.workers = this.createWorkers(numImageWorkers, createImageBitmapSupport);
            this.workers.forEach(function (worker) {
              worker.onmessage = _this9.handleMessage.bind(_this9);
            });
          }
          return _createClass(ImageWorkerManager, [{
            key: "handleMessage",
            value: function handleMessage(event) {
              var _event$data = event.data,
                id = _event$data.id,
                data = _event$data.data,
                error = _event$data.error;
              var msg = this.messageManager[id];
              if (msg) {
                var _msg = _slicedToArray(msg, 2),
                  resolve = _msg[0],
                  reject = _msg[1];
                delete this.messageManager[id];
                if (error) {
                  reject(new Error(error));
                } else {
                  resolve(data);
                }
              }
            }
          }, {
            key: "createWorkers",
            value: function createWorkers() {
              var numWorkers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
              var createImageBitmapSupport = arguments.length > 1 ? arguments[1] : undefined;
              var workerCode = "(".concat(createImageWorker.toString(), ")()");
              // Replace placeholders with actual initialization values
              if (createImageBitmapSupport.options === true) {
                workerCode = workerCode.replace('var supportsOptionsCreateImageBitmap = false;', 'var supportsOptionsCreateImageBitmap = true;');
              }
              if (createImageBitmapSupport.full === true) {
                workerCode = workerCode.replace('var supportsOptionsCreateImageBitmap = false;', 'var supportsOptionsCreateImageBitmap = true;');
                workerCode = workerCode.replace('var supportsFullCreateImageBitmap = false;', 'var supportsFullCreateImageBitmap = true;');
              }
              workerCode = workerCode.replace('"use strict";', '');
              var blob = new Blob([workerCode], {
                type: 'application/javascript'
              });
              var blobURL = (self.URL ? URL : webkitURL).createObjectURL(blob);
              var workers = [];
              for (var i = 0; i < numWorkers; i++) {
                workers.push(new Worker(blobURL));
              }
              return workers;
            }
          }, {
            key: "getNextWorker",
            value: function getNextWorker() {
              var worker = this.workers[this.workerIndex];
              this.workerIndex = (this.workerIndex + 1) % this.workers.length;
              return worker;
            }
          }, {
            key: "getImage",
            value: function getImage(src, premultiplyAlpha, sx, sy, sw, sh) {
              var _this10 = this;
              return new Promise(function (resolve, reject) {
                try {
                  if (_this10.workers) {
                    var id = _this10.nextId++;
                    _this10.messageManager[id] = [resolve, reject];
                    var nextWorker = _this10.getNextWorker();
                    if (nextWorker) {
                      nextWorker.postMessage({
                        id: id,
                        src: src,
                        premultiplyAlpha: premultiplyAlpha,
                        sx: sx,
                        sy: sy,
                        sw: sw,
                        sh: sh
                      });
                    }
                  }
                } catch (error) {
                  reject(error);
                }
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of only a 1x1 color pixel
         *
         * @remarks
         * The pixel color is set with the {@link ColorTextureProps.color} prop.
         *
         * This is the default texture used for a Node if it's
         * {@link INodeProps.texture} prop is set to `null` (the default)
         *
         * Generally the 1x1 color pixel is stretched to whatever the set dimensions of
         * a Node are.
         */
        var ColorTexture = /*#__PURE__*/function (_Texture2) {
          function ColorTexture(txManager, props) {
            var _this11;
            _classCallCheck(this, ColorTexture);
            _this11 = _callSuper(this, ColorTexture, [txManager]);
            _defineProperty(_this11, "type", TextureType.color);
            _defineProperty(_this11, "props", void 0);
            _this11.props = ColorTexture.resolveDefaults(props || {});
            return _this11;
          }
          _inherits(ColorTexture, _Texture2);
          return _createClass(ColorTexture, [{
            key: "color",
            get: function get() {
              return this.props.color;
            },
            set: function set(color) {
              this.props.color = color;
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
                var pixelData;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) switch (_context2.prev = _context2.next) {
                    case 0:
                      pixelData = new Uint8Array(4);
                      if (this.color === 0xffffffff) {
                        pixelData[0] = 255;
                        pixelData[1] = 255;
                        pixelData[2] = 255;
                        pixelData[3] = 255;
                      } else {
                        pixelData[0] = this.color >> 16 & 0xff; // Red
                        pixelData[1] = this.color >> 8 & 0xff; // Green
                        pixelData[2] = this.color & 0xff; // Blue
                        pixelData[3] = this.color >>> 24 & 0xff; // Alpha
                      }
                      this.setState('fetched', {
                        width: 1,
                        height: 1
                      });
                      return _context2.abrupt("return", {
                        data: pixelData,
                        premultiplyAlpha: true
                      });
                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }, _callee2, this);
              }));
              function getTextureSource() {
                return _getTextureSource.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              var resolvedProps = ColorTexture.resolveDefaults(props);
              return "ColorTexture,".concat(resolvedProps.color);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                color: props.color || 0xffffffff
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Tests if the given location is a compressed texture container
         * @param url
         * @remarks
         * This function is used to determine if the given image url is a compressed
         * and only supports the following extensions: .ktx and .pvr
         * @returns
         */
        _defineProperty(ColorTexture, "z$__type__Props", void 0);
        function isCompressedTextureContainer(url) {
          return /\.(ktx|pvr)$/.test(url);
        }
        /**
         * Loads a compressed texture container
         * @param url
         * @returns
         */
        var loadCompressedTexture = /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(url) {
            var response, arrayBuffer;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return fetch(url);
                case 2:
                  response = _context3.sent;
                  _context3.next = 5;
                  return response.arrayBuffer();
                case 5:
                  arrayBuffer = _context3.sent;
                  if (!(url.indexOf('.ktx') !== -1)) {
                    _context3.next = 8;
                    break;
                  }
                  return _context3.abrupt("return", loadKTXData(arrayBuffer));
                case 8:
                  return _context3.abrupt("return", loadPVRData(arrayBuffer));
                case 9:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          return function loadCompressedTexture(_x2) {
            return _ref3.apply(this, arguments);
          };
        }();
        /**
         * Loads a KTX texture container and returns the texture data
         * @param buffer
         * @returns
         */
        var loadKTXData = /*#__PURE__*/function () {
          var _ref4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(buffer) {
            var view, littleEndian, mipmaps, data, offset, i, imageSize;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  view = new DataView(buffer);
                  littleEndian = view.getUint32(12) === 16909060 ? true : false;
                  mipmaps = [];
                  data = {
                    glInternalFormat: view.getUint32(28, littleEndian),
                    pixelWidth: view.getUint32(36, littleEndian),
                    pixelHeight: view.getUint32(40, littleEndian),
                    numberOfMipmapLevels: view.getUint32(56, littleEndian),
                    bytesOfKeyValueData: view.getUint32(60, littleEndian)
                  };
                  offset = 64; // Key Value Pairs of data start at byte offset 64
                  // But the only known kvp is the API version, so skipping parsing.
                  offset += data.bytesOfKeyValueData;
                  for (i = 0; i < data.numberOfMipmapLevels; i++) {
                    imageSize = view.getUint32(offset);
                    offset += 4;
                    mipmaps.push(view.buffer.slice(offset, imageSize));
                    offset += imageSize;
                  }
                  return _context4.abrupt("return", {
                    data: {
                      glInternalFormat: data.glInternalFormat,
                      mipmaps: mipmaps,
                      width: data.pixelWidth || 0,
                      height: data.pixelHeight || 0,
                      type: 'ktx'
                    },
                    premultiplyAlpha: false
                  });
                case 8:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          return function loadKTXData(_x3) {
            return _ref4.apply(this, arguments);
          };
        }();
        /**
         * Loads a PVR texture container and returns the texture data
         * @param buffer
         * @returns
         */
        var loadPVRData = /*#__PURE__*/function () {
          var _ref5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(buffer) {
            var pvrHeaderLength, pvrFormatEtc1, pvrWidth, pvrHeight, pvrMipmapCount, pvrMetadata, arrayBuffer, header, dataOffset, pvrtcData, mipmaps, data, offset, width, height, i, level, view;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  // pvr header length in 32 bits
                  pvrHeaderLength = 13; // for now only we only support: COMPRESSED_RGB_ETC1_WEBGL
                  pvrFormatEtc1 = 0x8d64;
                  pvrWidth = 7;
                  pvrHeight = 6;
                  pvrMipmapCount = 11;
                  pvrMetadata = 12;
                  arrayBuffer = buffer;
                  header = new Int32Array(arrayBuffer, 0, pvrHeaderLength); // @ts-expect-error Object possibly undefined
                  // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                  dataOffset = header[pvrMetadata] + 52;
                  pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
                  mipmaps = [];
                  data = {
                    pixelWidth: header[pvrWidth],
                    pixelHeight: header[pvrHeight],
                    numberOfMipmapLevels: header[pvrMipmapCount] || 0
                  };
                  offset = 0;
                  width = data.pixelWidth || 0;
                  height = data.pixelHeight || 0;
                  for (i = 0; i < data.numberOfMipmapLevels; i++) {
                    level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
                    view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
                    mipmaps.push(view);
                    offset += level;
                    width = width >> 1;
                    height = height >> 1;
                  }
                  return _context5.abrupt("return", {
                    data: {
                      glInternalFormat: pvrFormatEtc1,
                      mipmaps: mipmaps,
                      width: data.pixelWidth || 0,
                      height: data.pixelHeight || 0,
                      type: 'pvr'
                    },
                    premultiplyAlpha: false
                  });
                case 17:
                case "end":
                  return _context5.stop();
              }
            }, _callee5);
          }));
          return function loadPVRData(_x4) {
            return _ref5.apply(this, arguments);
          };
        }();

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Tests if the given location is a SVG
         * @param url
         * @remarks
         * This function is used to determine if the given image url is a SVG
         * image
         * @returns
         */
        function isSvgImage(url) {
          return /\.(svg)(\?.*)?$/.test(url);
        }
        /**
         * Loads a SVG image
         * @param url
         * @returns
         */
        var loadSvg = function loadSvg(url, width, height, sx, sy, sw, sh) {
          return new Promise(function (resolve, reject) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            var img = new Image();
            img.onload = function () {
              var x = sx !== null && sx !== void 0 ? sx : 0;
              var y = sy !== null && sy !== void 0 ? sy : 0;
              var w = width || img.width;
              var h = height || img.height;
              canvas.width = w;
              canvas.height = h;
              ctx.drawImage(img, 0, 0, w, h);
              resolve({
                data: ctx.getImageData(x, y, sw !== null && sw !== void 0 ? sw : w, sh !== null && sh !== void 0 ? sh : h),
                premultiplyAlpha: false
              });
            };
            img.onerror = function (err) {
              reject(err);
            };
            img.src = url;
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function fetchJson(url) {
          var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = responseType;
            xhr.onreadystatechange = function () {
              if (xhr.readyState == XMLHttpRequest.DONE) {
                // On most devices like WebOS and Tizen, the file protocol returns 0 while http(s) protocol returns 200
                if (xhr.status === 0 || xhr.status === 200) {
                  resolve(xhr.response);
                } else {
                  reject(xhr.statusText);
                }
              }
            };
            xhr.open('GET', url, true);
            xhr.send(null);
          });
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of an image loaded from a URL
         *
         * @remarks
         * The ImageTexture's {@link ImageTextureProps.src} prop defines the image URL
         * to be downloaded.
         *
         * By default, the texture's alpha values will be premultiplied into its color
         * values which is generally the desired setting before they are sent to the
         * texture's associated {@link Shader}. However, in special cases you may want
         * the Shader to receive straight (non-premultiplied) values. In that case you
         * can disable the default behavior by setting the
         * {@link ImageTextureProps.premultiplyAlpha} prop to `false`.
         */
        var ImageTexture = /*#__PURE__*/function (_Texture3) {
          function ImageTexture(txManager, props) {
            var _this12;
            _classCallCheck(this, ImageTexture);
            _this12 = _callSuper(this, ImageTexture, [txManager]);
            _defineProperty(_this12, "props", void 0);
            _defineProperty(_this12, "type", TextureType.image);
            _this12.props = ImageTexture.resolveDefaults(props);
            return _this12;
          }
          _inherits(ImageTexture, _Texture3);
          return _createClass(ImageTexture, [{
            key: "hasAlphaChannel",
            value: function hasAlphaChannel(mimeType) {
              return mimeType.indexOf('image/png') !== -1;
            }
          }, {
            key: "loadImageFallback",
            value: function () {
              var _loadImageFallback = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(src, hasAlpha) {
                var img;
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) switch (_context6.prev = _context6.next) {
                    case 0:
                      img = new Image();
                      if (isBase64Image(src) === false) {
                        img.crossOrigin = 'anonymous';
                      }
                      return _context6.abrupt("return", new Promise(function (resolve) {
                        img.onload = function () {
                          resolve({
                            data: img,
                            premultiplyAlpha: hasAlpha
                          });
                        };
                        img.onerror = function () {
                          console.warn('Image loading failed, returning fallback object.');
                          resolve({
                            data: img,
                            premultiplyAlpha: hasAlpha
                          });
                        };
                        img.src = src;
                      }));
                    case 3:
                    case "end":
                      return _context6.stop();
                  }
                }, _callee6);
              }));
              function loadImageFallback(_x11, _x12) {
                return _loadImageFallback.apply(this, arguments);
              }
              return loadImageFallback;
            }()
          }, {
            key: "createImageBitmap",
            value: function (_createImageBitmap) {
              function createImageBitmap(_x5, _x6, _x7, _x8, _x9, _x10) {
                return _createImageBitmap.apply(this, arguments);
              }
              createImageBitmap.toString = function () {
                return _createImageBitmap.toString();
              };
              return createImageBitmap;
            }(/*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(blob, premultiplyAlpha, sx, sy, sw, sh) {
                var hasAlphaChannel, imageBitmapSupported, _bitmap, bitmap;
                return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      hasAlphaChannel = premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : blob.type.includes('image/png');
                      imageBitmapSupported = this.txManager.imageBitmapSupported;
                      if (!(imageBitmapSupported.full === true && sw !== null && sh !== null)) {
                        _context7.next = 9;
                        break;
                      }
                      _context7.next = 5;
                      return createImageBitmap(blob, sx || 0, sy || 0, sw, sh, {
                        premultiplyAlpha: hasAlphaChannel ? 'premultiply' : 'none',
                        colorSpaceConversion: 'none',
                        imageOrientation: 'none'
                      });
                    case 5:
                      _bitmap = _context7.sent;
                      return _context7.abrupt("return", {
                        data: _bitmap,
                        premultiplyAlpha: hasAlphaChannel
                      });
                    case 9:
                      if (!(imageBitmapSupported.basic === true)) {
                        _context7.next = 15;
                        break;
                      }
                      _context7.next = 12;
                      return createImageBitmap(blob);
                    case 12:
                      _context7.t0 = _context7.sent;
                      _context7.t1 = hasAlphaChannel;
                      return _context7.abrupt("return", {
                        data: _context7.t0,
                        premultiplyAlpha: _context7.t1
                      });
                    case 15:
                      _context7.next = 17;
                      return createImageBitmap(blob, {
                        premultiplyAlpha: hasAlphaChannel ? 'premultiply' : 'none',
                        colorSpaceConversion: 'none',
                        imageOrientation: 'none'
                      });
                    case 17:
                      bitmap = _context7.sent;
                      return _context7.abrupt("return", {
                        data: bitmap,
                        premultiplyAlpha: hasAlphaChannel
                      });
                    case 19:
                    case "end":
                      return _context7.stop();
                  }
                }, _callee7, this);
              }));
              return function (_x13, _x14, _x15, _x16, _x17, _x18) {
                return _ref6.apply(this, arguments);
              };
            }())
          }, {
            key: "loadImage",
            value: function () {
              var _loadImage = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(src) {
                var _this$props4, premultiplyAlpha, sx, sy, sw, sh, blob;
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) switch (_context8.prev = _context8.next) {
                    case 0:
                      _this$props4 = this.props, premultiplyAlpha = _this$props4.premultiplyAlpha, sx = _this$props4.sx, sy = _this$props4.sy, sw = _this$props4.sw, sh = _this$props4.sh;
                      if (!(this.txManager.hasCreateImageBitmap === true)) {
                        _context8.next = 8;
                        break;
                      }
                      if (!(isBase64Image(src) === false && this.txManager.hasWorker === true && this.txManager.imageWorkerManager !== null)) {
                        _context8.next = 4;
                        break;
                      }
                      return _context8.abrupt("return", this.txManager.imageWorkerManager.getImage(src, premultiplyAlpha, sx, sy, sw, sh));
                    case 4:
                      _context8.next = 6;
                      return fetchJson(src, 'blob').then(function (response) {
                        return response;
                      });
                    case 6:
                      blob = _context8.sent;
                      return _context8.abrupt("return", this.createImageBitmap(blob, premultiplyAlpha, sx, sy, sw, sh));
                    case 8:
                      return _context8.abrupt("return", this.loadImageFallback(src, premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : true));
                    case 9:
                    case "end":
                      return _context8.stop();
                  }
                }, _callee8, this);
              }));
              function loadImage(_x19) {
                return _loadImage.apply(this, arguments);
              }
              return loadImage;
            }()
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                var _this$props$premultip;
                var resp, width, height, _this$props$width, _this$props$height, _resp$data$width, _resp$data, _resp$data$height, _resp$data2;
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) switch (_context9.prev = _context9.next) {
                    case 0:
                      _context9.prev = 0;
                      _context9.next = 3;
                      return this.determineImageTypeAndLoadImage();
                    case 3:
                      resp = _context9.sent;
                      _context9.next = 10;
                      break;
                    case 6:
                      _context9.prev = 6;
                      _context9.t0 = _context9["catch"](0);
                      this.setState('failed', _context9.t0);
                      return _context9.abrupt("return", {
                        data: null
                      });
                    case 10:
                      if (!(resp.data === null)) {
                        _context9.next = 13;
                        break;
                      }
                      this.setState('failed', Error('ImageTexture: No image data'));
                      return _context9.abrupt("return", {
                        data: null
                      });
                    case 13:
                      // check if resp.data is typeof Uint8ClampedArray else
                      // use resp.data.width and resp.data.height
                      if (resp.data instanceof Uint8Array) {
                        width = (_this$props$width = this.props.width) !== null && _this$props$width !== void 0 ? _this$props$width : 0;
                        height = (_this$props$height = this.props.height) !== null && _this$props$height !== void 0 ? _this$props$height : 0;
                      } else {
                        width = (_resp$data$width = (_resp$data = resp.data) === null || _resp$data === void 0 ? void 0 : _resp$data.width) !== null && _resp$data$width !== void 0 ? _resp$data$width : this.props.width || 0;
                        height = (_resp$data$height = (_resp$data2 = resp.data) === null || _resp$data2 === void 0 ? void 0 : _resp$data2.height) !== null && _resp$data$height !== void 0 ? _resp$data$height : this.props.height || 0;
                      }
                      // we're loaded!
                      this.setState('fetched', {
                        width: width,
                        height: height
                      });
                      return _context9.abrupt("return", {
                        data: resp.data,
                        premultiplyAlpha: (_this$props$premultip = this.props.premultiplyAlpha) !== null && _this$props$premultip !== void 0 ? _this$props$premultip : true
                      });
                    case 16:
                    case "end":
                      return _context9.stop();
                  }
                }, _callee9, this, [[0, 6]]);
              }));
              function getTextureSource() {
                return _getTextureSource2.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }, {
            key: "determineImageTypeAndLoadImage",
            value: function determineImageTypeAndLoadImage() {
              var _this$props5 = this.props,
                src = _this$props5.src,
                premultiplyAlpha = _this$props5.premultiplyAlpha,
                type = _this$props5.type;
              if (src === null) {
                return {
                  data: null
                };
              }
              if (typeof src !== 'string') {
                if (src instanceof ImageData) {
                  return {
                    data: src,
                    premultiplyAlpha: premultiplyAlpha
                  };
                }
                return {
                  data: src(),
                  premultiplyAlpha: premultiplyAlpha
                };
              }
              var absoluteSrc = convertUrlToAbsolute(src);
              if (type === 'regular') {
                return this.loadImage(absoluteSrc);
              }
              if (type === 'svg') {
                return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
              }
              if (isSvgImage(src) === true) {
                return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
              }
              if (type === 'compressed') {
                return loadCompressedTexture(absoluteSrc);
              }
              if (isCompressedTextureContainer(src) === true) {
                return loadCompressedTexture(absoluteSrc);
              }
              // default
              return this.loadImage(absoluteSrc);
            }
            /**
             * Generates a cache key for the ImageTexture based on the provided props.
             * @param props - The props used to generate the cache key.
             * @returns The cache key as a string, or `false` if the key cannot be generated.
             */
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              var _resolvedProps$premul;
              var resolvedProps = ImageTexture.resolveDefaults(props);
              // Only cache key-able textures; prioritise key
              var key = resolvedProps.key || resolvedProps.src;
              if (typeof key !== 'string') {
                return false;
              }
              // if we have source dimensions, cache the texture separately
              var dimensionProps = '';
              if (resolvedProps.sh !== null && resolvedProps.sw !== null) {
                var _resolvedProps$sx, _resolvedProps$sy;
                dimensionProps += ',';
                dimensionProps += (_resolvedProps$sx = resolvedProps.sx) !== null && _resolvedProps$sx !== void 0 ? _resolvedProps$sx : '';
                dimensionProps += (_resolvedProps$sy = resolvedProps.sy) !== null && _resolvedProps$sy !== void 0 ? _resolvedProps$sy : '';
                dimensionProps += resolvedProps.sw || '';
                dimensionProps += resolvedProps.sh || '';
              }
              return "ImageTexture,".concat(key, ",").concat((_resolvedProps$premul = resolvedProps.premultiplyAlpha) !== null && _resolvedProps$premul !== void 0 ? _resolvedProps$premul : 'true').concat(dimensionProps);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$src, _props$premultiplyAlp, _props$key, _props$type, _props$width, _props$height, _props$sx, _props$sy, _props$sw, _props$sh;
              return {
                src: (_props$src = props.src) !== null && _props$src !== void 0 ? _props$src : '',
                premultiplyAlpha: (_props$premultiplyAlp = props.premultiplyAlpha) !== null && _props$premultiplyAlp !== void 0 ? _props$premultiplyAlp : true,
                // null,
                key: (_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : null,
                type: (_props$type = props.type) !== null && _props$type !== void 0 ? _props$type : null,
                width: (_props$width = props.width) !== null && _props$width !== void 0 ? _props$width : null,
                height: (_props$height = props.height) !== null && _props$height !== void 0 ? _props$height : null,
                sx: (_props$sx = props.sx) !== null && _props$sx !== void 0 ? _props$sx : null,
                sy: (_props$sy = props.sy) !== null && _props$sy !== void 0 ? _props$sy : null,
                sw: (_props$sw = props.sw) !== null && _props$sw !== void 0 ? _props$sw : null,
                sh: (_props$sh = props.sh) !== null && _props$sh !== void 0 ? _props$sh : null
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of a random grid of greyscale pixels
         *
         * @remarks
         * The width and height of the NoiseTexture are defined by it's
         * {@link NoiseTextureProps.width} and {@link NoiseTextureProps.height}
         * properties. The {@link NoiseTextureProps.cacheId} prop can be varied in order
         * to bypass cache and get newly randomized texture data.
         */
        _defineProperty(ImageTexture, "z$__type__Props", void 0);
        var NoiseTexture = /*#__PURE__*/function (_Texture4) {
          function NoiseTexture(txManager, props) {
            var _this13;
            _classCallCheck(this, NoiseTexture);
            _this13 = _callSuper(this, NoiseTexture, [txManager]);
            _defineProperty(_this13, "props", void 0);
            _defineProperty(_this13, "type", TextureType.noise);
            _this13.props = NoiseTexture.resolveDefaults(props);
            return _this13;
          }
          _inherits(NoiseTexture, _Texture4);
          return _createClass(NoiseTexture, [{
            key: "getTextureSource",
            value: function () {
              var _getTextureSource3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                var _this$props6, width, height, size, pixelData8, i, v;
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) switch (_context10.prev = _context10.next) {
                    case 0:
                      _this$props6 = this.props, width = _this$props6.width, height = _this$props6.height;
                      size = width * height * 4;
                      pixelData8 = new Uint8ClampedArray(size);
                      for (i = 0; i < size; i += 4) {
                        v = Math.floor(Math.random() * 256);
                        pixelData8[i] = v;
                        pixelData8[i + 1] = v;
                        pixelData8[i + 2] = v;
                        pixelData8[i + 3] = 255;
                      }
                      this.setState('fetched');
                      return _context10.abrupt("return", {
                        data: new ImageData(pixelData8, width, height)
                      });
                    case 6:
                    case "end":
                      return _context10.stop();
                  }
                }, _callee10, this);
              }));
              function getTextureSource() {
                return _getTextureSource3.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              if (props.cacheId === undefined) {
                return false;
              }
              var resolvedProps = NoiseTexture.resolveDefaults(props);
              return "NoiseTexture,".concat(resolvedProps.width, ",").concat(resolvedProps.height, ",").concat(resolvedProps.cacheId);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width2, _props$height2, _props$cacheId;
              return {
                width: (_props$width2 = props.width) !== null && _props$width2 !== void 0 ? _props$width2 : 128,
                height: (_props$height2 = props.height) !== null && _props$height2 !== void 0 ? _props$height2 : 128,
                cacheId: (_props$cacheId = props.cacheId) !== null && _props$cacheId !== void 0 ? _props$cacheId : 0
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * A Texture that is a sub-region of another Texture.
         *
         * @remarks
         * The parent texture can be a Sprite Sheet/Texture Atlas and set using the
         * {@link SubTextureProps.texture} prop. The sub-region relative to the parent
         * texture is defined with the {@link SubTextureProps.x},
         * {@link SubTextureProps.y}, {@link SubTextureProps.width}, and
         * {@link SubTextureProps.height} pixel values.
         */
        _defineProperty(NoiseTexture, "z$__type__Props", void 0);
        var SubTexture = /*#__PURE__*/function (_Texture5) {
          function SubTexture(txManager, props) {
            var _this14;
            _classCallCheck(this, SubTexture);
            _this14 = _callSuper(this, SubTexture, [txManager]);
            _defineProperty(_this14, "props", void 0);
            _defineProperty(_this14, "parentTexture", void 0);
            _defineProperty(_this14, "type", TextureType.subTexture);
            _defineProperty(_this14, "onParentTxLoaded", function () {
              // We ignore the parent's passed dimensions, and simply use the SubTexture's
              // configured dimensions (because that's all that matters here)
              _this14.forwardParentTxState('loaded', {
                width: _this14.props.width,
                height: _this14.props.height
              });
            });
            _defineProperty(_this14, "onParentTxFailed", function (target, error) {
              _this14.forwardParentTxState('failed', error);
            });
            _defineProperty(_this14, "onParentTxFetched", function () {
              _this14.forwardParentTxState('fetched', {
                width: _this14.props.width,
                height: _this14.props.height
              });
            });
            _defineProperty(_this14, "onParentTxFetching", function () {
              _this14.forwardParentTxState('fetching');
            });
            _defineProperty(_this14, "onParentTxLoading", function () {
              _this14.forwardParentTxState('loading');
            });
            _defineProperty(_this14, "onParentTxFreed", function () {
              _this14.forwardParentTxState('freed');
            });
            _this14.props = SubTexture.resolveDefaults(props || {});
            assertTruthy(_this14.props.texture);
            assertTruthy(_this14.props.texture instanceof ImageTexture);
            // Resolve parent texture from cache or fallback to provided texture
            _this14.parentTexture = txManager.resolveParentTexture(_this14.props.texture);
            if (_this14.renderableOwners.size > 0) {
              _this14.parentTexture.setRenderableOwner(_this14, true);
            }
            // If parent texture is already loaded / failed, trigger loaded event manually
            // so that users get a consistent event experience.
            // We do this in a microtask to allow listeners to be attached in the same
            // synchronous task after calling loadTexture()
            queueMicrotask(function () {
              var parentTx = _this14.parentTexture;
              if (parentTx.state === 'loaded') {
                _this14.onParentTxLoaded(parentTx, parentTx.dimensions);
              } else if (parentTx.state === 'fetching') {
                _this14.onParentTxFetching();
              } else if (parentTx.state === 'fetched') {
                _this14.onParentTxFetched();
              } else if (parentTx.state === 'loading') {
                _this14.onParentTxLoading();
              } else if (parentTx.state === 'failed') {
                _this14.onParentTxFailed(parentTx, parentTx.error);
              } else if (parentTx.state === 'freed') {
                _this14.onParentTxFreed();
              }
              parentTx.on('fetched', _this14.onParentTxFetched);
              parentTx.on('loading', _this14.onParentTxLoading);
              parentTx.on('fetching', _this14.onParentTxFetching);
              parentTx.on('loaded', _this14.onParentTxLoaded);
              parentTx.on('failed', _this14.onParentTxFailed);
              parentTx.on('freed', _this14.onParentTxFreed);
            });
            return _this14;
          }
          _inherits(SubTexture, _Texture5);
          return _createClass(SubTexture, [{
            key: "forwardParentTxState",
            value: function forwardParentTxState(state, errorOrDimensions) {
              this.setState(state, errorOrDimensions);
            }
          }, {
            key: "onChangeIsRenderable",
            value: function onChangeIsRenderable(isRenderable) {
              // Propagate the renderable owner change to the parent texture
              this.parentTexture.setRenderableOwner(this, isRenderable);
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                var _this15 = this;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      return _context11.abrupt("return", new Promise(function (resolve, reject) {
                        _this15.setState('fetched');
                        resolve({
                          data: _this15.props
                        });
                      }));
                    case 1:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11);
              }));
              function getTextureSource() {
                return _getTextureSource4.apply(this, arguments);
              }
              return getTextureSource;
            }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              return false;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                texture: props.texture,
                x: props.x || 0,
                y: props.y || 0,
                width: props.width || 0,
                height: props.height || 0
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(SubTexture, "z$__type__Props", void 0);
        var RenderTexture = /*#__PURE__*/function (_Texture6) {
          function RenderTexture(txManager, props) {
            var _this16;
            _classCallCheck(this, RenderTexture);
            _this16 = _callSuper(this, RenderTexture, [txManager]);
            _defineProperty(_this16, "props", void 0);
            _defineProperty(_this16, "type", TextureType.renderToTexture);
            _this16.props = RenderTexture.resolveDefaults(props || {});
            return _this16;
          }
          _inherits(RenderTexture, _Texture6);
          return _createClass(RenderTexture, [{
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              this.props.width = value;
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              this.props.height = value;
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      this.setState('fetched');
                      return _context12.abrupt("return", {
                        data: null,
                        premultiplyAlpha: null
                      });
                    case 2:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12, this);
              }));
              function getTextureSource() {
                return _getTextureSource5.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                width: props.width || 256,
                height: props.height || 256
              };
            }
          }]);
        }(Texture);
        _defineProperty(RenderTexture, "z$__type__Props", void 0);
        function validateCreateImageBitmap() {
          return _validateCreateImageBitmap.apply(this, arguments);
        }
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function _validateCreateImageBitmap() {
          _validateCreateImageBitmap = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
            var _bitmap$close;
            var pngBinaryData, support, blob, bitmap, _bitmapWithOptions$cl, options, bitmapWithOptions, _bitmapWithFullOption, bitmapWithFullOptions;
            return _regeneratorRuntime().wrap(function _callee20$(_context21) {
              while (1) switch (_context21.prev = _context21.next) {
                case 0:
                  // Test if createImageBitmap is supported using a simple 1x1 PNG image
                  // prettier-ignore
                  pngBinaryData = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
                  // PNG signature
                  0x00, 0x00, 0x00, 0x0d,
                  // IHDR chunk length
                  0x49, 0x48, 0x44, 0x52,
                  // "IHDR" chunk type
                  0x00, 0x00, 0x00, 0x01,
                  // Width: 1
                  0x00, 0x00, 0x00, 0x01,
                  // Height: 1
                  0x01,
                  // Bit depth: 1
                  0x03,
                  // Color type: Indexed
                  0x00,
                  // Compression method: Deflate
                  0x00,
                  // Filter method: None
                  0x00,
                  // Interlace method: None
                  0x25, 0xdb, 0x56, 0xca,
                  // CRC for IHDR
                  0x00, 0x00, 0x00, 0x03,
                  // PLTE chunk length
                  0x50, 0x4c, 0x54, 0x45,
                  // "PLTE" chunk type
                  0x00, 0x00, 0x00,
                  // Palette entry: Black
                  0xa7, 0x7a, 0x3d, 0xda,
                  // CRC for PLTE
                  0x00, 0x00, 0x00, 0x01,
                  // tRNS chunk length
                  0x74, 0x52, 0x4e, 0x53,
                  // "tRNS" chunk type
                  0x00,
                  // Transparency for black: Fully transparent
                  0x40, 0xe6, 0xd8, 0x66,
                  // CRC for tRNS
                  0x00, 0x00, 0x00, 0x0a,
                  // IDAT chunk length
                  0x49, 0x44, 0x41, 0x54,
                  // "IDAT" chunk type
                  0x08, 0xd7,
                  // Deflate header
                  0x63, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,
                  // Zlib-compressed data
                  0xe2, 0x21, 0xbc, 0x33,
                  // CRC for IDAT
                  0x00, 0x00, 0x00, 0x00,
                  // IEND chunk length
                  0x49, 0x45, 0x4e, 0x44,
                  // "IEND" chunk type
                  0xae, 0x42, 0x60, 0x82 // CRC for IEND
                  ]);
                  support = {
                    basic: false,
                    options: false,
                    full: false
                  }; // Test basic createImageBitmap support
                  blob = new Blob([pngBinaryData], {
                    type: 'image/png'
                  });
                  _context21.next = 5;
                  return createImageBitmap(blob);
                case 5:
                  bitmap = _context21.sent;
                  (_bitmap$close = bitmap.close) === null || _bitmap$close === void 0 || _bitmap$close.call(bitmap);
                  support.basic = true;
                  // Test createImageBitmap with options support
                  _context21.prev = 8;
                  options = {
                    premultiplyAlpha: 'none'
                  };
                  _context21.next = 12;
                  return createImageBitmap(blob, options);
                case 12:
                  bitmapWithOptions = _context21.sent;
                  (_bitmapWithOptions$cl = bitmapWithOptions.close) === null || _bitmapWithOptions$cl === void 0 || _bitmapWithOptions$cl.call(bitmapWithOptions);
                  support.options = true;
                  _context21.next = 19;
                  break;
                case 17:
                  _context21.prev = 17;
                  _context21.t0 = _context21["catch"](8);
                case 19:
                  _context21.prev = 19;
                  _context21.next = 22;
                  return createImageBitmap(blob, 0, 0, 1, 1, {
                    premultiplyAlpha: 'none'
                  });
                case 22:
                  bitmapWithFullOptions = _context21.sent;
                  (_bitmapWithFullOption = bitmapWithFullOptions.close) === null || _bitmapWithFullOption === void 0 || _bitmapWithFullOption.call(bitmapWithFullOptions);
                  support.full = true;
                  _context21.next = 29;
                  break;
                case 27:
                  _context21.prev = 27;
                  _context21.t1 = _context21["catch"](19);
                case 29:
                  return _context21.abrupt("return", support);
                case 30:
                case "end":
                  return _context21.stop();
              }
            }, _callee20, null, [[8, 17], [19, 27]]);
          }));
          return _validateCreateImageBitmap.apply(this, arguments);
        }
        var CoreTextureManager = /*#__PURE__*/function (_EventEmitter6) {
          function CoreTextureManager(stage, settings) {
            var _this17;
            _classCallCheck(this, CoreTextureManager);
            _this17 = _callSuper(this, CoreTextureManager);
            /**
             * Map of textures by cache key
             */
            _defineProperty(_this17, "keyCache", new Map());
            /**
             * Map of cache keys by texture
             */
            _defineProperty(_this17, "inverseKeyCache", new WeakMap());
            /**
             * Map of texture constructors by their type name
             */
            _defineProperty(_this17, "txConstructors", {});
            _defineProperty(_this17, "downloadTextureSourceQueue", []);
            _defineProperty(_this17, "priorityQueue", []);
            _defineProperty(_this17, "uploadTextureQueue", []);
            _defineProperty(_this17, "initialized", false);
            _defineProperty(_this17, "stage", void 0);
            _defineProperty(_this17, "numImageWorkers", void 0);
            _defineProperty(_this17, "imageWorkerManager", null);
            _defineProperty(_this17, "hasCreateImageBitmap", !!self.createImageBitmap);
            _defineProperty(_this17, "imageBitmapSupported", {
              basic: false,
              options: false,
              full: false
            });
            _defineProperty(_this17, "hasWorker", !!self.Worker);
            /**
             * Renderer that this texture manager is associated with
             *
             * @remarks
             * This MUST be set before the texture manager is used. Otherwise errors
             * will occur when using the texture manager.
             */
            _defineProperty(_this17, "renderer", void 0);
            /**
             * The current frame time in milliseconds
             *
             * @remarks
             * This is used to populate the `lastRenderableChangeTime` property of
             * {@link Texture} instances when their renderable state changes.
             *
             * Set by stage via `updateFrameTime` method.
             */
            _defineProperty(_this17, "frameTime", 0);
            var numImageWorkers = settings.numImageWorkers,
              createImageBitmapSupport = settings.createImageBitmapSupport;
            _this17.stage = stage;
            _this17.numImageWorkers = numImageWorkers;
            if (createImageBitmapSupport === 'auto') {
              validateCreateImageBitmap().then(function (result) {
                _this17.initialize(result);
              }).catch(function (e) {
                console.warn('[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.');
                // initialized without image worker manager and createImageBitmap
                _this17.initialized = true;
                _this17.emit('initialized');
              });
            } else {
              _this17.initialize({
                basic: createImageBitmapSupport === 'basic',
                options: createImageBitmapSupport === 'options',
                full: createImageBitmapSupport === 'full'
              });
            }
            _this17.registerTextureType('ImageTexture', ImageTexture);
            _this17.registerTextureType('ColorTexture', ColorTexture);
            _this17.registerTextureType('NoiseTexture', NoiseTexture);
            _this17.registerTextureType('SubTexture', SubTexture);
            _this17.registerTextureType('RenderTexture', RenderTexture);
            return _this17;
          }
          _inherits(CoreTextureManager, _EventEmitter6);
          return _createClass(CoreTextureManager, [{
            key: "registerTextureType",
            value: function registerTextureType(textureType, textureClass) {
              this.txConstructors[textureType] = textureClass;
            }
          }, {
            key: "initialize",
            value: function initialize(support) {
              this.hasCreateImageBitmap = support.basic || support.options || support.full;
              this.imageBitmapSupported = support;
              if (!this.hasCreateImageBitmap) {
                console.warn('[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.');
              }
              if (this.hasCreateImageBitmap && this.hasWorker && this.numImageWorkers > 0) {
                this.imageWorkerManager = new ImageWorkerManager(this.numImageWorkers, support);
              } else {
                console.warn('[Lightning] Imageworker is 0 or not supported on this browser. Image loading will be slower.');
              }
              this.initialized = true;
              this.emit('initialized');
            }
            /**
             * Enqueue a texture for downloading its source image.
             */
          }, {
            key: "enqueueDownloadTextureSource",
            value: function enqueueDownloadTextureSource(texture) {
              if (!this.downloadTextureSourceQueue.includes(texture)) {
                this.downloadTextureSourceQueue.push(texture);
              }
            }
            /**
             * Enqueue a texture for uploading to the GPU.
             *
             * @param texture - The texture to upload
             */
          }, {
            key: "enqueueUploadTexture",
            value: function enqueueUploadTexture(texture) {
              if (this.uploadTextureQueue.includes(texture) === false) {
                this.uploadTextureQueue.push(texture);
              }
            }
            /**
             * Create a texture
             *
             * @param textureType - The type of texture to create
             * @param props - The properties to use for the texture
             */
          }, {
            key: "createTexture",
            value: function createTexture(textureType, props) {
              var texture;
              var TextureClass = this.txConstructors[textureType];
              if (!TextureClass) {
                throw new Error("Texture type \"".concat(textureType, "\" is not registered"));
              }
              var cacheKey = TextureClass.makeCacheKey(props);
              if (cacheKey && this.keyCache.has(cacheKey)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                texture = this.keyCache.get(cacheKey);
              } else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
                texture = new TextureClass(this, props);
                if (cacheKey) {
                  this.initTextureToCache(texture, cacheKey);
                }
              }
              return texture;
            }
          }, {
            key: "orphanTexture",
            value: function orphanTexture(texture) {
              // if it is part of the download or upload queue, remove it
              this.removeTextureFromQueue(texture);
              if (texture.type === TextureType.subTexture) {
                // ignore subtextures
                return;
              }
              this.stage.txMemManager.addToOrphanedTextures(texture);
            }
            /**
             * Override loadTexture to use the batched approach.
             *
             * @param texture - The texture to load
             * @param immediate - Whether to prioritize the texture for immediate loading
             */
          }, {
            key: "loadTexture",
            value: function loadTexture(texture, priority) {
              var _this18 = this;
              this.stage.txMemManager.removeFromOrphanedTextures(texture);
              if (texture.type === TextureType.subTexture) {
                // ignore subtextures - they get loaded through their parent
                return;
              }
              // if the texture is already loaded, don't load it again
              if (texture.ctxTexture !== undefined && texture.ctxTexture.state === 'loaded') {
                texture.setState('loaded');
                return;
              }
              // if the texture is already being processed, don't load it again
              if (this.downloadTextureSourceQueue.includes(texture) === true || this.uploadTextureQueue.includes(texture) === true) {
                return;
              }
              // if the texture is already loading, free it, this can happen if the texture is
              // orphaned and then reloaded
              if (texture.ctxTexture !== undefined && texture.ctxTexture.state === 'loading') {
                // if the texture has texture data, queue it for upload
                if (texture.textureData !== null) {
                  this.enqueueUploadTexture(texture);
                }
                // else we will have to re-download the texture
                texture.free();
              }
              // if we're not initialized, just queue the texture into the priority queue
              if (this.initialized === false) {
                this.priorityQueue.push(texture);
                return;
              }
              // these types of textures don't need to be downloaded
              // Technically the noise texture shouldn't either, but it's a special case
              // and not really used in production so who cares \_()_/
              if ((texture.type === TextureType.color || texture.type === TextureType.renderToTexture) && texture.state !== 'initial') {
                texture.setState('fetched');
                this.enqueueUploadTexture(texture);
                return;
              }
              texture.setState('loading');
              // prioritize the texture for immediate loading
              if (priority === true) {
                texture.getTextureData().then(function () {
                  _this18.uploadTexture(texture);
                }).catch(function (err) {
                  console.error(err);
                });
              }
              // enqueue the texture for download and upload
              this.enqueueDownloadTextureSource(texture);
            }
            /**
             * Upload a texture to the GPU
             *
             * @param texture Texture to upload
             */
          }, {
            key: "uploadTexture",
            value: function uploadTexture(texture) {
              if (this.stage.txMemManager.doNotExceedCriticalThreshold === true && this.stage.txMemManager.criticalCleanupRequested === true) {
                // we're at a critical memory threshold, don't upload textures
                this.enqueueUploadTexture(texture);
                return;
              }
              var coreContext = texture.loadCtxTexture();
              if (coreContext !== null && coreContext.state === 'loaded') {
                texture.setState('loaded');
                return;
              }
              coreContext.load();
            }
            /**
             * Check if a texture is being processed
             */
          }, {
            key: "isProcessingTexture",
            value: function isProcessingTexture(texture) {
              return this.downloadTextureSourceQueue.includes(texture) === true || this.uploadTextureQueue.includes(texture) === true;
            }
            /**
             * Process a limited number of downloads and uploads.
             *
             * @param maxItems - The maximum number of items to process
             */
          }, {
            key: "processSome",
            value: function processSome(maxProcessingTime) {
              var _this19 = this;
              if (this.initialized === false) {
                return;
              }
              var startTime = getTimeStamp();
              // Process priority queue
              var _loop = function _loop() {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var texture = _this19.priorityQueue.pop();
                texture.getTextureData().then(function () {
                  _this19.uploadTexture(texture);
                });
              };
              while (this.priorityQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime) {
                _loop();
              }
              // Process uploads
              while (this.uploadTextureQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.uploadTexture(this.uploadTextureQueue.pop());
              }
              // Process downloads
              var _loop2 = function _loop2() {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                var texture = _this19.downloadTextureSourceQueue.shift();
                texture.getTextureData().then(function () {
                  if (texture.state === 'fetched') {
                    _this19.enqueueUploadTexture(texture);
                  }
                });
              };
              while (this.downloadTextureSourceQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime) {
                _loop2();
              }
            }
          }, {
            key: "hasUpdates",
            value: function hasUpdates() {
              return this.downloadTextureSourceQueue.length > 0 || this.uploadTextureQueue.length > 0;
            }
            /**
             * Initialize a texture to the cache
             *
             * @param texture Texture to cache
             * @param cacheKey Cache key for the texture
             */
          }, {
            key: "initTextureToCache",
            value: function initTextureToCache(texture, cacheKey) {
              var keyCache = this.keyCache,
                inverseKeyCache = this.inverseKeyCache;
              keyCache.set(cacheKey, texture);
              inverseKeyCache.set(texture, cacheKey);
            }
            /**
             * Get a texture from the cache
             *
             * @param cacheKey
             */
          }, {
            key: "getTextureFromCache",
            value: function getTextureFromCache(cacheKey) {
              return this.keyCache.get(cacheKey);
            }
            /**
             * Remove a texture from the cache
             *
             * @remarks
             * Called by Texture Cleanup when a texture is freed.
             *
             * @param texture
             */
          }, {
            key: "removeTextureFromCache",
            value: function removeTextureFromCache(texture) {
              var inverseKeyCache = this.inverseKeyCache,
                keyCache = this.keyCache;
              var cacheKey = inverseKeyCache.get(texture);
              if (cacheKey) {
                keyCache.delete(cacheKey);
              }
            }
            /**
             * Remove texture from the queue's
             *
             * @param texture - The texture to remove
             */
          }, {
            key: "removeTextureFromQueue",
            value: function removeTextureFromQueue(texture) {
              var downloadIndex = this.downloadTextureSourceQueue.indexOf(texture);
              if (downloadIndex !== -1) {
                this.downloadTextureSourceQueue.splice(downloadIndex, 1);
              }
              var uploadIndex = this.uploadTextureQueue.indexOf(texture);
              if (uploadIndex !== -1) {
                this.uploadTextureQueue.splice(uploadIndex, 1);
              }
            }
            /**
             * Resolve a parent texture from the cache or fallback to the provided texture.
             *
             * @param texture - The provided texture to resolve.
             * @returns The cached or provided texture.
             */
          }, {
            key: "resolveParentTexture",
            value: function resolveParentTexture(texture) {
              if (!(texture !== null && texture !== void 0 && texture.props)) {
                return texture;
              }
              var cacheKey = ImageTexture.makeCacheKey(texture.props);
              var cachedTexture = cacheKey ? this.getTextureFromCache(cacheKey) : undefined;
              return cachedTexture !== null && cachedTexture !== void 0 ? cachedTexture : texture;
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var weightConversions = {
          normal: 400,
          bold: 700,
          bolder: 900,
          lighter: 100
        };
        var fontWeightToNumber = function fontWeightToNumber(weight) {
          if (typeof weight === 'number') {
            return weight;
          }
          return weightConversions[weight] || 400;
        };
        function resolveFontToUse(familyMapsByPriority, family, weightIn, style, stretch) {
          var weight = fontWeightToNumber(weightIn);
          var _iterator8 = _createForOfIteratorHelper(familyMapsByPriority),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var fontFamiles = _step8.value;
              var fontFaces = fontFamiles[family];
              if (!fontFaces) {
                continue;
              }
              if (fontFaces.size === 1) {
                // No Exact match found, find nearest weight match
                console.warn("TrFontManager: Only one font face found for family: '".concat(family, "' - will be used for all weights and styles"));
                return fontFaces.values().next().value;
              }
              var weightMap = new Map();
              var _iterator9 = _createForOfIteratorHelper(fontFaces),
                _step9;
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var fontFace = _step9.value;
                  var fontFamilyWeight = fontWeightToNumber(fontFace.descriptors.weight);
                  if (fontFamilyWeight === weight && fontFace.descriptors.style === style && fontFace.descriptors.stretch === stretch) {
                    return fontFace;
                  }
                  weightMap.set(fontFamilyWeight, fontFace);
                }
                // No Exact match found, find nearest weight match
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
              var msg = "TrFontManager: No exact match: '".concat(family, " Weight: ").concat(weight, " Style: ").concat(style, " Stretch: ").concat(stretch, "'");
              console.error(msg);
              // Follow the CSS font-weight algorithm to find the nearest weight match
              // https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/#font-matching-algorithm
              if (weight === 400 && weightMap.has(500)) {
                return weightMap.get(500);
              }
              if (weight === 500 && weightMap.has(400)) {
                return weightMap.get(400);
              }
              if (weight < 400) {
                while (weight > 0) {
                  if (weightMap.has(weight)) {
                    return weightMap.get(weight);
                  }
                  weight -= 100;
                }
                // reset back for the next loop
                weight = 600;
              }
              while (weight < 1000) {
                if (weightMap.has(weight)) {
                  return weightMap.get(weight);
                }
                weight += 100;
              }
              // finally check lower again
              weight = 500;
              while (weight > 0) {
                if (weightMap.has(weight)) {
                  return weightMap.get(weight);
                }
                weight -= 100;
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
          return;
        }
        var TrFontManager = /*#__PURE__*/function () {
          function TrFontManager(textRenderers) {
            _classCallCheck(this, TrFontManager);
            _defineProperty(this, "textRenderers", void 0);
            _defineProperty(this, "fontCache", new Map());
            this.textRenderers = textRenderers;
            // Intentionally left blank
          }
          return _createClass(TrFontManager, [{
            key: "addFontFace",
            value: function addFontFace(font) {
              // All the font face to all of the text renderers that support it
              for (var trId in this.textRenderers) {
                var tr = this.textRenderers[trId];
                if (tr && tr.isFontFaceSupported(font)) {
                  tr.addFontFace(font);
                }
              }
            }
            /**
             * Utility method to resolve a single font face from a list of prioritized family maps based on
             * a set of font properties.
             *
             * @remarks
             * These are to be used by a text renderer to resolve a font face if needed.
             *
             * @param familyMapsByPriority
             * @param props
             * @returns
             */
          }, {
            key: "resolveFontFace",
            value: function resolveFontFace(familyMapsByPriority, props, rendererType) {
              var fontFamily = props.fontFamily,
                fontWeight = props.fontWeight,
                fontStyle = props.fontStyle,
                fontStretch = props.fontStretch;
              var fontCacheString = "".concat(rendererType, "_").concat(fontFamily, "_").concat(fontStyle, "_").concat(fontWeight, "_").concat(fontStretch);
              if (this.fontCache.has(fontCacheString) === true) {
                return this.fontCache.get(fontCacheString);
              }
              var resolvedFont = resolveFontToUse(familyMapsByPriority, fontFamily, fontWeight, fontStyle, fontStretch);
              if (resolvedFont !== undefined) {
                this.fontCache.set(fontCacheString, resolvedFont);
              }
              return resolvedFont;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreShader = /*#__PURE__*/function () {
          function CoreShader() {
            _classCallCheck(this, CoreShader);
          }
          return _createClass(CoreShader, null, [{
            key: "makeCacheKey",
            value:
            // abstract draw(): void;
            function makeCacheKey(props) {
              return false;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {};
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        //#endregion Types
        function createShader(glw, type, source) {
          var shader = glw.createShader(type);
          if (!shader) {
            var glError = glw.getError();
            throw new Error("Unable to create the shader: ".concat(type === glw.VERTEX_SHADER ? 'VERTEX_SHADER' : 'FRAGMENT_SHADER', ".").concat(glError ? " WebGlContext Error: ".concat(glError) : ''));
          }
          glw.shaderSource(shader, source);
          glw.compileShader(shader);
          var success = !!glw.getShaderParameter(shader, glw.COMPILE_STATUS);
          if (success) {
            return shader;
          }
          console.error(glw.getShaderInfoLog(shader));
          glw.deleteShader(shader);
        }
        function createProgram(glw, vertexShader, fragmentShader) {
          var program = glw.createProgram();
          if (!program) {
            throw new Error('Unable to create program');
          }
          glw.attachShader(program, vertexShader);
          glw.attachShader(program, fragmentShader);
          glw.linkProgram(program);
          var success = !!glw.getProgramParameter(program, glw.LINK_STATUS);
          if (success) {
            return program;
          }
          console.warn(glw.getProgramInfoLog(program));
          glw.deleteProgram(program);
          return undefined;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreShader = /*#__PURE__*/function (_CoreShader) {
          function WebGlCoreShader(options) {
            var _this20;
            _classCallCheck(this, WebGlCoreShader);
            _this20 = _callSuper(this, WebGlCoreShader);
            _defineProperty(_this20, "boundBufferCollection", null);
            _defineProperty(_this20, "buffersBound", false);
            _defineProperty(_this20, "program", void 0);
            /**
             * Vertex Array Object
             *
             * @remarks
             * Used by WebGL2 Only
             */
            _defineProperty(_this20, "vao", void 0);
            _defineProperty(_this20, "renderer", void 0);
            _defineProperty(_this20, "glw", void 0);
            _defineProperty(_this20, "attributeBuffers", void 0);
            _defineProperty(_this20, "attributeLocations", void 0);
            _defineProperty(_this20, "attributeNames", void 0);
            _defineProperty(_this20, "uniformLocations", void 0);
            _defineProperty(_this20, "uniformTypes", void 0);
            _defineProperty(_this20, "supportsIndexedTextures", void 0);
            var renderer = _this20.renderer = options.renderer;
            var glw = _this20.glw = _this20.renderer.glw;
            _this20.supportsIndexedTextures = options.supportsIndexedTextures || false;
            // Check that extensions are supported
            var webGl2 = glw.isWebGl2();
            var requiredExtensions = webGl2 && options.webgl2Extensions || !webGl2 && options.webgl1Extensions || [];
            var glVersion = webGl2 ? '2.0' : '1.0';
            requiredExtensions.forEach(function (extensionName) {
              if (!glw.getExtension(extensionName)) {
                throw new Error("Shader \"".concat(_this20.constructor.name, "\" requires extension \"").concat(extensionName, "\" for WebGL ").concat(glVersion, " but wasn't found"));
              }
            });
            // Gather shader sources
            // - If WebGL 2 and special WebGL 2 sources are provided, we copy those sources and delete
            // the extra copy of them to save memory.
            // TODO: This could be further made optimal by just caching the compiled shaders and completely deleting
            // the source code
            var shaderSources = options.shaderSources || _this20.constructor.shaderSources;
            if (!shaderSources) {
              throw new Error("Shader \"".concat(_this20.constructor.name, "\" is missing shaderSources."));
            } else if (webGl2 && shaderSources !== null && shaderSources !== void 0 && shaderSources.webGl2) {
              shaderSources.fragment = shaderSources.webGl2.fragment;
              shaderSources.vertex = shaderSources.webGl2.vertex;
              delete shaderSources.webGl2;
            }
            var textureUnits = renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            var vertexSource = shaderSources.vertex instanceof Function ? shaderSources.vertex(textureUnits) : shaderSources.vertex;
            var fragmentSource = shaderSources.fragment instanceof Function ? shaderSources.fragment(textureUnits) : shaderSources.fragment;
            var vertexShader = createShader(glw, glw.VERTEX_SHADER, vertexSource);
            var fragmentShader = createShader(glw, glw.FRAGMENT_SHADER, fragmentSource);
            if (!vertexShader || !fragmentShader) {
              throw new Error("Unable to create the following shader(s): ".concat([!vertexShader && 'VERTEX_SHADER', !fragmentShader && 'FRAGMENT_SHADER'].filter(Boolean).join(' and ')));
            }
            var program = createProgram(glw, vertexShader, fragmentShader);
            if (!program) {
              throw new Error('Unable to create program');
            }
            _this20.program = program;
            _this20.attributeLocations = {};
            _this20.attributeBuffers = {};
            _this20.attributeNames = [];
            _toConsumableArray(options.attributes).forEach(function (attributeName) {
              var location = glw.getAttribLocation(_this20.program, attributeName);
              if (location < 0) {
                throw new Error("".concat(_this20.constructor.name, ": Vertex shader must have an attribute \"").concat(attributeName, "\"!"));
              }
              var buffer = glw.createBuffer();
              if (!buffer) {
                throw new Error("".concat(_this20.constructor.name, ": Could not create buffer for attribute \"").concat(attributeName, "\""));
              }
              _this20.attributeLocations[attributeName] = location;
              _this20.attributeBuffers[attributeName] = buffer;
              _this20.attributeNames.push(attributeName);
            });
            _this20.uniformLocations = {};
            _this20.uniformTypes = {};
            options.uniforms.forEach(function (uniform) {
              var location = glw.getUniformLocation(_this20.program, uniform.name);
              _this20.uniformTypes[uniform.name] = uniform.uniform;
              if (!location) {
                console.warn("Shader \"".concat(_this20.constructor.name, "\" could not get uniform location for \"").concat(uniform.name, "\""));
                return;
              }
              _this20.uniformLocations[uniform.name] = location;
            });
            return _this20;
          }
          _inherits(WebGlCoreShader, _CoreShader);
          return _createClass(WebGlCoreShader, [{
            key: "bindBufferAttribute",
            value: function bindBufferAttribute(location, buffer, attribute) {
              var glw = this.glw;
              glw.enableVertexAttribArray(location);
              glw.vertexAttribPointer(buffer, location, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.offset);
            }
          }, {
            key: "disableAttribute",
            value: function disableAttribute(location) {
              this.glw.disableVertexAttribArray(location);
            }
          }, {
            key: "disableAttributes",
            value: function disableAttributes() {
              for (var loc in this.attributeLocations) {
                this.disableAttribute(this.attributeLocations[loc]);
              }
              this.boundBufferCollection = null;
            }
            /**
             * Given two sets of Shader props destined for this Shader, determine if they can be batched together
             * to reduce the number of draw calls.
             *
             * @remarks
             * This is used by the {@link WebGlCoreRenderer} to determine if it can batch multiple consecutive draw
             * calls into a single draw call.
             *
             * By default, this returns false (meaning no batching is allowed), but can be
             * overridden by child classes to provide more efficient batching.
             *
             * @param propsA
             * @param propsB
             * @returns
             */
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              return false;
            }
          }, {
            key: "bindRenderOp",
            value: function bindRenderOp(renderOp, props) {
              this.bindBufferCollection(renderOp.buffers);
              if (renderOp.textures.length > 0) {
                this.bindTextures(renderOp.textures);
              }
              var glw = renderOp.glw,
                parentHasRenderTexture = renderOp.parentHasRenderTexture,
                renderToTexture = renderOp.renderToTexture;
              // Skip if the parent and current operation both have render textures
              if (renderToTexture && parentHasRenderTexture) {
                return;
              }
              // Bind render texture framebuffer dimensions as resolution
              // if the parent has a render texture
              if (parentHasRenderTexture) {
                var _ref7 = renderOp.framebufferDimensions || {},
                  width = _ref7.width,
                  height = _ref7.height;
                // Force pixel ratio to 1.0 for render textures since they are always 1:1
                // the final render texture will be rendered to the screen with the correct pixel ratio
                glw.uniform1f(this.getUniformLocation('u_pixelRatio'), 1.0);
                // Set resolution to the framebuffer dimensions
                glw.uniform2f(this.getUniformLocation('u_resolution'), width !== null && width !== void 0 ? width : 0, height !== null && height !== void 0 ? height : 0);
              } else {
                glw.uniform1f(this.getUniformLocation('u_pixelRatio'), renderOp.options.pixelRatio);
                glw.uniform2f(this.getUniformLocation('u_resolution'), glw.canvas.width, glw.canvas.height);
              }
              if (props) {
                // Bind optional automatic uniforms
                // These are only bound if their keys are present in the props.
                if (hasOwn(props, '$dimensions')) {
                  var dimensions = props.$dimensions;
                  if (!dimensions) {
                    dimensions = renderOp.dimensions;
                  }
                  glw.uniform2f(this.getUniformLocation('u_dimensions'), dimensions.width, dimensions.height);
                }
                if (hasOwn(props, '$alpha')) {
                  var alpha = props.$alpha;
                  if (!alpha) {
                    alpha = renderOp.alpha;
                  }
                  glw.uniform1f(this.getUniformLocation('u_alpha'), alpha);
                }
                this.bindProps(props);
              }
            }
          }, {
            key: "getUniformLocation",
            value: function getUniformLocation(name) {
              return this.uniformLocations[name] || null;
            }
          }, {
            key: "bindBufferCollection",
            value: function bindBufferCollection(buffer) {
              if (this.boundBufferCollection === buffer) {
                return;
              }
              for (var attributeName in this.attributeLocations) {
                var resolvedBuffer = buffer.getBuffer(attributeName);
                var resolvedInfo = buffer.getAttributeInfo(attributeName);
                this.bindBufferAttribute(this.attributeLocations[attributeName], resolvedBuffer, resolvedInfo);
              }
              this.boundBufferCollection = buffer;
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              // Implement in child class
            }
          }, {
            key: "bindTextures",
            value: function bindTextures(textures) {
              // no defaults
            }
          }, {
            key: "attach",
            value: function attach() {
              this.glw.useProgram(this.program);
              if (this.glw.isWebGl2() && this.vao) {
                this.glw.bindVertexArray(this.vao);
              }
            }
          }, {
            key: "detach",
            value: function detach() {
              this.disableAttributes();
            }
          }]);
        }(CoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(WebGlCoreShader, "shaderSources", void 0);
        var DefaultShader = /*#__PURE__*/function (_WebGlCoreShader2) {
          function DefaultShader(renderer) {
            _classCallCheck(this, DefaultShader);
            return _callSuper(this, DefaultShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2fv'
              }]
            }]);
          }
          _inherits(DefaultShader, _WebGlCoreShader2);
          return _createClass(DefaultShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // import type { Texture } from '../textures/Texture';
        _defineProperty(DefaultShader, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio;\n        vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);\n\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);\n        gl_Position.y = -sign(screenSpace.y) * gl_Position.y;\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n          vec4 color = texture2D(u_texture, v_textureCoordinate);\n          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);\n      }\n    "
        });
        var DefaultShaderBatched = /*#__PURE__*/function (_WebGlCoreShader3) {
          function DefaultShaderBatched(renderer) {
            var _this21;
            _classCallCheck(this, DefaultShaderBatched);
            _this21 = _callSuper(this, DefaultShaderBatched, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color', 'a_textureIndex'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_textures[0]',
                uniform: 'uniform1iv'
              }]
            }]);
            _defineProperty(_this21, "supportsIndexedTextures", true);
            return _this21;
          }
          _inherits(DefaultShaderBatched, _WebGlCoreShader3);
          return _createClass(DefaultShaderBatched, [{
            key: "bindTextures",
            value: function bindTextures(texture) {
              var renderer = this.renderer,
                glw = this.glw;
              if (texture.length > renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS) {
                throw new Error("DefaultShaderBatched: Cannot bind more than ".concat(renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS, " textures"));
              }
              texture.forEach(function (t, i) {
                glw.activeTexture(i);
                glw.bindTexture(t.ctxTexture);
              });
              var samplers = Array.from(Array(texture.length).keys());
              this.glw.uniform1iv(this.getUniformLocation('u_textures[0]'), samplers);
            }
          }]);
        }(WebGlCoreShader);
        _defineProperty(DefaultShaderBatched, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_textureCoordinate;\n      attribute vec2 a_position;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      void main(){\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n        v_textureIndex = a_textureIndex;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",
          fragment: function fragment(textureUnits) {
            return "\n      #define txUnits ".concat(textureUnits, "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textures[txUnits];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      vec4 sampleFromTexture(sampler2D textures[").concat(textureUnits, "], int idx, vec2 uv) {\n        ").concat(Array.from(Array(textureUnits).keys()).map(function (idx) {
              return "\n          ".concat(idx !== 0 ? 'else ' : '', "if (idx == ").concat(idx, ") {\n            return texture2D(textures[").concat(idx, "], uv);\n          }\n        ");
            }).join(''), "\n        return texture2D(textures[0], uv);\n      }\n\n      void main(){\n        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);\n      }\n    ");
          }
        });
        var ShaderEffect = /*#__PURE__*/function () {
          function ShaderEffect(options) {
            _classCallCheck(this, ShaderEffect);
            _defineProperty(this, "priority", 1);
            _defineProperty(this, "name", '');
            _defineProperty(this, "ref", void 0);
            _defineProperty(this, "target", void 0);
            _defineProperty(this, "passParameters", '');
            _defineProperty(this, "declaredUniforms", '');
            _defineProperty(this, "uniformInfo", {});
            var ref = options.ref,
              target = options.target,
              _options$props = options.props,
              props = _options$props === void 0 ? {} : _options$props;
            this.ref = ref;
            this.target = target;
            var uniformInfo = {};
            var passParameters = [];
            var declaredUniforms = '';
            var uniforms = this.constructor.uniforms || {};
            for (var u in uniforms) {
              var unif = uniforms[u];
              var uniType = unif.type;
              //make unique uniform name
              var uniformName = "".concat(ref, "_").concat(u);
              var define = '';
              if (unif.size) {
                define = "[".concat(unif.size(props), "]");
              }
              passParameters.push(uniformName);
              declaredUniforms += "uniform ".concat(uniType, " ").concat(uniformName).concat(define, ";");
              uniformInfo[u] = {
                name: uniformName,
                uniform: uniforms[u].method
              };
            }
            this.passParameters = passParameters.join(',');
            this.declaredUniforms = declaredUniforms;
            this.uniformInfo = uniformInfo;
          }
          return _createClass(ShaderEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              return '';
            }
          }, {
            key: "getMethodParameters",
            value: function getMethodParameters(uniforms, props) {
              var res = [];
              for (var u in uniforms) {
                var uni = uniforms[u];
                var define = '';
                if (uni.size) {
                  define = "[".concat(uni.size(props), "]");
                }
                res.push("".concat(uni.type, " ").concat(u).concat(define));
              }
              return res.join(',');
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {};
            }
          }, {
            key: "makeEffectKey",
            value: function makeEffectKey(props) {
              return false;
            }
          }]);
        }();
        _defineProperty(ShaderEffect, "uniforms", {});
        _defineProperty(ShaderEffect, "methods", void 0);
        _defineProperty(ShaderEffect, "onShaderMask", void 0);
        _defineProperty(ShaderEffect, "onColorize", void 0);
        _defineProperty(ShaderEffect, "onEffectMask", void 0);
        var effectCache = new Map();
        var getResolvedEffect = function getResolvedEffect(effects, effectContructors) {
          var key = JSON.stringify(effects);
          if (effectCache.has(key)) {
            return effectCache.get(key);
          }
          effects = effects !== null && effects !== void 0 ? effects : [];
          var resolvedEffects = [];
          var effectsLength = effects.length;
          var i = 0;
          for (; i < effectsLength; i++) {
            var _effects$i = effects[i],
              name = _effects$i.name,
              type = _effects$i.type,
              props = _effects$i.props;
            var resolvedEffect = {
              name: name,
              type: type,
              props: {}
            };
            var effectConstructor = effectContructors[type];
            var defaultPropValues = effectConstructor.resolveDefaults(props);
            var uniforms = effectConstructor.uniforms;
            var uniformKeys = Object.keys(uniforms);
            var uniformsLength = uniformKeys.length;
            var j = 0;
            for (; j < uniformsLength; j++) {
              var _key11 = uniformKeys[j];
              var uniform = uniforms[_key11];
              var result = {
                value: defaultPropValues[_key11],
                programValue: undefined,
                method: uniform.method,
                updateOnBind: uniform.updateOnBind || false,
                hasValidator: uniform.validator !== undefined,
                hasProgramValueUpdater: uniform.updateProgramValue !== undefined
              };
              var validatedValue = result.hasValidator && uniform.validator(defaultPropValues[_key11], defaultPropValues) || defaultPropValues[_key11];
              if (defaultPropValues[_key11] !== validatedValue) {
                result.validatedValue = validatedValue;
              }
              if (result.hasProgramValueUpdater) {
                uniform.updateProgramValue(result);
              }
              if (result.programValue === undefined) {
                result.programValue = result.value;
              }
              resolvedEffect.props[_key11] = result;
            }
            resolvedEffects.push(resolvedEffect);
          }
          effectCache.set(key, resolvedEffects);
          return resolvedEffects;
        };
        var DynamicShader = /*#__PURE__*/function (_WebGlCoreShader4) {
          function DynamicShader(renderer, props, effectContructors) {
            var _this22;
            _classCallCheck(this, DynamicShader);
            var shader = DynamicShader.createShader(props, effectContructors);
            _this22 = _callSuper(this, DynamicShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2fv'
              }, {
                name: 'u_dimensions',
                uniform: 'uniform2fv'
              }, {
                name: 'u_alpha',
                uniform: 'uniform1f'
              }].concat(_toConsumableArray(shader.uniforms)),
              shaderSources: {
                vertex: shader.vertex,
                fragment: shader.fragment
              }
            }]);
            _defineProperty(_this22, "effects", []);
            _this22.effects = shader.effects;
            return _this22;
          }
          _inherits(DynamicShader, _WebGlCoreShader4);
          return _createClass(DynamicShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindUniformMethods",
            value: function bindUniformMethods(props) {
              var _this23 = this;
              var glw = this.glw;
              var effects = props.effects;
              var effectsL = effects.length;
              for (var i = 0; i < effectsL; i++) {
                var uniformInfo = this.effects[i].uniformInfo;
                var _effect2 = effects[i];
                var propKeys = Object.keys(_effect2.props);
                var propsLength = propKeys.length;
                var _loop3 = function _loop3() {
                    var key = propKeys[j];
                    var method = _effect2.props[key].method;
                    var location = _this23.getUniformLocation(uniformInfo[key].name);
                    if (method === 'uniform2fv' || method === 'uniform2iv' ||
                    //uniform === 'uniform3fv	' || <--- check why this isnt recognized
                    method === 'uniform3iv' || method === 'uniform4fv' || method === 'uniform4iv' || method === 'uniformMatrix2fv' || method === 'uniformMatrix3fv' || method === 'uniformMatrix4fv' || method === 'uniform1f' || method === 'uniform1fv' || method === 'uniform1i' || method === 'uniform1iv') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform2f' || method === 'uniform2i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1]);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform3f' || method === 'uniform3i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2]);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform4f' || method === 'uniform4i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2], this.programValue[3]);
                      };
                      return 0; // continue
                    }
                  },
                  _ret;
                for (var j = 0; j < propsLength; j++) {
                  _ret = _loop3();
                  if (_ret === 0) continue;
                }
              }
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var effects = props.effects;
              var effectsL = effects.length;
              var i = 0;
              for (; i < effectsL; i++) {
                var _effect3 = effects[i];
                var propKeys = Object.keys(_effect3.props);
                var propsLength = propKeys.length;
                var j = 0;
                for (; j < propsLength; j++) {
                  var _key12 = propKeys[j];
                  var prop = _effect3.props[_key12];
                  if (prop.updateOnBind === true) {
                    var _this$renderer$shMana;
                    var uniform = (_this$renderer$shMana = this.renderer.shManager.getRegisteredEffects()[_effect3.type]) === null || _this$renderer$shMana === void 0 ? void 0 : _this$renderer$shMana.uniforms[_key12];
                    uniform === null || uniform === void 0 || uniform.updateProgramValue(_effect3.props[_key12], props);
                  }
                  prop.setUniformValue();
                }
              }
            }
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              if (propsA.$alpha !== propsB.$alpha || propsA.$dimensions.width !== propsB.$dimensions.width || propsA.$dimensions.height !== propsB.$dimensions.height || propsA.effects.length !== propsB.effects.length) {
                return false;
              }
              var propsEffectsLen = propsA.effects.length;
              var i = 0;
              for (; i < propsEffectsLen; i++) {
                var effectA = propsA.effects[i];
                var effectB = propsB.effects[i];
                if (effectA.type !== effectB.type) {
                  return false;
                }
                for (var _key13 in effectA.props) {
                  if (effectB.props && !effectB.props[_key13] || effectA.props[_key13].value !== effectB.props[_key13].value) {
                    return false;
                  }
                }
              }
              return true;
            }
          }], [{
            key: "createShader",
            value: function createShader(props, effectContructors) {
              //counts duplicate effects
              var effectNameCount = {};
              var methods = {};
              var declareUniforms = '';
              var uniforms = [];
              var uFx = [];
              var effects = props.effects.map(function (effect) {
                var baseClass = effectContructors[effect.type];
                var key = baseClass.getEffectKey(effect.props || {});
                effectNameCount[key] = effectNameCount[key] ? ++effectNameCount[key] : 1;
                var nr = effectNameCount[key];
                if (nr === 1) {
                  uFx.push({
                    key: key,
                    type: effect.type,
                    props: effect.props
                  });
                }
                //initialize new effect class;
                var fxClass = new baseClass({
                  ref: "".concat(key).concat(nr === 1 ? '' : nr),
                  target: key,
                  props: effect.props
                });
                declareUniforms += fxClass.declaredUniforms;
                uniforms.push.apply(uniforms, _toConsumableArray(Object.values(fxClass.uniformInfo)));
                return fxClass;
              });
              //build source
              var effectMethods = '';
              uFx === null || uFx === void 0 || uFx.forEach(function (fx) {
                var _fx$props;
                var fxClass = effectContructors[fx.type];
                var fxProps = fxClass.resolveDefaults((_fx$props = fx.props) !== null && _fx$props !== void 0 ? _fx$props : {});
                var remap = [];
                for (var m in fxClass.methods) {
                  var cm = m;
                  var fxMethod = fxClass.methods[m];
                  if (methods[m] && methods[m] !== fxMethod) {
                    cm = DynamicShader.resolveMethodDuplicate(m, fxMethod, methods);
                  }
                  methods[cm] = fxMethod.replace('function', cm);
                  remap.push({
                    m: m,
                    cm: cm
                  });
                }
                var onShaderMask = fxClass.onShaderMask instanceof Function ? fxClass.onShaderMask(fxProps) : fxClass.onShaderMask;
                var onColorize = fxClass.onColorize instanceof Function ? fxClass.onColorize(fxProps) : fxClass.onColorize;
                var onEffectMask = fxClass.onEffectMask instanceof Function ? fxClass.onEffectMask(fxProps) : fxClass.onEffectMask;
                remap.forEach(function (r) {
                  var m = r.m,
                    cm = r.cm;
                  var reg = new RegExp("\\$".concat(m), 'g');
                  if (onShaderMask) {
                    onShaderMask = onShaderMask.replace(reg, cm);
                  }
                  if (onColorize) {
                    onColorize = onColorize.replace(reg, cm);
                  }
                  if (onEffectMask) {
                    onEffectMask = onEffectMask.replace(reg, cm);
                  }
                });
                var methodParameters = fxClass.getMethodParameters(fxClass.uniforms, fxProps);
                var pm = methodParameters.length > 0 ? ", ".concat(methodParameters) : '';
                if (onShaderMask) {
                  effectMethods += "\n        float fx_".concat(fx.key, "_onShaderMask(float shaderMask ").concat(pm, ") {\n          ").concat(onShaderMask, "\n        }\n        ");
                }
                if (onColorize) {
                  effectMethods += "\n          vec4 fx_".concat(fx.key, "_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(pm, ") {\n            ").concat(onColorize, "\n          }\n        ");
                }
                if (onEffectMask) {
                  effectMethods += "\n          vec4 fx_".concat(fx.key, "_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(pm, ") {\n            ").concat(onEffectMask, "\n          }\n        ");
                }
              });
              var sharedMethods = '';
              for (var m in methods) {
                sharedMethods += methods[m];
              }
              //fill main functions
              var currentMask = "mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))";
              var drawEffects = "\n\n    ";
              for (var i = 0; i < effects.length; i++) {
                var current = effects[i];
                var pm = current.passParameters.length > 0 ? ", ".concat(current.passParameters) : '';
                var currentClass = effectContructors[current.name];
                if (currentClass.onShaderMask) {
                  drawEffects += "\n        shaderMask = fx_".concat(current.target, "_onShaderMask(shaderMask ").concat(pm, ");\n        ");
                }
                if (currentClass.onColorize) {
                  drawEffects += "\n        maskColor = fx_".concat(current.target, "_onColorize(shaderMask, maskColor, shaderColor").concat(pm, ");\n        ");
                }
                if (currentClass.onEffectMask) {
                  currentMask = "fx_".concat(current.target, "_onEffectMask(shaderMask, maskColor, shaderColor").concat(pm, ")");
                }
                var next = effects[i + 1];
                if (next === undefined || effectContructors[next.name].onEffectMask) {
                  drawEffects += "\n          shaderColor = ".concat(currentMask, ";\n        ");
                }
              }
              return {
                effects: effects,
                uniforms: uniforms,
                fragment: DynamicShader.fragment(declareUniforms, sharedMethods, effectMethods, drawEffects),
                vertex: DynamicShader.vertex()
              };
            }
          }, {
            key: "resolveMethodDuplicate",
            value: function resolveMethodDuplicate(key, effectMethod, methodCollection) {
              var increment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var m = key + (increment > 0 ? increment : '');
              if (methodCollection[m] && methodCollection[m] !== effectMethod) {
                return this.resolveMethodDuplicate(key, effectMethod, methodCollection, ++increment);
              }
              return m;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props, effectContructors) {
              var _props$effects;
              return {
                effects: getResolvedEffect((_props$effects = props.effects) !== null && _props$effects !== void 0 ? _props$effects : [], effectContructors),
                $dimensions: {
                  width: 0,
                  height: 0
                },
                $alpha: 0
              };
            }
          }, {
            key: "makeCacheKey",
            value: function makeCacheKey(props, effectContructors) {
              var _props$effects2;
              var fx = '';
              (_props$effects2 = props.effects) === null || _props$effects2 === void 0 || _props$effects2.forEach(function (effect) {
                var baseClass = effectContructors[effect.type];
                var key = baseClass.getEffectKey(effect.props || {});
                fx += ",".concat(key);
              });
              return "DynamicShader".concat(fx);
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Similar to the {@link DefaultShader} but cuts out 4 rounded rectangle corners
         * as defined by the specified corner {@link RoundedRectangleProps.radius}
         */
        _defineProperty(DynamicShader, "z$__type__Props", void 0);
        _defineProperty(DynamicShader, "vertex", function () {
          return "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_textureCoordinate;\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    attribute float a_textureIndex;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n    varying float v_textureIndex;\n\n    void main(){\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      // pass to fragment\n      v_color = a_color;\n      v_textureCoordinate = a_textureCoordinate;\n      v_textureIndex = a_textureIndex;\n\n      // flip y\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  ";
        });
        _defineProperty(DynamicShader, "fragment", function (uniforms, methods, effectMethods, drawEffects) {
          return "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_radius;\n    uniform sampler2D u_texture;\n    uniform float u_pixelRatio;\n\n    ".concat(uniforms, "\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n\n    ").concat(methods, "\n\n    ").concat(effectMethods, "\n\n    void main() {\n      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;\n      vec2 d = abs(p) - (u_dimensions) * 0.5;\n      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n      vec4 shaderColor = vec4(0.0);\n      float shaderMask = lng_DefaultMask;\n\n      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;\n\n      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));\n\n      ").concat(drawEffects, "\n\n      gl_FragColor = shaderColor * u_alpha;\n    }\n  ");
        });
        var RoundedRectangle = /*#__PURE__*/function (_WebGlCoreShader5) {
          function RoundedRectangle(renderer) {
            _classCallCheck(this, RoundedRectangle);
            return _callSuper(this, RoundedRectangle, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2f'
              }, {
                name: 'u_dimensions',
                uniform: 'uniform2fv'
              }, {
                name: 'u_radius',
                uniform: 'uniform1f'
              }]
            }]);
          }
          _inherits(RoundedRectangle, _WebGlCoreShader5);
          return _createClass(RoundedRectangle, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var radiusFactor = Math.min(props.$dimensions.width, props.$dimensions.height) / (2.0 * props.radius);
              this.glw.uniform1f(this.getUniformLocation('u_radius'), props.radius * Math.min(radiusFactor, 1));
            }
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              return propsA.radius === propsB.radius && propsA.$dimensions.width === propsB.$dimensions.width && propsA.$dimensions.height === propsB.$dimensions.height;
            }
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                radius: props.radius || 10,
                $dimensions: {
                  width: 0,
                  height: 0
                }
              };
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(RoundedRectangle, "z$__type__Props", void 0);
        _defineProperty(RoundedRectangle, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform vec2 u_dimensions;\n      uniform float u_radius;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      float boxDist(vec2 p, vec2 size, float radius){\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n\n      float fillMask(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;\n        vec2 halfDimensions = u_dimensions * 0.5;\n\n        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);\n        gl_FragColor = mix(vec4(0.0), color, fillMask(d));\n      }\n    "
        });
        var IDENTITY_MATRIX_3x3 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        /**
         * SdfShader supports multi-channel and single-channel signed distance field textures.
         *
         * @remarks
         * This Shader is used by the {@link SdfTextRenderer}. Do not use thie Shader
         * directly. Instead create a Text Node and assign a SDF font family to it.
         *
         * @internalRemarks
         * The only thing this shader does to support multi-channel SDFs is to
         * add a median function to the fragment shader. If this one function call
         * ends up being a performance bottleneck we can always look at ways to
         * remove it.
         */
        var SdfShader = /*#__PURE__*/function (_WebGlCoreShader6) {
          function SdfShader(renderer) {
            _classCallCheck(this, SdfShader);
            return _callSuper(this, SdfShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_transform',
                uniform: 'uniformMatrix3fv'
              }, {
                name: 'u_scrollY',
                uniform: 'uniform1f'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2f'
              }, {
                name: 'u_color',
                uniform: 'uniform4fv'
              }, {
                name: 'u_size',
                uniform: 'uniform1f'
              }, {
                name: 'u_distanceRange',
                uniform: 'uniform1f'
              }, {
                name: 'u_debug',
                uniform: 'uniform1i'
              }]
            }]);
          }
          _inherits(SdfShader, _WebGlCoreShader6);
          return _createClass(SdfShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var resolvedProps = SdfShader.resolveDefaults(props);
              for (var _key14 in resolvedProps) {
                if (_key14 === 'transform') {
                  this.glw.uniformMatrix3fv(this.getUniformLocation('u_transform'), resolvedProps[_key14]);
                } else if (_key14 === 'scrollY') {
                  this.glw.uniform1f(this.getUniformLocation('u_scrollY'), resolvedProps[_key14]);
                } else if (_key14 === 'color') {
                  var components = getNormalizedRgbaComponents(resolvedProps.color);
                  this.glw.uniform4fv(this.getUniformLocation('u_color'), components);
                } else if (_key14 === 'size') {
                  this.glw.uniform1f(this.getUniformLocation('u_size'), resolvedProps[_key14]);
                } else if (_key14 === 'distanceRange') {
                  this.glw.uniform1f(this.getUniformLocation('u_distanceRange'), resolvedProps[_key14]);
                } else if (_key14 === 'debug') {
                  this.glw.uniform1i(this.getUniformLocation('u_debug'), resolvedProps[_key14] ? 1 : 0);
                }
              }
            }
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults() {
              var _props$transform, _props$scrollY, _props$color, _props$size, _props$distanceRange, _props$debug;
              var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return {
                transform: (_props$transform = props.transform) !== null && _props$transform !== void 0 ? _props$transform : IDENTITY_MATRIX_3x3,
                scrollY: (_props$scrollY = props.scrollY) !== null && _props$scrollY !== void 0 ? _props$scrollY : 0,
                color: (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : 0xffffffff,
                size: (_props$size = props.size) !== null && _props$size !== void 0 ? _props$size : 16,
                distanceRange: (_props$distanceRange = props.distanceRange) !== null && _props$distanceRange !== void 0 ? _props$distanceRange : 1.0,
                debug: (_props$debug = props.debug) !== null && _props$debug !== void 0 ? _props$debug : false
              };
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(SdfShader, "z$__type__Props", void 0);
        _defineProperty(SdfShader, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n\n      uniform vec2 u_resolution;\n      uniform mat3 u_transform;\n      uniform float u_scrollY;\n      uniform float u_pixelRatio;\n      uniform float u_size;\n\n      varying vec2 v_texcoord;\n\n      void main() {\n        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);\n        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;\n\n        // Calculate screen space with pixel ratio\n        vec2 screenSpace = (transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1);\n\n        gl_Position = vec4(screenSpace, 0.0, 1.0);\n        v_texcoord = a_textureCoordinate;\n\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n      uniform vec4 u_color;\n      uniform sampler2D u_texture;\n      uniform float u_distanceRange;\n      uniform float u_pixelRatio;\n      uniform int u_debug;\n\n      varying vec2 v_texcoord;\n\n      float median(float r, float g, float b) {\n          return max(min(r, g), min(max(r, g), b));\n      }\n\n      void main() {\n          vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n          if (u_debug == 1) {\n            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);\n            return;\n          }\n          float scaledDistRange = u_distanceRange * u_pixelRatio;\n          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n          // Build the final color.\n          // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n      }\n    "
        });
        var updateShaderEffectColor = function updateShaderEffectColor(values) {
          if (values.programValue === undefined) {
            values.programValue = new Float32Array(4);
          }
          var rgba = values.value;
          var floatArray = values.programValue;
          floatArray[0] = (rgba >>> 24) / 255;
          floatArray[1] = (rgba >>> 16 & 0xff) / 255;
          floatArray[2] = (rgba >>> 8 & 0xff) / 255;
          floatArray[3] = (rgba & 0xff) / 255;
        };
        var updateFloat32ArrayLength2 = function updateFloat32ArrayLength2(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var floatArray = values.programValue;
            floatArray[0] = validatedValue[0];
            floatArray[1] = validatedValue[1];
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var updateFloat32ArrayLength4 = function updateFloat32ArrayLength4(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var floatArray = values.programValue;
            floatArray[0] = validatedValue[0];
            floatArray[1] = validatedValue[1];
            floatArray[2] = validatedValue[2];
            floatArray[3] = validatedValue[3];
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var updateFloat32ArrayLengthN = function updateFloat32ArrayLengthN(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var len = validatedValue.length;
            var programValue = values.programValue;
            for (var i = 0; i < len; i++) {
              programValue[i] = validatedValue[i];
            }
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var validateArrayLength4 = function validateArrayLength4(value) {
          var isArray = Array.isArray(value);
          if (!isArray) {
            return [value, value, value, value];
          } else if (isArray && value.length === 4) {
            return value;
          } else if (isArray && value.length === 2) {
            return [value[0], value[1], value[0], value[1]];
          } else if (isArray && value.length === 3) {
            return [value[0], value[1], value[2], value[0]];
          }
          return [value[0], value[0], value[0], value[0]];
        };
        var updateWebSafeRadius = function updateWebSafeRadius(values, shaderProps) {
          if (values.programValue === undefined) {
            values.programValue = new Float32Array(4);
          }
          var programValue = values.programValue;
          var validatedValue = values.validatedValue || values.value;
          if (shaderProps === undefined && values.$dimensions === undefined) {
            programValue[0] = validatedValue[0];
            programValue[1] = validatedValue[1];
            programValue[2] = validatedValue[2];
            programValue[3] = validatedValue[3];
            return;
          }
          var storedDimensions = values.$dimensions;
          if (shaderProps !== undefined) {
            var $dimensions = shaderProps.$dimensions;
            if (storedDimensions !== undefined && (storedDimensions.width === $dimensions.width || storedDimensions.height === $dimensions.height)) {
              return;
            }
            if (storedDimensions === undefined) {
              storedDimensions = {
                width: $dimensions === null || $dimensions === void 0 ? void 0 : $dimensions.width,
                height: $dimensions === null || $dimensions === void 0 ? void 0 : $dimensions.height
              };
              values.$dimensions = storedDimensions;
            }
          }
          var _storedDimensions = storedDimensions,
            width = _storedDimensions.width,
            height = _storedDimensions.height;
          var _validatedValue = _slicedToArray(validatedValue, 4),
            r0 = _validatedValue[0],
            r1 = _validatedValue[1],
            r2 = _validatedValue[2],
            r3 = _validatedValue[3];
          var factor = Math.min(Math.min(Math.min(width / Math.max(width, r0 + r1), width / Math.max(width, r2 + r3)), Math.min(height / Math.max(height, r0 + r2), height / Math.max(height, r1 + r3))), 1);
          programValue[0] = r0 * factor;
          programValue[1] = r1 * factor;
          programValue[2] = r2 * factor;
          programValue[3] = r3 * factor;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Masks the current maskcolor with rounded corners similar to {@link RoundedRectangle}
         */
        var RadiusEffect = /*#__PURE__*/function (_ShaderEffect2) {
          function RadiusEffect() {
            var _this24;
            _classCallCheck(this, RadiusEffect);
            for (var _len = arguments.length, args = new Array(_len), _key15 = 0; _key15 < _len; _key15++) {
              args[_key15] = arguments[_key15];
            }
            _this24 = _callSuper(this, RadiusEffect, [].concat(args));
            _defineProperty(_this24, "name", 'radius');
            return _this24;
          }
          _inherits(RadiusEffect, _ShaderEffect2);
          return _createClass(RadiusEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "radius";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$radius;
              return {
                radius: (_props$radius = props.radius) !== null && _props$radius !== void 0 ? _props$radius : 10
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderEffect renders a border along all edges of an element
         */
        _defineProperty(RadiusEffect, "z$__type__Props", void 0);
        _defineProperty(RadiusEffect, "uniforms", {
          radius: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            updateOnBind: true,
            validator: validateArrayLength4,
            updateProgramValue: updateWebSafeRadius
          }
        });
        _defineProperty(RadiusEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          boxDist: "\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "
        });
        _defineProperty(RadiusEffect, "onShaderMask", "\n  vec2 halfDimensions = u_dimensions * 0.5;\n  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);\n  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);\n  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);\n  ");
        _defineProperty(RadiusEffect, "onEffectMask", "\n  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));\n  ");
        var BorderEffect = /*#__PURE__*/function (_ShaderEffect3) {
          function BorderEffect() {
            var _this25;
            _classCallCheck(this, BorderEffect);
            for (var _len2 = arguments.length, args = new Array(_len2), _key16 = 0; _key16 < _len2; _key16++) {
              args[_key16] = arguments[_key16];
            }
            _this25 = _callSuper(this, BorderEffect, [].concat(args));
            _defineProperty(_this25, "name", 'border');
            return _this25;
          }
          _inherits(BorderEffect, _ShaderEffect3);
          return _createClass(BorderEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "border";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width3, _props$color2;
              return {
                width: (_props$width3 = props.width) !== null && _props$width3 !== void 0 ? _props$width3 : 10,
                color: (_props$color2 = props.color) !== null && _props$color2 !== void 0 ? _props$color2 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Linear Gradient effect over a effect mask
         */
        _defineProperty(BorderEffect, "z$__type__Props", void 0);
        _defineProperty(BorderEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderEffect, "onEffectMask", "\n  float intR = shaderMask + 1.0;\n  float mask = clamp(intR + width, 0.0, 1.0) - clamp(intR, 0.0, 1.0);\n  return mix(shaderColor, mix(shaderColor, maskColor, maskColor.a), mask);\n  ");
        _defineProperty(BorderEffect, "onColorize", "\n    return color;\n  ");
        var LinearGradientEffect = /*#__PURE__*/function (_ShaderEffect4) {
          function LinearGradientEffect() {
            var _this26;
            _classCallCheck(this, LinearGradientEffect);
            for (var _len3 = arguments.length, args = new Array(_len3), _key17 = 0; _key17 < _len3; _key17++) {
              args[_key17] = arguments[_key17];
            }
            _this26 = _callSuper(this, LinearGradientEffect, [].concat(args));
            _defineProperty(_this26, "name", 'linearGradient');
            return _this26;
          }
          _inherits(LinearGradientEffect, _ShaderEffect4);
          return _createClass(LinearGradientEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              if (props.colors.value) {
                return "linearGradient".concat(props.colors.value.length);
              }
              return "linearGradient".concat(props.colors.length);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$colors, _props$angle;
              var colors = (_props$colors = props.colors) !== null && _props$colors !== void 0 ? _props$colors : [0xff000000, 0xffffffff];
              var stops = props.stops || [];
              if (stops.length === 0 || stops.length !== colors.length) {
                var colorsL = colors.length;
                var i = 0;
                var tmp = stops;
                for (; i < colorsL; i++) {
                  if (stops[i]) {
                    tmp[i] = stops[i];
                    if (stops[i - 1] === undefined && tmp[i - 2] !== undefined) {
                      tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
                    }
                  } else {
                    tmp[i] = i * (1 / (colors.length - 1));
                  }
                }
                stops = tmp;
              }
              return {
                colors: colors,
                stops: stops,
                angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Grayscale effect grayscales the color values of the current mask color
         */
        _LinearGradientEffect = LinearGradientEffect;
        _defineProperty(LinearGradientEffect, "z$__type__Props", void 0);
        _defineProperty(LinearGradientEffect, "uniforms", {
          angle: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          colors: {
            value: 0xffffffff,
            validator: function validator(rgbas) {
              return rgbas.reduce(function (acc, val) {
                return acc.concat(getNormalizedRgbaComponents(val));
              }, []);
            },
            updateProgramValue: updateFloat32ArrayLengthN,
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform4fv',
            type: 'vec4'
          },
          stops: {
            value: [],
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform1fv',
            type: 'float'
          }
        });
        _defineProperty(LinearGradientEffect, "methods", {
          fromLinear: "\n      vec4 function(vec4 linearRGB) {\n        vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n        vec4 lower = linearRGB * vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",
          toLinear: "\n      vec4 function(vec4 sRGB) {\n        vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n        vec4 lower = sRGB/vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",
          calcPoint: "\n      vec2 function(float d, float angle) {\n        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n      }\n    "
        });
        _defineProperty(LinearGradientEffect, "ColorLoop", function (amount) {
          var loop = '';
          for (var i = 2; i < amount; i++) {
            loop += "colorOut = mix(colorOut, colors[".concat(i, "], clamp((dist - stops[").concat(i - 1, "]) / (stops[").concat(i, "] - stops[").concat(i - 1, "]), 0.0, 1.0));");
          }
          return loop;
        });
        _defineProperty(LinearGradientEffect, "onColorize", function (props) {
          var colors = props.colors.length || 1;
          return "\n      float a = angle - (PI / 180.0 * 90.0);\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = $calcPoint(lineDist * 0.5, a);\n      vec2 t = $calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = $fromLinear(mix($toLinear(colors[0]), $toLinear(colors[1]), stopCalc));\n      ".concat(_LinearGradientEffect.ColorLoop(colors), "\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    ");
        });
        var GrayscaleEffect = /*#__PURE__*/function (_ShaderEffect5) {
          function GrayscaleEffect() {
            var _this27;
            _classCallCheck(this, GrayscaleEffect);
            for (var _len4 = arguments.length, args = new Array(_len4), _key18 = 0; _key18 < _len4; _key18++) {
              args[_key18] = arguments[_key18];
            }
            _this27 = _callSuper(this, GrayscaleEffect, [].concat(args));
            _defineProperty(_this27, "name", 'grayscale');
            return _this27;
          }
          _inherits(GrayscaleEffect, _ShaderEffect5);
          return _createClass(GrayscaleEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "grayscale";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$amount;
              return {
                amount: (_props$amount = props.amount) !== null && _props$amount !== void 0 ? _props$amount : 1
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the right side of an element
         */
        _defineProperty(GrayscaleEffect, "uniforms", {
          amount: {
            value: 1,
            method: 'uniform1f',
            type: 'float'
          }
        });
        _defineProperty(GrayscaleEffect, "onColorize", "\n    float grayness = 0.2 * maskColor.r + 0.6 * maskColor.g + 0.2 * maskColor.b;\n    return vec4(amount * vec3(grayness) + (1.0 - amount) * maskColor.rgb, maskColor.a);\n  ");
        var BorderRightEffect = /*#__PURE__*/function (_ShaderEffect6) {
          function BorderRightEffect() {
            var _this28;
            _classCallCheck(this, BorderRightEffect);
            for (var _len5 = arguments.length, args = new Array(_len5), _key19 = 0; _key19 < _len5; _key19++) {
              args[_key19] = arguments[_key19];
            }
            _this28 = _callSuper(this, BorderRightEffect, [].concat(args));
            _defineProperty(_this28, "name", 'borderRight');
            return _this28;
          }
          _inherits(BorderRightEffect, _ShaderEffect6);
          return _createClass(BorderRightEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderRight";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width4, _props$color3;
              return {
                width: (_props$width4 = props.width) !== null && _props$width4 !== void 0 ? _props$width4 : 10,
                color: (_props$color3 = props.color) !== null && _props$color3 !== void 0 ? _props$color3 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the top side of an element
         */
        _defineProperty(BorderRightEffect, "z$__type__Props", void 0);
        _defineProperty(BorderRightEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderRightEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderRightEffect, "onEffectMask", "\n  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderRightEffect, "onColorize", "\n    return color;\n  ");
        var BorderTopEffect = /*#__PURE__*/function (_ShaderEffect7) {
          function BorderTopEffect() {
            var _this29;
            _classCallCheck(this, BorderTopEffect);
            for (var _len6 = arguments.length, args = new Array(_len6), _key20 = 0; _key20 < _len6; _key20++) {
              args[_key20] = arguments[_key20];
            }
            _this29 = _callSuper(this, BorderTopEffect, [].concat(args));
            _defineProperty(_this29, "name", 'borderTop');
            return _this29;
          }
          _inherits(BorderTopEffect, _ShaderEffect7);
          return _createClass(BorderTopEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderTop";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width5, _props$color4;
              return {
                width: (_props$width5 = props.width) !== null && _props$width5 !== void 0 ? _props$width5 : 10,
                color: (_props$color4 = props.color) !== null && _props$color4 !== void 0 ? _props$color4 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the bottom side of an element
         */
        _defineProperty(BorderTopEffect, "z$__type__Props", void 0);
        _defineProperty(BorderTopEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderTopEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderTopEffect, "onEffectMask", "\n  vec2 pos = vec2(0.0, width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderTopEffect, "onColorize", "\n    return color;\n  ");
        var BorderBottomEffect = /*#__PURE__*/function (_ShaderEffect8) {
          function BorderBottomEffect() {
            var _this30;
            _classCallCheck(this, BorderBottomEffect);
            for (var _len7 = arguments.length, args = new Array(_len7), _key21 = 0; _key21 < _len7; _key21++) {
              args[_key21] = arguments[_key21];
            }
            _this30 = _callSuper(this, BorderBottomEffect, [].concat(args));
            _defineProperty(_this30, "name", 'borderBottom');
            return _this30;
          }
          _inherits(BorderBottomEffect, _ShaderEffect8);
          return _createClass(BorderBottomEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderBottom";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width6, _props$color5;
              return {
                width: (_props$width6 = props.width) !== null && _props$width6 !== void 0 ? _props$width6 : 10,
                color: (_props$color5 = props.color) !== null && _props$color5 !== void 0 ? _props$color5 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the left of an element
         */
        _defineProperty(BorderBottomEffect, "z$__type__Props", void 0);
        _defineProperty(BorderBottomEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderBottomEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderBottomEffect, "onEffectMask", "\n  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderBottomEffect, "onColorize", "\n    return color;\n  ");
        var BorderLeftEffect = /*#__PURE__*/function (_ShaderEffect9) {
          function BorderLeftEffect() {
            var _this31;
            _classCallCheck(this, BorderLeftEffect);
            for (var _len8 = arguments.length, args = new Array(_len8), _key22 = 0; _key22 < _len8; _key22++) {
              args[_key22] = arguments[_key22];
            }
            _this31 = _callSuper(this, BorderLeftEffect, [].concat(args));
            _defineProperty(_this31, "name", 'borderLeft');
            return _this31;
          }
          _inherits(BorderLeftEffect, _ShaderEffect9);
          return _createClass(BorderLeftEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderLeft";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width7, _props$color6;
              return {
                width: (_props$width7 = props.width) !== null && _props$width7 !== void 0 ? _props$width7 : 10,
                color: (_props$color6 = props.color) !== null && _props$color6 !== void 0 ? _props$color6 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /**
         * Renders a Glitch effect using the incoming texture
         */
        _defineProperty(BorderLeftEffect, "z$__type__Props", void 0);
        _defineProperty(BorderLeftEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderLeftEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderLeftEffect, "onEffectMask", "\n  vec2 pos = vec2(width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderLeftEffect, "onColorize", "\n    return color;\n  ");
        var GlitchEffect = /*#__PURE__*/function (_ShaderEffect10) {
          function GlitchEffect() {
            var _this32;
            _classCallCheck(this, GlitchEffect);
            for (var _len9 = arguments.length, args = new Array(_len9), _key23 = 0; _key23 < _len9; _key23++) {
              args[_key23] = arguments[_key23];
            }
            _this32 = _callSuper(this, GlitchEffect, [].concat(args));
            _defineProperty(_this32, "name", 'glitch');
            return _this32;
          }
          _inherits(GlitchEffect, _ShaderEffect10);
          return _createClass(GlitchEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              return "glitch";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$amplitude, _props$narrowness, _props$blockiness, _props$minimizer, _props$time;
              return {
                amplitude: (_props$amplitude = props.amplitude) !== null && _props$amplitude !== void 0 ? _props$amplitude : 0.2,
                narrowness: (_props$narrowness = props.narrowness) !== null && _props$narrowness !== void 0 ? _props$narrowness : 4.0,
                blockiness: (_props$blockiness = props.blockiness) !== null && _props$blockiness !== void 0 ? _props$blockiness : 2.0,
                minimizer: (_props$minimizer = props.minimizer) !== null && _props$minimizer !== void 0 ? _props$minimizer : 8.0,
                time: (_props$time = props.time) !== null && _props$time !== void 0 ? _props$time : Date.now()
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(GlitchEffect, "z$__type__Props", void 0);
        _defineProperty(GlitchEffect, "uniforms", {
          amplitude: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          narrowness: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          blockiness: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          minimizer: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          time: {
            value: 0,
            method: 'uniform1f',
            updateOnBind: true,
            updateProgramValue: function updateProgramValue(values) {
              var value = values.value = (Date.now() - values.value) % 1000;
              values.programValue = value;
            },
            type: 'float'
          }
        });
        _defineProperty(GlitchEffect, "methods", {
          rand: "\n      float function(vec2 p, float time) {\n        float t = floor(time * 20.) / 10.;\n        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n      }\n    ",
          noise: "\n      float function(vec2 uv, float blockiness, float time) {\n        vec2 lv = fract(uv);\n        vec2 id = floor(uv);\n\n        float n1 = rand(id, time);\n        float n2 = rand(id+vec2(1,0), time);\n        float n3 = rand(id+vec2(0,1), time);\n        float n4 = rand(id+vec2(1,1), time);\n        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n      }\n    ",
          fbm: "\n      float function(vec2 uv, int count, float blockiness, float complexity, float time) {\n        float val = 0.0;\n        float amp = 0.5;\n        const int MAX_ITERATIONS = 10;\n\n        for(int i = 0; i < MAX_ITERATIONS; i++) {\n          if(i >= count) {break;}\n          val += amp * noise(uv, blockiness, time);\n          amp *= 0.5;\n          uv *= complexity;\n        }\n        return val;\n      }\n    "
        });
        _defineProperty(GlitchEffect, "onColorize", "\n    vec2 uv = v_textureCoordinate.xy;\n    float aspect = u_dimensions.x / u_dimensions.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));\n\n    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);\n    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);\n    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);\n    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n\n    vec3 f = vec3(colR, colG, colB);\n    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);\n  ");
        var FadeOutEffect = /*#__PURE__*/function (_ShaderEffect11) {
          function FadeOutEffect() {
            var _this33;
            _classCallCheck(this, FadeOutEffect);
            for (var _len10 = arguments.length, args = new Array(_len10), _key24 = 0; _key24 < _len10; _key24++) {
              args[_key24] = arguments[_key24];
            }
            _this33 = _callSuper(this, FadeOutEffect, [].concat(args));
            _defineProperty(_this33, "name", 'fadeOut');
            return _this33;
          }
          _inherits(FadeOutEffect, _ShaderEffect11);
          return _createClass(FadeOutEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "fadeOut";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$fade;
              return {
                fade: (_props$fade = props.fade) !== null && _props$fade !== void 0 ? _props$fade : 10
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(FadeOutEffect, "z$__type__Props", void 0);
        _defineProperty(FadeOutEffect, "uniforms", {
          fade: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            validator: validateArrayLength4,
            updateProgramValue: updateFloat32ArrayLength4
          }
        });
        _defineProperty(FadeOutEffect, "onColorize", "\n  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;\n  vec2 pos1;\n  vec2 pos2;\n  vec2 d;\n  float c;\n  vec4 result = maskColor;\n\n\n  if(fade[0] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x, point.y + fade[0]);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[1] > 0.0) {\n    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);\n    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[2] > 0.0) {\n    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);\n    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[3] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x + fade[3], point.y);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  return result;\n  ");
        var RadialGradientEffect = /*#__PURE__*/function (_ShaderEffect12) {
          function RadialGradientEffect() {
            var _this34;
            _classCallCheck(this, RadialGradientEffect);
            for (var _len11 = arguments.length, args = new Array(_len11), _key25 = 0; _key25 < _len11; _key25++) {
              args[_key25] = arguments[_key25];
            }
            _this34 = _callSuper(this, RadialGradientEffect, [].concat(args));
            _defineProperty(_this34, "name", 'radialGradient');
            return _this34;
          }
          _inherits(RadialGradientEffect, _ShaderEffect12);
          return _createClass(RadialGradientEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              if (props.colors.value) {
                return "radialGradient".concat(props.colors.value.length);
              }
              return "radialGradient".concat(props.colors.length);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$colors2, _props$width8, _ref8, _props$height3, _props$pivot;
              var colors = (_props$colors2 = props.colors) !== null && _props$colors2 !== void 0 ? _props$colors2 : [0xff000000, 0xffffffff];
              var stops = props.stops || [];
              if (stops.length === 0 || stops.length !== colors.length) {
                var colorsL = colors.length;
                var i = 0;
                var tmp = stops;
                for (; i < colorsL; i++) {
                  if (stops[i]) {
                    tmp[i] = stops[i];
                    if (stops[i - 1] === undefined && tmp[i - 2] !== undefined) {
                      tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
                    }
                  } else {
                    tmp[i] = i * (1 / (colors.length - 1));
                  }
                }
                stops = tmp;
              }
              return {
                colors: colors,
                stops: stops,
                width: (_props$width8 = props.width) !== null && _props$width8 !== void 0 ? _props$width8 : 0,
                height: (_ref8 = (_props$height3 = props.height) !== null && _props$height3 !== void 0 ? _props$height3 : props.width) !== null && _ref8 !== void 0 ? _ref8 : 0,
                pivot: (_props$pivot = props.pivot) !== null && _props$pivot !== void 0 ? _props$pivot : [0.5, 0.5]
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The RadialProgressEffect renders a border along all edges of an element
         */
        _RadialGradientEffect = RadialGradientEffect;
        _defineProperty(RadialGradientEffect, "z$__type__Props", void 0);
        _defineProperty(RadialGradientEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          height: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          pivot: {
            value: [0.5, 0.5],
            updateProgramValue: updateFloat32ArrayLength2,
            method: 'uniform2fv',
            type: 'vec2'
          },
          colors: {
            value: 0xffffffff,
            validator: function validator(rgbas) {
              return rgbas.reduce(function (acc, val) {
                return acc.concat(getNormalizedRgbaComponents(val));
              }, []);
            },
            updateProgramValue: updateFloat32ArrayLengthN,
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform4fv',
            type: 'vec4'
          },
          stops: {
            value: [],
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform1fv',
            type: 'float'
          }
        });
        _defineProperty(RadialGradientEffect, "ColorLoop", function (amount) {
          var loop = '';
          for (var i = 2; i < amount; i++) {
            loop += "colorOut = mix(colorOut, colors[".concat(i, "], clamp((dist - stops[").concat(i - 1, "]) / (stops[").concat(i, "] - stops[").concat(i - 1, "]), 0.0, 1.0));");
          }
          return loop;
        });
        _defineProperty(RadialGradientEffect, "onColorize", function (props) {
          var colors = props.colors.length || 1;
          return "\n      vec2 point = v_textureCoordinate.xy * u_dimensions;\n      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);\n\n      float dist = length((point - projection) / vec2(width, height));\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = mix(colors[0], colors[1], stopCalc);\n      ".concat(_RadialGradientEffect.ColorLoop(colors), "\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    ");
        });
        var RadialProgressEffect = /*#__PURE__*/function (_ShaderEffect13) {
          function RadialProgressEffect() {
            var _this35;
            _classCallCheck(this, RadialProgressEffect);
            for (var _len12 = arguments.length, args = new Array(_len12), _key26 = 0; _key26 < _len12; _key26++) {
              args[_key26] = arguments[_key26];
            }
            _this35 = _callSuper(this, RadialProgressEffect, [].concat(args));
            _defineProperty(_this35, "name", 'radialProgress');
            return _this35;
          }
          _inherits(RadialProgressEffect, _ShaderEffect13);
          return _createClass(RadialProgressEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "radialProgress";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width9, _props$progress, _props$offset, _props$range, _props$rounded, _props$radius2, _props$color7;
              return {
                width: (_props$width9 = props.width) !== null && _props$width9 !== void 0 ? _props$width9 : 10,
                progress: (_props$progress = props.progress) !== null && _props$progress !== void 0 ? _props$progress : 0.5,
                offset: (_props$offset = props.offset) !== null && _props$offset !== void 0 ? _props$offset : 0,
                range: (_props$range = props.range) !== null && _props$range !== void 0 ? _props$range : Math.PI * 2,
                rounded: (_props$rounded = props.rounded) !== null && _props$rounded !== void 0 ? _props$rounded : false,
                radius: (_props$radius2 = props.radius) !== null && _props$radius2 !== void 0 ? _props$radius2 : 1,
                color: (_props$color7 = props.color) !== null && _props$color7 !== void 0 ? _props$color7 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /**
         * Masks the current maskcolor a holepunch effect with rounded corners similar to {@link RoundedRectangle}
         */
        _defineProperty(RadialProgressEffect, "z$__type__Props", void 0);
        _defineProperty(RadialProgressEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          progress: {
            value: 0.5,
            method: 'uniform1f',
            type: 'float'
          },
          offset: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          range: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          rounded: {
            value: 0,
            method: 'uniform1f',
            type: 'float',
            validator: function validator(value) {
              return value ? 1 : 0;
            }
          },
          radius: {
            value: 1,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(RadialProgressEffect, "methods", {
          rotateUV: "\n    vec2 function(vec2 uv, float d) {\n      float s = sin(d);\n      float c = cos(d);\n      mat2 rotMatrix = mat2(c, -s, s, c);\n      return uv * rotMatrix;\n    }\n    ",
          drawDot: "\n    float function(vec2 uv, vec2 p, float r) {\n      uv += p;\n      float circle = length(uv) - r;\n      return clamp(-circle, 0.0, 1.0);\n    }\n    "
        });
        _defineProperty(RadialProgressEffect, "onEffectMask", "\n    float outerRadius = radius * u_dimensions.y * 0.5;\n\n    float endAngle = range * progress - 0.0005;\n\n    vec2 uv = v_textureCoordinate.xy * u_dimensions.xy - u_dimensions * 0.5;\n\n    uv = $rotateUV(uv, -(offset));\n    float linewidth = width * u_pixelRatio;\n    float circle = length(uv) - (outerRadius - linewidth) ;\n    circle = abs(circle) - linewidth;\n    circle = clamp(-circle, 0.0, 1.0);\n\n    float angle = (atan(uv.x, -uv.y) / 3.14159265359 * 0.5);\n    float p = endAngle / (PI * 2.);\n\n    circle *= step(fract(angle), fract(p));\n\n    circle = rounded < 1. ? circle : max(circle, $drawDot(uv, vec2(0, outerRadius - linewidth), linewidth));\n    circle = rounded < 1. ? circle : max(circle, $drawDot($rotateUV(uv, -(endAngle)), vec2(0, outerRadius - linewidth), linewidth));\n\n    return mix(shaderColor, maskColor, circle);\n  ");
        _defineProperty(RadialProgressEffect, "onColorize", "\n    return color;\n  ");
        var HolePunchEffect = /*#__PURE__*/function (_ShaderEffect14) {
          function HolePunchEffect() {
            var _this36;
            _classCallCheck(this, HolePunchEffect);
            for (var _len13 = arguments.length, args = new Array(_len13), _key27 = 0; _key27 < _len13; _key27++) {
              args[_key27] = arguments[_key27];
            }
            _this36 = _callSuper(this, HolePunchEffect, [].concat(args));
            _defineProperty(_this36, "name", 'holePunch');
            return _this36;
          }
          _inherits(HolePunchEffect, _ShaderEffect14);
          return _createClass(HolePunchEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "holePunch";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$radius3;
              return {
                x: props.x || 0,
                y: props.y || 0,
                width: props.width || 50,
                height: props.height || 50,
                radius: (_props$radius3 = props.radius) !== null && _props$radius3 !== void 0 ? _props$radius3 : 0
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(HolePunchEffect, "z$__type__Props", void 0);
        _defineProperty(HolePunchEffect, "uniforms", {
          x: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          y: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          height: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          radius: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            updateOnBind: true,
            validator: validateArrayLength4,
            updateProgramValue: updateWebSafeRadius
          }
        });
        _defineProperty(HolePunchEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          boxDist: "\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "
        });
        _defineProperty(HolePunchEffect, "onShaderMask", "\n  vec2 halfDimensions = u_dimensions * 0.5;\n  vec2 size = vec2(width, height) * 0.5;\n  vec2 basePos = v_textureCoordinate.xy * u_dimensions.xy - vec2(x, y);\n  vec2 pos = basePos - size;\n  float r = radius[0] * step(pos.x, 0.5) * step(pos.y, 0.5);\n  r = r + radius[1] * step(0.5, pos.x) * step(pos.y, 0.5);\n  r = r + radius[2] * step(0.5, pos.x) * step(0.5, pos.y);\n  r = r + radius[3] * step(pos.x, 0.5) * step(0.5, pos.y);\n  return $boxDist(pos, size, r);\n  ");
        _defineProperty(HolePunchEffect, "onEffectMask", "\n  return mix(maskColor, vec4(0.0), $fillMask(shaderMask));\n  ");
        var ROUNDED_RECTANGLE_SHADER_TYPE = 'RoundedRectangle';
        var UnsupportedShader = /*#__PURE__*/function (_CoreShader2) {
          function UnsupportedShader(shType) {
            var _this37;
            _classCallCheck(this, UnsupportedShader);
            _this37 = _callSuper(this, UnsupportedShader);
            _defineProperty(_this37, "shType", void 0);
            _this37.shType = shType;
            // if (shType !== ROUNDED_RECTANGLE_SHADER_TYPE) {
            //   console.warn('Unsupported shader:', shType);
            // }
            return _this37;
          }
          _inherits(UnsupportedShader, _CoreShader2);
          return _createClass(UnsupportedShader, [{
            key: "bindRenderOp",
            value: function bindRenderOp() {
              // noop
            }
          }, {
            key: "bindProps",
            value: function bindProps() {
              // noop
            }
          }, {
            key: "attach",
            value: function attach() {
              // noop
            }
          }, {
            key: "detach",
            value: function detach() {
              // noop
            }
          }]);
        }(CoreShader);
        /**
         * Shader Controller Class
         *
         * @remarks
         * This class is used to control shader props.
         */
        var ShaderController = /*#__PURE__*/function () {
          function ShaderController(type, shader, props, stage) {
            var _this38 = this;
            _classCallCheck(this, ShaderController);
            _defineProperty(this, "type", void 0);
            _defineProperty(this, "shader", void 0);
            _defineProperty(this, "resolvedProps", void 0);
            _defineProperty(this, "props", void 0);
            this.type = type;
            this.shader = shader;
            this.resolvedProps = props;
            var keys = Object.keys(props);
            var l = keys.length;
            var definedProps = {};
            var _loop4 = function _loop4() {
              var name = keys[i];
              Object.defineProperty(definedProps, name, {
                get: function get() {
                  return _this38.resolvedProps[name];
                },
                set: function set(value) {
                  _this38.resolvedProps[name] = value;
                  stage.requestRender();
                }
              });
            };
            for (var i = 0; i < l; i++) {
              _loop4();
            }
            this.props = definedProps;
          }
          return _createClass(ShaderController, [{
            key: "getResolvedProps",
            value: function getResolvedProps() {
              return this.resolvedProps;
            }
          }]);
        }();
        var DynamicShaderController = /*#__PURE__*/function () {
          function DynamicShaderController(shader, props, shManager) {
            var _this39 = this;
            _classCallCheck(this, DynamicShaderController);
            _defineProperty(this, "shader", void 0);
            _defineProperty(this, "resolvedProps", void 0);
            _defineProperty(this, "props", void 0);
            _defineProperty(this, "type", void 0);
            this.shader = shader;
            this.type = 'DynamicShader';
            this.resolvedProps = props;
            var effectConstructors = shManager.getRegisteredEffects();
            var definedProps = {};
            var effects = props.effects;
            var effectsLength = effects.length;
            var _loop5 = function _loop5(i) {
              var _effects$i2 = effects[i],
                effectName = _effects$i2.name,
                effectProps = _effects$i2.props,
                effectType = _effects$i2.type;
              if (effectName === undefined) {
                return 1; // continue
              }
              var definedEffectProps = {};
              var propEntries = Object.keys(effectProps);
              var propEntriesLength = propEntries.length;
              var _loop6 = function _loop6() {
                var propName = propEntries[j];
                Object.defineProperty(definedEffectProps, propName, {
                  get: function get() {
                    return _this39.resolvedProps.effects[i].props[propName].value;
                  },
                  set: function set(value) {
                    var target = _this39.resolvedProps.effects[i].props[propName];
                    target.value = value;
                    if (target.hasValidator) {
                      var _effectConstructors$e;
                      value = target.validatedValue = (_effectConstructors$e = effectConstructors[effectType].uniforms[propName]) === null || _effectConstructors$e === void 0 ? void 0 : _effectConstructors$e.validator(value, effectProps);
                    }
                    if (target.hasProgramValueUpdater) {
                      var _effectConstructors$e2;
                      (_effectConstructors$e2 = effectConstructors[effectType].uniforms[propName]) === null || _effectConstructors$e2 === void 0 || _effectConstructors$e2.updateProgramValue(target);
                    } else {
                      target.programValue = value;
                    }
                    shManager.renderer.stage.requestRender();
                  }
                });
              };
              for (var j = 0; j < propEntriesLength; j++) {
                _loop6();
              }
              Object.defineProperty(definedProps, effectName, {
                get: function get() {
                  return definedEffectProps;
                }
              });
            };
            for (var i = 0; i < effectsLength; i++) {
              if (_loop5(i)) continue;
            }
            this.props = definedProps;
          }
          return _createClass(DynamicShaderController, [{
            key: "getResolvedProps",
            value: function getResolvedProps() {
              return this.resolvedProps;
            }
          }]);
        }();
        var CoreShaderManager = /*#__PURE__*/function () {
          function CoreShaderManager() {
            _classCallCheck(this, CoreShaderManager);
            _defineProperty(this, "shCache", new Map());
            _defineProperty(this, "shConstructors", {});
            _defineProperty(this, "attachedShader", null);
            _defineProperty(this, "effectConstructors", {});
            _defineProperty(this, "renderer", void 0);
            this.registerShaderType('DefaultShader', DefaultShader);
            this.registerShaderType('DefaultShaderBatched', DefaultShaderBatched);
            this.registerShaderType('RoundedRectangle', RoundedRectangle);
            this.registerShaderType('DynamicShader', DynamicShader);
            this.registerShaderType('SdfShader', SdfShader);
            this.registerEffectType('border', BorderEffect);
            this.registerEffectType('borderBottom', BorderBottomEffect);
            this.registerEffectType('borderLeft', BorderLeftEffect);
            this.registerEffectType('borderRight', BorderRightEffect);
            this.registerEffectType('borderTop', BorderTopEffect);
            this.registerEffectType('fadeOut', FadeOutEffect);
            this.registerEffectType('linearGradient', LinearGradientEffect);
            this.registerEffectType('radialGradient', RadialGradientEffect);
            this.registerEffectType('grayscale', GrayscaleEffect);
            this.registerEffectType('glitch', GlitchEffect);
            this.registerEffectType('radius', RadiusEffect);
            this.registerEffectType('radialProgress', RadialProgressEffect);
            this.registerEffectType('holePunch', HolePunchEffect);
          }
          return _createClass(CoreShaderManager, [{
            key: "registerShaderType",
            value: function registerShaderType(shType, shClass) {
              this.shConstructors[shType] = shClass;
            }
          }, {
            key: "registerEffectType",
            value: function registerEffectType(effectType, effectClass) {
              this.effectConstructors[effectType] = effectClass;
            }
          }, {
            key: "getRegisteredEffects",
            value: function getRegisteredEffects() {
              return this.effectConstructors;
            }
          }, {
            key: "getRegisteredShaders",
            value: function getRegisteredShaders() {
              return this.shConstructors;
            }
            /**
             * Loads a shader (if not already loaded) and returns a controller for it.
             *
             * @param shType
             * @param props
             * @returns
             */
          }, {
            key: "loadShader",
            value: function loadShader(shType, props) {
              if (!this.renderer) {
                throw new Error("Renderer is not been defined");
              }
              var ShaderClass = this.shConstructors[shType];
              if (!ShaderClass) {
                throw new Error("Shader type \"".concat(shType, "\" is not registered"));
              }
              if (this.renderer.mode === 'canvas' && ShaderClass.prototype instanceof WebGlCoreShader) {
                return this._createShaderCtr(shType, new UnsupportedShader(shType), props);
              }
              if (shType === 'DynamicShader') {
                return this.loadDynamicShader(props);
              }
              var resolvedProps = ShaderClass.resolveDefaults(props);
              var cacheKey = ShaderClass.makeCacheKey(resolvedProps) || ShaderClass.name;
              if (cacheKey && this.shCache.has(cacheKey)) {
                return this._createShaderCtr(shType, this.shCache.get(cacheKey), resolvedProps);
              }
              // @ts-expect-error ShaderClass WILL accept a Renderer
              var shader = new ShaderClass(this.renderer, props);
              if (cacheKey) {
                this.shCache.set(cacheKey, shader);
              }
              return this._createShaderCtr(shType, shader, resolvedProps);
            }
          }, {
            key: "loadDynamicShader",
            value: function loadDynamicShader(props) {
              if (!this.renderer) {
                throw new Error("Renderer is not been defined");
              }
              var resolvedProps = DynamicShader.resolveDefaults(props, this.effectConstructors);
              var cacheKey = DynamicShader.makeCacheKey(resolvedProps, this.effectConstructors);
              if (cacheKey && this.shCache.has(cacheKey)) {
                return this._createDynShaderCtr(this.shCache.get(cacheKey), resolvedProps);
              }
              var shader = new DynamicShader(this.renderer, props, this.effectConstructors);
              if (cacheKey) {
                this.shCache.set(cacheKey, shader);
              }
              return this._createDynShaderCtr(shader, resolvedProps);
            }
          }, {
            key: "_createShaderCtr",
            value: function _createShaderCtr(type, shader, props) {
              return new ShaderController(type, shader, props, this.renderer.stage);
            }
          }, {
            key: "_createDynShaderCtr",
            value: function _createDynShaderCtr(shader, props) {
              shader.bindUniformMethods(props);
              return new DynamicShaderController(shader, props, this);
            }
          }, {
            key: "useShader",
            value: function useShader(shader) {
              if (this.attachedShader === shader) {
                return;
              }
              if (this.attachedShader) {
                this.attachedShader.detach();
              }
              shader.attach();
              this.attachedShader = shader;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var trPropSetterDefaults = {
          x: function x(state, value) {
            state.props.x = value;
          },
          y: function y(state, value) {
            state.props.y = value;
          },
          width: function width(state, value) {
            state.props.width = value;
          },
          height: function height(state, value) {
            state.props.height = value;
          },
          color: function color(state, value) {
            state.props.color = value;
          },
          zIndex: function zIndex(state, value) {
            state.props.zIndex = value;
          },
          fontFamily: function fontFamily(state, value) {
            state.props.fontFamily = value;
          },
          fontWeight: function fontWeight(state, value) {
            state.props.fontWeight = value;
          },
          fontStyle: function fontStyle(state, value) {
            state.props.fontStyle = value;
          },
          fontStretch: function fontStretch(state, value) {
            state.props.fontStretch = value;
          },
          fontSize: function fontSize(state, value) {
            state.props.fontSize = value;
          },
          text: function text(state, value) {
            state.props.text = value;
          },
          textAlign: function textAlign(state, value) {
            state.props.textAlign = value;
          },
          contain: function contain(state, value) {
            state.props.contain = value;
          },
          offsetY: function offsetY(state, value) {
            state.props.offsetY = value;
          },
          scrollable: function scrollable(state, value) {
            state.props.scrollable = value;
          },
          scrollY: function scrollY(state, value) {
            state.props.scrollY = value;
          },
          letterSpacing: function letterSpacing(state, value) {
            state.props.letterSpacing = value;
          },
          lineHeight: function lineHeight(state, value) {
            state.props.lineHeight = value;
          },
          maxLines: function maxLines(state, value) {
            state.props.maxLines = value;
          },
          textBaseline: function textBaseline(state, value) {
            state.props.textBaseline = value;
          },
          verticalAlign: function verticalAlign(state, value) {
            state.props.verticalAlign = value;
          },
          overflowSuffix: function overflowSuffix(state, value) {
            state.props.overflowSuffix = value;
          },
          debug: function debug(state, value) {
            state.props.debug = value;
          }
        };
        var TextRenderer = /*#__PURE__*/function () {
          function TextRenderer(stage) {
            var _this40 = this;
            _classCallCheck(this, TextRenderer);
            _defineProperty(this, "stage", void 0);
            _defineProperty(this, "set", void 0);
            this.stage = stage;
            var propSetters = _objectSpread(_objectSpread({}, trPropSetterDefaults), this.getPropertySetters());
            // For each prop setter add a wrapper method that checks if the prop is
            // different before calling the setter
            var propSet = {};
            Object.keys(propSetters).forEach(function (key) {
              Object.defineProperty(propSet, key, {
                value: function value(state, _value) {
                  // Check if the current prop value is different before calling the setter
                  if (state.props[key] !== _value) {
                    propSetters[key](state, _value);
                    // Assume any prop change will require a render
                    // This ensures that renders are triggered appropriately even with RAF paused
                    _this40.stage.requestRender();
                  }
                },
                writable: false,
                // Prevents property from being changed
                configurable: false // Prevents property from being deleted
              });
            });
            this.set = propSet;
          }
          return _createClass(TextRenderer, [{
            key: "setStatus",
            value: function setStatus(state, status, error) {
              // Don't emit the same status twice
              if (state.status === status) {
                return;
              }
              state.status = status;
              state.emitter.emit(status, error);
            }
            /**
             * Allows the CoreTextNode to communicate changes to the isRenderable state of
             * the itself.
             *
             * @param state
             * @param renderable
             */
          }, {
            key: "setIsRenderable",
            value: function setIsRenderable(state, renderable) {
              state.isRenderable = renderable;
            }
            /**
             * Destroy/Clean up the state object
             *
             * @remarks
             * Opposite of createState(). Frees any event listeners / resources held by
             * the state that may not reliably get garbage collected.
             *
             * @param state
             */
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              this.setStatus(state, 'destroyed');
              state.emitter.removeAllListeners();
            }
            /**
             * Schedule a state update via queueMicrotask
             *
             * @remarks
             * This method is used to schedule a state update via queueMicrotask. This
             * method should be called whenever a state update is needed, and it will
             * ensure that the state is only updated once per microtask.
             * @param state
             * @returns
             */
          }, {
            key: "scheduleUpdateState",
            value: function scheduleUpdateState(state) {
              var _this41 = this;
              if (state.updateScheduled) {
                return;
              }
              state.updateScheduled = true;
              queueMicrotask(function () {
                // If the state has been destroyed, don't update it
                if (state.status === 'destroyed') {
                  return;
                }
                state.updateScheduled = false;
                _this41.updateState(state);
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Class that keeps track of the invocations of Context methods when
         * the `enableContextSpy` renderer option is enabled.
         */
        var ContextSpy = /*#__PURE__*/function () {
          function ContextSpy() {
            _classCallCheck(this, ContextSpy);
            _defineProperty(this, "data", {});
          }
          return _createClass(ContextSpy, [{
            key: "reset",
            value: function reset() {
              this.data = {};
            }
          }, {
            key: "increment",
            value: function increment(name) {
              if (!this.data[name]) {
                this.data[name] = 0;
              }
              this.data[name]++;
            }
          }, {
            key: "getData",
            value: function getData() {
              return _objectSpread({}, this.data);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2024 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * LRU (Least Recently Used) style memory manager for textures
         *
         * @remarks
         * This class is responsible for managing the memory usage of textures
         * in the Renderer. It keeps track of the memory used by each texture
         * and triggers a cleanup when the memory usage exceeds a critical
         * threshold (`criticalThreshold`).
         *
         * The cleanup process will free up non-renderable textures until the
         * memory usage is below a target threshold (`targetThresholdLevel`).
         *
         * The memory manager's clean up process will also be triggered when the
         * scene is idle for a certain amount of time (`cleanupInterval`).
         */
        var TextureMemoryManager = /*#__PURE__*/function () {
          function TextureMemoryManager(stage, settings) {
            var _this42 = this;
            _classCallCheck(this, TextureMemoryManager);
            _defineProperty(this, "stage", void 0);
            _defineProperty(this, "memUsed", 0);
            _defineProperty(this, "loadedTextures", new Map());
            _defineProperty(this, "orphanedTextures", []);
            _defineProperty(this, "criticalThreshold", void 0);
            _defineProperty(this, "targetThreshold", void 0);
            _defineProperty(this, "cleanupInterval", void 0);
            _defineProperty(this, "debugLogging", void 0);
            _defineProperty(this, "lastCleanupTime", 0);
            _defineProperty(this, "baselineMemoryAllocation", void 0);
            _defineProperty(this, "criticalCleanupRequested", false);
            _defineProperty(this, "doNotExceedCriticalThreshold", void 0);
            /**
             * The current frame time in milliseconds
             *
             * @remarks
             * This is used to determine when to perform Idle Texture Cleanups.
             *
             * Set by stage via `updateFrameTime` method.
             */
            _defineProperty(this, "frameTime", 0);
            this.stage = stage;
            var criticalThreshold = settings.criticalThreshold,
              doNotExceedCriticalThreshold = settings.doNotExceedCriticalThreshold;
            this.doNotExceedCriticalThreshold = doNotExceedCriticalThreshold || false;
            this.criticalThreshold = Math.round(criticalThreshold);
            var targetFraction = Math.max(0, Math.min(1, settings.targetThresholdLevel));
            this.cleanupInterval = settings.cleanupInterval;
            this.debugLogging = settings.debugLogging;
            this.baselineMemoryAllocation = Math.round(settings.baselineMemoryAllocation);
            this.targetThreshold = Math.max(Math.round(criticalThreshold * targetFraction), this.baselineMemoryAllocation);
            this.memUsed = Math.round(settings.baselineMemoryAllocation);
            if (settings.debugLogging) {
              var lastMemUse = 0;
              setInterval(function () {
                if (lastMemUse !== _this42.memUsed) {
                  lastMemUse = _this42.memUsed;
                  console.log("[TextureMemoryManager] Memory used: ".concat(bytesToMb$1(_this42.memUsed), " mb / ").concat(bytesToMb$1(_this42.criticalThreshold), " mb (").concat((_this42.memUsed / _this42.criticalThreshold * 100).toFixed(1), "%)"));
                }
              }, 1000);
            }
            // If the threshold is 0, we disable the memory manager by replacing the
            // setTextureMemUse method with a no-op function.
            if (criticalThreshold === 0) {
              this.setTextureMemUse = function () {};
            }
          }
          /**
           * Add a texture to the orphaned textures list
           *
           * @param texture - The texture to add to the orphaned textures list
           */
          return _createClass(TextureMemoryManager, [{
            key: "addToOrphanedTextures",
            value: function addToOrphanedTextures(texture) {
              // if the texture is already in the orphaned textures list add it at the end
              if (this.orphanedTextures.includes(texture)) {
                this.removeFromOrphanedTextures(texture);
              }
              // If the texture can be cleaned up, add it to the orphaned textures list
              if (texture.preventCleanup === false) {
                this.orphanedTextures.push(texture);
              }
            }
            /**
             * Remove a texture from the orphaned textures list
             *
             * @param texture - The texture to remove from the orphaned textures list
             */
          }, {
            key: "removeFromOrphanedTextures",
            value: function removeFromOrphanedTextures(texture) {
              var index = this.orphanedTextures.indexOf(texture);
              if (index !== -1) {
                this.orphanedTextures.splice(index, 1);
              }
            }
            /**
             * Set the memory usage of a texture
             *
             * @param texture - The texture to set memory usage for
             * @param byteSize - The size of the texture in bytes
             */
          }, {
            key: "setTextureMemUse",
            value: function setTextureMemUse(texture, byteSize) {
              if (this.loadedTextures.has(texture)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.memUsed -= this.loadedTextures.get(texture);
              }
              if (byteSize === 0) {
                this.loadedTextures.delete(texture);
                return;
              } else {
                this.memUsed += byteSize;
                this.loadedTextures.set(texture, byteSize);
              }
              if (this.memUsed > this.criticalThreshold) {
                this.criticalCleanupRequested = true;
              }
            }
          }, {
            key: "checkCleanup",
            value: function checkCleanup() {
              return this.criticalCleanupRequested || this.memUsed > this.targetThreshold && this.frameTime - this.lastCleanupTime >= this.cleanupInterval;
            }
          }, {
            key: "checkCriticalCleanup",
            value: function checkCriticalCleanup() {
              return this.memUsed > this.criticalThreshold;
            }
          }, {
            key: "cleanupQuick",
            value: function cleanupQuick(critical) {
              // Free non-renderable textures until we reach the target threshold
              var memTarget = this.targetThreshold;
              var txManager = this.stage.txManager;
              var timestamp = getTimeStamp();
              while (this.memUsed >= memTarget && this.orphanedTextures.length > 0 && (critical || getTimeStamp() - timestamp < 10)) {
                var texture = this.orphanedTextures.shift();
                if (texture === undefined) {
                  continue;
                }
                if (texture.renderable === true) {
                  // If the texture is renderable, we can't free it up
                  continue;
                }
                texture.free();
                txManager.removeTextureFromCache(texture);
              }
            }
          }, {
            key: "cleanupDeep",
            value: function cleanupDeep(critical) {
              // Free non-renderable textures until we reach the target threshold
              var memTarget = critical ? this.criticalThreshold : this.targetThreshold;
              var txManager = this.stage.txManager;
              // sort by renderability
              var filteredAndSortedTextures = [];
              var textures = _toConsumableArray(this.loadedTextures.keys());
              for (var i = 0; i < textures.length; i++) {
                var texture = textures[i];
                if (texture === undefined) {
                  continue;
                }
                if (texture.type === TextureType.image || texture.type === TextureType.noise || texture.type === TextureType.renderToTexture) {
                  if (texture.renderable === true) {
                    filteredAndSortedTextures.push(texture);
                  } else {
                    filteredAndSortedTextures.unshift(texture);
                  }
                }
              }
              while (this.memUsed >= memTarget && filteredAndSortedTextures.length > 0) {
                var _texture = filteredAndSortedTextures.shift();
                if (_texture === undefined) {
                  continue;
                }
                if (_texture.preventCleanup === true) {
                  continue;
                }
                if (_texture.renderable === true) {
                  break;
                }
                _texture.free();
                this.removeFromOrphanedTextures(_texture);
                txManager.removeTextureFromCache(_texture);
                txManager.removeTextureFromQueue(_texture);
              }
            }
          }, {
            key: "cleanup",
            value: function cleanup() {
              var aggressive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var critical = this.criticalCleanupRequested;
              this.lastCleanupTime = this.frameTime;
              if (critical === true) {
                this.stage.queueFrameEvent('criticalCleanup', {
                  memUsed: this.memUsed,
                  criticalThreshold: this.criticalThreshold
                });
              }
              if (this.debugLogging === true) {
                console.log("[TextureMemoryManager] Cleaning up textures. Critical: ".concat(critical, ". Aggressive: ").concat(aggressive));
              }
              // try a quick cleanup first
              this.cleanupQuick(critical);
              // if we're still above the target threshold, do a deep cleanup
              if (aggressive === true && this.memUsed >= this.criticalThreshold) {
                this.cleanupDeep(critical);
              }
              if (this.memUsed >= this.criticalThreshold) {
                this.stage.queueFrameEvent('criticalCleanupFailed', {
                  memUsed: this.memUsed,
                  criticalThreshold: this.criticalThreshold
                });
                if (this.debugLogging === true || isProductionEnvironment() === false) {
                  console.warn("[TextureMemoryManager] Memory usage above critical threshold after cleanup: ".concat(this.memUsed));
                }
              } else {
                this.criticalCleanupRequested = false;
              }
            }
            /**
             * Get the current texture memory usage information
             *
             * @remarks
             * This method is for debugging purposes and returns information about the
             * current memory usage of the textures in the Renderer.
             */
          }, {
            key: "getMemoryInfo",
            value: function getMemoryInfo() {
              var _this43 = this;
              var renderableTexturesLoaded = 0;
              var renderableMemUsed = _toConsumableArray(this.loadedTextures.keys()).reduce(function (acc, texture) {
                renderableTexturesLoaded += texture.renderable ? 1 : 0;
                return acc + (texture.renderable ? _this43.loadedTextures.get(texture) : 0);
              }, this.baselineMemoryAllocation);
              return {
                criticalThreshold: this.criticalThreshold,
                targetThreshold: this.targetThreshold,
                renderableMemUsed: renderableMemUsed,
                memUsed: this.memUsed,
                renderableTexturesLoaded: renderableTexturesLoaded,
                loadedTextures: this.loadedTextures.size,
                baselineMemoryAllocation: this.baselineMemoryAllocation
              };
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreContextTexture = /*#__PURE__*/function () {
          function CoreContextTexture(memManager, textureSource) {
            _classCallCheck(this, CoreContextTexture);
            _defineProperty(this, "textureSource", void 0);
            _defineProperty(this, "memManager", void 0);
            _defineProperty(this, "state", 'freed');
            this.memManager = memManager;
            this.textureSource = textureSource;
          }
          return _createClass(CoreContextTexture, [{
            key: "setTextureMemUse",
            value: function setTextureMemUse(byteSize) {
              this.memManager.setTextureMemUse(this.textureSource, byteSize);
            }
          }, {
            key: "renderable",
            get: function get() {
              return this.textureSource.renderable;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreRenderer = /*#__PURE__*/_createClass(function CoreRenderer(options) {
          _classCallCheck(this, CoreRenderer);
          _defineProperty(this, "options", void 0);
          _defineProperty(this, "mode", void 0);
          _defineProperty(this, "stage", void 0);
          //// Core Managers
          _defineProperty(this, "txManager", void 0);
          _defineProperty(this, "txMemManager", void 0);
          _defineProperty(this, "shManager", void 0);
          _defineProperty(this, "rttNodes", []);
          this.options = options;
          this.stage = options.stage;
          this.txManager = options.txManager;
          this.txMemManager = options.txMemManager;
          this.shManager = options.shManager;
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * An CoreNode in the Renderer scene graph that renders text.
         *
         * @remarks
         * A Text Node is the second graphical building block of the Renderer scene
         * graph. It renders text using a specific text renderer that is automatically
         * chosen based on the font requested and what type of fonts are installed
         * into an app.
         *
         * The text renderer can be overridden by setting the `textRendererOverride`
         *
         * The `texture` and `shader` properties are managed by loaded text renderer and
         * should not be set directly.
         *
         * For non-text rendering, see {@link CoreNode}.
         */
        var CoreTextNode = /*#__PURE__*/function (_CoreNode2) {
          function CoreTextNode(stage, props, textRenderer) {
            var _this44;
            _classCallCheck(this, CoreTextNode);
            _this44 = _callSuper(this, CoreTextNode, [stage, props]);
            _defineProperty(_this44, "textRenderer", void 0);
            _defineProperty(_this44, "trState", void 0);
            _defineProperty(_this44, "_textRendererOverride", null);
            _defineProperty(_this44, "onTextLoaded", function () {
              var _this45 = _this44,
                contain = _this45.contain;
              var setWidth = _this44.trState.props.width;
              var setHeight = _this44.trState.props.height;
              var calcWidth = _this44.trState.textW || 0;
              var calcHeight = _this44.trState.textH || 0;
              if (contain === 'both') {
                _this44.props.width = setWidth;
                _this44.props.height = setHeight;
              } else if (contain === 'width') {
                _this44.props.width = setWidth;
                _this44.props.height = calcHeight;
              } else if (contain === 'none') {
                _this44.props.width = calcWidth;
                _this44.props.height = calcHeight;
              }
              _this44.updateLocalTransform();
              // Incase the RAF loop has been stopped already before text was loaded,
              // we request a render so it can be drawn.
              _this44.stage.requestRender();
              _this44.emit('loaded', {
                type: 'text',
                dimensions: {
                  width: _this44.trState.textW || 0,
                  height: _this44.trState.textH || 0
                }
              });
            });
            _defineProperty(_this44, "onTextFailed", function (target, error) {
              _this44.emit('failed', {
                type: 'text',
                error: error
              });
            });
            _this44._textRendererOverride = props.textRendererOverride;
            _this44.textRenderer = textRenderer;
            var textRendererState = _this44.createState({
              x: _this44.absX,
              y: _this44.absY,
              width: props.width,
              height: props.height,
              textAlign: props.textAlign,
              color: props.color,
              zIndex: props.zIndex,
              contain: props.contain,
              scrollable: props.scrollable,
              scrollY: props.scrollY,
              offsetY: props.offsetY,
              letterSpacing: props.letterSpacing,
              debug: props.debug,
              fontFamily: props.fontFamily,
              fontSize: props.fontSize,
              fontStretch: props.fontStretch,
              fontStyle: props.fontStyle,
              fontWeight: props.fontWeight,
              text: props.text,
              lineHeight: props.lineHeight,
              maxLines: props.maxLines,
              textBaseline: props.textBaseline,
              verticalAlign: props.verticalAlign,
              overflowSuffix: props.overflowSuffix
            });
            _this44.trState = textRendererState;
            return _this44;
          }
          _inherits(CoreTextNode, _CoreNode2);
          return _createClass(CoreTextNode, [{
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              this.props.width = value;
              this.textRenderer.set.width(this.trState, value);
              // If not containing, we must update the local transform to account for the
              // new width
              if (this.contain === 'none') {
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              this.props.height = value;
              this.textRenderer.set.height(this.trState, value);
              // If not containing in the horizontal direction, we must update the local
              // transform to account for the new height
              if (this.contain !== 'both') {
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "color",
            get: function get() {
              return this.trState.props.color;
            },
            set: function set(value) {
              this.textRenderer.set.color(this.trState, value);
            }
          }, {
            key: "text",
            get: function get() {
              return this.trState.props.text;
            },
            set: function set(value) {
              this.textRenderer.set.text(this.trState, value);
            }
          }, {
            key: "textRendererOverride",
            get: function get() {
              return this._textRendererOverride;
            },
            set: function set(value) {
              this._textRendererOverride = value;
              this.textRenderer.destroyState(this.trState);
              var textRenderer = this.stage.resolveTextRenderer(this.trState.props, this._textRendererOverride);
              if (!textRenderer) {
                console.warn('Text Renderer not found for font', this.trState.props.fontFamily);
                return;
              }
              this.textRenderer = textRenderer;
              this.trState = this.createState(this.trState.props);
            }
          }, {
            key: "fontSize",
            get: function get() {
              return this.trState.props.fontSize;
            },
            set: function set(value) {
              this.textRenderer.set.fontSize(this.trState, value);
            }
          }, {
            key: "fontFamily",
            get: function get() {
              return this.trState.props.fontFamily;
            },
            set: function set(value) {
              this.textRenderer.set.fontFamily(this.trState, value);
            }
          }, {
            key: "fontStretch",
            get: function get() {
              return this.trState.props.fontStretch;
            },
            set: function set(value) {
              this.textRenderer.set.fontStretch(this.trState, value);
            }
          }, {
            key: "fontStyle",
            get: function get() {
              return this.trState.props.fontStyle;
            },
            set: function set(value) {
              this.textRenderer.set.fontStyle(this.trState, value);
            }
          }, {
            key: "fontWeight",
            get: function get() {
              return this.trState.props.fontWeight;
            },
            set: function set(value) {
              this.textRenderer.set.fontWeight(this.trState, value);
            }
          }, {
            key: "textAlign",
            get: function get() {
              return this.trState.props.textAlign;
            },
            set: function set(value) {
              this.textRenderer.set.textAlign(this.trState, value);
            }
          }, {
            key: "contain",
            get: function get() {
              return this.trState.props.contain;
            },
            set: function set(value) {
              this.textRenderer.set.contain(this.trState, value);
            }
          }, {
            key: "scrollable",
            get: function get() {
              return this.trState.props.scrollable;
            },
            set: function set(value) {
              this.textRenderer.set.scrollable(this.trState, value);
            }
          }, {
            key: "scrollY",
            get: function get() {
              return this.trState.props.scrollY;
            },
            set: function set(value) {
              this.textRenderer.set.scrollY(this.trState, value);
            }
          }, {
            key: "offsetY",
            get: function get() {
              return this.trState.props.offsetY;
            },
            set: function set(value) {
              this.textRenderer.set.offsetY(this.trState, value);
            }
          }, {
            key: "letterSpacing",
            get: function get() {
              return this.trState.props.letterSpacing;
            },
            set: function set(value) {
              this.textRenderer.set.letterSpacing(this.trState, value);
            }
          }, {
            key: "lineHeight",
            get: function get() {
              return this.trState.props.lineHeight;
            },
            set: function set(value) {
              this.textRenderer.set.lineHeight(this.trState, value);
            }
          }, {
            key: "maxLines",
            get: function get() {
              return this.trState.props.maxLines;
            },
            set: function set(value) {
              this.textRenderer.set.maxLines(this.trState, value);
            }
          }, {
            key: "textBaseline",
            get: function get() {
              return this.trState.props.textBaseline;
            },
            set: function set(value) {
              this.textRenderer.set.textBaseline(this.trState, value);
            }
          }, {
            key: "verticalAlign",
            get: function get() {
              return this.trState.props.verticalAlign;
            },
            set: function set(value) {
              this.textRenderer.set.verticalAlign(this.trState, value);
            }
          }, {
            key: "overflowSuffix",
            get: function get() {
              return this.trState.props.overflowSuffix;
            },
            set: function set(value) {
              this.textRenderer.set.overflowSuffix(this.trState, value);
            }
          }, {
            key: "debug",
            get: function get() {
              return this.trState.props.debug;
            },
            set: function set(value) {
              this.textRenderer.set.debug(this.trState, value);
            }
          }, {
            key: "update",
            value: function update(delta, parentClippingRect) {
              _superPropGet(CoreTextNode, "update", this, 3)([delta, parentClippingRect]);
              assertTruthy(this.globalTransform);
              // globalTransform is updated in super.update(delta)
              this.textRenderer.set.x(this.trState, this.globalTransform.tx);
              this.textRenderer.set.y(this.trState, this.globalTransform.ty);
            }
          }, {
            key: "checkBasicRenderability",
            value: function checkBasicRenderability() {
              if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
                return false;
              }
              if (this.trState && this.trState.props.text !== '') {
                return true;
              }
              return false;
            }
          }, {
            key: "setRenderable",
            value: function setRenderable(isRenderable) {
              _superPropGet(CoreTextNode, "setRenderable", this, 3)([isRenderable]);
              this.textRenderer.setIsRenderable(this.trState, isRenderable);
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(renderer) {
              var _this$props$parent4;
              assertTruthy(this.globalTransform);
              // If the text renderer does not support rendering quads, fallback to the
              // default renderQuads method
              if (!this.textRenderer.renderQuads) {
                _superPropGet(CoreTextNode, "renderQuads", this, 3)([renderer]);
                return;
              }
              // If the text renderer does support rendering quads, use it...
              // Prevent quad rendering if parent has a render texture
              // and this node is not the render texture
              if (this.parentHasRenderTexture) {
                if (!renderer.renderToTextureActive) {
                  return;
                }
                // Prevent quad rendering if parent render texture is not the active render texture
                if (this.parentRenderTexture !== renderer.activeRttNode) {
                  return;
                }
              }
              if (this.parentHasRenderTexture && (_this$props$parent4 = this.props.parent) !== null && _this$props$parent4 !== void 0 && _this$props$parent4.rtt) {
                this.globalTransform = Matrix3d.identity();
                if (this.localTransform) {
                  this.globalTransform.multiply(this.localTransform);
                }
              }
              assertTruthy(this.globalTransform);
              this.textRenderer.renderQuads(this.trState, this.globalTransform, this.clippingRect, this.worldAlpha, this.parentHasRenderTexture, this.framebufferDimensions);
            }
            /**
             * Destroy the node and cleanup all resources
             */
          }, {
            key: "destroy",
            value: function destroy() {
              _superPropGet(CoreTextNode, "destroy", this, 3)([]);
              this.textRenderer.destroyState(this.trState);
            }
            /**
             * Resolve a text renderer and a new state based on the current text renderer props provided
             * @param props
             * @returns
             */
          }, {
            key: "createState",
            value: function createState(props) {
              var textRendererState = this.textRenderer.createState(props, this);
              textRendererState.emitter.on('loaded', this.onTextLoaded);
              textRendererState.emitter.on('failed', this.onTextFailed);
              this.textRenderer.scheduleUpdateState(textRendererState);
              return textRendererState;
            }
          }]);
        }(CoreNode);
        function santizeCustomDataMap(d) {
          var validTypes = {
            boolean: true,
            string: true,
            number: true,
            undefined: true
          };
          var keys = Object.keys(d);
          for (var i = 0; i < keys.length; i++) {
            var _key28 = keys[i];
            if (!_key28) {
              continue;
            }
            var value = d[_key28];
            var valueType = _typeof(value);
            // Typescript doesn't understand the above const valueType \_()_/
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore-next-line
            if (valueType === 'string' && value.length > 2048) {
              console.warn("Custom Data value for ".concat(_key28, " is too long, it will be truncated to 2048 characters"));
              // same here, see above comment, this can only be a string at this point
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore-next-line
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
              d[_key28] = value.substring(0, 2048);
            }
            if (!validTypes[valueType]) {
              console.warn("Custom Data value for ".concat(_key28, " is not a boolean, string, or number, it will be ignored"));
              delete d[_key28];
            }
          }
          return d;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var bufferMemory = 2e6;
        var Stage = /*#__PURE__*/function () {
          /**
           * Stage constructor
           */
          function Stage(options) {
            var _this46 = this;
            _classCallCheck(this, Stage);
            _defineProperty(this, "options", void 0);
            /// Module Instances
            _defineProperty(this, "animationManager", void 0);
            _defineProperty(this, "txManager", void 0);
            _defineProperty(this, "txMemManager", void 0);
            _defineProperty(this, "fontManager", void 0);
            _defineProperty(this, "textRenderers", void 0);
            _defineProperty(this, "shManager", void 0);
            _defineProperty(this, "renderer", void 0);
            _defineProperty(this, "root", void 0);
            _defineProperty(this, "boundsMargin", void 0);
            _defineProperty(this, "defShaderCtr", void 0);
            _defineProperty(this, "strictBound", void 0);
            _defineProperty(this, "preloadBound", void 0);
            _defineProperty(this, "strictBounds", void 0);
            _defineProperty(this, "defaultTexture", null);
            /**
             * Renderer Event Bus for the Stage to emit events onto
             *
             * @remarks
             * In reality this is just the RendererMain instance, which is an EventEmitter.
             * this allows us to directly emit events from the Stage to RendererMain
             * without having to set up forwarding handlers.
             */
            _defineProperty(this, "eventBus", void 0);
            /// State
            _defineProperty(this, "deltaTime", 0);
            _defineProperty(this, "lastFrameTime", 0);
            _defineProperty(this, "currentFrameTime", 0);
            _defineProperty(this, "fpsNumFrames", 0);
            _defineProperty(this, "fpsElapsedTime", 0);
            _defineProperty(this, "numQuadsRendered", 0);
            _defineProperty(this, "renderRequested", false);
            _defineProperty(this, "frameEventQueue", []);
            _defineProperty(this, "fontResolveMap", {});
            /// Debug data
            _defineProperty(this, "contextSpy", null);
            this.options = options;
            var canvas = options.canvas,
              clearColor = options.clearColor,
              appWidth = options.appWidth,
              appHeight = options.appHeight,
              boundsMargin = options.boundsMargin,
              enableContextSpy = options.enableContextSpy,
              forceWebGL2 = options.forceWebGL2,
              numImageWorkers = options.numImageWorkers,
              textureMemory = options.textureMemory,
              renderEngine = options.renderEngine,
              fontEngines = options.fontEngines,
              createImageBitmapSupport = options.createImageBitmapSupport;
            this.eventBus = options.eventBus;
            this.txManager = new CoreTextureManager(this, {
              numImageWorkers: numImageWorkers,
              createImageBitmapSupport: createImageBitmapSupport
            });
            // Wait for the Texture Manager to initialize
            // once it does, request a render
            this.txManager.on('initialized', function () {
              _this46.requestRender();
            });
            this.txMemManager = new TextureMemoryManager(this, textureMemory);
            this.shManager = new CoreShaderManager();
            this.animationManager = new AnimationManager();
            this.contextSpy = enableContextSpy ? new ContextSpy() : null;
            this.strictBounds = options.strictBounds;
            var bm = [0, 0, 0, 0];
            if (boundsMargin) {
              bm = Array.isArray(boundsMargin) ? boundsMargin : [boundsMargin, boundsMargin, boundsMargin, boundsMargin];
            }
            this.boundsMargin = bm;
            // precalculate our viewport bounds
            this.strictBound = createBound(0, 0, appWidth, appHeight);
            this.preloadBound = createPreloadBounds(this.strictBound, bm);
            var rendererOptions = {
              stage: this,
              canvas: canvas,
              pixelRatio: options.devicePhysicalPixelRatio * options.deviceLogicalPixelRatio,
              clearColor: clearColor !== null && clearColor !== void 0 ? clearColor : 0xff000000,
              bufferMemory: bufferMemory,
              txManager: this.txManager,
              txMemManager: this.txMemManager,
              shManager: this.shManager,
              contextSpy: this.contextSpy,
              forceWebGL2: forceWebGL2
            };
            this.renderer = new renderEngine(rendererOptions);
            var renderMode = this.renderer.mode || 'webgl';
            this.createDefaultTexture();
            this.defShaderCtr = this.renderer.getDefShaderCtr();
            setPremultiplyMode(renderMode);
            // Must do this after renderer is created
            this.txManager.renderer = this.renderer;
            // Create text renderers
            this.textRenderers = {};
            fontEngines.forEach(function (fontEngineConstructor) {
              var fontEngineInstance = new fontEngineConstructor(_this46);
              var className = fontEngineInstance.type;
              if (className === 'sdf' && renderMode === 'canvas') {
                console.warn('SdfTextRenderer is not compatible with Canvas renderer. Skipping...');
                return;
              }
              if (fontEngineInstance instanceof TextRenderer) {
                if (className === 'canvas') {
                  _this46.textRenderers['canvas'] = fontEngineInstance;
                } else if (className === 'sdf') {
                  _this46.textRenderers['sdf'] = fontEngineInstance;
                }
              }
            });
            if (Object.keys(this.textRenderers).length === 0) {
              console.warn('No text renderers available. Your text will not render.');
            }
            this.fontManager = new TrFontManager(this.textRenderers);
            // create root node
            var rootNode = new CoreNode(this, {
              x: 0,
              y: 0,
              width: appWidth,
              height: appHeight,
              alpha: 1,
              autosize: false,
              boundsMargin: null,
              clipping: false,
              color: 0x00000000,
              colorTop: 0x00000000,
              colorBottom: 0x00000000,
              colorLeft: 0x00000000,
              colorRight: 0x00000000,
              colorTl: 0x00000000,
              colorTr: 0x00000000,
              colorBl: 0x00000000,
              colorBr: 0x00000000,
              zIndex: 0,
              zIndexLocked: 0,
              scaleX: 1,
              scaleY: 1,
              mountX: 0,
              mountY: 0,
              mount: 0,
              pivot: 0.5,
              pivotX: 0.5,
              pivotY: 0.5,
              rotation: 0,
              parent: null,
              texture: null,
              textureOptions: {},
              shader: this.defShaderCtr,
              rtt: false,
              src: null,
              scale: 1,
              preventCleanup: false,
              strictBounds: this.strictBounds
            });
            this.root = rootNode;
            // execute platform start loop
            {
              startLoop(this);
            }
          }
          return _createClass(Stage, [{
            key: "setClearColor",
            value: function setClearColor(color) {
              this.renderer.updateClearColor(color);
              this.renderRequested = true;
            }
          }, {
            key: "updateFrameTime",
            value: function updateFrameTime() {
              var newFrameTime = getTimeStamp();
              this.lastFrameTime = this.currentFrameTime;
              this.currentFrameTime = newFrameTime;
              this.deltaTime = !this.lastFrameTime ? 100 / 6 : newFrameTime - this.lastFrameTime;
              this.txManager.frameTime = newFrameTime;
              this.txMemManager.frameTime = newFrameTime;
              // This event is emitted at the beginning of the frame (before any updates
              // or rendering), so no need to to use `stage.queueFrameEvent` here.
              this.eventBus.emit('frameTick', {
                time: this.currentFrameTime,
                delta: this.deltaTime
              });
            }
            /**
             * Create default PixelTexture
             */
          }, {
            key: "createDefaultTexture",
            value: function createDefaultTexture() {
              var _this47 = this;
              console.log('Creating default texture');
              this.defaultTexture = this.txManager.createTexture('ColorTexture', {
                color: 0xffffffff
              });
              assertTruthy(this.defaultTexture instanceof ColorTexture);
              this.txManager.loadTexture(this.defaultTexture, true);
              // Mark the default texture as ALWAYS renderable
              // This prevents it from ever being cleaned up.
              // Fixes https://github.com/lightning-js/renderer/issues/262
              this.defaultTexture.setRenderableOwner(this, true);
              // When the default texture is loaded, request a render in case the
              // RAF is paused. Fixes: https://github.com/lightning-js/renderer/issues/123
              this.defaultTexture.once('loaded', function () {
                _this47.requestRender();
              });
            }
            /**
             * Update animations
             */
          }, {
            key: "updateAnimations",
            value: function updateAnimations() {
              var animationManager = this.animationManager;
              if (!this.root) {
                return;
              }
              // step animation
              animationManager.update(this.deltaTime);
            }
            /**
             * Check if the scene has updates
             */
          }, {
            key: "hasSceneUpdates",
            value: function hasSceneUpdates() {
              return !!this.root.updateType || this.renderRequested || this.txManager.hasUpdates();
            }
            /**
             * Start a new frame draw
             */
          }, {
            key: "drawFrame",
            value: function drawFrame() {
              var renderer = this.renderer,
                renderRequested = this.renderRequested;
              // Update tree if needed
              if (this.root.updateType !== 0) {
                this.root.update(this.deltaTime, this.root.clippingRect);
              }
              // Process some textures
              this.txManager.processSome(this.options.textureProcessingTimeLimit);
              // Reset render operations and clear the canvas
              renderer.reset();
              // Check if we need to cleanup textures
              if (this.txMemManager.criticalCleanupRequested === true) {
                this.txMemManager.cleanup(false);
                if (this.txMemManager.criticalCleanupRequested === true) {
                  // If we still need to cleanup, request another but aggressive cleanup
                  this.txMemManager.cleanup(true);
                }
              }
              // If we have RTT nodes draw them first
              // So we can use them as textures in the main scene
              if (renderer.rttNodes.length > 0) {
                renderer.renderRTTNodes();
              }
              // Fill quads buffer
              this.addQuads(this.root);
              // Perform render pass
              renderer === null || renderer === void 0 || renderer.render();
              this.calculateFps();
              this.calculateQuads();
              // Reset renderRequested flag if it was set
              if (renderRequested) {
                this.renderRequested = false;
              }
            }
            /**
             * Queue an event to be emitted after the current/next frame is rendered
             *
             * @remarks
             * When we are operating in the context of the render loop, we may want to
             * emit events that are related to the current frame. However, we generally do
             * NOT want to emit events directly in the middle of the render loop, since
             * this could enable event handlers to modify the scene graph and cause
             * unexpected behavior. Instead, we queue up events to be emitted and then
             * flush the queue after the frame has been rendered.
             *
             * @param name
             * @param data
             */
          }, {
            key: "queueFrameEvent",
            value: function queueFrameEvent(name, data) {
              this.frameEventQueue.push([name, data]);
            }
            /**
             * Emit all queued frame events
             *
             * @remarks
             * This method should be called after the frame has been rendered to emit
             * all events that were queued during the frame.
             *
             * See {@link queueFrameEvent} for more information.
             */
          }, {
            key: "flushFrameEvents",
            value: function flushFrameEvents() {
              var _iterator10 = _createForOfIteratorHelper(this.frameEventQueue),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var _step10$value = _slicedToArray(_step10.value, 2),
                    name = _step10$value[0],
                    data = _step10$value[1];
                  this.eventBus.emit(name, data);
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
              this.frameEventQueue = [];
            }
          }, {
            key: "calculateFps",
            value: function calculateFps() {
              // If there's an FPS update interval, emit the FPS update event
              // when the specified interval has elapsed.
              var fpsUpdateInterval = this.options.fpsUpdateInterval;
              if (fpsUpdateInterval) {
                this.fpsNumFrames++;
                this.fpsElapsedTime += this.deltaTime;
                if (this.fpsElapsedTime >= fpsUpdateInterval) {
                  var _this$contextSpy$getD, _this$contextSpy, _this$contextSpy2;
                  var _fps = Math.round(this.fpsNumFrames * 1000 / this.fpsElapsedTime);
                  this.fpsNumFrames = 0;
                  this.fpsElapsedTime = 0;
                  this.queueFrameEvent('fpsUpdate', {
                    fps: _fps,
                    contextSpyData: (_this$contextSpy$getD = (_this$contextSpy = this.contextSpy) === null || _this$contextSpy === void 0 ? void 0 : _this$contextSpy.getData()) !== null && _this$contextSpy$getD !== void 0 ? _this$contextSpy$getD : null
                  });
                  (_this$contextSpy2 = this.contextSpy) === null || _this$contextSpy2 === void 0 || _this$contextSpy2.reset();
                }
              }
            }
          }, {
            key: "calculateQuads",
            value: function calculateQuads() {
              var quads = this.renderer.getQuadCount();
              if (quads && quads !== this.numQuadsRendered) {
                this.numQuadsRendered = quads;
                this.queueFrameEvent('quadsUpdate', {
                  quads: quads
                });
              }
            }
          }, {
            key: "addQuads",
            value: function addQuads(node) {
              assertTruthy(this.renderer);
              // If the node is renderable and has a loaded texture, render it
              if (node.isRenderable === true) {
                node.renderQuads(this.renderer);
              }
              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                if (child === undefined) {
                  continue;
                }
                if (child.worldAlpha === 0 || child.strictBounds === true && child.renderState === CoreNodeRenderState.OutOfBounds) {
                  continue;
                }
                this.addQuads(child);
              }
            }
            /**
             * Request a render pass without forcing an update
             */
          }, {
            key: "requestRender",
            value: function requestRender() {
              this.renderRequested = true;
            }
            /**
             * Given a font name, and possible renderer override, return the best compatible text renderer.
             *
             * @remarks
             * Will try to return a canvas renderer if no other suitable renderer can be resolved.
             *
             * @param fontFamily
             * @param textRendererOverride
             * @returns
             */
          }, {
            key: "resolveTextRenderer",
            value: function resolveTextRenderer(trProps) {
              var textRendererOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var fontCacheString = "".concat(trProps.fontFamily).concat(trProps.fontStyle).concat(trProps.fontWeight).concat(trProps.fontStretch).concat(textRendererOverride ? textRendererOverride : '');
              // check our resolve cache first
              if (this.fontResolveMap[fontCacheString] !== undefined) {
                return this.fontResolveMap[fontCacheString];
              }
              // Resolve the text renderer
              var rendererId = textRendererOverride;
              var overrideFallback = false;
              // Check if the override is valid (if one is provided)
              if (rendererId) {
                var possibleRenderer = this.textRenderers[rendererId];
                if (!possibleRenderer) {
                  console.warn("Text renderer override '".concat(rendererId, "' not found."));
                  rendererId = null;
                  overrideFallback = true;
                } else if (!possibleRenderer.canRenderFont(trProps)) {
                  console.warn("Cannot use override text renderer '".concat(rendererId, "' for font"), trProps);
                  rendererId = null;
                  overrideFallback = true;
                }
              }
              if (!rendererId) {
                // Iterate through the text renderers and find the first one that can render the font
                for (var _i = 0, _Object$entries = Object.entries(this.textRenderers); _i < _Object$entries.length; _i++) {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                    trId = _Object$entries$_i[0],
                    tr = _Object$entries$_i[1];
                  if (tr.canRenderFont(trProps)) {
                    rendererId = trId;
                    break;
                  }
                }
                if (!rendererId && this.textRenderers.canvas !== undefined) {
                  // If no renderer can be found, use the canvas renderer
                  rendererId = 'canvas';
                }
              }
              if (overrideFallback) {
                console.warn("Falling back to text renderer ".concat(String(rendererId)));
              }
              if (!rendererId) {
                // silently fail if no renderer can be found, the error is already created
                // at the constructor level
                return null;
              }
              // By now we are guaranteed to have a valid rendererId (at least Canvas);
              var resolvedTextRenderer = this.textRenderers[rendererId];
              // cache the resolved renderer for future use with these trProps
              this.fontResolveMap[fontCacheString] = resolvedTextRenderer;
              // Need to explicitly cast to TextRenderer because TS doesn't like
              // the covariant state argument in the setter method map
              return resolvedTextRenderer;
            }
            /**
             * Create a shader controller instance
             *
             * @param type
             * @param props
             * @returns
             */
          }, {
            key: "createShaderCtr",
            value: function createShaderCtr(type, props) {
              return this.shManager.loadShader(type, props);
            }
          }, {
            key: "createNode",
            value: function createNode(props) {
              var resolvedProps = this.resolveNodeDefaults(props);
              return new CoreNode(this, resolvedProps);
            }
          }, {
            key: "createTextNode",
            value: function createTextNode(props) {
              var _props$fontSize, _props$text, _props$textRendererOv, _props$fontFamily, _props$fontStyle, _props$fontWeight, _props$fontStretch, _props$textAlign, _props$contain, _props$scrollable, _props$scrollY2, _props$offsetY, _props$letterSpacing, _props$maxLines, _props$textBaseline, _props$verticalAlign, _props$overflowSuffix, _props$debug2;
              var fontSize = (_props$fontSize = props.fontSize) !== null && _props$fontSize !== void 0 ? _props$fontSize : 16;
              var resolvedProps = _objectSpread(_objectSpread({}, this.resolveNodeDefaults(props)), {}, {
                text: (_props$text = props.text) !== null && _props$text !== void 0 ? _props$text : '',
                textRendererOverride: (_props$textRendererOv = props.textRendererOverride) !== null && _props$textRendererOv !== void 0 ? _props$textRendererOv : null,
                fontSize: fontSize,
                fontFamily: (_props$fontFamily = props.fontFamily) !== null && _props$fontFamily !== void 0 ? _props$fontFamily : 'sans-serif',
                fontStyle: (_props$fontStyle = props.fontStyle) !== null && _props$fontStyle !== void 0 ? _props$fontStyle : 'normal',
                fontWeight: (_props$fontWeight = props.fontWeight) !== null && _props$fontWeight !== void 0 ? _props$fontWeight : 'normal',
                fontStretch: (_props$fontStretch = props.fontStretch) !== null && _props$fontStretch !== void 0 ? _props$fontStretch : 'normal',
                textAlign: (_props$textAlign = props.textAlign) !== null && _props$textAlign !== void 0 ? _props$textAlign : 'left',
                contain: (_props$contain = props.contain) !== null && _props$contain !== void 0 ? _props$contain : 'none',
                scrollable: (_props$scrollable = props.scrollable) !== null && _props$scrollable !== void 0 ? _props$scrollable : false,
                scrollY: (_props$scrollY2 = props.scrollY) !== null && _props$scrollY2 !== void 0 ? _props$scrollY2 : 0,
                offsetY: (_props$offsetY = props.offsetY) !== null && _props$offsetY !== void 0 ? _props$offsetY : 0,
                letterSpacing: (_props$letterSpacing = props.letterSpacing) !== null && _props$letterSpacing !== void 0 ? _props$letterSpacing : 0,
                lineHeight: props.lineHeight,
                // `undefined` is a valid value
                maxLines: (_props$maxLines = props.maxLines) !== null && _props$maxLines !== void 0 ? _props$maxLines : 0,
                textBaseline: (_props$textBaseline = props.textBaseline) !== null && _props$textBaseline !== void 0 ? _props$textBaseline : 'alphabetic',
                verticalAlign: (_props$verticalAlign = props.verticalAlign) !== null && _props$verticalAlign !== void 0 ? _props$verticalAlign : 'middle',
                overflowSuffix: (_props$overflowSuffix = props.overflowSuffix) !== null && _props$overflowSuffix !== void 0 ? _props$overflowSuffix : '...',
                debug: (_props$debug2 = props.debug) !== null && _props$debug2 !== void 0 ? _props$debug2 : {},
                shaderProps: null
              });
              var resolvedTextRenderer = this.resolveTextRenderer(resolvedProps, props.textRendererOverride);
              if (!resolvedTextRenderer) {
                throw new Error("No compatible text renderer found for ".concat(resolvedProps.fontFamily));
              }
              return new CoreTextNode(this, resolvedProps, resolvedTextRenderer);
            }
          }, {
            key: "setBoundsMargin",
            value: function setBoundsMargin(value) {
              this.boundsMargin = Array.isArray(value) ? value : [value, value, value, value];
              this.root.setUpdateType(UpdateType.RenderBounds);
            }
            /**
             * Resolves the default property values for a Node
             *
             * @remarks
             * This method is used internally by the RendererMain to resolve the default
             * property values for a Node. It is exposed publicly so that it can be used
             * by Core Driver implementations.
             *
             * @param props
             * @returns
             */
          }, {
            key: "resolveNodeDefaults",
            value: function resolveNodeDefaults(props) {
              var _props$color8, _ref9, _ref10, _props$colorTl, _ref11, _ref12, _props$colorTr, _ref13, _ref14, _props$colorBl, _ref15, _ref16, _props$colorBr, _props$x, _props$y, _props$width10, _props$height4, _props$alpha, _props$autosize, _props$boundsMargin, _props$clipping, _props$colorTop, _props$colorBottom, _props$colorLeft, _props$colorRight, _props$zIndex, _props$zIndexLocked, _props$parent3, _props$texture, _props$textureOptions, _props$shader, _props$src2, _props$scale, _ref17, _props$scaleX, _ref18, _props$scaleY, _props$mount, _ref19, _props$mountX, _ref20, _props$mountY, _props$pivot2, _ref21, _props$pivotX, _ref22, _props$pivotY, _props$rotation, _props$rtt, _props$preventCleanup, _props$strictBounds;
              var color = (_props$color8 = props.color) !== null && _props$color8 !== void 0 ? _props$color8 : 0xffffffff;
              var colorTl = (_ref9 = (_ref10 = (_props$colorTl = props.colorTl) !== null && _props$colorTl !== void 0 ? _props$colorTl : props.colorTop) !== null && _ref10 !== void 0 ? _ref10 : props.colorLeft) !== null && _ref9 !== void 0 ? _ref9 : color;
              var colorTr = (_ref11 = (_ref12 = (_props$colorTr = props.colorTr) !== null && _props$colorTr !== void 0 ? _props$colorTr : props.colorTop) !== null && _ref12 !== void 0 ? _ref12 : props.colorRight) !== null && _ref11 !== void 0 ? _ref11 : color;
              var colorBl = (_ref13 = (_ref14 = (_props$colorBl = props.colorBl) !== null && _props$colorBl !== void 0 ? _props$colorBl : props.colorBottom) !== null && _ref14 !== void 0 ? _ref14 : props.colorLeft) !== null && _ref13 !== void 0 ? _ref13 : color;
              var colorBr = (_ref15 = (_ref16 = (_props$colorBr = props.colorBr) !== null && _props$colorBr !== void 0 ? _props$colorBr : props.colorBottom) !== null && _ref16 !== void 0 ? _ref16 : props.colorRight) !== null && _ref15 !== void 0 ? _ref15 : color;
              var data = {};
              if (this.options.inspector === true) {
                var _props$data;
                data = santizeCustomDataMap((_props$data = props.data) !== null && _props$data !== void 0 ? _props$data : {});
              }
              return {
                x: (_props$x = props.x) !== null && _props$x !== void 0 ? _props$x : 0,
                y: (_props$y = props.y) !== null && _props$y !== void 0 ? _props$y : 0,
                width: (_props$width10 = props.width) !== null && _props$width10 !== void 0 ? _props$width10 : 0,
                height: (_props$height4 = props.height) !== null && _props$height4 !== void 0 ? _props$height4 : 0,
                alpha: (_props$alpha = props.alpha) !== null && _props$alpha !== void 0 ? _props$alpha : 1,
                autosize: (_props$autosize = props.autosize) !== null && _props$autosize !== void 0 ? _props$autosize : false,
                boundsMargin: (_props$boundsMargin = props.boundsMargin) !== null && _props$boundsMargin !== void 0 ? _props$boundsMargin : null,
                clipping: (_props$clipping = props.clipping) !== null && _props$clipping !== void 0 ? _props$clipping : false,
                color: color,
                colorTop: (_props$colorTop = props.colorTop) !== null && _props$colorTop !== void 0 ? _props$colorTop : color,
                colorBottom: (_props$colorBottom = props.colorBottom) !== null && _props$colorBottom !== void 0 ? _props$colorBottom : color,
                colorLeft: (_props$colorLeft = props.colorLeft) !== null && _props$colorLeft !== void 0 ? _props$colorLeft : color,
                colorRight: (_props$colorRight = props.colorRight) !== null && _props$colorRight !== void 0 ? _props$colorRight : color,
                colorBl: colorBl,
                colorBr: colorBr,
                colorTl: colorTl,
                colorTr: colorTr,
                zIndex: (_props$zIndex = props.zIndex) !== null && _props$zIndex !== void 0 ? _props$zIndex : 0,
                zIndexLocked: (_props$zIndexLocked = props.zIndexLocked) !== null && _props$zIndexLocked !== void 0 ? _props$zIndexLocked : 0,
                parent: (_props$parent3 = props.parent) !== null && _props$parent3 !== void 0 ? _props$parent3 : null,
                texture: (_props$texture = props.texture) !== null && _props$texture !== void 0 ? _props$texture : null,
                textureOptions: (_props$textureOptions = props.textureOptions) !== null && _props$textureOptions !== void 0 ? _props$textureOptions : {},
                shader: (_props$shader = props.shader) !== null && _props$shader !== void 0 ? _props$shader : this.defShaderCtr,
                // Since setting the `src` will trigger a texture load, we need to set it after
                // we set the texture. Otherwise, problems happen.
                src: (_props$src2 = props.src) !== null && _props$src2 !== void 0 ? _props$src2 : null,
                srcHeight: props.srcHeight,
                srcWidth: props.srcWidth,
                srcX: props.srcX,
                srcY: props.srcY,
                scale: (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : null,
                scaleX: (_ref17 = (_props$scaleX = props.scaleX) !== null && _props$scaleX !== void 0 ? _props$scaleX : props.scale) !== null && _ref17 !== void 0 ? _ref17 : 1,
                scaleY: (_ref18 = (_props$scaleY = props.scaleY) !== null && _props$scaleY !== void 0 ? _props$scaleY : props.scale) !== null && _ref18 !== void 0 ? _ref18 : 1,
                mount: (_props$mount = props.mount) !== null && _props$mount !== void 0 ? _props$mount : 0,
                mountX: (_ref19 = (_props$mountX = props.mountX) !== null && _props$mountX !== void 0 ? _props$mountX : props.mount) !== null && _ref19 !== void 0 ? _ref19 : 0,
                mountY: (_ref20 = (_props$mountY = props.mountY) !== null && _props$mountY !== void 0 ? _props$mountY : props.mount) !== null && _ref20 !== void 0 ? _ref20 : 0,
                pivot: (_props$pivot2 = props.pivot) !== null && _props$pivot2 !== void 0 ? _props$pivot2 : 0.5,
                pivotX: (_ref21 = (_props$pivotX = props.pivotX) !== null && _props$pivotX !== void 0 ? _props$pivotX : props.pivot) !== null && _ref21 !== void 0 ? _ref21 : 0.5,
                pivotY: (_ref22 = (_props$pivotY = props.pivotY) !== null && _props$pivotY !== void 0 ? _props$pivotY : props.pivot) !== null && _ref22 !== void 0 ? _ref22 : 0.5,
                rotation: (_props$rotation = props.rotation) !== null && _props$rotation !== void 0 ? _props$rotation : 0,
                rtt: (_props$rtt = props.rtt) !== null && _props$rtt !== void 0 ? _props$rtt : false,
                data: data,
                preventCleanup: (_props$preventCleanup = props.preventCleanup) !== null && _props$preventCleanup !== void 0 ? _props$preventCleanup : false,
                imageType: props.imageType,
                strictBounds: (_props$strictBounds = props.strictBounds) !== null && _props$strictBounds !== void 0 ? _props$strictBounds : this.strictBounds
              };
            }
            /**
             * Cleanup Orphaned Textures
             *
             * @remarks
             * This method is used to cleanup orphaned textures that are no longer in use.
             */
          }, {
            key: "cleanup",
            value: function cleanup(aggressive) {
              this.txMemManager.cleanup(aggressive);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The Renderer Main API
         *
         * @remarks
         * This is the primary class used to configure and operate the Renderer.
         *
         * It is used to create and destroy Nodes, as well as Texture and Shader
         * references.
         *
         * Example:
         * ```ts
         * import { RendererMain, MainCoreDriver } from '@lightningjs/renderer';
         *
         * // Initialize the Renderer
         * const renderer = new RendererMain(
         *   {
         *     appWidth: 1920,
         *     appHeight: 1080
         *   },
         *   'app',
         *   new MainCoreDriver(),
         * );
         * ```
         *
         * ## Events
         * - `fpsUpdate`
         *   - Emitted every `fpsUpdateInterval` milliseconds with the current FPS
         * - `frameTick`
         *   - Emitted every frame tick
         * - `quadsUpdate`
         *  - Emitted when number of quads rendered is updated
         * - `idle`
         *   - Emitted when the renderer is idle (no changes to the scene
         *     graph/animations running)
         * - `criticalCleanup`
         *  - Emitted when the Texture Memory Manager Cleanup process is triggered
         *  - Payload: { memUsed: number, criticalThreshold: number }
         *    - `memUsed` - The amount of memory (in bytes) used by textures before the
         *       cleanup process
         *    - `criticalThreshold` - The critical threshold (in bytes)
         * - `criticalCleanupFailed`
         *   - Emitted when the Texture Memory Manager Cleanup process is unable to free
         *     up enough texture memory to reach below the critical threshold.
         *     This can happen when there is not enough non-renderable textures to
         *     free up.
         *   - Payload (object with keys):
         *     - `memUsed` - The amount of memory (in bytes) used by textures after
         *       the cleanup process
         *     - `criticalThreshold` - The critical threshold (in bytes)
         */
        var RendererMain = /*#__PURE__*/function (_EventEmitter7) {
          /**
           * Constructs a new Renderer instance
           *
           * @param settings Renderer settings
           * @param target Element ID or HTMLElement to insert the canvas into
           * @param driver Core Driver to use
           */
          function RendererMain(settings, target) {
            var _settings$textureMemo, _settings$textureMemo2, _settings$textureMemo3, _settings$textureMemo4, _settings$textureMemo5, _settings$textureMemo6, _settings$clearColor, _settings$enableConte, _settings$forceWebGL, _settings$inspector, _settings$quadBufferS, _settings$strictBound;
            var _this48;
            _classCallCheck(this, RendererMain);
            _this48 = _callSuper(this, RendererMain);
            _defineProperty(_this48, "root", void 0);
            _defineProperty(_this48, "canvas", void 0);
            _defineProperty(_this48, "settings", void 0);
            _defineProperty(_this48, "stage", void 0);
            _defineProperty(_this48, "inspector", null);
            var resolvedTxSettings = {
              criticalThreshold: ((_settings$textureMemo = settings.textureMemory) === null || _settings$textureMemo === void 0 ? void 0 : _settings$textureMemo.criticalThreshold) || 124e6,
              targetThresholdLevel: ((_settings$textureMemo2 = settings.textureMemory) === null || _settings$textureMemo2 === void 0 ? void 0 : _settings$textureMemo2.targetThresholdLevel) || 0.5,
              cleanupInterval: ((_settings$textureMemo3 = settings.textureMemory) === null || _settings$textureMemo3 === void 0 ? void 0 : _settings$textureMemo3.cleanupInterval) || 5000,
              debugLogging: ((_settings$textureMemo4 = settings.textureMemory) === null || _settings$textureMemo4 === void 0 ? void 0 : _settings$textureMemo4.debugLogging) || false,
              baselineMemoryAllocation: ((_settings$textureMemo5 = settings.textureMemory) === null || _settings$textureMemo5 === void 0 ? void 0 : _settings$textureMemo5.baselineMemoryAllocation) || 26e6,
              doNotExceedCriticalThreshold: ((_settings$textureMemo6 = settings.textureMemory) === null || _settings$textureMemo6 === void 0 ? void 0 : _settings$textureMemo6.doNotExceedCriticalThreshold) || false
            };
            var resolvedSettings = {
              appWidth: settings.appWidth || 1920,
              appHeight: settings.appHeight || 1080,
              textureMemory: resolvedTxSettings,
              boundsMargin: settings.boundsMargin || 0,
              deviceLogicalPixelRatio: settings.deviceLogicalPixelRatio || 1,
              devicePhysicalPixelRatio: settings.devicePhysicalPixelRatio || window.devicePixelRatio,
              clearColor: (_settings$clearColor = settings.clearColor) !== null && _settings$clearColor !== void 0 ? _settings$clearColor : 0x00000000,
              fpsUpdateInterval: settings.fpsUpdateInterval || 0,
              numImageWorkers: settings.numImageWorkers !== undefined ? settings.numImageWorkers : 2,
              enableContextSpy: (_settings$enableConte = settings.enableContextSpy) !== null && _settings$enableConte !== void 0 ? _settings$enableConte : false,
              forceWebGL2: (_settings$forceWebGL = settings.forceWebGL2) !== null && _settings$forceWebGL !== void 0 ? _settings$forceWebGL : false,
              inspector: (_settings$inspector = settings.inspector) !== null && _settings$inspector !== void 0 ? _settings$inspector : false,
              renderEngine: settings.renderEngine,
              quadBufferSize: (_settings$quadBufferS = settings.quadBufferSize) !== null && _settings$quadBufferS !== void 0 ? _settings$quadBufferS : 4 * 1024 * 1024,
              fontEngines: settings.fontEngines,
              strictBounds: (_settings$strictBound = settings.strictBounds) !== null && _settings$strictBound !== void 0 ? _settings$strictBound : true,
              textureProcessingTimeLimit: settings.textureProcessingTimeLimit || 10,
              canvas: settings.canvas || document.createElement('canvas'),
              createImageBitmapSupport: settings.createImageBitmapSupport || 'full'
            };
            _this48.settings = resolvedSettings;
            var appWidth = resolvedSettings.appWidth,
              appHeight = resolvedSettings.appHeight,
              deviceLogicalPixelRatio = resolvedSettings.deviceLogicalPixelRatio,
              devicePhysicalPixelRatio = resolvedSettings.devicePhysicalPixelRatio,
              inspector = resolvedSettings.inspector,
              canvas = resolvedSettings.canvas;
            var deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
            var deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
            _this48.canvas = canvas;
            canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
            canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
            canvas.style.width = "".concat(deviceLogicalWidth, "px");
            canvas.style.height = "".concat(deviceLogicalHeight, "px");
            // Initialize the stage
            _this48.stage = new Stage({
              appWidth: _this48.settings.appWidth,
              appHeight: _this48.settings.appHeight,
              boundsMargin: _this48.settings.boundsMargin,
              clearColor: _this48.settings.clearColor,
              canvas: _this48.canvas,
              deviceLogicalPixelRatio: _this48.settings.deviceLogicalPixelRatio,
              devicePhysicalPixelRatio: _this48.settings.devicePhysicalPixelRatio,
              enableContextSpy: _this48.settings.enableContextSpy,
              forceWebGL2: _this48.settings.forceWebGL2,
              fpsUpdateInterval: _this48.settings.fpsUpdateInterval,
              numImageWorkers: _this48.settings.numImageWorkers,
              renderEngine: _this48.settings.renderEngine,
              textureMemory: resolvedTxSettings,
              eventBus: _this48,
              quadBufferSize: _this48.settings.quadBufferSize,
              fontEngines: _this48.settings.fontEngines,
              inspector: _this48.settings.inspector !== null,
              strictBounds: _this48.settings.strictBounds,
              textureProcessingTimeLimit: _this48.settings.textureProcessingTimeLimit,
              createImageBitmapSupport: _this48.settings.createImageBitmapSupport
            });
            // Extract the root node
            _this48.root = _this48.stage.root;
            // Get the target element and attach the canvas to it
            var targetEl;
            if (typeof target === 'string') {
              targetEl = document.getElementById(target);
            } else {
              targetEl = target;
            }
            if (!targetEl) {
              throw new Error('Could not find target element');
            }
            targetEl.appendChild(canvas);
            return _this48;
          }
          /**
           * Create a new scene graph node
           *
           * @remarks
           * A node is the main graphical building block of the Renderer scene graph. It
           * can be a container for other nodes, or it can be a leaf node that renders a
           * solid color, gradient, image, or specific texture, using a specific shader.
           *
           * To create a text node, see {@link createTextNode}.
           *
           * See {@link CoreNode} for more details.
           *
           * @param props
           * @returns
           */
          _inherits(RendererMain, _EventEmitter7);
          return _createClass(RendererMain, [{
            key: "createNode",
            value: function createNode(props) {
              var node = this.stage.createNode(props);
              if (this.inspector) {
                return this.inspector.createNode(node);
              }
              // FIXME onDestroy event? node.once('beforeDestroy'
              // FIXME onCreate event?
              return node;
            }
            /**
             * Create a new scene graph text node
             *
             * @remarks
             * A text node is the second graphical building block of the Renderer scene
             * graph. It renders text using a specific text renderer that is automatically
             * chosen based on the font requested and what type of fonts are installed
             * into an app.
             *
             * See {@link ITextNode} for more details.
             *
             * @param props
             * @returns
             */
          }, {
            key: "createTextNode",
            value: function createTextNode(props) {
              var textNode = this.stage.createTextNode(props);
              if (this.inspector) {
                return this.inspector.createTextNode(textNode);
              }
              return textNode;
            }
            /**
             * Destroy a node
             *
             * @remarks
             * This method destroys a node
             *
             * @param node
             * @returns
             */
          }, {
            key: "destroyNode",
            value: function destroyNode(node) {
              if (this.inspector) {
                this.inspector.destroyNode(node.id);
              }
              return node.destroy();
            }
            /**
             * Create a new texture reference
             *
             * @remarks
             * This method creates a new reference to a texture. The texture is not
             * loaded until it is used on a node.
             *
             * It can be assigned to a node's `texture` property, or it can be used
             * when creating a SubTexture.
             *
             * @param textureType
             * @param props
             * @param options
             * @returns
             */
          }, {
            key: "createTexture",
            value: function createTexture(textureType, props) {
              return this.stage.txManager.createTexture(textureType, props);
            }
            /**
             * Create a new shader controller for a shader type
             *
             * @remarks
             * This method creates a new Shader Controller for a specific shader type.
             *
             * If the shader has not been loaded yet, it will be loaded. Otherwise, the
             * existing shader will be reused.
             *
             * It can be assigned to a Node's `shader` property.
             *
             * @param shaderType
             * @param props
             * @returns
             */
          }, {
            key: "createShader",
            value: function createShader(shaderType, props) {
              return this.stage.shManager.loadShader(shaderType, props);
            }
            /**
             * Create a new Dynamic Shader controller
             *
             * @remarks
             * A Dynamic Shader is a shader that can be composed of an array of mulitple
             * effects. Each effect can be animated or changed after creation (provided
             * the effect is given a name).
             *
             * Example:
             * ```ts
             * renderer.createNode({
             *   shader: renderer.createDynamicShader([
             *     renderer.createEffect('radius', {
             *       radius: 0
             *     }, 'effect1'),
             *     renderer.createEffect('border', {
             *       color: 0xff00ffff,
             *       width: 10,
             *     }, 'effect2'),
             *   ]),
             * });
             * ```
             *
             * @param effects
             * @returns
             */
          }, {
            key: "createDynamicShader",
            value: function createDynamicShader(effects) {
              return this.stage.shManager.loadDynamicShader({
                effects: effects
              });
            }
            /**
             * Create an effect to be used in a Dynamic Shader
             *
             * @remark
             * The {name} parameter is optional but required if you want to animate the effect
             * or change the effect's properties after creation.
             *
             * See {@link createDynamicShader} for an example.
             *
             * @param type
             * @param props
             * @param name
             * @returns
             */
          }, {
            key: "createEffect",
            value: function createEffect(type, props, name) {
              return {
                name: name,
                type: type,
                props: props
              };
            }
            /**
             * Get a Node by its ID
             *
             * @param id
             * @returns
             */
          }, {
            key: "getNodeById",
            value: function getNodeById(id) {
              var _this$stage;
              var root = (_this$stage = this.stage) === null || _this$stage === void 0 ? void 0 : _this$stage.root;
              if (!root) {
                return null;
              }
              var _findNode = function findNode(node) {
                if (node.id === id) {
                  return node;
                }
                var _iterator11 = _createForOfIteratorHelper(node.children),
                  _step11;
                try {
                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                    var child = _step11.value;
                    var found = _findNode(child);
                    if (found) {
                      return found;
                    }
                  }
                } catch (err) {
                  _iterator11.e(err);
                } finally {
                  _iterator11.f();
                }
                return null;
              };
              return _findNode(root);
            }
          }, {
            key: "toggleFreeze",
            value: function toggleFreeze() {
              throw new Error('Not implemented');
            }
          }, {
            key: "advanceFrame",
            value: function advanceFrame() {
              throw new Error('Not implemented');
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              return this.stage.renderer.getBufferInfo();
            }
            /**
             * Re-render the current frame without advancing any running animations.
             *
             * @remarks
             * Any state changes will be reflected in the re-rendered frame. Useful for
             * debugging.
             *
             * May not do anything if the render loop is running on a separate worker.
             */
          }, {
            key: "rerender",
            value: function rerender() {
              this.stage.requestRender();
            }
            /**
             * Cleanup textures that are not being used
             *
             * @param aggressive - If true, will cleanup all textures, regardless of render status
             *
             * @remarks
             * This can be used to free up GFX memory used by textures that are no longer
             * being displayed.
             *
             * This routine is also called automatically when the memory used by textures
             * exceeds the critical threshold on frame generation **OR** when the renderer
             * is idle and the memory used by textures exceeds the target threshold.
             *
             * **NOTE**: This is a heavy operation and should be used sparingly.
             * **NOTE2**: This will not cleanup textures that are currently being displayed.
             * **NOTE3**: This will not cleanup textures that are marked as `preventCleanup`.
             * **NOTE4**: This has nothing to do with the garbage collection of JavaScript.
             */
          }, {
            key: "cleanup",
            value: function cleanup() {
              var aggressive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              this.stage.cleanup(aggressive);
            }
            /**
             * Sets the clear color for the stage.
             *
             * @param color - The color to set as the clear color.
             */
          }, {
            key: "setClearColor",
            value: function setClearColor(color) {
              this.stage.setClearColor(color);
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TrFontFace = /*#__PURE__*/function (_EventEmitter8) {
          function TrFontFace(options) {
            var _this49;
            _classCallCheck(this, TrFontFace);
            _this49 = _callSuper(this, TrFontFace);
            _defineProperty(_this49, "fontFamily", void 0);
            _defineProperty(_this49, "descriptors", void 0);
            _defineProperty(_this49, "loaded", false);
            _defineProperty(_this49, "metrics", null);
            var fontFamily = options.fontFamily,
              descriptors = options.descriptors,
              metrics = options.metrics;
            if (metrics) {
              // Normalize metrics to be in the range of 0 to 1
              _this49.metrics = {
                ascender: metrics.ascender / metrics.unitsPerEm,
                descender: metrics.descender / metrics.unitsPerEm,
                lineGap: metrics.lineGap / metrics.unitsPerEm
              };
            }
            _this49.fontFamily = fontFamily;
            _this49.descriptors = _objectSpread({
              style: 'normal',
              weight: 'normal',
              stretch: 'normal'
            }, descriptors);
            return _this49;
          }
          /**
           * Convert a TrFontFaceDescriptors to a FontFaceDescriptors which differ slightly
           *
           * @param descriptors
           * @returns
           */
          _inherits(TrFontFace, _EventEmitter8);
          return _createClass(TrFontFace, null, [{
            key: "convertToCssFontFaceDescriptors",
            value: function convertToCssFontFaceDescriptors(descriptors) {
              return {
                style: descriptors.style,
                weight: typeof descriptors.weight === 'number' ? "".concat(descriptors.weight) : descriptors.weight,
                stretch: descriptors.stretch,
                unicodeRange: descriptors.unicodeRange,
                featureSettings: descriptors.featureSettings,
                display: descriptors.display
              };
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebTrFontFace = /*#__PURE__*/function (_TrFontFace2) {
          function WebTrFontFace(options) {
            var _this50;
            _classCallCheck(this, WebTrFontFace);
            _this50 = _callSuper(this, WebTrFontFace, [options]);
            _defineProperty(_this50, "fontFace", void 0);
            _defineProperty(_this50, "fontUrl", void 0);
            var fontFamily = options.fontFamily,
              fontUrl = options.fontUrl;
            // Filter out parentheses from fontUrl
            var fontUrlWithoutParentheses = fontUrl.replace(/\(|\)/g, '');
            // Defaults for descriptors resolved in the super constructor
            var determinedDescriptors = _this50.descriptors;
            // Convert TrFontFaceDescriptors to CSS FontFaceDescriptors
            var cssDescriptors = {
              style: determinedDescriptors.style,
              weight: typeof determinedDescriptors.weight === 'number' ? "".concat(determinedDescriptors.weight) : determinedDescriptors.weight,
              stretch: determinedDescriptors.stretch,
              unicodeRange: determinedDescriptors.unicodeRange,
              featureSettings: determinedDescriptors.featureSettings,
              display: determinedDescriptors.display
            };
            for (var k in cssDescriptors) {
              var _key29 = k;
              if (cssDescriptors[_key29] === undefined) {
                delete cssDescriptors[_key29];
              }
            }
            var fontFace = new FontFace(fontFamily, "url(".concat(fontUrlWithoutParentheses, ")"), cssDescriptors);
            if (fontUrlWithoutParentheses.length > 0) {
              fontFace.load().then(function () {
                _this50.loaded = true;
                _this50.emit('loaded');
              }).catch(console.error);
            } else {
              // Default font
              _this50.loaded = true;
              _this50.emit('loaded');
            }
            _this50.fontFace = fontFace;
            _this50.fontUrl = fontUrl;
            return _this50;
          }
          _inherits(WebTrFontFace, _TrFontFace2);
          return _createClass(WebTrFontFace);
        }(TrFontFace);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreRenderOp = /*#__PURE__*/_createClass(function CoreRenderOp() {
          _classCallCheck(this, CoreRenderOp);
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Can render multiple quads with multiple textures (up to vertex shader texture limit)
         *
         */
        var WebGlCoreRenderOp = /*#__PURE__*/function (_CoreRenderOp) {
          function WebGlCoreRenderOp(glw, options, buffers, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, zIndex, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
            var _this51;
            _classCallCheck(this, WebGlCoreRenderOp);
            _this51 = _callSuper(this, WebGlCoreRenderOp);
            _defineProperty(_this51, "glw", void 0);
            _defineProperty(_this51, "options", void 0);
            _defineProperty(_this51, "buffers", void 0);
            _defineProperty(_this51, "shader", void 0);
            _defineProperty(_this51, "shaderProps", void 0);
            _defineProperty(_this51, "alpha", void 0);
            _defineProperty(_this51, "clippingRect", void 0);
            _defineProperty(_this51, "dimensions", void 0);
            _defineProperty(_this51, "bufferIdx", void 0);
            _defineProperty(_this51, "zIndex", void 0);
            _defineProperty(_this51, "renderToTexture", void 0);
            _defineProperty(_this51, "parentHasRenderTexture", void 0);
            _defineProperty(_this51, "framebufferDimensions", void 0);
            _defineProperty(_this51, "length", 0);
            _defineProperty(_this51, "numQuads", 0);
            _defineProperty(_this51, "textures", []);
            _defineProperty(_this51, "maxTextures", void 0);
            _this51.glw = glw;
            _this51.options = options;
            _this51.buffers = buffers;
            _this51.shader = shader;
            _this51.shaderProps = shaderProps;
            _this51.alpha = alpha;
            _this51.clippingRect = clippingRect;
            _this51.dimensions = dimensions;
            _this51.bufferIdx = bufferIdx;
            _this51.zIndex = zIndex;
            _this51.renderToTexture = renderToTexture;
            _this51.parentHasRenderTexture = parentHasRenderTexture;
            _this51.framebufferDimensions = framebufferDimensions;
            _this51.maxTextures = shader.supportsIndexedTextures ? glw.getParameter(glw.MAX_VERTEX_TEXTURE_IMAGE_UNITS) : 1;
            return _this51;
          }
          _inherits(WebGlCoreRenderOp, _CoreRenderOp);
          return _createClass(WebGlCoreRenderOp, [{
            key: "addTexture",
            value: function addTexture(texture) {
              var textures = this.textures,
                maxTextures = this.maxTextures;
              var existingIdx = -1;
              var texturesLength = textures.length;
              for (var i = 0; i < texturesLength; i++) {
                var t = textures[i];
                if (t === texture) {
                  existingIdx = i;
                  break;
                }
              }
              if (existingIdx !== -1) {
                return existingIdx;
              }
              if (texturesLength >= maxTextures) {
                return 0xffffffff;
              }
              this.textures.push(texture);
              return texturesLength;
            }
          }, {
            key: "draw",
            value: function draw() {
              var glw = this.glw,
                shader = this.shader,
                shaderProps = this.shaderProps,
                options = this.options;
              var shManager = options.shManager;
              shManager.useShader(shader);
              shader.bindRenderOp(this, shaderProps);
              // TODO: Reduce calculations required
              var quadIdx = this.bufferIdx / 24 * 6 * 2;
              // Clipping
              if (this.clippingRect.valid) {
                var _this$clippingRect = this.clippingRect,
                  x = _this$clippingRect.x,
                  y = _this$clippingRect.y,
                  width = _this$clippingRect.width,
                  height = _this$clippingRect.height;
                var pixelRatio = this.parentHasRenderTexture ? 1 : options.pixelRatio;
                var canvasHeight = options.canvas.height;
                var clipX = Math.round(x * pixelRatio);
                var clipWidth = Math.round(width * pixelRatio);
                var clipHeight = Math.round(height * pixelRatio);
                var clipY = Math.round(canvasHeight - clipHeight - y * pixelRatio);
                // if parent has render texture, we need to adjust the scissor rect
                // to be relative to the parent's framebuffer
                if (this.parentHasRenderTexture) {
                  clipY = this.framebufferDimensions ? this.framebufferDimensions.height - this.dimensions.height : 0;
                }
                glw.setScissorTest(true);
                glw.scissor(clipX, clipY, clipWidth, clipHeight);
              } else {
                glw.setScissorTest(false);
              }
              glw.drawElements(glw.TRIANGLES, 6 * this.numQuads, glw.UNSIGNED_SHORT, quadIdx);
            }
          }]);
        }(CoreRenderOp);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Get device specific webgl parameters
         * @param glw
         */
        function getWebGlParameters(glw) {
          var params = {
            MAX_RENDERBUFFER_SIZE: 0,
            MAX_TEXTURE_SIZE: 0,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
            MAX_VIEWPORT_DIMS: 0,
            // Code below will replace this with an Int32Array
            MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0,
            MAX_TEXTURE_IMAGE_UNITS: 0,
            MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0,
            MAX_VERTEX_ATTRIBS: 0,
            MAX_VARYING_VECTORS: 0,
            MAX_VERTEX_UNIFORM_VECTORS: 0,
            MAX_FRAGMENT_UNIFORM_VECTORS: 0
          };
          // Map over all parameters and get them
          var keys = Object.keys(params);
          keys.forEach(function (key) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            params[key] = glw.getParameter(glw[key]);
          });
          return params;
        }
        /**
         * Get device webgl extensions
         * @param glw
         */
        function getWebGlExtensions(glw) {
          var extensions = {
            ANGLE_instanced_arrays: null,
            WEBGL_compressed_texture_s3tc: null,
            WEBGL_compressed_texture_astc: null,
            WEBGL_compressed_texture_etc: null,
            WEBGL_compressed_texture_etc1: null,
            WEBGL_compressed_texture_pvrtc: null,
            WEBKIT_WEBGL_compressed_texture_pvrtc: null,
            WEBGL_compressed_texture_s3tc_srgb: null,
            OES_vertex_array_object: null
          };
          // Map over all extensions and get them
          var keys = Object.keys(extensions);
          keys.forEach(function (key) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            extensions[key] = glw.getExtension(key);
          });
          return extensions;
        }
        /**
         * Allocate big memory chunk that we
         * can re-use to draw quads
         *
         * @param glw
         * @param size
         */
        function createIndexBuffer(glw, size) {
          var maxQuads = ~~(size / 80);
          var indices = new Uint16Array(maxQuads * 6);
          for (var i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
            indices[i] = j;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 2;
            indices[i + 4] = j + 1;
            indices[i + 5] = j + 3;
          }
          var buffer = glw.createBuffer();
          glw.elementArrayBufferData(buffer, indices, glw.STATIC_DRAW);
        }
        /**
         * Checks if an object is of type HTMLImageElement.
         * This is used because we cant check for HTMLImageElement directly when the
         * renderer is running in a seperate web worker context.
         *
         * @param obj
         * @returns
         */
        function isHTMLImageElement(obj) {
          return obj !== null && (_typeof(obj) === 'object' && obj.constructor && obj.constructor.name === 'HTMLImageElement' || typeof HTMLImageElement !== 'undefined' && obj instanceof HTMLImageElement);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TRANSPARENT_TEXTURE_DATA = new Uint8Array([0, 0, 0, 0]);
        /**
         * A wrapper around a WebGLTexture that handles loading the texture data
         * from a Texture source and uploading it to the GPU as well as freeing
         * the uploaded texture.
         *
         * @remarks
         * When accessing the ctxTexture property, the texture will be loaded if
         * it hasn't been already. ctxTexture will always return a valid WebGLTexture
         * and trigger the loading/uploading of the texture's data if it hasn't been
         * loaded yet.
         */
        var WebGlCoreCtxTexture = /*#__PURE__*/function (_CoreContextTexture2) {
          function WebGlCoreCtxTexture(glw, memManager, textureSource) {
            var _this52;
            _classCallCheck(this, WebGlCoreCtxTexture);
            _this52 = _callSuper(this, WebGlCoreCtxTexture, [memManager, textureSource]);
            _defineProperty(_this52, "glw", void 0);
            _defineProperty(_this52, "_nativeCtxTexture", null);
            _defineProperty(_this52, "_w", 0);
            _defineProperty(_this52, "_h", 0);
            _this52.glw = glw;
            return _this52;
          }
          _inherits(WebGlCoreCtxTexture, _CoreContextTexture2);
          return _createClass(WebGlCoreCtxTexture, [{
            key: "ctxTexture",
            get: function get() {
              if (this.state === 'freed') {
                this.load();
                return null;
              }
              assertTruthy(this._nativeCtxTexture);
              return this._nativeCtxTexture;
            }
          }, {
            key: "w",
            get: function get() {
              return this._w;
            }
          }, {
            key: "h",
            get: function get() {
              return this._h;
            }
            /**
             * Load the texture data from the Texture source and upload it to the GPU
             *
             * @remarks
             * This method is called automatically when accessing the ctxTexture property
             * if the texture hasn't been loaded yet. But it can also be called manually
             * to force the texture to be pre-loaded prior to accessing the ctxTexture
             * property.
             */
          }, {
            key: "load",
            value: function load() {
              var _this53 = this;
              // If the texture is already loading or loaded, don't load it again.
              if (this.state === 'loading' || this.state === 'loaded') {
                return;
              }
              this.state = 'loading';
              this.textureSource.setState('loading');
              this._nativeCtxTexture = this.createNativeCtxTexture();
              if (this._nativeCtxTexture === null) {
                this.state = 'failed';
                this.textureSource.setState('failed', new Error('Could not create WebGL Texture'));
                console.error('Could not create WebGL Texture');
                return;
              }
              this.onLoadRequest().then(function (_ref23) {
                var width = _ref23.width,
                  height = _ref23.height;
                // If the texture has been freed while loading, return early.
                if (_this53.state === 'freed') {
                  return;
                }
                _this53.state = 'loaded';
                _this53._w = width;
                _this53._h = height;
                // Update the texture source's width and height so that it can be used
                // for rendering.
                _this53.textureSource.setState('loaded', {
                  width: width,
                  height: height
                });
                // cleanup source texture data
                _this53.textureSource.freeTextureData();
              }).catch(function (err) {
                // If the texture has been freed while loading, return early.
                if (_this53.state === 'freed') {
                  return;
                }
                _this53.state = 'failed';
                _this53.textureSource.setState('failed', err);
                _this53.textureSource.freeTextureData();
                console.error(err);
              });
            }
            /**
             * Called when the texture data needs to be loaded and uploaded to a texture
             */
          }, {
            key: "onLoadRequest",
            value: (function () {
              var _onLoadRequest = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                var glw, textureData, width, height, tdata, format, formatBytes, memoryPadding, _mipmaps$, mipmaps, _tdata$width, _width, _tdata$height, _height, type, glInternalFormat, view;
                return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                  while (1) switch (_context13.prev = _context13.next) {
                    case 0:
                      glw = this.glw;
                      textureData = this.textureSource.textureData;
                      if (!(textureData === null || this._nativeCtxTexture === null)) {
                        _context13.next = 4;
                        break;
                      }
                      throw new Error('Texture data or native texture is null ' + this.textureSource.type);
                    case 4:
                      // Set to a 1x1 transparent texture
                      glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                      this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
                      width = 0;
                      height = 0;
                      glw.activeTexture(0);
                      tdata = textureData.data;
                      format = glw.RGBA;
                      formatBytes = 4;
                      memoryPadding = 1.1; // Add padding to account for GPU Padding
                      // If textureData is null, the texture is empty (0, 0) and we don't need to
                      // upload any data to the GPU.
                      if (typeof ImageBitmap !== 'undefined' && tdata instanceof ImageBitmap || tdata instanceof ImageData ||
                      // not using typeof HTMLImageElement due to web worker
                      isHTMLImageElement(tdata)) {
                        width = tdata.width;
                        height = tdata.height;
                        glw.bindTexture(this._nativeCtxTexture);
                        glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
                        glw.texImage2D(0, format, format, glw.UNSIGNED_BYTE, tdata);
                        this.setTextureMemUse(height * width * formatBytes * memoryPadding);
                      } else if (tdata === null) {
                        width = 0;
                        height = 0;
                        // Reset to a 1x1 transparent texture
                        glw.bindTexture(this._nativeCtxTexture);
                        glw.texImage2D(0, format, 1, 1, 0, format, glw.UNSIGNED_BYTE, TRANSPARENT_TEXTURE_DATA);
                        this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
                      } else if ('mipmaps' in tdata && tdata.mipmaps) {
                        mipmaps = tdata.mipmaps, _tdata$width = tdata.width, _width = _tdata$width === void 0 ? 0 : _tdata$width, _tdata$height = tdata.height, _height = _tdata$height === void 0 ? 0 : _tdata$height, type = tdata.type, glInternalFormat = tdata.glInternalFormat;
                        view = type === 'ktx' ? new DataView((_mipmaps$ = mipmaps[0]) !== null && _mipmaps$ !== void 0 ? _mipmaps$ : new ArrayBuffer(0)) : mipmaps[0];
                        glw.bindTexture(this._nativeCtxTexture);
                        glw.compressedTexImage2D(0, glInternalFormat, _width, _height, 0, view);
                        glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                        glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                        glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                        glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
                        this.setTextureMemUse(view.byteLength);
                      } else if (tdata && tdata instanceof Uint8Array) {
                        // Color Texture
                        width = 1;
                        height = 1;
                        glw.bindTexture(this._nativeCtxTexture);
                        glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
                        glw.texImage2D(0, format, width, height, 0, format, glw.UNSIGNED_BYTE, tdata);
                        this.setTextureMemUse(width * height * formatBytes);
                      } else {
                        console.error("WebGlCoreCtxTexture.onLoadRequest: Unexpected textureData returned", textureData);
                      }
                      return _context13.abrupt("return", {
                        width: width,
                        height: height
                      });
                    case 15:
                    case "end":
                      return _context13.stop();
                  }
                }, _callee13, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest.apply(this, arguments);
              }
              return onLoadRequest;
            }()
            /**
             * Free the WebGLTexture from the GPU
             *
             * @returns
             */
            )
          }, {
            key: "free",
            value: function free() {
              if (this.state === 'freed') {
                return;
              }
              this.state = 'freed';
              this.textureSource.setState('freed');
              this._w = 0;
              this._h = 0;
              if (this._nativeCtxTexture !== null) {
                this.glw.deleteTexture(this._nativeCtxTexture);
                this.setTextureMemUse(0);
                this._nativeCtxTexture = null;
              }
              // if the texture still has source data, free it
              this.textureSource.freeTextureData();
            }
            /**
             * Create native context texture
             *
             * @remarks
             * When this method returns the returned texture will be bound to the GL context state.
             *
             * @param width
             * @param height
             * @returns
             */
          }, {
            key: "createNativeCtxTexture",
            value: function createNativeCtxTexture() {
              var glw = this.glw;
              var nativeTexture = glw.createTexture();
              if (!nativeTexture) {
                return null;
              }
              // On initial load request, create a 1x1 transparent texture to use until
              // the texture data is finally loaded.
              glw.activeTexture(0);
              glw.bindTexture(nativeTexture);
              // linear texture filtering
              glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
              glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
              // texture wrapping method
              glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
              glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
              return nativeTexture;
            }
          }]);
        }(CoreContextTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreCtxSubTexture = /*#__PURE__*/function (_WebGlCoreCtxTexture2) {
          function WebGlCoreCtxSubTexture(glw, memManager, textureSource) {
            _classCallCheck(this, WebGlCoreCtxSubTexture);
            return _callSuper(this, WebGlCoreCtxSubTexture, [glw, memManager, textureSource]);
          }
          _inherits(WebGlCoreCtxSubTexture, _WebGlCoreCtxTexture2);
          return _createClass(WebGlCoreCtxSubTexture, [{
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest2 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                var _props$data2, _props$data3;
                var props;
                return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                  while (1) switch (_context14.prev = _context14.next) {
                    case 0:
                      props = this.textureSource.textureData;
                      if (!(props.data instanceof Uint8Array)) {
                        _context14.next = 3;
                        break;
                      }
                      return _context14.abrupt("return", {
                        width: 1,
                        height: 1
                      });
                    case 3:
                      return _context14.abrupt("return", {
                        width: ((_props$data2 = props.data) === null || _props$data2 === void 0 ? void 0 : _props$data2.width) || 0,
                        height: ((_props$data3 = props.data) === null || _props$data3 === void 0 ? void 0 : _props$data3.height) || 0
                      });
                    case 4:
                    case "end":
                      return _context14.stop();
                  }
                }, _callee14, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest2.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }]);
        }(WebGlCoreCtxTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Represents a collection of WebGL Buffers along with their associated
         * vertex attribute formats.
         */
        var BufferCollection = /*#__PURE__*/function () {
          function BufferCollection(config) {
            _classCallCheck(this, BufferCollection);
            _defineProperty(this, "config", void 0);
            this.config = config;
          }
          /**
           * Get the WebGLBuffer associated with the given attribute name if it exists.
           *
           * @param attributeName
           * @returns
           */
          return _createClass(BufferCollection, [{
            key: "getBuffer",
            value: function getBuffer(attributeName) {
              var _this$config$find;
              return (_this$config$find = this.config.find(function (item) {
                return item.attributes[attributeName];
              })) === null || _this$config$find === void 0 ? void 0 : _this$config$find.buffer;
            }
            /**
             * Get the AttributeInfo associated with the given attribute name if it exists.
             *
             * @param attributeName
             * @returns
             */
          }, {
            key: "getAttributeInfo",
            value: function getAttributeInfo(attributeName) {
              var _this$config$find2;
              return (_this$config$find2 = this.config.find(function (item) {
                return item.attributes[attributeName];
              })) === null || _this$config$find2 === void 0 ? void 0 : _this$config$find2.attributes[attributeName];
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Generic WebGL Utility Functions
         *
         * @remarks
         * Nothing here should be coupled to Renderer logic / types.
         *
         * @param gl
         * @returns
         */
        function _isWebGl(gl) {
          return self.WebGL2RenderingContext && gl instanceof self.WebGL2RenderingContext;
        }

        /* eslint-disable @typescript-eslint/no-unsafe-return */
        /* eslint-disable @typescript-eslint/no-explicit-any */
        /* eslint-disable @typescript-eslint/no-unsafe-argument */
        /**
         * Optimized WebGL Context Wrapper
         *
         * @remarks
         * This class contains the subset of the WebGLRenderingContext & WebGL2RenderingContext
         * API that is used by the renderer. Select high volume WebGL methods include
         * caching optimizations to avoid making WebGL calls if the state is already set
         * to the desired value.
         *
         * While most methods contained are direct passthroughs to the WebGL context,
         * some methods combine multiple WebGL calls into one for convenience, modify
         * arguments to be more convenient, or are replaced by more specific methods.
         *
         * Not all methods are optimized. Only methods that are called frequently
         * and/or have a high cost are optimized.
         *
         * A subset of GLenum constants are also exposed as properties on this class
         * for convenience.
         */
        var WebGlContextWrapper = /*#__PURE__*/function () {
          //#endregion WebGL Enums
          function WebGlContextWrapper(gl) {
            var _this54 = this;
            _classCallCheck(this, WebGlContextWrapper);
            _defineProperty(this, "gl", void 0);
            //#region Cached WebGL State
            _defineProperty(this, "activeTextureUnit", 0);
            _defineProperty(this, "texture2dUnits", void 0);
            _defineProperty(this, "texture2dParams", new WeakMap());
            _defineProperty(this, "scissorEnabled", void 0);
            _defineProperty(this, "scissorX", void 0);
            _defineProperty(this, "scissorY", void 0);
            _defineProperty(this, "scissorWidth", void 0);
            _defineProperty(this, "scissorHeight", void 0);
            _defineProperty(this, "blendEnabled", void 0);
            _defineProperty(this, "blendSrcRgb", void 0);
            _defineProperty(this, "blendDstRgb", void 0);
            _defineProperty(this, "blendSrcAlpha", void 0);
            _defineProperty(this, "blendDstAlpha", void 0);
            _defineProperty(this, "boundArrayBuffer", void 0);
            _defineProperty(this, "boundElementArrayBuffer", void 0);
            _defineProperty(this, "curProgram", void 0);
            //#endregion Cached WebGL State
            //#region Canvas
            _defineProperty(this, "canvas", void 0);
            //#endregion Canvas
            //#region WebGL Enums
            _defineProperty(this, "MAX_RENDERBUFFER_SIZE", void 0);
            _defineProperty(this, "MAX_TEXTURE_SIZE", void 0);
            _defineProperty(this, "MAX_VIEWPORT_DIMS", void 0);
            _defineProperty(this, "MAX_VERTEX_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_COMBINED_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_VERTEX_ATTRIBS", void 0);
            _defineProperty(this, "MAX_VARYING_VECTORS", void 0);
            _defineProperty(this, "MAX_VERTEX_UNIFORM_VECTORS", void 0);
            _defineProperty(this, "MAX_FRAGMENT_UNIFORM_VECTORS", void 0);
            _defineProperty(this, "TEXTURE_MAG_FILTER", void 0);
            _defineProperty(this, "TEXTURE_MIN_FILTER", void 0);
            _defineProperty(this, "TEXTURE_WRAP_S", void 0);
            _defineProperty(this, "TEXTURE_WRAP_T", void 0);
            _defineProperty(this, "LINEAR", void 0);
            _defineProperty(this, "CLAMP_TO_EDGE", void 0);
            _defineProperty(this, "RGB", void 0);
            _defineProperty(this, "RGBA", void 0);
            _defineProperty(this, "UNSIGNED_BYTE", void 0);
            _defineProperty(this, "UNPACK_PREMULTIPLY_ALPHA_WEBGL", void 0);
            _defineProperty(this, "UNPACK_FLIP_Y_WEBGL", void 0);
            _defineProperty(this, "FLOAT", void 0);
            _defineProperty(this, "TRIANGLES", void 0);
            _defineProperty(this, "UNSIGNED_SHORT", void 0);
            _defineProperty(this, "ONE", void 0);
            _defineProperty(this, "ONE_MINUS_SRC_ALPHA", void 0);
            _defineProperty(this, "VERTEX_SHADER", void 0);
            _defineProperty(this, "FRAGMENT_SHADER", void 0);
            _defineProperty(this, "STATIC_DRAW", void 0);
            _defineProperty(this, "COMPILE_STATUS", void 0);
            _defineProperty(this, "LINK_STATUS", void 0);
            _defineProperty(this, "DYNAMIC_DRAW", void 0);
            _defineProperty(this, "COLOR_ATTACHMENT0", void 0);
            _defineProperty(this, "INVALID_ENUM", void 0);
            _defineProperty(this, "INVALID_OPERATION", void 0);
            this.gl = gl;
            // The following code extracts the current state of the WebGL context
            // to our local JavaScript cached version of it. This is so we can
            // avoid making WebGL calls if we don't need to.
            // We could assume that the WebGL context is in a default state, but
            // in the future we may want to support restoring a broken WebGL context
            // and this will help with that.
            this.activeTextureUnit = gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
            var maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            // save current texture units
            this.texture2dUnits = new Array(maxTextureUnits).fill(undefined).map(function (_, i) {
              _this54.activeTexture(i);
              return gl.getParameter(gl.TEXTURE_BINDING_2D);
            });
            // restore active texture unit
            this.activeTexture(this.activeTextureUnit);
            this.scissorEnabled = gl.isEnabled(gl.SCISSOR_TEST);
            var scissorBox = gl.getParameter(gl.SCISSOR_BOX);
            this.scissorX = scissorBox[0];
            this.scissorY = scissorBox[1];
            this.scissorWidth = scissorBox[2];
            this.scissorHeight = scissorBox[3];
            this.blendEnabled = gl.isEnabled(gl.BLEND);
            this.blendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
            this.blendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
            this.blendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
            this.blendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
            this.boundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
            this.boundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
            this.curProgram = gl.getParameter(gl.CURRENT_PROGRAM);
            this.canvas = gl.canvas;
            // Extract GLenums
            this.MAX_RENDERBUFFER_SIZE = gl.MAX_RENDERBUFFER_SIZE;
            this.MAX_TEXTURE_SIZE = gl.MAX_TEXTURE_SIZE;
            this.MAX_VIEWPORT_DIMS = gl.MAX_VIEWPORT_DIMS;
            this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            this.MAX_TEXTURE_IMAGE_UNITS = gl.MAX_TEXTURE_IMAGE_UNITS;
            this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
            this.MAX_VERTEX_ATTRIBS = gl.MAX_VERTEX_ATTRIBS;
            this.MAX_VARYING_VECTORS = gl.MAX_VARYING_VECTORS;
            this.MAX_VERTEX_UNIFORM_VECTORS = gl.MAX_VERTEX_UNIFORM_VECTORS;
            this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.MAX_FRAGMENT_UNIFORM_VECTORS;
            this.TEXTURE_MAG_FILTER = gl.TEXTURE_MAG_FILTER;
            this.TEXTURE_MIN_FILTER = gl.TEXTURE_MIN_FILTER;
            this.TEXTURE_WRAP_S = gl.TEXTURE_WRAP_S;
            this.TEXTURE_WRAP_T = gl.TEXTURE_WRAP_T;
            this.LINEAR = gl.LINEAR;
            this.CLAMP_TO_EDGE = gl.CLAMP_TO_EDGE;
            this.RGB = gl.RGB;
            this.RGBA = gl.RGBA;
            this.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
            this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
            this.UNPACK_FLIP_Y_WEBGL = gl.UNPACK_FLIP_Y_WEBGL;
            this.FLOAT = gl.FLOAT;
            this.TRIANGLES = gl.TRIANGLES;
            this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
            this.ONE = gl.ONE;
            this.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
            this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            this.TRIANGLES = gl.TRIANGLES;
            this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
            this.VERTEX_SHADER = gl.VERTEX_SHADER;
            this.FRAGMENT_SHADER = gl.FRAGMENT_SHADER;
            this.STATIC_DRAW = gl.STATIC_DRAW;
            this.COMPILE_STATUS = gl.COMPILE_STATUS;
            this.LINK_STATUS = gl.LINK_STATUS;
            this.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;
            this.COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
            this.INVALID_ENUM = gl.INVALID_ENUM;
            this.INVALID_OPERATION = gl.INVALID_OPERATION;
          }
          /**
           * Returns true if the WebGL context is WebGL2
           *
           * @returns
           */
          return _createClass(WebGlContextWrapper, [{
            key: "isWebGl2",
            value: function isWebGl2() {
              return _isWebGl(this.gl);
            }
            /**
             * ```
             * gl.activeTexture(textureUnit + gl.TEXTURE0);
             * ```
             *
             * @remarks
             * **WebGL Difference**: `textureUnit` is based from 0, not `gl.TEXTURE0`.
             *
             * @param textureUnit
             */
          }, {
            key: "activeTexture",
            value: function activeTexture(textureUnit) {
              var gl = this.gl;
              if (this.activeTextureUnit !== textureUnit) {
                gl.activeTexture(textureUnit + gl.TEXTURE0);
                this.activeTextureUnit = textureUnit;
              }
            }
            /**
             * ```
             * gl.bindTexture(gl.TEXTURE_2D, texture);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             *
             * @param texture
             */
          }, {
            key: "bindTexture",
            value: function bindTexture(texture) {
              var gl = this.gl,
                activeTextureUnit = this.activeTextureUnit,
                texture2dUnits = this.texture2dUnits;
              if (texture2dUnits[activeTextureUnit] === texture) {
                return;
              }
              texture2dUnits[activeTextureUnit] = texture;
              gl.bindTexture(this.gl.TEXTURE_2D, texture);
            }
          }, {
            key: "_getActiveTexture",
            value: function _getActiveTexture() {
              var activeTextureUnit = this.activeTextureUnit,
                texture2dUnits = this.texture2dUnits;
              return texture2dUnits[activeTextureUnit];
            }
            /**
             * ```
             * gl.texParameteri(gl.TEXTURE_2D, pname, param);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             *
             * @param pname
             * @param param
             * @returns
             */
          }, {
            key: "texParameteri",
            value: function texParameteri(pname, param) {
              var gl = this.gl,
                texture2dParams = this.texture2dParams;
              var activeTexture = this._getActiveTexture();
              if (!activeTexture) {
                throw new Error('No active texture');
              }
              var textureParams = texture2dParams.get(activeTexture);
              if (!textureParams) {
                textureParams = {};
                texture2dParams.set(activeTexture, textureParams);
              }
              if (textureParams[pname] === param) {
                return;
              }
              textureParams[pname] = param;
              gl.texParameteri(gl.TEXTURE_2D, pname, param);
            }
          }, {
            key: "texImage2D",
            value: function texImage2D(level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels) {
              var gl = this.gl;
              if (format) {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels);
              } else {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource);
              }
            }
            /**
             * ```
             * gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, data);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             */
          }, {
            key: "compressedTexImage2D",
            value: function compressedTexImage2D(level, internalformat, width, height, border, data) {
              var gl = this.gl;
              gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalformat, width, height, border, data);
            }
            /**
             * ```
             * gl.pixelStorei(pname, param);
             * ```
             *
             * @param pname
             * @param param
             */
          }, {
            key: "pixelStorei",
            value: function pixelStorei(pname, param) {
              var gl = this.gl;
              gl.pixelStorei(pname, param);
            }
            /**
             * ```
             * gl.generateMipmap(gl.TEXTURE_2D);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             */
          }, {
            key: "generateMipmap",
            value: function generateMipmap() {
              var gl = this.gl;
              gl.generateMipmap(gl.TEXTURE_2D);
            }
            /**
             * ```
             * gl.createTexture();
             * ```
             *
             * @returns
             */
          }, {
            key: "createTexture",
            value: function createTexture() {
              var gl = this.gl;
              return gl.createTexture();
            }
            /**
             * ```
             * gl.deleteTexture(texture);
             * ```
             *
             * @param texture
             */
          }, {
            key: "deleteTexture",
            value: function deleteTexture(texture) {
              var gl = this.gl;
              if (texture) {
                this.texture2dParams.delete(texture);
              }
              gl.deleteTexture(texture);
            }
            /**
             * ```
             * gl.deleteFramebuffer(framebuffer);
             *
             * @param framebuffer
             */
          }, {
            key: "deleteFramebuffer",
            value: function deleteFramebuffer(framebuffer) {
              this.gl.deleteFramebuffer(framebuffer);
            }
            /**
             * ```
             * gl.viewport(x, y, width, height);
             * ```
             */
          }, {
            key: "viewport",
            value: function viewport(x, y, width, height) {
              var gl = this.gl;
              gl.viewport(x, y, width, height);
            }
            /**
             * ```
             * gl.clearColor(red, green, blue, alpha);
             * ```
             *
             * @param red
             * @param green
             * @param blue
             * @param alpha
             */
          }, {
            key: "clearColor",
            value: function clearColor(red, green, blue, alpha) {
              var gl = this.gl;
              gl.clearColor(red, green, blue, alpha);
            }
            /**
             * ```
             * gl["enable"|"disable"](gl.SCISSOR_TEST);
             * ```
             * @param enable
             */
          }, {
            key: "setScissorTest",
            value: function setScissorTest(enable) {
              var gl = this.gl,
                scissorEnabled = this.scissorEnabled;
              if (enable === scissorEnabled) {
                return;
              }
              if (enable) {
                gl.enable(gl.SCISSOR_TEST);
              } else {
                gl.disable(gl.SCISSOR_TEST);
              }
              this.scissorEnabled = enable;
            }
            /**
             * ```
             * gl.scissor(x, y, width, height);
             * ```
             *
             * @param x
             * @param y
             * @param width
             * @param height
             */
          }, {
            key: "scissor",
            value: function scissor(x, y, width, height) {
              var gl = this.gl,
                scissorX = this.scissorX,
                scissorY = this.scissorY,
                scissorWidth = this.scissorWidth,
                scissorHeight = this.scissorHeight;
              if (x !== scissorX || y !== scissorY || width !== scissorWidth || height !== scissorHeight) {
                gl.scissor(x, y, width, height);
                this.scissorX = x;
                this.scissorY = y;
                this.scissorWidth = width;
                this.scissorHeight = height;
              }
            }
            /**
             * ```
             * gl["enable"|"disable"](gl.BLEND);
             * ```
             *
             * @param blend
             * @returns
             */
          }, {
            key: "setBlend",
            value: function setBlend(blend) {
              var gl = this.gl,
                blendEnabled = this.blendEnabled;
              if (blend === blendEnabled) {
                return;
              }
              if (blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }
              this.blendEnabled = blend;
            }
            /**
             * ```
             * gl.blendFunc(src, dst);
             * ```
             *
             * @param src
             * @param dst
             */
          }, {
            key: "blendFunc",
            value: function blendFunc(src, dst) {
              var gl = this.gl,
                blendSrcRgb = this.blendSrcRgb,
                blendDstRgb = this.blendDstRgb,
                blendSrcAlpha = this.blendSrcAlpha,
                blendDstAlpha = this.blendDstAlpha;
              if (src !== blendSrcRgb || dst !== blendDstRgb || src !== blendSrcAlpha || dst !== blendDstAlpha) {
                gl.blendFunc(src, dst);
                this.blendSrcRgb = src;
                this.blendDstRgb = dst;
                this.blendSrcAlpha = src;
                this.blendDstAlpha = dst;
              }
            }
            /**
             * ```
             * gl.createBuffer();
             * ```
             *
             * @returns
             */
          }, {
            key: "createBuffer",
            value: function createBuffer() {
              var gl = this.gl;
              return gl.createBuffer();
            }
            /**
             * ```
             * gl.createFramebuffer();
             * ```
             * @returns
             */
          }, {
            key: "createFramebuffer",
            value: function createFramebuffer() {
              var gl = this.gl;
              return gl.createFramebuffer();
            }
            /**
             * ```
             * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
             * ```
             *
             * @param framebuffer
             */
          }, {
            key: "bindFramebuffer",
            value: function bindFramebuffer(framebuffer) {
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            }
            /**
             * ```
             * gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.FRAMEBUFFER` and textarget is always `gl.TEXTURE_2D`
             */
          }, {
            key: "framebufferTexture2D",
            value: function framebufferTexture2D(attachment, texture, level) {
              var gl = this.gl;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
            }
            /**
             * ```
             * gl.clear(gl.COLOR_BUFFER_BIT);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Clear mask is always `gl.COLOR_BUFFER_BIT`
             */
          }, {
            key: "clear",
            value: function clear() {
              var gl = this.gl;
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
             * gl.bufferData(gl.ARRAY_BUFFER, data, usage);
             * ```
             *
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
             *
             * @param buffer
             * @param data
             * @param usage
             */
          }, {
            key: "arrayBufferData",
            value: function arrayBufferData(buffer, data, usage) {
              var gl = this.gl,
                boundArrayBuffer = this.boundArrayBuffer;
              if (boundArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                this.boundArrayBuffer = buffer;
              }
              gl.bufferData(gl.ARRAY_BUFFER, data, usage);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
             * gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
             * ```
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
             *
             * @param buffer
             * @param data
             * @param usage
             */
          }, {
            key: "elementArrayBufferData",
            value: function elementArrayBufferData(buffer, data, usage) {
              var gl = this.gl,
                boundElementArrayBuffer = this.boundElementArrayBuffer;
              if (boundElementArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                this.boundElementArrayBuffer = buffer;
              }
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
             * gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
             * ```
             *
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.vertexAttribPointer` are combined into one function.
             *
             * @param buffer
             * @param index
             * @param size
             * @param type
             * @param normalized
             * @param stride
             * @param offset
             */
          }, {
            key: "vertexAttribPointer",
            value: function vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
              var gl = this.gl,
                boundArrayBuffer = this.boundArrayBuffer;
              if (boundArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                this.boundArrayBuffer = buffer;
              }
              gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
            }
            /**
             * ```
             * gl.useProgram(program);
             * ```
             *
             * @param program
             * @returns
             */
          }, {
            key: "useProgram",
            value: function useProgram(program) {
              var gl = this.gl,
                curProgram = this.curProgram;
              if (curProgram === program) {
                return;
              }
              gl.useProgram(program);
              this.curProgram = program;
            }
            /**
             * Sets the value of a single float uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The value to set.
             */
          }, {
            key: "uniform1f",
            value: function uniform1f(location, v0) {
              var gl = this.gl;
              gl.uniform1f(location, v0);
            }
            /**
             * Sets the value of a float array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of values to set.
             */
          }, {
            key: "uniform1fv",
            value: function uniform1fv(location, value) {
              var gl = this.gl;
              gl.uniform1fv(location, value);
            }
            /**
             * Sets the value of a single integer uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The value to set.
             */
          }, {
            key: "uniform1i",
            value: function uniform1i(location, v0) {
              var gl = this.gl;
              gl.uniform1i(location, v0);
            }
            /**
             * Sets the value of an integer array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of values to set.
             */
          }, {
            key: "uniform1iv",
            value: function uniform1iv(location, value) {
              var gl = this.gl;
              gl.uniform1iv(location, value);
            }
            /**
             * Sets the value of a vec2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             */
          }, {
            key: "uniform2f",
            value: function uniform2f(location, v0, v1) {
              var gl = this.gl;
              gl.uniform2f(location, v0, v1);
            }
            /**
             * Sets the value of a vec2 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec2 values to set.
             */
          }, {
            key: "uniform2fv",
            value: function uniform2fv(location, value) {
              var gl = this.gl;
              gl.uniform2fv(location, value);
            }
            /**
             * Sets the value of a ivec2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             */
          }, {
            key: "uniform2i",
            value: function uniform2i(location, v0, v1) {
              var gl = this.gl;
              gl.uniform2i(location, v0, v1);
            }
            /**
             * Sets the value of an ivec2 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec2 values to set.
             */
          }, {
            key: "uniform2iv",
            value: function uniform2iv(location, value) {
              var gl = this.gl;
              gl.uniform2iv(location, value);
            }
            /**
             * Sets the value of a vec3 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             */
          }, {
            key: "uniform3f",
            value: function uniform3f(location, v0, v1, v2) {
              var gl = this.gl;
              gl.uniform3f(location, v0, v1, v2);
            }
            /**
             * Sets the value of a vec3 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec3 values to set.
             */
          }, {
            key: "uniform3fv",
            value: function uniform3fv(location, value) {
              var gl = this.gl;
              gl.uniform3fv(location, value);
            }
            /**
             * Sets the value of a ivec3 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             */
          }, {
            key: "uniform3i",
            value: function uniform3i(location, v0, v1, v2) {
              var gl = this.gl;
              gl.uniform3i(location, v0, v1, v2);
            }
            /**
             * Sets the value of an ivec3 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec3 values to set.
             */
          }, {
            key: "uniform3iv",
            value: function uniform3iv(location, value) {
              var gl = this.gl;
              gl.uniform3iv(location, value);
            }
            /**
             * Sets the value of a vec4 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             * @param v3 - The fourth component of the vector.
             */
          }, {
            key: "uniform4f",
            value: function uniform4f(location, v0, v1, v2, v3) {
              var gl = this.gl;
              gl.uniform4f(location, v0, v1, v2, v3);
            }
            /**
             * Sets the value of a vec4 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec4 values to set.
             */
          }, {
            key: "uniform4fv",
            value: function uniform4fv(location, value) {
              var gl = this.gl;
              gl.uniform4fv(location, value);
            }
            /**
             * Sets the value of a ivec4 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             * @param v3 - The fourth component of the vector.
             */
          }, {
            key: "uniform4i",
            value: function uniform4i(location, v0, v1, v2, v3) {
              var gl = this.gl;
              gl.uniform4i(location, v0, v1, v2, v3);
            }
            /**
             * Sets the value of an ivec4 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec4 values to set.
             */
          }, {
            key: "uniform4iv",
            value: function uniform4iv(location, value) {
              var gl = this.gl;
              gl.uniform4iv(location, value);
            }
            /**
             * Sets the value of a mat2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param transpose - Whether to transpose the matrix.
             * @param value - The array of mat2 values to set.
             */
          }, {
            key: "uniformMatrix2fv",
            value: function uniformMatrix2fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix2fv(location, false, value);
            }
            /**
             * Sets the value of a mat2 uniform variable.
             * @param location - The location of the uniform variable.
             * @param value - The array of mat2 values to set.
             */
          }, {
            key: "uniformMatrix3fv",
            value: function uniformMatrix3fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix3fv(location, false, value);
            }
            /**
             * Sets the value of a mat4 uniform variable.
             * @param location - The location of the uniform variable.
             * @param value - The array of mat4 values to set.
             */
          }, {
            key: "uniformMatrix4fv",
            value: function uniformMatrix4fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix4fv(location, false, value);
            }
            /**
             * ```
             * gl.getParameter(pname);
             * ```
             *
             * @param pname
             * @returns
             */
          }, {
            key: "getParameter",
            value: function getParameter(pname) {
              var gl = this.gl;
              return gl.getParameter(pname);
            }
            /**
             * ```
             * gl.drawElements(mode, count, type, offset);
             * ```
             *
             * @param mode
             * @param count
             * @param type
             * @param offset
             */
          }, {
            key: "drawElements",
            value: function drawElements(mode, count, type, offset) {
              var gl = this.gl;
              gl.drawElements(mode, count, type, offset);
            }
            /**
             * ```
             * gl.drawArrays(mode, first, count);
             * ```
             *
             * @param name
             * @returns
             */
          }, {
            key: "getExtension",
            value: function getExtension(name) {
              var gl = this.gl;
              return gl.getExtension(name);
            }
            /**
             * ```
             * gl.getError(type);
             * ```
             *
             * @returns
             */
          }, {
            key: "getError",
            value: function getError() {
              var gl = this.gl;
              return gl.getError();
            }
            /**
             * ```
             * gl.createVertexArray();
             * ```
             *
             * @returns
             */
          }, {
            key: "createVertexArray",
            value: function createVertexArray() {
              var gl = this.gl;
              return gl.createVertexArray();
            }
            /**
             * ```
             * gl.bindVertexArray(vertexArray);
             * ```
             *
             * @param vertexArray
             */
          }, {
            key: "bindVertexArray",
            value: function bindVertexArray(vertexArray) {
              var gl = this.gl;
              gl.bindVertexArray(vertexArray);
            }
            /**
             * ```
             * gl.getAttribLocation(program, name);
             * ```
             *
             * @param program
             * @param name
             * @returns
             */
          }, {
            key: "getAttribLocation",
            value: function getAttribLocation(program, name) {
              var gl = this.gl;
              return gl.getAttribLocation(program, name);
            }
            /**
             * ```
             * gl.getUniformLocation(program, name);
             * ```
             *
             * @param program
             * @param name
             * @returns
             */
          }, {
            key: "getUniformLocation",
            value: function getUniformLocation(program, name) {
              var gl = this.gl;
              return gl.getUniformLocation(program, name);
            }
            /**
             * ```
             * gl.enableVertexAttribArray(index);
             * ```
             *
             * @param index
             */
          }, {
            key: "enableVertexAttribArray",
            value: function enableVertexAttribArray(index) {
              var gl = this.gl;
              gl.enableVertexAttribArray(index);
            }
            /**
             * ```
             * gl.disableVertexAttribArray(index);
             * ```
             *
             * @param index
             */
          }, {
            key: "disableVertexAttribArray",
            value: function disableVertexAttribArray(index) {
              var gl = this.gl;
              gl.disableVertexAttribArray(index);
            }
            /**
             * ```
             * gl.createShader(type);
             * ```
             *
             * @param type
             * @returns
             */
          }, {
            key: "createShader",
            value: function createShader(type) {
              var gl = this.gl;
              return gl.createShader(type);
            }
            /**
             * ```
             * gl.compileShader(shader);
             * ```
             *
             * @param shader
             * @returns
             */
          }, {
            key: "compileShader",
            value: function compileShader(shader) {
              var gl = this.gl;
              gl.compileShader(shader);
            }
            /**
             * ```
             * gl.attachShader(program, shader);
             * ```
             *
             * @param program
             * @param shader
             */
          }, {
            key: "attachShader",
            value: function attachShader(program, shader) {
              var gl = this.gl;
              gl.attachShader(program, shader);
            }
            /**
             * ```
             * gl.linkProgram(program);
             * ```
             *
             * @param program
             */
          }, {
            key: "linkProgram",
            value: function linkProgram(program) {
              var gl = this.gl;
              gl.linkProgram(program);
            }
            /**
             * ```
             * gl.deleteProgram(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "deleteProgram",
            value: function deleteProgram(shader) {
              var gl = this.gl;
              gl.deleteProgram(shader);
            }
            /**
             * ```
             * gl.getShaderParameter(shader, pname);
             * ```
             *
             * @param shader
             * @param pname
             */
          }, {
            key: "getShaderParameter",
            value: function getShaderParameter(shader, pname) {
              var gl = this.gl;
              return gl.getShaderParameter(shader, pname);
            }
            /**
             * ```
             * gl.getShaderInfoLog(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "getShaderInfoLog",
            value: function getShaderInfoLog(shader) {
              var gl = this.gl;
              return gl.getShaderInfoLog(shader);
            }
            /**
             * ```
             * gl.createProgram();
             * ```
             *
             * @returns
             */
          }, {
            key: "createProgram",
            value: function createProgram() {
              var gl = this.gl;
              return gl.createProgram();
            }
            /**
             * ```
             * gl.getProgramParameter(program, pname);
             * ```
             *
             * @param program
             * @param pname
             * @returns
             */
          }, {
            key: "getProgramParameter",
            value: function getProgramParameter(program, pname) {
              var gl = this.gl;
              return gl.getProgramParameter(program, pname);
            }
            /**
             * ```
             * gl.getProgramInfoLog(program);
             * ```
             *
             * @param program
             * @returns
             */
          }, {
            key: "getProgramInfoLog",
            value: function getProgramInfoLog(program) {
              var gl = this.gl;
              return gl.getProgramInfoLog(program);
            }
            /**
             * ```
             * gl.shaderSource(shader, source);
             * ```
             *
             * @param shader
             * @param source
             */
          }, {
            key: "shaderSource",
            value: function shaderSource(shader, source) {
              var gl = this.gl;
              gl.shaderSource(shader, source);
            }
            /**
             * ```
             * gl.deleteShader(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "deleteShader",
            value: function deleteShader(shader) {
              var gl = this.gl;
              gl.deleteShader(shader);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2024 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreCtxRenderTexture = /*#__PURE__*/function (_WebGlCoreCtxTexture3) {
          function WebGlCoreCtxRenderTexture(glw, memManager, textureSource) {
            var _this55;
            _classCallCheck(this, WebGlCoreCtxRenderTexture);
            _this55 = _callSuper(this, WebGlCoreCtxRenderTexture, [glw, memManager, textureSource]);
            _defineProperty(_this55, "framebuffer", null);
            return _this55;
          }
          _inherits(WebGlCoreCtxRenderTexture, _WebGlCoreCtxTexture3);
          return _createClass(WebGlCoreCtxRenderTexture, [{
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                var glw, nativeTexture, _this$textureSource, width, height;
                return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      glw = this.glw;
                      nativeTexture = this._nativeCtxTexture = this.createNativeCtxTexture();
                      _this$textureSource = this.textureSource, width = _this$textureSource.width, height = _this$textureSource.height; // Create Framebuffer object
                      this.framebuffer = glw.createFramebuffer();
                      // Set the dimensions of the render texture
                      glw.texImage2D(0, glw.RGBA, width, height, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                      // Update the texture memory manager
                      this.setTextureMemUse(width * height * 4);
                      // Bind the framebuffer
                      glw.bindFramebuffer(this.framebuffer);
                      // Attach the texture to the framebuffer
                      glw.framebufferTexture2D(glw.COLOR_ATTACHMENT0, nativeTexture, 0);
                      // Unbind the framebuffer
                      glw.bindFramebuffer(null);
                      return _context15.abrupt("return", {
                        width: width,
                        height: height
                      });
                    case 10:
                    case "end":
                      return _context15.stop();
                  }
                }, _callee15, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest3.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }, {
            key: "free",
            value: function free() {
              _superPropGet(WebGlCoreCtxRenderTexture, "free", this, 3)([]);
              // Delete the framebuffer
              this.glw.deleteFramebuffer(this.framebuffer);
              this.framebuffer = null;
            }
          }]);
        }(WebGlCoreCtxTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WORDS_PER_QUAD = 24;
        var WebGlCoreRenderer = /*#__PURE__*/function (_CoreRenderer2) {
          function WebGlCoreRenderer(options) {
            var _this56;
            _classCallCheck(this, WebGlCoreRenderer);
            _this56 = _callSuper(this, WebGlCoreRenderer, [options]);
            //// WebGL Native Context and Data
            _defineProperty(_this56, "glw", void 0);
            _defineProperty(_this56, "system", void 0);
            //// Persistent data
            _defineProperty(_this56, "quadBuffer", void 0);
            _defineProperty(_this56, "fQuadBuffer", void 0);
            _defineProperty(_this56, "uiQuadBuffer", void 0);
            _defineProperty(_this56, "renderOps", []);
            //// Render Op / Buffer Filling State
            _defineProperty(_this56, "curBufferIdx", 0);
            _defineProperty(_this56, "curRenderOp", null);
            _defineProperty(_this56, "rttNodes", []);
            _defineProperty(_this56, "activeRttNode", null);
            //// Default Shader
            _defineProperty(_this56, "defShaderCtrl", void 0);
            _defineProperty(_this56, "defaultShader", void 0);
            _defineProperty(_this56, "quadBufferCollection", void 0);
            _defineProperty(_this56, "clearColor", {
              raw: 0x00000000,
              normalized: [0, 0, 0, 0]
            });
            /**
             * White pixel texture used by default when no texture is specified.
             */
            _defineProperty(_this56, "quadBufferUsage", 0);
            _defineProperty(_this56, "numQuadsRendered", 0);
            /**
             * Whether the renderer is currently rendering to a texture.
             */
            _defineProperty(_this56, "renderToTextureActive", false);
            _this56.quadBuffer = new ArrayBuffer(_this56.stage.options.quadBufferSize);
            _this56.fQuadBuffer = new Float32Array(_this56.quadBuffer);
            _this56.uiQuadBuffer = new Uint32Array(_this56.quadBuffer);
            _this56.mode = 'webgl';
            var canvas = options.canvas,
              clearColor = options.clearColor,
              bufferMemory = options.bufferMemory;
            var gl = createWebGLContext(canvas, options.forceWebGL2, options.contextSpy);
            var glw = _this56.glw = new WebGlContextWrapper(gl);
            glw.viewport(0, 0, canvas.width, canvas.height);
            _this56.updateClearColor(clearColor);
            glw.setBlend(true);
            glw.blendFunc(glw.ONE, glw.ONE_MINUS_SRC_ALPHA);
            createIndexBuffer(glw, bufferMemory);
            _this56.system = {
              parameters: getWebGlParameters(_this56.glw),
              extensions: getWebGlExtensions(_this56.glw)
            };
            _this56.shManager.renderer = _this56;
            _this56.defShaderCtrl = _this56.shManager.loadShader('DefaultShader');
            _this56.defaultShader = _this56.defShaderCtrl.shader;
            var quadBuffer = glw.createBuffer();
            var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
            _this56.quadBufferCollection = new BufferCollection([{
              buffer: quadBuffer,
              attributes: {
                a_position: {
                  name: 'a_position',
                  size: 2,
                  // 2 components per iteration
                  type: glw.FLOAT,
                  // the data is 32bit floats
                  normalized: false,
                  // don't normalize the data
                  stride: stride,
                  // 0 = move forward size * sizeof(type) each iteration to get the next position
                  offset: 0 // start at the beginning of the buffer
                },
                a_textureCoordinate: {
                  name: 'a_textureCoordinate',
                  size: 2,
                  type: glw.FLOAT,
                  normalized: false,
                  stride: stride,
                  offset: 2 * Float32Array.BYTES_PER_ELEMENT
                },
                a_color: {
                  name: 'a_color',
                  size: 4,
                  type: glw.UNSIGNED_BYTE,
                  normalized: true,
                  stride: stride,
                  offset: 4 * Float32Array.BYTES_PER_ELEMENT
                },
                a_textureIndex: {
                  name: 'a_textureIndex',
                  size: 1,
                  type: glw.FLOAT,
                  normalized: false,
                  stride: stride,
                  offset: 5 * Float32Array.BYTES_PER_ELEMENT
                }
              }
            }]);
            return _this56;
          }
          _inherits(WebGlCoreRenderer, _CoreRenderer2);
          return _createClass(WebGlCoreRenderer, [{
            key: "reset",
            value: function reset() {
              var glw = this.glw;
              this.curBufferIdx = 0;
              this.curRenderOp = null;
              this.renderOps.length = 0;
              glw.setScissorTest(false);
              glw.clear();
            }
          }, {
            key: "getShaderManager",
            value: function getShaderManager() {
              return this.shManager;
            }
          }, {
            key: "createCtxTexture",
            value: function createCtxTexture(textureSource) {
              if (textureSource instanceof SubTexture) {
                return new WebGlCoreCtxSubTexture(this.glw, this.txMemManager, textureSource);
              } else if (textureSource instanceof RenderTexture) {
                return new WebGlCoreCtxRenderTexture(this.glw, this.txMemManager, textureSource);
              }
              return new WebGlCoreCtxTexture(this.glw, this.txMemManager, textureSource);
            }
            /**
             * This function adds a quad (a rectangle composed of two triangles) to the WebGL rendering pipeline.
             *
             * It takes a set of options that define the quad's properties, such as its dimensions, colors, texture, shader, and transformation matrix.
             * The function first updates the shader properties with the current dimensions if necessary, then sets the default texture if none is provided.
             * It then checks if a new render operation is needed, based on the current shader and clipping rectangle.
             * If a new render operation is needed, it creates one and updates the current render operation.
             * The function then adjusts the texture coordinates based on the texture options and adds the texture to the texture manager.
             *
             * Finally, it calculates the vertices for the quad, taking into account any transformations, and adds them to the quad buffer.
             * The function updates the length and number of quads in the current render operation, and updates the current buffer index.
             */
          }, {
            key: "addQuad",
            value: function addQuad(params) {
              var fQuadBuffer = this.fQuadBuffer,
                uiQuadBuffer = this.uiQuadBuffer;
              var texture = params.texture;
              /**
               * If the shader props contain any automatic properties, update it with the
               * current dimensions and or alpha that will be used to render the quad.
               */
              if (params.shaderProps !== null) {
                if (hasOwn(params.shaderProps, '$dimensions') == true) {
                  var dimensions = params.shaderProps.$dimensions;
                  dimensions.width = params.width;
                  dimensions.height = params.height;
                }
                if (hasOwn(params.shaderProps, '$alpha') === true) {
                  params.shaderProps.$alpha = params.alpha;
                }
              }
              var bufferIdx = this.curBufferIdx,
                curRenderOp = this.curRenderOp;
              var targetDims = {
                width: -1,
                height: -1
              };
              targetDims.width = params.width;
              targetDims.height = params.height;
              var targetShader = params.shader || this.defaultShader;
              assertTruthy(targetShader.getUniformLocation !== undefined);
              if (this.reuseRenderOp(params) === false) {
                this.newRenderOp(targetShader, params.shaderProps, params.alpha, targetDims, params.clippingRect, bufferIdx, params.rtt, params.parentHasRenderTexture, params.framebufferDimensions);
                curRenderOp = this.curRenderOp;
              }
              var texCoordX1 = 0;
              var texCoordY1 = 0;
              var texCoordX2 = 1;
              var texCoordY2 = 1;
              if (texture.type === TextureType.subTexture) {
                var _texture$props = texture.props,
                  tx = _texture$props.x,
                  ty = _texture$props.y,
                  tw = _texture$props.width,
                  th = _texture$props.height;
                var _ref24 = texture.parentTexture.dimensions || {
                    width: 0,
                    height: 0
                  },
                  _ref24$width = _ref24.width,
                  parentW = _ref24$width === void 0 ? 0 : _ref24$width,
                  _ref24$height = _ref24.height,
                  parentH = _ref24$height === void 0 ? 0 : _ref24$height;
                texCoordX1 = tx / parentW;
                texCoordX2 = texCoordX1 + tw / parentW;
                texCoordY1 = ty / parentH;
                texCoordY2 = texCoordY1 + th / parentH;
                texture = texture.parentTexture;
              }
              if (texture.type === TextureType.image && params.textureOptions !== null && params.textureOptions.resizeMode !== undefined && texture.dimensions !== null) {
                var resizeMode = params.textureOptions.resizeMode;
                var _texture$dimensions2 = texture.dimensions,
                  _tw = _texture$dimensions2.width,
                  _th = _texture$dimensions2.height;
                if (resizeMode.type === 'cover') {
                  var scaleX = params.width / _tw;
                  var scaleY = params.height / _th;
                  var scale = Math.max(scaleX, scaleY);
                  var precision = 1 / scale;
                  // Determine based on width
                  if (scale && scaleX && scaleX < scale) {
                    var _resizeMode$clipX;
                    var desiredSize = precision * params.width;
                    texCoordX1 = (1 - desiredSize / _tw) * ((_resizeMode$clipX = resizeMode.clipX) !== null && _resizeMode$clipX !== void 0 ? _resizeMode$clipX : 0.5);
                    texCoordX2 = texCoordX1 + desiredSize / _tw;
                  }
                  // Determine based on height
                  if (scale && scaleY && scaleY < scale) {
                    var _resizeMode$clipY;
                    var _desiredSize = precision * params.height;
                    texCoordY1 = (1 - _desiredSize / _th) * ((_resizeMode$clipY = resizeMode.clipY) !== null && _resizeMode$clipY !== void 0 ? _resizeMode$clipY : 0.5);
                    texCoordY2 = texCoordY1 + _desiredSize / _th;
                  }
                }
              }
              // Flip texture coordinates if dictated by texture options
              var flipY = 0;
              if (params.textureOptions !== null) {
                if (params.textureOptions.flipX === true) {
                  var _ref25 = [texCoordX2, texCoordX1];
                  texCoordX1 = _ref25[0];
                  texCoordX2 = _ref25[1];
                }
                // convert to integer for bitwise operation below
                flipY = +(params.textureOptions.flipY || false);
              }
              // Eitherone should be true
              if (flipY ^ +(texture.type === TextureType.renderToTexture)) {
                var _ref26 = [texCoordY2, texCoordY1];
                texCoordY1 = _ref26[0];
                texCoordY2 = _ref26[1];
              }
              var ctxTexture = texture.ctxTexture;
              var textureIdx = this.addTexture(ctxTexture, bufferIdx);
              assertTruthy(this.curRenderOp !== null);
              if (params.renderCoords) {
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.renderCoords.x1; // vertexX
                fQuadBuffer[bufferIdx++] = params.renderCoords.y1; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = params.renderCoords.x2;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y2;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.renderCoords.x4;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y4;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = params.renderCoords.x3;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y3;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              } else if (params.tb !== 0 || params.tc !== 0) {
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.tx; // vertexX
                fQuadBuffer[bufferIdx++] = params.ty; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta;
                fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.tx + params.height * params.tb;
                fQuadBuffer[bufferIdx++] = params.ty + params.height * params.td;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta + params.height * params.tb;
                fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc + params.height * params.td;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              } else {
                // Calculate the right corner of the quad
                // multiplied by the scale
                var rightCornerX = params.tx + params.width * params.ta;
                var rightCornerY = params.ty + params.height * params.td;
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.tx; // vertexX
                fQuadBuffer[bufferIdx++] = params.ty; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = rightCornerX;
                fQuadBuffer[bufferIdx++] = params.ty;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.tx;
                fQuadBuffer[bufferIdx++] = rightCornerY;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = rightCornerX;
                fQuadBuffer[bufferIdx++] = rightCornerY;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              }
              // Update the length of the current render op
              this.curRenderOp.length += WORDS_PER_QUAD;
              this.curRenderOp.numQuads++;
              this.curBufferIdx = bufferIdx;
            }
            /**
             * Replace the existing RenderOp with a new one that uses the specified Shader
             * and starts at the specified buffer index.
             *
             * @param shader
             * @param bufferIdx
             */
          }, {
            key: "newRenderOp",
            value: function newRenderOp(shader, shaderProps, alpha, dimensions, clippingRect, bufferIdx, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
              var curRenderOp = new WebGlCoreRenderOp(this.glw, this.options, this.quadBufferCollection, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, 0,
              // Z-Index is only used for explictly added Render Ops
              renderToTexture, parentHasRenderTexture, framebufferDimensions);
              this.curRenderOp = curRenderOp;
              this.renderOps.push(curRenderOp);
            }
            /**
             * Add a texture to the current RenderOp. If the texture cannot be added to the
             * current RenderOp, a new RenderOp will be created and the texture will be added
             * to that one.
             *
             * If the texture cannot be added to the new RenderOp, an error will be thrown.
             *
             * @param texture
             * @param bufferIdx
             * @param recursive
             * @returns Assigned Texture Index of the texture in the render op
             */
          }, {
            key: "addTexture",
            value: function addTexture(texture, bufferIdx, recursive) {
              var curRenderOp = this.curRenderOp;
              var textureIdx = curRenderOp.addTexture(texture);
              // TODO: Refactor to be more DRY
              if (textureIdx === 0xffffffff) {
                if (recursive) {
                  throw new Error('Unable to add texture to render op');
                }
                this.newRenderOp(curRenderOp.shader, curRenderOp.shaderProps, curRenderOp.alpha, curRenderOp.dimensions, curRenderOp.clippingRect, bufferIdx);
                return this.addTexture(texture, bufferIdx, true);
              }
              return textureIdx;
            }
            /**
             * Test if the current Render operation can be reused for the specified parameters.
             * @param params
             * @returns
             */
          }, {
            key: "reuseRenderOp",
            value: function reuseRenderOp(params) {
              var _this$curRenderOp;
              var shader = params.shader,
                shaderProps = params.shaderProps,
                parentHasRenderTexture = params.parentHasRenderTexture,
                rtt = params.rtt,
                clippingRect = params.clippingRect;
              var targetShader = shader || this.defaultShader;
              // Switching shader program will require a new render operation
              if (((_this$curRenderOp = this.curRenderOp) === null || _this$curRenderOp === void 0 ? void 0 : _this$curRenderOp.shader) !== targetShader) {
                return false;
              }
              // Switching clipping rect will require a new render operation
              if (compareRect(this.curRenderOp.clippingRect, clippingRect) === false) {
                return false;
              }
              // Force new render operation if rendering to texture
              // @todo: This needs to be improved, render operations could also be reused
              // for rendering to texture
              if (parentHasRenderTexture !== undefined || rtt !== undefined) {
                return false;
              }
              // Check if the shader can batch the shader properties
              if (this.curRenderOp.shader !== this.defaultShader && (shaderProps === null || this.curRenderOp.shader.canBatchShaderProps(this.curRenderOp.shaderProps, shaderProps) === false)) {
                return false;
              }
              // Render operation can be reused
              return true;
            }
            /**
             * add RenderOp to the render pipeline
             */
          }, {
            key: "addRenderOp",
            value: function addRenderOp(renderable) {
              this.renderOps.push(renderable);
              this.curRenderOp = null;
            }
            /**
             * Render the current set of RenderOps to render to the specified surface.
             *
             * TODO: 'screen' is the only supported surface at the moment.
             *
             * @param surface
             */
          }, {
            key: "render",
            value: function render() {
              var surface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'screen';
              var glw = this.glw,
                quadBuffer = this.quadBuffer;
              var arr = new Float32Array(quadBuffer, 0, this.curBufferIdx);
              var buffer = this.quadBufferCollection.getBuffer('a_position') || null;
              glw.arrayBufferData(buffer, arr, glw.STATIC_DRAW);
              for (var i = 0, length = this.renderOps.length; i < length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.renderOps[i].draw();
              }
              this.quadBufferUsage = this.curBufferIdx * arr.BYTES_PER_ELEMENT;
              // Calculate the size of each quad in bytes (4 vertices per quad) times the size of each vertex in bytes
              var QUAD_SIZE_IN_BYTES = 4 * (6 * arr.BYTES_PER_ELEMENT); // 6 attributes per vertex
              this.numQuadsRendered = this.quadBufferUsage / QUAD_SIZE_IN_BYTES;
            }
          }, {
            key: "getQuadCount",
            value: function getQuadCount() {
              return this.numQuadsRendered;
            }
          }, {
            key: "renderToTexture",
            value: function renderToTexture(node) {
              for (var i = 0; i < this.rttNodes.length; i++) {
                if (this.rttNodes[i] === node) {
                  return;
                }
              }
              this.insertRTTNodeInOrder(node);
            }
            /**
             * Inserts an RTT node into `this.rttNodes` while maintaining the correct rendering order based on hierarchy.
             *
             * Rendering order for RTT nodes is critical when nested RTT nodes exist in a parent-child relationship.
             * Specifically:
             *  - Child RTT nodes must be rendered before their RTT-enabled parents to ensure proper texture composition.
             *  - If an RTT node is added and it has existing RTT children, it should be rendered after those children.
             *
             * This function addresses both cases by:
             * 1. **Checking Upwards**: It traverses the node's hierarchy upwards to identify any RTT parent
             *    already in `rttNodes`. If an RTT parent is found, the new node is placed before this parent.
             * 2. **Checking Downwards**: It traverses the nodes children recursively to find any RTT-enabled
             *    children that are already in `rttNodes`. If such children are found, the new node is inserted
             *    after the last (highest index) RTT child node.
             *
             * The final calculated insertion index ensures the new node is positioned in `rttNodes` to respect
             * both parent-before-child and child-before-parent rendering rules, preserving the correct order
             * for the WebGL renderer.
             *
             * @param node - The RTT-enabled CoreNode to be added to `rttNodes` in the appropriate hierarchical position.
             */
          }, {
            key: "insertRTTNodeInOrder",
            value: function insertRTTNodeInOrder(node) {
              var insertIndex = this.rttNodes.length; // Default to the end of the array
              // 1. Traverse upwards to ensure the node is placed before its RTT parent (if any).
              var currentNode = node;
              while (currentNode) {
                if (!currentNode.parent) {
                  break;
                }
                var parentIndex = this.rttNodes.indexOf(currentNode.parent);
                if (parentIndex !== -1) {
                  // Found an RTT parent in the list; set insertIndex to place node before the parent
                  insertIndex = parentIndex;
                  break;
                }
                currentNode = currentNode.parent;
              }
              // 2. Traverse downwards to ensure the node is placed after any RTT children.
              // Look through each child recursively to see if any are already in rttNodes.
              var maxChildIndex = this.findMaxChildRTTIndex(node);
              if (maxChildIndex !== -1) {
                // Adjust insertIndex to be after the last child RTT node
                insertIndex = Math.max(insertIndex, maxChildIndex + 1);
              }
              // 3. Insert the node at the calculated position
              this.rttNodes.splice(insertIndex, 0, node);
            }
            // Helper function to find the highest index of any RTT children of a node within rttNodes
          }, {
            key: "findMaxChildRTTIndex",
            value: function findMaxChildRTTIndex(node) {
              var _this57 = this;
              var maxIndex = -1;
              var _traverseChildren = function traverseChildren(currentNode) {
                var currentIndex = _this57.rttNodes.indexOf(currentNode);
                if (currentIndex !== -1) {
                  maxIndex = Math.max(maxIndex, currentIndex);
                }
                // Recursively check all children of the current node
                var _iterator12 = _createForOfIteratorHelper(currentNode.children),
                  _step12;
                try {
                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                    var child = _step12.value;
                    _traverseChildren(child);
                  }
                } catch (err) {
                  _iterator12.e(err);
                } finally {
                  _iterator12.f();
                }
              };
              // Start traversal directly with the provided node
              _traverseChildren(node);
              return maxIndex;
            }
          }, {
            key: "renderRTTNodes",
            value: function renderRTTNodes() {
              var glw = this.glw;
              this.stage;
              // Render all associated RTT nodes to their textures
              for (var i = 0; i < this.rttNodes.length; i++) {
                var node = this.rttNodes[i];
                // Skip nodes that don't have RTT updates
                if (node === undefined || node.hasRTTupdates === false) {
                  continue;
                }
                // Skip nodes that are not visible
                if (node.worldAlpha === 0 || node.strictBounds === true && node.renderState === CoreNodeRenderState.OutOfBounds) {
                  continue;
                }
                // Skip nodes that do not have a loaded texture
                if (node.texture === null || node.texture.state !== 'loaded') {
                  continue;
                }
                // Set the active RTT node to the current node
                // So we can prevent rendering children of nested RTT nodes
                this.activeRttNode = node;
                assertTruthy(node.texture);
                var ctxTexture = node.texture.ctxTexture;
                this.renderToTextureActive = true;
                // Bind the the texture's framebuffer
                glw.bindFramebuffer(ctxTexture.framebuffer);
                glw.viewport(0, 0, ctxTexture.w, ctxTexture.h);
                // Set the clear color to transparent
                glw.clearColor(0, 0, 0, 0);
                glw.clear();
                // Render all associated quads to the texture
                for (var _i2 = 0; _i2 < node.children.length; _i2++) {
                  var child = node.children[_i2];
                  if (child === undefined) {
                    continue;
                  }
                  this.stage.addQuads(child);
                  child.hasRTTupdates = false;
                }
                // Render all associated quads to the texture
                this.render();
                // Reset render operations
                this.renderOps.length = 0;
                node.hasRTTupdates = false;
              }
              var clearColor = this.clearColor.normalized;
              // Restore the default clear color
              glw.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
              // Bind the default framebuffer
              glw.bindFramebuffer(null);
              glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
              this.renderToTextureActive = false;
            }
          }, {
            key: "removeRTTNode",
            value: function removeRTTNode(node) {
              var index = this.rttNodes.indexOf(node);
              if (index === -1) {
                return;
              }
              this.rttNodes.splice(index, 1);
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              var bufferInfo = {
                totalAvailable: this.stage.options.quadBufferSize,
                totalUsed: this.quadBufferUsage
              };
              return bufferInfo;
            }
          }, {
            key: "getDefShaderCtr",
            value: function getDefShaderCtr() {
              return this.defShaderCtrl;
            }
            /**
             * Updates the WebGL context's clear color and clears the color buffer.
             *
             * @param color - The color to set as the clear color, represented as a 32-bit integer.
             */
          }, {
            key: "updateClearColor",
            value: function updateClearColor(color) {
              if (this.clearColor.raw === color) {
                return;
              }
              var glw = this.glw;
              var normalizedColor = getNormalizedRgbaComponents(color);
              glw.clearColor(normalizedColor[0], normalizedColor[1], normalizedColor[2], normalizedColor[3]);
              this.clearColor = {
                raw: color,
                normalized: normalizedColor
              };
              glw.clear();
            }
          }]);
        }(CoreRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var SpecialCodepoints = {
          LINE_FEED: 0x0a,
          CARRIAGE_RETURN: 0x0d,
          SPACE: 0x20,
          TAB: 0x09,
          ZERO_WIDTH_SPACE: 0x200b,
          ZERO_WIDTH_NON_JOINER: 0x200c,
          ZERO_WIDTH_JOINER: 0x200d,
          LEFT_TO_RIGHT_MARK: 0x200e,
          RIGHT_TO_LEFT_MARK: 0x200f,
          LEFT_TO_RIGHT_EMBEDDING: 0x202a,
          RIGHT_TO_LEFT_EMBEDDING: 0x202b,
          POP_DIRECTIONAL_FORMATTING: 0x202c,
          LEFT_TO_RIGHT_OVERRIDE: 0x202d,
          RIGHT_TO_LEFT_OVERRIDE: 0x202e,
          LINE_SEPARATOR: 0x2028,
          PARAGRAPH_SEPARATOR: 0x2029,
          OBJECT_REPLACEMENT_CHARACTER: 0xfffc,
          REPLACEMENT_CHARACTER: 0xfffd,
          ZERO_WIDTH_NO_BREAK_SPACE: 0xfeff,
          LEFT_TO_RIGHT_ISOLATE: 0x2066,
          RIGHT_TO_LEFT_ISOLATE: 0x2067,
          FIRST_STRONG_ISOLATE: 0x2068,
          POP_DIRECTIONAL_ISOLATE: 0x2069,
          INHIBIT_SYMMETRIC_SWAPPING: 0x206a,
          ACTIVATE_SYMMETRIC_SWAPPING: 0x206b,
          INHIBIT_ARABIC_FORM_SHAPING: 0x206c,
          ACTIVATE_ARABIC_FORM_SHAPING: 0x206d,
          NATIONAL_DIGIT_SHAPES: 0x206e,
          NOMINAL_DIGIT_SHAPES: 0x206f,
          LEFT_TO_RIGHT_BOUNDARY: 0x200e,
          RIGHT_TO_LEFT_BOUNDARY: 0x200f
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var FontShaper = /*#__PURE__*/_createClass(function FontShaper() {
          _classCallCheck(this, FontShaper);
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var SdfFontShaper = /*#__PURE__*/function (_FontShaper) {
          function SdfFontShaper(data, glyphMap) {
            var _this58;
            _classCallCheck(this, SdfFontShaper);
            _this58 = _callSuper(this, SdfFontShaper);
            _defineProperty(_this58, "data", void 0);
            _defineProperty(_this58, "glyphMap", void 0);
            _defineProperty(_this58, "kernings", void 0);
            _this58.data = data;
            _this58.glyphMap = glyphMap;
            var kernings = _this58.kernings = {};
            data.kernings.forEach(function (kerning) {
              var second = kerning.second;
              var firsts = kernings[second] = kernings[second] || {};
              firsts[kerning.first] = kerning.amount;
            });
            _this58.kernings = kernings;
            return _this58;
          }
          _inherits(SdfFontShaper, _FontShaper);
          return _createClass(SdfFontShaper, [{
            key: "shapeText",
            value: /*#__PURE__*/_regeneratorRuntime().mark(function shapeText(props, codepoints) {
              var codepointResult, lastGlyphId, codepoint, glyph, _this$kernings$glyph$, kerning;
              return _regeneratorRuntime().wrap(function shapeText$(_context16) {
                while (1) switch (_context16.prev = _context16.next) {
                  case 0:
                    lastGlyphId = undefined;
                  case 1:
                    if (!((codepointResult = codepoints.peek()) && !codepointResult.done)) {
                      _context16.next = 17;
                      break;
                    }
                    codepoint = codepointResult.value;
                    glyph = this.glyphMap.get(codepoint);
                    codepoints.next();
                    if (!(glyph !== undefined)) {
                      _context16.next = 12;
                      break;
                    }
                    // We found a glyph for this codepoint
                    // Yield the mapped glyph info
                    /**
                     * Kerning includes any possible additional letter spacing
                     */
                    kerning = lastGlyphId !== undefined ? (((_this$kernings$glyph$ = this.kernings[glyph.id]) === null || _this$kernings$glyph$ === void 0 ? void 0 : _this$kernings$glyph$[lastGlyphId]) || 0) + props.letterSpacing : 0;
                    lastGlyphId = glyph.id;
                    _context16.next = 10;
                    return {
                      mapped: true,
                      glyphId: glyph.id,
                      codepoint: codepoint,
                      cluster: codepoints.lastIndex,
                      xAdvance: glyph.xadvance + kerning,
                      yAdvance: 0,
                      xOffset: glyph.xoffset + kerning,
                      yOffset: glyph.yoffset,
                      xBearing: 0,
                      yBearing: 0,
                      width: glyph.width,
                      height: glyph.height
                    };
                  case 10:
                    _context16.next = 15;
                    break;
                  case 12:
                    // We didn't find a glyph for this codepoint
                    // Yield the unmapped codepoint info
                    // If this codepoint is a linebreak, we should reset the last glyph id
                    // so that the next glyph will not be kerned with the last glyph of the
                    // previous line.
                    if (codepoint === SpecialCodepoints.LINE_FEED) {
                      lastGlyphId = undefined;
                    }
                    _context16.next = 15;
                    return {
                      mapped: false,
                      codepoint: codepoint,
                      cluster: codepoints.lastIndex
                    };
                  case 15:
                    _context16.next = 1;
                    break;
                  case 17:
                  case "end":
                    return _context16.stop();
                }
              }, shapeText, this);
            })
          }]);
        }(FontShaper);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // import type { Renderer } from '../../../Renderer';
        var SdfTrFontFace = /*#__PURE__*/function (_TrFontFace3) {
          function SdfTrFontFace(type, options) {
            var _this59;
            _classCallCheck(this, SdfTrFontFace);
            _this59 = _callSuper(this, SdfTrFontFace, [options]);
            _defineProperty(_this59, "type", void 0);
            _defineProperty(_this59, "texture", void 0);
            /**
             * Height of the tallest character in the font including the whitespace above it
             * in SDF/vertex units.
             */
            _defineProperty(_this59, "maxCharHeight", 0);
            _defineProperty(_this59, "shaper", void 0);
            _defineProperty(_this59, "glyphMap", new Map());
            _defineProperty(_this59, "data", void 0);
            var atlasUrl = options.atlasUrl,
              atlasDataUrl = options.atlasDataUrl,
              stage = options.stage;
            _this59.type = type;
            stage.renderer;
            // Load image
            _this59.texture = stage.txManager.createTexture('ImageTexture', {
              src: atlasUrl,
              // IMPORTANT: The SDF shader requires the alpha channel to NOT be
              // premultiplied on the atlas texture. If it is premultiplied, the
              // rendering of SDF glyphs (especially single-channel SDF fonts) will
              // be very jagged.
              premultiplyAlpha: false
            });
            // Load the texture
            stage.txManager.loadTexture(_this59.texture, true);
            // FIXME This is a stop-gap solution to avoid Font Face textures to be cleaned up
            // Ideally we do want to clean up the textures if they're not being used to save as much memory as possible
            // However, we need to make sure that the font face is reloaded if the texture is cleaned up and needed again
            // and make sure the SdfFontRenderer is properly guarded against textures being reloaded
            // for now this will do the trick and the increase on memory is not that big
            _this59.texture.preventCleanup = true;
            _this59.texture.on('loaded', function () {
              _this59.checkLoaded();
              // Make sure we mark the stage for a re-render (in case the font's texture was freed and reloaded)
              stage.requestRender();
            });
            // Set this.data to the fetched data from dataUrl
            fetchJson(atlasDataUrl).then(function (response) {
              _this59.data = JSON.parse(response);
              assertTruthy(_this59.data);
              // Add all the glyphs to the glyph map
              var maxCharHeight = 0;
              _this59.data.chars.forEach(function (glyph) {
                _this59.glyphMap.set(glyph.id, glyph);
                var charHeight = glyph.yoffset + glyph.height;
                if (charHeight > maxCharHeight) {
                  maxCharHeight = charHeight;
                }
              });
              _this59.maxCharHeight = maxCharHeight;
              // We know `data` is defined here, because we just set it
              _this59.shaper = new SdfFontShaper(_this59.data, _this59.glyphMap);
              // If the metrics aren't provided explicitly in the font face options,
              // Gather them from the metrics added by the msdf-generator tool ()
              // If they are missing then we throw an error.
              if (!_this59.metrics) {
                var _this59$data;
                if ((_this59$data = _this59.data) !== null && _this59$data !== void 0 && _this59$data.lightningMetrics) {
                  var _this59$data$lightnin = _this59.data.lightningMetrics,
                    ascender = _this59$data$lightnin.ascender,
                    descender = _this59$data$lightnin.descender,
                    lineGap = _this59$data$lightnin.lineGap,
                    unitsPerEm = _this59$data$lightnin.unitsPerEm;
                  _this59.metrics = {
                    ascender: ascender / unitsPerEm,
                    descender: descender / unitsPerEm,
                    lineGap: lineGap / unitsPerEm
                  };
                } else {
                  throw new Error("Font metrics not found in ".concat(_this59.type, " font ").concat(_this59.fontFamily, ". ") + 'Make sure you are using the latest version of the Lightning ' + '3 `msdf-generator` tool to generate your SDF fonts.');
                }
              }
              _this59.checkLoaded();
            }).catch(console.error);
            return _this59;
          }
          _inherits(SdfTrFontFace, _TrFontFace3);
          return _createClass(SdfTrFontFace, [{
            key: "getAtlasEntry",
            value: function getAtlasEntry(glyphId) {
              var glyph = this.glyphMap.get(glyphId);
              if (glyph === undefined) {
                throw new Error("Glyph ".concat(glyphId, " not found in font ").concat(this.fontFamily));
              }
              return {
                x: glyph.x,
                y: glyph.y,
                width: glyph.width,
                height: glyph.height
              };
            }
          }, {
            key: "checkLoaded",
            value: function checkLoaded() {
              if (this.loaded) return;
              if (this.texture.state === 'loaded' && this.data) {
                this.loaded = true;
                this.emit('loaded');
              }
            }
          }]);
        }(TrFontFace);
        var renderer$2;
        function startLightningRenderer(options) {
          var rootId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'app';
          renderer$2 = new RendererMain(options, rootId);
          return renderer$2;
        }
        function loadFonts(fonts) {
          var stage = renderer$2.stage;
          var _iterator13 = _createForOfIteratorHelper(fonts),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var font = _step13.value;
              if ('type' in font && (font.type === 'msdf' || font.type === 'ssdf')) {
                if (renderer$2.stage.renderer.mode === 'webgl') {
                  stage.fontManager.addFontFace(new SdfTrFontFace(font.type, _objectSpread(_objectSpread({}, font), {}, {
                    stage: stage
                  })));
                }
              } else if ('fontUrl' in font) {
                stage.fontManager.addFontFace(new WebTrFontFace(font));
              }
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
        }
        ({
          "BASE_URL": "/solid-demo-app/",
          "DEV": false,
          "LEGACY": true,
          "MODE": "production",
          "PROD": true,
          "SSR": false
        });
        var Config = {
          debug: false,
          focusDebug: false,
          keyDebug: false,
          animationsEnabled: true,
          animationSettings: {
            duration: 250,
            easing: "ease-in-out"
          },
          fontSettings: {
            fontFamily: "Ubuntu",
            fontSize: 100
          },
          setActiveElement: function setActiveElement() {},
          focusStateKey: "$focus"
        };
        var NodeType = {
          Element: 'element',
          TextNode: 'textNode',
          Text: 'text'
        };
        function log(msg, node) {}
        var isFunc = function isFunc(obj) {
          return obj instanceof Function;
        };
        var isFunction = exports("n", function (obj) {
          return typeof obj === 'function';
        });
        function isArray(item) {
          return Array.isArray(item);
        }
        function isString(item) {
          return typeof item === 'string';
        }
        function isNumber(item) {
          return typeof item === 'number';
        }
        function isInteger(item) {
          return Number.isInteger(item);
        }
        function isINode(node) {
          return 'destroy' in node && typeof node.destroy === 'function';
        }
        function isElementNode(node) {
          return node instanceof ElementNode;
        }
        function isElementText(node) {
          return node._type === NodeType.TextNode;
        }
        function isTextNode(node) {
          return node._type === NodeType.Text;
        }
        function keyExists(obj, keys) {
          var _iterator14 = _createForOfIteratorHelper(keys),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var _key30 = _step14.value;
              if (_key30 in obj) {
                return true;
              }
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
          return false;
        }
        var States = /*#__PURE__*/function (_Array) {
          function States(callback) {
            var _this60;
            var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, States);
            if (isArray(initialState)) {
              _this60 = _callSuper(this, States, _toConsumableArray(initialState));
              _defineProperty(_assertThisInitialized(_this60), "onChange", void 0);
            } else if (isString(initialState)) {
              _this60 = _callSuper(this, States, [initialState]); // Assert as DollarString
              _defineProperty(_assertThisInitialized(_this60), "onChange", void 0);
            } else {
              _this60 = _callSuper(this, States, _toConsumableArray(Object.entries(initialState).filter(function (_ref27) {
                var _ref28 = _slicedToArray(_ref27, 2),
                  _key = _ref28[0],
                  value = _ref28[1];
                return value;
              }).map(function (_ref29) {
                var _ref30 = _slicedToArray(_ref29, 1),
                  key = _ref30[0];
                return key;
              })));
              _defineProperty(_assertThisInitialized(_this60), "onChange", void 0);
            }
            _this60.onChange = callback;
            return _possibleConstructorReturn(_this60, _assertThisInitialized(_this60));
          }
          _inherits(States, _Array);
          return _createClass(States, [{
            key: "has",
            value: function has(state) {
              // temporary check for $ prefix
              return this.indexOf(state) >= 0 || this.indexOf("$".concat(state)) >= 0;
            }
          }, {
            key: "is",
            value: function is(state) {
              return this.indexOf(state) >= 0;
            }
          }, {
            key: "add",
            value: function add(state) {
              if (this.has(state)) {
                return;
              }
              this.push(state);
              this.onChange();
            }
          }, {
            key: "toggle",
            value: function toggle(state, force) {
              if (force === true) {
                this.add(state);
              } else if (force === false) {
                this.remove(state);
              } else {
                if (this.has(state)) {
                  this.remove(state);
                } else {
                  this.add(state);
                }
              }
            }
          }, {
            key: "merge",
            value: function merge(newStates) {
              if (isArray(newStates)) {
                this.length = 0; // Clear the current states
                this.push.apply(this, _toConsumableArray(newStates));
              } else if (isString(newStates)) {
                this.length = 0; // Clear the current states
                this.push(newStates); // Assert as DollarString
              } else {
                for (var state in newStates) {
                  var value = newStates[state];
                  if (value) {
                    if (!this.has(state)) {
                      this.push(state);
                    }
                  } else {
                    var stateIndexToRemove = this.indexOf(state);
                    if (stateIndexToRemove >= 0) {
                      this.splice(stateIndexToRemove, 1);
                    }
                  }
                }
              }
              return this;
            }
          }, {
            key: "remove",
            value: function remove(state) {
              var stateIndexToRemove = this.indexOf(state);
              if (stateIndexToRemove >= 0) {
                this.splice(stateIndexToRemove, 1);
                this.onChange();
              }
            }
          }]);
        }(/*#__PURE__*/_wrapNativeSuper(Array));
        function calculateFlex(node) {
          var children = [];
          var hasOrder = false;
          var growSize = 0;
          for (var i = 0; i < node.children.length; i++) {
            var c = node.children[i];
            if (isElementText(c) && c.text && !(c.width || c.height)) {
              return false;
            }
            // Filter empty text nodes which are place holders for <Show> and elements missing dimensions
            if (isTextNode(c) || c.flexItem === false) {
              continue;
            }
            if (c.flexOrder !== undefined) {
              hasOrder = true;
            }
            if (c.flexGrow !== undefined) {
              growSize += c.flexGrow;
            }
            children.push(c);
          }
          if (hasOrder) {
            children.sort(function (a, b) {
              return (a.flexOrder || 0) - (b.flexOrder || 0);
            });
          } else if (node.direction === 'rtl') {
            children.reverse();
          }
          var numChildren = children.length;
          var direction = node.flexDirection || 'row';
          var isRow = direction === 'row';
          var dimension = isRow ? 'width' : 'height';
          var crossDimension = isRow ? 'height' : 'width';
          var marginOne = isRow ? 'marginLeft' : 'marginTop';
          var crossMarginOne = isRow ? 'marginTop' : 'marginLeft';
          var marginTwo = isRow ? 'marginRight' : 'marginBottom';
          var crossMarginTwo = isRow ? 'marginBottom' : 'marginRight';
          var prop = isRow ? 'x' : 'y';
          var crossProp = isRow ? 'y' : 'x';
          var containerSize = node[dimension] || 0;
          var containerCrossSize = node[crossDimension] || 0;
          var gap = node.gap || 0;
          var justify = node.justifyContent || 'flexStart';
          var align = node.alignItems;
          var containerUpdated = false;
          // if there is only 1 child by default it inherits the parent size so we can skip
          if (growSize && numChildren > 1) {
            node.flexBoundary = node.flexBoundary || 'fixed'; // cant change size of flex container
            var flexBasis = children.reduce(function (prev, c) {
              return prev + (c.flexGrow != null && c.flexGrow >= 0 ? 0 : c[dimension] || 0) + (c[marginOne] || 0) + (c[marginTwo] || 0);
            }, 0);
            var growFactor = (containerSize - flexBasis - gap * (numChildren - 1)) / growSize;
            if (growFactor >= 0) {
              for (var _i3 = 0; _i3 < numChildren; _i3++) {
                var _c = children[_i3];
                if (_c.flexGrow != null && _c.flexGrow >= 0) {
                  _c[dimension] = _c.flexGrow * growFactor;
                }
              }
            } else {
              console.warn('Negative growFactor, flexGrow not applied');
            }
          }
          var itemSize = 0;
          if (justify === 'center' || justify === 'spaceBetween' || justify === 'spaceEvenly') {
            itemSize = children.reduce(function (prev, c) {
              return prev + (c[dimension] || 0) + (c[marginOne] || 0) + (c[marginTwo] || 0);
            }, 0);
          }
          // Only align children if container has a cross size
          var crossAlignChild = containerCrossSize && align ? function (c) {
            if (align === 'flexStart') {
              c[crossProp] = c[crossMarginOne] || 0;
            } else if (align === 'center') {
              c[crossProp] = (containerCrossSize - (c[crossDimension] || 0)) / 2 + (c[crossMarginOne] || 0);
            } else if (align === 'flexEnd') {
              c[crossProp] = containerCrossSize - (c[crossDimension] || 0) - (c[crossMarginTwo] || 0);
            }
          } : function (c) {
            return c;
          };
          if (isRow && node._calcHeight && !node.flexCrossBoundary) {
            var _children$;
            // Assuming all the children have the same height
            var newHeight = ((_children$ = children[0]) === null || _children$ === void 0 ? void 0 : _children$.height) || node.height;
            if (newHeight !== node.height) {
              containerUpdated = true;
              node.height = containerCrossSize = newHeight;
            }
          }
          if (justify === 'flexStart') {
            var start = node.padding || 0;
            for (var _i4 = 0; _i4 < children.length; _i4++) {
              var _c2 = children[_i4];
              _c2[prop] = start + (_c2[marginOne] || 0);
              start += (_c2[dimension] || 0) + gap + (_c2[marginOne] || 0) + (_c2[marginTwo] || 0);
              crossAlignChild(_c2);
            }
            // Update container size
            if (node.flexBoundary !== 'fixed') {
              var calculatedSize = start - gap + (node.padding || 0);
              if (calculatedSize !== containerSize) {
                // store the original size for Row & Column
                node["preFlex".concat(dimension)] = containerSize;
                node[dimension] = calculatedSize;
                return true;
              }
            }
          } else if (justify === 'flexEnd') {
            var _start = containerSize;
            for (var _i5 = numChildren - 1; _i5 >= 0; _i5--) {
              var _c3 = children[_i5];
              _c3[prop] = _start - (_c3[dimension] || 0) - (_c3[marginTwo] || 0);
              _start -= (_c3[dimension] || 0) + gap + (_c3[marginOne] || 0) + (_c3[marginTwo] || 0);
              crossAlignChild(_c3);
            }
          } else if (justify === 'center') {
            var _start2 = (containerSize - (itemSize + gap * (numChildren - 1))) / 2;
            for (var _i6 = 0; _i6 < children.length; _i6++) {
              var _c4 = children[_i6];
              _c4[prop] = _start2 + (_c4[marginOne] || 0);
              _start2 += (_c4[dimension] || 0) + gap + (_c4[marginOne] || 0) + (_c4[marginTwo] || 0);
              crossAlignChild(_c4);
            }
          } else if (justify === 'spaceBetween') {
            var toPad = (containerSize - itemSize) / (numChildren - 1);
            var _start3 = 0;
            for (var _i7 = 0; _i7 < children.length; _i7++) {
              var _c5 = children[_i7];
              _c5[prop] = _start3 + (_c5[marginOne] || 0);
              _start3 += (_c5[dimension] || 0) + toPad + (_c5[marginOne] || 0) + (_c5[marginTwo] || 0);
              crossAlignChild(_c5);
            }
          } else if (justify === 'spaceEvenly') {
            var _toPad = (containerSize - itemSize) / (numChildren + 1);
            var _start4 = _toPad;
            for (var _i8 = 0; _i8 < children.length; _i8++) {
              var _c6 = children[_i8];
              _c6[prop] = _start4 + (_c6[marginOne] || 0);
              _start4 += (_c6[dimension] || 0) + _toPad + (_c6[marginOne] || 0) + (_c6[marginTwo] || 0);
              crossAlignChild(_c6);
            }
          }
          // Container was not updated
          return containerUpdated;
        }
        var keyMapEntries = {
          ArrowLeft: 'Left',
          ArrowRight: 'Right',
          ArrowUp: 'Up',
          ArrowDown: 'Down',
          Enter: 'Enter',
          l: 'Last',
          ' ': 'Space',
          Backspace: 'Back',
          Escape: 'Escape'
        };
        var keyHoldMapEntries = {
          // Enter: 'EnterHold',
        };
        var flattenKeyMap = function flattenKeyMap(keyMap, targetMap) {
          var _loop7 = function _loop7() {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i9], 2),
              key = _Object$entries2$_i[0],
              value = _Object$entries2$_i[1];
            if (Array.isArray(value)) {
              value.forEach(function (v) {
                targetMap[v] = key;
              });
            } else if (value === null) {
              delete targetMap[key];
            } else {
              targetMap[value] = key;
            }
          };
          for (var _i9 = 0, _Object$entries2 = Object.entries(keyMap); _i9 < _Object$entries2.length; _i9++) {
            _loop7();
          }
        };
        var needFocusDebugStyles = true;
        var addFocusDebug = function addFocusDebug(prevFocusPath, newFocusPath) {
          if (needFocusDebugStyles) {
            var style = document.createElement('style');
            style.type = 'text/css';
            style.innerHTML = "\n      [data-focus=\"3\"] {\n        border: 2px solid rgba(255, 33, 33, 0.2);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus=\"2\"] {\n        border: 2px solid rgba(255, 33, 33, 0.4);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus=\"1\"] {\n        border: 4px solid rgba(255, 33, 33, 0.9);\n        border-radius: 5px;\n        transition: border-color 0.5s ease;\n      }\n    ";
            document.head.appendChild(style);
            needFocusDebugStyles = false;
          }
          prevFocusPath.forEach(function (elm) {
            elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
              focus: undefined
            });
          });
          newFocusPath.forEach(function (elm, i) {
            elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
              focus: i + 1
            });
          });
        };
        var activeElement$1;
        var setActiveElement$1 = function setActiveElement$1(elm) {
          updateFocusPath(elm, activeElement$1);
          activeElement$1 = elm;
          // Callback for libraries to use signals / refs
          Config.setActiveElement(elm);
        };
        var focusPath$1 = [];
        var updateFocusPath = function updateFocusPath(currentFocusedElm, prevFocusedElm) {
          var current = currentFocusedElm;
          var fp = [];
          while (current) {
            if (!current.states.has(Config.focusStateKey) || current === currentFocusedElm) {
              var _current$onFocus, _current$onFocusChang;
              current.states.add(Config.focusStateKey);
              (_current$onFocus = current.onFocus) === null || _current$onFocus === void 0 || _current$onFocus.call(current, currentFocusedElm, prevFocusedElm);
              (_current$onFocusChang = current.onFocusChanged) === null || _current$onFocusChang === void 0 || _current$onFocusChang.call(current, true, currentFocusedElm, prevFocusedElm);
            }
            fp.push(current);
            current = current.parent;
          }
          focusPath$1.forEach(function (elm) {
            if (!fp.includes(elm)) {
              var _elm$onBlur, _elm$onFocusChanged;
              elm.states.remove(Config.focusStateKey);
              (_elm$onBlur = elm.onBlur) === null || _elm$onBlur === void 0 || _elm$onBlur.call(elm, currentFocusedElm, prevFocusedElm);
              (_elm$onFocusChanged = elm.onFocusChanged) === null || _elm$onFocusChanged === void 0 || _elm$onFocusChanged.call(elm, false, currentFocusedElm, prevFocusedElm);
            }
          });
          if (Config.focusDebug) {
            addFocusDebug(focusPath$1, fp);
          }
          focusPath$1 = fp;
          return fp;
        };
        var propagateKeyPress = function propagateKeyPress(e, mappedEvent) {
          var isHold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var isUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var finalFocusElm;
          var numItems = focusPath$1.length;
          for (var i = numItems - 1; i >= 0; i--) {
            var elm = focusPath$1[i];
            var captureKey = "capture".concat(e.key);
            var captureHandler = elm[captureKey] || elm.captureKey;
            if (isFunction(captureHandler)) {
              if (captureHandler.call(elm, e, elm, finalFocusElm) === true) {
                return true;
              }
            }
          }
          for (var _i10 = 0; _i10 < numItems; _i10++) {
            var _elm = focusPath$1[_i10];
            if (!finalFocusElm) finalFocusElm = _elm;
            if (mappedEvent) {
              var eventHandler = isUp ? _elm["on".concat(mappedEvent, "Release")] : _elm["on".concat(mappedEvent)];
              if (isFunction(eventHandler)) {
                if (eventHandler.call(_elm, e, _elm, finalFocusElm) === true) {
                  return true;
                }
              }
            }
            if (!isUp) {
              var fallbackHandler = isHold ? _elm.onKeyHold : _elm.onKeyPress;
              if (isFunction(fallbackHandler)) {
                if (fallbackHandler.call(_elm, e, mappedEvent, _elm, finalFocusElm) === true) {
                  return true;
                }
              }
            }
          }
          return false;
        };
        var DEFAULT_KEY_HOLD_THRESHOLD = 500; // ms
        var keyHoldTimeouts = {};
        var handleKeyEvents = function handleKeyEvents(delay, keydown, keyup) {
          if (keydown) {
            var _key31 = keydown.key || keydown.keyCode;
            var mappedKeyHoldEvent = keyHoldMapEntries[keydown.key] || keyHoldMapEntries[keydown.keyCode];
            var mappedKeyEvent = keyMapEntries[keydown.key] || keyMapEntries[keydown.keyCode];
            if (mappedKeyHoldEvent) {
              if (!keyHoldTimeouts[_key31]) {
                keyHoldTimeouts[_key31] = window.setTimeout(function () {
                  keyHoldTimeouts[_key31] = true;
                  propagateKeyPress(keydown, mappedKeyHoldEvent, true);
                }, delay);
              }
              return;
            }
            propagateKeyPress(keydown, mappedKeyEvent, false);
          } else if (keyup) {
            var _key32 = keyup.key || keyup.keyCode;
            var _mappedKeyEvent = keyMapEntries[keyup.key] || keyMapEntries[keyup.keyCode];
            if (keyHoldTimeouts[_key32] === true) {
              delete keyHoldTimeouts[_key32];
            } else if (keyHoldTimeouts[_key32]) {
              clearTimeout(keyHoldTimeouts[_key32]);
              delete keyHoldTimeouts[_key32];
              // trigger key down event when hold didn't finish
              propagateKeyPress(keyup, _mappedKeyEvent, false);
            }
            propagateKeyPress(keyup, _mappedKeyEvent, false, true);
          }
        };
        var useFocusManager$1 = function useFocusManager$1() {
          var _ref31 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            userKeyMap = _ref31.userKeyMap,
            keyHoldOptions = _ref31.keyHoldOptions,
            _ref31$ownerContext = _ref31.ownerContext,
            ownerContext = _ref31$ownerContext === void 0 ? function (cb) {
              cb();
            } : _ref31$ownerContext;
          if (userKeyMap) {
            flattenKeyMap(userKeyMap, keyMapEntries);
          }
          if (keyHoldOptions !== null && keyHoldOptions !== void 0 && keyHoldOptions.userKeyHoldMap) {
            flattenKeyMap(keyHoldOptions.userKeyHoldMap, keyHoldMapEntries);
          }
          var delay = (keyHoldOptions === null || keyHoldOptions === void 0 ? void 0 : keyHoldOptions.holdThreshold) || DEFAULT_KEY_HOLD_THRESHOLD;
          var runKeyEvent = handleKeyEvents.bind(null, delay);
          // Owner context is for frameworks that need effects
          var keyPressHandler = function keyPressHandler(event) {
            return ownerContext(function () {
              runKeyEvent(event, undefined);
            });
          };
          var keyUpHandler = function keyUpHandler(event) {
            return ownerContext(function () {
              runKeyEvent(undefined, event);
            });
          };
          document.addEventListener('keyup', keyUpHandler);
          document.addEventListener('keydown', keyPressHandler);
          return {
            cleanup: function cleanup() {
              document.removeEventListener('keydown', keyPressHandler);
              document.removeEventListener('keyup', keyUpHandler);
              for (var _i11 = 0, _Object$entries3 = Object.entries(keyHoldTimeouts); _i11 < _Object$entries3.length; _i11++) {
                var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i11], 2),
                  _ = _Object$entries3$_i[0],
                  timeout = _Object$entries3$_i[1];
                if (timeout && timeout !== true) clearTimeout(timeout);
              }
            },
            focusPath: function focusPath() {
              return focusPath$1;
            }
          };
        };
        var layoutQueue = new Set();
        function runLayout() {
          var queue = _toConsumableArray(layoutQueue);
          layoutQueue.clear();
          for (var i = queue.length - 1; i >= 0; i--) {
            var node = queue[i];
            node.updateLayout();
          }
        }
        function convertEffectsToShader(node, styleEffects) {
          var effects = [];
          for (var type in styleEffects) {
            // @ts-ignore getting the right type info is hard
            effects.push(renderer$2.createEffect(type, styleEffects[type], type));
          }
          return renderer$2.createShader('DynamicShader', {
            effects: effects
          });
        }
        function borderAccessor() {
          var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          return {
            set: function set(value) {
              // Format: width || { width, color }
              if (isNumber(value)) {
                value = {
                  width: value,
                  color: 0x000000ff
                };
              }
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects || {}), _defineProperty({}, "border".concat(direction), value)) : _defineProperty({}, "border".concat(direction), value);
            },
            get: function get() {
              var _this$effects;
              return (_this$effects = this.effects) === null || _this$effects === void 0 ? void 0 : _this$effects["border".concat(direction)];
            }
          };
        }
        var LightningRendererNumberProps = ['alpha', 'color', 'colorTop', 'colorRight', 'colorLeft', 'colorBottom', 'colorTl', 'colorTr', 'colorBl', 'colorBr', 'height', 'fontSize', 'lineHeight', 'mount', 'mountX', 'mountY', 'pivot', 'pivotX', 'pivotY', 'rotation', 'scale', 'scaleX', 'scaleY', 'width', 'worldX', 'worldY', 'x', 'y', 'zIndex', 'zIndexLocked'];
        var LightningRendererNonAnimatingProps = ['absX', 'absY', 'autosize', 'clipping', 'contain', 'data', 'fontFamily', 'fontStretch', 'fontStyle', 'fontWeight', 'imageType', 'letterSpacing', 'maxLines', 'offsetY', 'overflowSuffix', 'preventCleanup', 'rtt', 'scrollable', 'scrollY', 'srcHeight', 'srcWidth', 'srcX', 'srcY', 'strictBounds', 'text', 'textAlign', 'textBaseline', 'textOverflow', 'texture', 'textureOptions', 'verticalAlign', 'wordWrap'];
        var ElementNode = /*#__PURE__*/function (_Object) {
          function ElementNode(name) {
            var _this61;
            _classCallCheck(this, ElementNode);
            _this61 = _callSuper(this, ElementNode);
            _this61._type = name === 'text' ? NodeType.TextNode : NodeType.Element;
            _this61.rendered = false;
            _this61.lng = {};
            _this61.children = [];
            return _this61;
          }
          _inherits(ElementNode, _Object);
          return _createClass(ElementNode, [{
            key: "effects",
            get: function get() {
              return this._effects;
            },
            set: function set(v) {
              this._effects = v;
              if (this.rendered) {
                this.lng.shader = convertEffectsToShader(this, v);
                // if (this.lng.shader) {
                //   updateShaderEffects(this, v);
                // } else {
                // }
              }
            }
          }, {
            key: "id",
            get: function get() {
              return this._id;
            },
            set: function set(id) {
              var _Config$rendererOptio;
              this._id = id;
              if ((_Config$rendererOptio = Config.rendererOptions) !== null && _Config$rendererOptio !== void 0 && _Config$rendererOptio.inspector) {
                this.data = _objectSpread(_objectSpread({}, this.data), {}, {
                  testId: id
                });
              }
            }
          }, {
            key: "parent",
            get: function get() {
              return this._parent;
            },
            set: function set(p) {
              this._parent = p;
              if (this.rendered) {
                var _p$lng;
                this.lng.parent = (_p$lng = p === null || p === void 0 ? void 0 : p.lng) !== null && _p$lng !== void 0 ? _p$lng : null;
              }
            }
          }, {
            key: "insertChild",
            value: function insertChild(node, beforeNode) {
              node.parent = this;
              if (beforeNode) {
                // SolidJS can move nodes around in the children array.
                // We need to insert following DOM insertBefore which moves elements.
                this.removeChild(node);
                var index = this.children.indexOf(beforeNode);
                if (index >= 0) {
                  this.children.splice(index, 0, node);
                  return;
                }
              }
              this.children.push(node);
            }
          }, {
            key: "removeChild",
            value: function removeChild(node) {
              var nodeIndexToRemove = this.children.indexOf(node);
              if (nodeIndexToRemove >= 0) {
                this.children.splice(nodeIndexToRemove, 1);
              }
            }
          }, {
            key: "selectedNode",
            get: function get() {
              var selectedIndex = this.selected || 0;
              for (var i = selectedIndex; i < this.children.length; i++) {
                var element = this.children[i];
                if (isElementNode(element)) {
                  this.selected = i;
                  return element;
                }
              }
              return undefined;
            }
          }, {
            key: "shader",
            set: function set(shaderProps) {
              var shProps = shaderProps;
              if (isArray(shaderProps)) {
                var _renderer$;
                shProps = (_renderer$ = renderer$2).createShader.apply(_renderer$, _toConsumableArray(shaderProps));
              }
              this.lng.shader = shProps;
            }
          }, {
            key: "_sendToLightningAnimatable",
            value: function _sendToLightningAnimatable(name, value) {
              var _this62 = this;
              if (this.transition && this.rendered && Config.animationsEnabled && (this.transition === true || this.transition[name])) {
                var animationSettings = this.transition === true || this.transition[name] === true ? undefined : this.transition[name];
                var animationController = this.animate(_defineProperty({}, name, value), animationSettings);
                if (this.onAnimation) {
                  var animationEvents = Object.keys(this.onAnimation);
                  var _loop8 = function _loop8() {
                    var event = _animationEvents[_i12];
                    var handler = _this62.onAnimation[event];
                    animationController.on(event, function (controller, props) {
                      handler.call(_this62, controller, name, value, props);
                    });
                  };
                  for (var _i12 = 0, _animationEvents = animationEvents; _i12 < _animationEvents.length; _i12++) {
                    _loop8();
                  }
                }
                return animationController.start();
              }
              this.lng[name] = value;
            }
          }, {
            key: "animate",
            value: function animate(props, animationSettings) {
              assertTruthy(this.rendered);
              return this.lng.animate(props, animationSettings || this.animationSettings || {});
            }
          }, {
            key: "chain",
            value: function chain(props, animationSettings) {
              if (this._animationRunning) {
                this._animationQueue = [];
                this._animationRunning = false;
              }
              if (animationSettings) {
                this._animationQueueSettings = animationSettings;
              } else if (!this._animationQueueSettings) {
                this._animationQueueSettings = animationSettings || this.animationSettings;
              }
              animationSettings = animationSettings || this._animationQueueSettings;
              this._animationQueue = this._animationQueue || [];
              this._animationQueue.push({
                props: props,
                animationSettings: animationSettings
              });
              return this;
            }
          }, {
            key: "start",
            value: function () {
              var _start5 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                var animation;
                return _regeneratorRuntime().wrap(function _callee16$(_context17) {
                  while (1) switch (_context17.prev = _context17.next) {
                    case 0:
                      animation = this._animationQueue.shift();
                    case 1:
                      if (!animation) {
                        _context17.next = 8;
                        break;
                      }
                      this._animationRunning = true;
                      _context17.next = 5;
                      return this.animate(animation.props, animation.animationSettings).start().waitUntilStopped();
                    case 5:
                      animation = this._animationQueue.shift();
                      _context17.next = 1;
                      break;
                    case 8:
                      this._animationRunning = false;
                      this._animationQueueSettings = undefined;
                    case 10:
                    case "end":
                      return _context17.stop();
                  }
                }, _callee16, this);
              }));
              function start() {
                return _start5.apply(this, arguments);
              }
              return start;
            }()
          }, {
            key: "emit",
            value: function emit(event) {
              var current = this;
              var capitalizedEvent = "on".concat(event.charAt(0).toUpperCase()).concat(event.slice(1));
              for (var _len14 = arguments.length, args = new Array(_len14 > 1 ? _len14 - 1 : 0), _key33 = 1; _key33 < _len14; _key33++) {
                args[_key33 - 1] = arguments[_key33];
              }
              while (current) {
                var handler = current[capitalizedEvent];
                if (isFunction(handler)) {
                  if (handler.call.apply(handler, [current, this].concat(args)) === true) {
                    return true;
                  }
                }
                current = current.parent;
              }
              return false;
            }
          }, {
            key: "setFocus",
            value: function setFocus() {
              var _this63 = this;
              if (this.rendered) {
                // can be 0
                if (this.forwardFocus !== undefined) {
                  if (isFunc(this.forwardFocus)) {
                    if (this.forwardFocus.call(this, this) !== false) {
                      return;
                    }
                  } else {
                    var focusedIndex = typeof this.forwardFocus === 'number' ? this.forwardFocus : null;
                    var nodes = this.children;
                    if (focusedIndex !== null && focusedIndex < nodes.length) {
                      var child = nodes[focusedIndex];
                      isElementNode(child) && child.setFocus();
                      return;
                    }
                  }
                }
                // Delay setting focus so children can render (useful for Row + Column)
                queueMicrotask(function () {
                  return setActiveElement$1(_this63);
                });
              } else {
                this._autofocus = true;
              }
            }
          }, {
            key: "_layoutOnLoad",
            value: function _layoutOnLoad() {
              var _this64 = this;
              this.lng.on('loaded', function () {
                _this64.parent.updateLayout();
              });
            }
          }, {
            key: "getText",
            value: function getText() {
              var result = '';
              for (var i = 0; i < this.children.length; i++) {
                result += this.children[i].text;
              }
              return result;
            }
          }, {
            key: "destroy",
            value: function destroy() {
              var _this65 = this;
              if (this.onDestroy) {
                var destroyPromise = this.onDestroy(this);
                // If onDestroy returns a promise, wait for it to resolve before destroying
                // Useful with animations waitUntilStopped method which returns promise
                if (destroyPromise instanceof Promise) {
                  destroyPromise.then(function () {
                    return _this65._destroy();
                  });
                } else {
                  this._destroy();
                }
              } else {
                this._destroy();
              }
            }
          }, {
            key: "_destroy",
            value: function _destroy() {
              if (this._queueDelete && isINode(this.lng)) {
                var _this$parent2;
                this.lng.destroy();
                if ((_this$parent2 = this.parent) !== null && _this$parent2 !== void 0 && _this$parent2.requiresLayout()) {
                  this.parent.updateLayout();
                }
              }
            }
          }, {
            key: "style",
            get: function get() {
              return this._style;
            },
            set: function set(style) {
              if (!style) {
                return;
              }
              this._style = style;
              // Keys set in JSX are more important
              for (var _key34 in this._style) {
                // be careful of 0 values
                if (this[_key34] === undefined) {
                  this[_key34] = this._style[_key34];
                }
              }
            }
          }, {
            key: "hasChildren",
            get: function get() {
              return this.children.length > 0;
            }
          }, {
            key: "src",
            get: function get() {
              return this.lng.src;
            },
            set: function set(src) {
              if (typeof src === 'string') {
                this.lng.src = src;
                if (!this.color && this.rendered) {
                  this.color = 0xffffffff;
                }
              } else {
                this.color = 0x00000000;
              }
            }
          }, {
            key: "getChildById",
            value: function getChildById(id) {
              return this.children.find(function (c) {
                return c.id === id;
              });
            }
          }, {
            key: "searchChildrenById",
            value: function searchChildrenById(id) {
              // traverse all the childrens children
              for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (isElementNode(child)) {
                  if (child.id === id) {
                    return child;
                  }
                  var found = child.searchChildrenById(id);
                  if (found) {
                    return found;
                  }
                }
              }
            }
          }, {
            key: "states",
            get: function get() {
              this._states = this._states || new States(this._stateChanged.bind(this));
              return this._states;
            },
            set: function set(states) {
              this._states = this._states ? this._states.merge(states) : new States(this._stateChanged.bind(this), states);
              if (this.rendered) {
                this._stateChanged();
              }
            }
          }, {
            key: "animationSettings",
            get: function get() {
              return this._animationSettings || Config.animationSettings;
            },
            set: function set(animationSettings) {
              this._animationSettings = animationSettings;
            }
          }, {
            key: "hidden",
            get: function get() {
              return this.alpha === 0;
            }
            /**
             * Sets the autofocus state of the element.
             * When set to a truthy value, the element will automatically gain focus.
             * You can also set it to a signal to recalculate
             *
             * @param val - A value to determine if the element should autofocus.
             *              A truthy value enables autofocus, otherwise disables it.
             */,
            set: function set(val) {
              this.alpha = val ? 0 : 1;
            }
          }, {
            key: "autofocus",
            get: function get() {
              return this._autofocus;
            },
            set: function set(val) {
              var _this66 = this;
              this._autofocus = val;
              // Delay setting focus so children can render (useful for Row + Column)
              // which now uses forwardFocus
              val && queueMicrotask(function () {
                return _this66.setFocus();
              });
            }
          }, {
            key: "requiresLayout",
            value: function requiresLayout() {
              return this.display === 'flex' || this.onLayout;
            }
          }, {
            key: "updateLayoutOn",
            get: function get() {
              return null;
            },
            set: function set(v) {
              this.updateLayout();
            }
          }, {
            key: "updateLayout",
            value: function updateLayout() {
              if (this.hasChildren) {
                if (this.display === 'flex') {
                  if (calculateFlex(this)) {
                    var _this$parent3;
                    (_this$parent3 = this.parent) === null || _this$parent3 === void 0 || _this$parent3.updateLayout();
                  }
                }
                if (isFunc(this.onLayout) && this.onLayout.call(this, this)) {
                  var _this$parent4;
                  (_this$parent4 = this.parent) === null || _this$parent4 === void 0 || _this$parent4.updateLayout();
                }
              }
            }
          }, {
            key: "_stateChanged",
            value: function _stateChanged() {
              var _this67 = this;
              log('State Changed: ', this, this.states);
              if (this.forwardStates) {
                // apply states to children first
                var _states = this.states.slice();
                this.children.forEach(function (c) {
                  c.states = _states;
                });
              }
              var states = this.states;
              if (this._undoStyles || keyExists(this, states)) {
                var stylesToUndo;
                if (this._undoStyles && this._undoStyles.length) {
                  stylesToUndo = {};
                  this._undoStyles.forEach(function (styleKey) {
                    stylesToUndo[styleKey] = _this67.style[styleKey];
                  });
                }
                var numStates = states.length;
                if (numStates === 0) {
                  Object.assign(this, stylesToUndo);
                  this._undoStyles = [];
                  return;
                }
                var newStyles;
                if (numStates === 1) {
                  newStyles = this[states[0]];
                  newStyles = stylesToUndo ? _objectSpread(_objectSpread({}, stylesToUndo), newStyles) : newStyles;
                } else {
                  newStyles = states.reduce(function (acc, state) {
                    var styles = _this67[state];
                    return styles ? _objectSpread(_objectSpread({}, acc), styles) : acc;
                  }, stylesToUndo || {});
                }
                if (newStyles) {
                  this._undoStyles = Object.keys(newStyles);
                  // Apply transition first
                  if (newStyles.transition !== undefined) {
                    this.transition = newStyles.transition;
                  }
                  // Apply the styles
                  Object.assign(this, newStyles);
                } else {
                  this._undoStyles = [];
                }
              }
            }
          }, {
            key: "render",
            value: function render(topNode) {
              var _node$lng;
              // Elements are inserted from the inside out, then rendered from the outside in.
              // Render starts when an element is insertered with a parent that is already renderered.
              var node = this;
              var parent = this.parent;
              if (!parent) {
                console.warn('Parent not set - no node created for: ', this);
                return;
              }
              if (!parent.rendered) {
                console.warn('Parent not rendered yet: ', this);
                return;
              }
              if (parent.requiresLayout()) {
                layoutQueue.add(parent);
              }
              if (this.rendered) {
                // This happens if Array of items is reordered to reuse elements.
                // We return after layout is queued so the change can trigger layout updates.
                return;
              }
              if (this._states) {
                this._stateChanged();
              }
              var props = node.lng;
              props.x = props.x || 0;
              props.y = props.y || 0;
              props.parent = parent.lng;
              if (this.right || this.right === 0) {
                props.x = (parent.width || 0) - this.right;
                props.mountX = 1;
              }
              if (this.bottom || this.bottom === 0) {
                props.y = (parent.height || 0) - this.bottom;
                props.mountY = 1;
              }
              if (this.center) {
                this.centerX = this.centerY = true;
              }
              if (this.centerX) {
                props.x += (parent.width || 0) / 2;
                props.mountX = 0.5;
              }
              if (this.centerY) {
                props.y += (parent.height || 0) / 2;
                props.mountY = 0.5;
              }
              if (isElementText(node)) {
                var textProps = props;
                if (Config.fontSettings) {
                  for (var _key35 in Config.fontSettings) {
                    if (textProps[_key35] === undefined) {
                      textProps[_key35] = Config.fontSettings[_key35];
                    }
                  }
                }
                textProps.text = textProps.text || node.getText();
                if (textProps.textAlign && !textProps.contain) {
                  console.warn('Text align requires contain: ', node.getText());
                }
                // contain is either width or both
                if (textProps.contain) {
                  if (!textProps.width) {
                    textProps.width = (parent.width || 0) - textProps.x - (textProps.marginRight || 0);
                  }
                  if (textProps.contain === 'both' && !textProps.height && !textProps.maxLines) {
                    textProps.height = (parent.height || 0) - textProps.y - (textProps.marginBottom || 0);
                  } else if (textProps.maxLines === 1) {
                    textProps.height = textProps.height || textProps.lineHeight || textProps.fontSize;
                  }
                }
                if (node._effects) {
                  props.shader = convertEffectsToShader(node, node._effects);
                }
                node.lng = renderer$2.createTextNode(props);
                if (parent.requiresLayout()) {
                  if (!props.width || !props.height) {
                    node._layoutOnLoad();
                  }
                }
              } else {
                // If its not an image or texture apply some defaults
                if (!props.texture) {
                  // Set width and height to parent less offset
                  if (isNaN(props.width)) {
                    props.width = (parent.width || 0) - props.x;
                    node._calcWidth = true;
                  }
                  if (isNaN(props.height)) {
                    props.height = (parent.height || 0) - props.y;
                    node._calcHeight = true;
                  }
                  if (props.rtt && !props.color) {
                    props.color = 0xffffffff;
                  }
                  if (!props.color && !props.src) {
                    // Default color to transparent - If you later set a src, you'll need
                    // to set color 0xFFFFFFFF
                    props.color = 0x00000000;
                  }
                }
                if (node._effects) {
                  props.shader = convertEffectsToShader(node, node._effects);
                }
                node.lng = renderer$2.createNode(props);
              }
              node.rendered = true;
              if (node.autosize && parent.requiresLayout()) {
                node._layoutOnLoad();
              }
              isFunc(this.onCreate) && this.onCreate.call(this, node);
              if (node.onEvent) {
                var _loop9 = function _loop9() {
                  var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i13], 2),
                    name = _Object$entries4$_i[0],
                    handler = _Object$entries4$_i[1];
                  node.lng.on(name, function (_inode, data) {
                    return handler.call(node, node, data);
                  });
                };
                for (var _i13 = 0, _Object$entries4 = Object.entries(node.onEvent); _i13 < _Object$entries4.length; _i13++) {
                  _loop9();
                }
              }
              // L3 Inspector adds div to the lng object
              //@ts-expect-error - div is not in the typings
              if ((_node$lng = node.lng) !== null && _node$lng !== void 0 && _node$lng.div) {
                //@ts-expect-error - div is not in the typings
                node.lng.div.element = node;
              }
              if (node._type === NodeType.Element) {
                // only element nodes will have children that need rendering
                var numChildren = node.children.length;
                for (var i = 0; i < numChildren; i++) {
                  var c = node.children[i];
                  if (isElementNode(c)) {
                    c.render();
                  }
                }
              }
              if (topNode) {
                //Do one pass of layout, then another with Text completed
                runLayout();
              }
              node._autofocus && node.setFocus();
            }
          }]);
        }(/*#__PURE__*/_wrapNativeSuper(Object));
        exports("E", ElementNode);
        var _loop10 = function _loop10() {
          var key = _LightningRendererNum[_i14];
          Object.defineProperty(ElementNode.prototype, key, {
            get: function get() {
              return this.lng[key];
            },
            set: function set(v) {
              this._sendToLightningAnimatable(key, v);
            }
          });
        };
        for (var _i14 = 0, _LightningRendererNum = LightningRendererNumberProps; _i14 < _LightningRendererNum.length; _i14++) {
          _loop10();
        }
        var _loop11 = function _loop11() {
          var key = _LightningRendererNon[_i15];
          Object.defineProperty(ElementNode.prototype, key, {
            get: function get() {
              return this.lng[key];
            },
            set: function set(v) {
              this.lng[key] = v;
            }
          });
        };
        for (var _i15 = 0, _LightningRendererNon = LightningRendererNonAnimatingProps; _i15 < _LightningRendererNon.length; _i15++) {
          _loop11();
        }
        // Add Border Helpers
        function createEffectAccessor(key) {
          return {
            set: function set(value) {
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects), {}, _defineProperty({}, key, value)) : _defineProperty({}, key, value);
            },
            get: function get() {
              var _this$effects2;
              return (_this$effects2 = this.effects) === null || _this$effects2 === void 0 ? void 0 : _this$effects2[key];
            }
          };
        }
        Object.defineProperties(ElementNode.prototype, {
          border: borderAccessor(),
          borderLeft: borderAccessor('Left'),
          borderRight: borderAccessor('Right'),
          borderTop: borderAccessor('Top'),
          borderBottom: borderAccessor('Bottom'),
          linearGradient: createEffectAccessor('linearGradient'),
          radialGradient: createEffectAccessor('radialGradient'),
          radialProgress: createEffectAccessor('radialProgressGradient'),
          borderRadius: {
            set: function set(radius) {
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects), {}, {
                radius: {
                  radius: radius
                }
              }) : {
                radius: {
                  radius: radius
                }
              };
            },
            get: function get() {
              var _this$effects3;
              return (_this$effects3 = this.effects) === null || _this$effects3 === void 0 || (_this$effects3 = _this$effects3.radius) === null || _this$effects3 === void 0 ? void 0 : _this$effects3.radius;
            }
          }
        });
        var sharedConfig = {
          context: undefined,
          registry: undefined,
          effects: undefined,
          done: false,
          getContextId: function getContextId() {
            return _getContextId(this.context.count);
          },
          getNextContextId: function getNextContextId() {
            return _getContextId(this.context.count++);
          }
        };
        function _getContextId(count) {
          var num = String(count),
            len = num.length - 1;
          return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
        }
        function setHydrateContext(context) {
          sharedConfig.context = context;
        }
        var equalFn = function equalFn(a, b) {
          return a === b;
        };
        var $PROXY = Symbol("solid-proxy");
        var SUPPORTS_PROXY$1 = typeof Proxy === "function";
        var $TRACK = exports("$", Symbol("solid-track"));
        var signalOptions = {
          equals: equalFn
        };
        var runEffects = runQueue;
        var STALE = 1;
        var PENDING = 2;
        var UNOWNED = {
          owned: null,
          cleanups: null,
          context: null,
          owner: null
        };
        var NO_INIT = {};
        var Owner = null;
        var Transition = null;
        var ExternalSourceConfig = null;
        var Listener = null;
        var Updates = null;
        var Effects = null;
        var ExecCount = 0;
        function createRoot(fn, detachedOwner) {
          var listener = Listener,
            owner = Owner,
            unowned = fn.length === 0,
            current = owner,
            root = unowned ? UNOWNED : {
              owned: null,
              cleanups: null,
              context: current ? current.context : null,
              owner: current
            },
            updateFn = unowned ? fn : function () {
              return fn(function () {
                return untrack(function () {
                  return cleanNode(root);
                });
              });
            };
          Owner = root;
          Listener = null;
          try {
            return runUpdates(updateFn, true);
          } finally {
            Listener = listener;
            Owner = owner;
          }
        }
        function createSignal(value, options) {
          options = options ? Object.assign({}, signalOptions, options) : signalOptions;
          var s = {
            value: value,
            observers: null,
            observerSlots: null,
            comparator: options.equals || undefined
          };
          var setter = function setter(value) {
            if (typeof value === "function") {
              value = value(s.value);
            }
            return writeSignal(s, value);
          };
          return [readSignal.bind(s), setter];
        }
        function createComputed(fn, value, options) {
          var c = createComputation(fn, value, true, STALE);
          updateComputation(c);
        }
        function createRenderEffect(fn, value, options) {
          var c = createComputation(fn, value, false, STALE);
          updateComputation(c);
        }
        function createEffect(fn, value, options) {
          runEffects = runUserEffects;
          var c = createComputation(fn, value, false, STALE);
          c.user = true;
          Effects ? Effects.push(c) : updateComputation(c);
        }
        function createMemo(fn, value, options) {
          options = options ? Object.assign({}, signalOptions, options) : signalOptions;
          var c = createComputation(fn, value, true, 0);
          c.observers = null;
          c.observerSlots = null;
          c.comparator = options.equals || undefined;
          updateComputation(c);
          return readSignal.bind(c);
        }
        function isPromise(v) {
          return v && _typeof(v) === "object" && "then" in v;
        }
        function createResource(pSource, pFetcher, pOptions) {
          var source;
          var fetcher;
          var options;
          if (typeof pFetcher === "function") {
            source = pSource;
            fetcher = pFetcher;
            options = {};
          } else {
            source = true;
            fetcher = pSource;
            options = pFetcher || {};
          }
          var pr = null,
            initP = NO_INIT,
            id = null,
            scheduled = false,
            resolved = "initialValue" in options,
            dynamic = typeof source === "function" && createMemo(source);
          var contexts = new Set(),
            _ref34 = (options.storage || createSignal)(options.initialValue),
            _ref35 = _slicedToArray(_ref34, 2),
            value = _ref35[0],
            setValue = _ref35[1],
            _createSignal = createSignal(undefined),
            _createSignal2 = _slicedToArray(_createSignal, 2),
            error = _createSignal2[0],
            setError = _createSignal2[1],
            _createSignal3 = createSignal(undefined, {
              equals: false
            }),
            _createSignal4 = _slicedToArray(_createSignal3, 2),
            track = _createSignal4[0],
            trigger = _createSignal4[1],
            _createSignal5 = createSignal(resolved ? "ready" : "unresolved"),
            _createSignal6 = _slicedToArray(_createSignal5, 2),
            state = _createSignal6[0],
            setState = _createSignal6[1];
          if (sharedConfig.context) {
            id = sharedConfig.getNextContextId();
            if (options.ssrLoadFrom === "initial") initP = options.initialValue;else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
          }
          function loadEnd(p, v, error, key) {
            if (pr === p) {
              pr = null;
              key !== undefined && (resolved = true);
              if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(function () {
                return options.onHydrated(key, {
                  value: v
                });
              });
              initP = NO_INIT;
              completeLoad(v, error);
            }
            return v;
          }
          function completeLoad(v, err) {
            runUpdates(function () {
              if (err === undefined) setValue(function () {
                return v;
              });
              setState(err !== undefined ? "errored" : resolved ? "ready" : "unresolved");
              setError(err);
              var _iterator15 = _createForOfIteratorHelper(contexts.keys()),
                _step15;
              try {
                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                  var c = _step15.value;
                  c.decrement();
                }
              } catch (err) {
                _iterator15.e(err);
              } finally {
                _iterator15.f();
              }
              contexts.clear();
            }, false);
          }
          function read() {
            var c = SuspenseContext,
              v = value(),
              err = error();
            if (err !== undefined && !pr) throw err;
            if (Listener && !Listener.user && c) ;
            return v;
          }
          function load() {
            var refetching = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            if (refetching !== false && scheduled) return;
            scheduled = false;
            var lookup = dynamic ? dynamic() : source;
            if (lookup == null || lookup === false) {
              loadEnd(pr, untrack(value));
              return;
            }
            var p = initP !== NO_INIT ? initP : untrack(function () {
              return fetcher(lookup, {
                value: value(),
                refetching: refetching
              });
            });
            if (!isPromise(p)) {
              loadEnd(pr, p, undefined, lookup);
              return p;
            }
            pr = p;
            if ("value" in p) {
              if (p.status === "success") loadEnd(pr, p.value, undefined, lookup);else loadEnd(pr, undefined, castError(p.value), lookup);
              return p;
            }
            scheduled = true;
            queueMicrotask(function () {
              return scheduled = false;
            });
            runUpdates(function () {
              setState(resolved ? "refreshing" : "pending");
              trigger();
            }, false);
            return p.then(function (v) {
              return loadEnd(p, v, undefined, lookup);
            }, function (e) {
              return loadEnd(p, undefined, castError(e), lookup);
            });
          }
          Object.defineProperties(read, {
            state: {
              get: function get() {
                return state();
              }
            },
            error: {
              get: function get() {
                return error();
              }
            },
            loading: {
              get: function get() {
                var s = state();
                return s === "pending" || s === "refreshing";
              }
            },
            latest: {
              get: function get() {
                if (!resolved) return read();
                var err = error();
                if (err && !pr) throw err;
                return value();
              }
            }
          });
          if (dynamic) createComputed(function () {
            return load(false);
          });else load(false);
          return [read, {
            refetch: load,
            mutate: setValue
          }];
        }
        function createSelector(source) {
          var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : equalFn;
          var options = arguments.length > 2 ? arguments[2] : undefined;
          var subs = new Map();
          var node = createComputation(function (p) {
            var v = source();
            var _iterator16 = _createForOfIteratorHelper(subs.entries()),
              _step16;
            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var _step16$value = _slicedToArray(_step16.value, 2),
                  _key36 = _step16$value[0],
                  val = _step16$value[1];
                if (fn(_key36, v) !== fn(_key36, p)) {
                  var _iterator17 = _createForOfIteratorHelper(val.values()),
                    _step17;
                  try {
                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                      var c = _step17.value;
                      c.state = STALE;
                      if (c.pure) Updates.push(c);else Effects.push(c);
                    }
                  } catch (err) {
                    _iterator17.e(err);
                  } finally {
                    _iterator17.f();
                  }
                }
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
            return v;
          }, undefined, true, STALE);
          updateComputation(node);
          return function (key) {
            var listener = Listener;
            if (listener) {
              var l;
              if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));
              onCleanup(function () {
                l.delete(listener);
                !l.size && subs.delete(key);
              });
            }
            return fn(key, node.value);
          };
        }
        function batch(fn) {
          return runUpdates(fn, false);
        }
        function untrack(fn) {
          if (Listener === null) return fn();
          var listener = Listener;
          Listener = null;
          try {
            if (ExternalSourceConfig) ;
            return fn();
          } finally {
            Listener = listener;
          }
        }
        function on(deps, fn, options) {
          var isArray = Array.isArray(deps);
          var prevInput;
          var defer = options && options.defer;
          return function (prevValue) {
            var input;
            if (isArray) {
              input = Array(deps.length);
              for (var i = 0; i < deps.length; i++) input[i] = deps[i]();
            } else input = deps();
            if (defer) {
              defer = false;
              return prevValue;
            }
            var result = untrack(function () {
              return fn(input, prevInput, prevValue);
            });
            prevInput = input;
            return result;
          };
        }
        function onMount(fn) {
          createEffect(function () {
            return untrack(fn);
          });
        }
        function onCleanup(fn) {
          if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
          return fn;
        }
        function getOwner() {
          return Owner;
        }
        function runWithOwner(o, fn) {
          var prev = Owner;
          var prevListener = Listener;
          Owner = o;
          Listener = null;
          try {
            return runUpdates(fn, true);
          } catch (err) {
            handleError(err);
          } finally {
            Owner = prev;
            Listener = prevListener;
          }
        }
        function startTransition(fn) {
          var l = Listener;
          var o = Owner;
          return Promise.resolve().then(function () {
            Listener = l;
            Owner = o;
            var t;
            runUpdates(fn, false);
            Listener = Owner = null;
            return t ? t.done : undefined;
          });
        }
        function createContext(defaultValue, options) {
          var id = Symbol("context");
          return {
            id: id,
            Provider: createProvider(id),
            defaultValue: defaultValue
          };
        }
        function useContext(context) {
          var value;
          return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined ? value : context.defaultValue;
        }
        function children(fn) {
          var children = createMemo(fn);
          var memo = createMemo(function () {
            return resolveChildren(children());
          });
          memo.toArray = function () {
            var c = memo();
            return Array.isArray(c) ? c : c != null ? [c] : [];
          };
          return memo;
        }
        var SuspenseContext;
        function readSignal() {
          var _this68 = this;
          if (this.sources && this.state) {
            if (this.state === STALE) updateComputation(this);else {
              var updates = Updates;
              Updates = null;
              runUpdates(function () {
                return lookUpstream(_this68);
              }, false);
              Updates = updates;
            }
          }
          if (Listener) {
            var sSlot = this.observers ? this.observers.length : 0;
            if (!Listener.sources) {
              Listener.sources = [this];
              Listener.sourceSlots = [sSlot];
            } else {
              Listener.sources.push(this);
              Listener.sourceSlots.push(sSlot);
            }
            if (!this.observers) {
              this.observers = [Listener];
              this.observerSlots = [Listener.sources.length - 1];
            } else {
              this.observers.push(Listener);
              this.observerSlots.push(Listener.sources.length - 1);
            }
          }
          return this.value;
        }
        function writeSignal(node, value, isComp) {
          var current = node.value;
          if (!node.comparator || !node.comparator(current, value)) {
            node.value = value;
            if (node.observers && node.observers.length) {
              runUpdates(function () {
                for (var i = 0; i < node.observers.length; i += 1) {
                  var o = node.observers[i];
                  var TransitionRunning = Transition && Transition.running;
                  if (TransitionRunning && Transition.disposed.has(o)) ;
                  if (TransitionRunning ? !o.tState : !o.state) {
                    if (o.pure) Updates.push(o);else Effects.push(o);
                    if (o.observers) markDownstream(o);
                  }
                  if (!TransitionRunning) o.state = STALE;
                }
                if (Updates.length > 10e5) {
                  Updates = [];
                  if (false) ;
                  throw new Error();
                }
              }, false);
            }
          }
          return value;
        }
        function updateComputation(node) {
          if (!node.fn) return;
          cleanNode(node);
          var time = ExecCount;
          runComputation(node, node.value, time);
        }
        function runComputation(node, value, time) {
          var nextValue;
          var owner = Owner,
            listener = Listener;
          Listener = Owner = node;
          try {
            nextValue = node.fn(value);
          } catch (err) {
            if (node.pure) {
              {
                node.state = STALE;
                node.owned && node.owned.forEach(cleanNode);
                node.owned = null;
              }
            }
            node.updatedAt = time + 1;
            return handleError(err);
          } finally {
            Listener = listener;
            Owner = owner;
          }
          if (!node.updatedAt || node.updatedAt <= time) {
            if (node.updatedAt != null && "observers" in node) {
              writeSignal(node, nextValue);
            } else node.value = nextValue;
            node.updatedAt = time;
          }
        }
        function createComputation(fn, init, pure) {
          var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STALE;
          var options = arguments.length > 4 ? arguments[4] : undefined;
          var c = {
            fn: fn,
            state: state,
            updatedAt: null,
            owned: null,
            sources: null,
            sourceSlots: null,
            cleanups: null,
            value: init,
            owner: Owner,
            context: Owner ? Owner.context : null,
            pure: pure
          };
          if (Owner === null) ;else if (Owner !== UNOWNED) {
            {
              if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
            }
          }
          return c;
        }
        function runTop(node) {
          if (node.state === 0) return;
          if (node.state === PENDING) return lookUpstream(node);
          if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
          var ancestors = [node];
          while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
            if (node.state) ancestors.push(node);
          }
          for (var i = ancestors.length - 1; i >= 0; i--) {
            node = ancestors[i];
            if (node.state === STALE) {
              updateComputation(node);
            } else if (node.state === PENDING) {
              var updates = Updates;
              Updates = null;
              runUpdates(function () {
                return lookUpstream(node, ancestors[0]);
              }, false);
              Updates = updates;
            }
          }
        }
        function runUpdates(fn, init) {
          if (Updates) return fn();
          var wait = false;
          if (!init) Updates = [];
          if (Effects) wait = true;else Effects = [];
          ExecCount++;
          try {
            var res = fn();
            completeUpdates(wait);
            return res;
          } catch (err) {
            if (!wait) Effects = null;
            Updates = null;
            handleError(err);
          }
        }
        function completeUpdates(wait) {
          if (Updates) {
            runQueue(Updates);
            Updates = null;
          }
          if (wait) return;
          var e = Effects;
          Effects = null;
          if (e.length) runUpdates(function () {
            return runEffects(e);
          }, false);
        }
        function runQueue(queue) {
          for (var i = 0; i < queue.length; i++) runTop(queue[i]);
        }
        function runUserEffects(queue) {
          var i,
            userLength = 0;
          for (i = 0; i < queue.length; i++) {
            var e = queue[i];
            if (!e.user) runTop(e);else queue[userLength++] = e;
          }
          if (sharedConfig.context) {
            if (sharedConfig.count) {
              var _sharedConfig$effects;
              sharedConfig.effects || (sharedConfig.effects = []);
              (_sharedConfig$effects = sharedConfig.effects).push.apply(_sharedConfig$effects, _toConsumableArray(queue.slice(0, userLength)));
              return;
            }
            setHydrateContext();
          }
          if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
            queue = [].concat(_toConsumableArray(sharedConfig.effects), _toConsumableArray(queue));
            userLength += sharedConfig.effects.length;
            delete sharedConfig.effects;
          }
          for (i = 0; i < userLength; i++) runTop(queue[i]);
        }
        function lookUpstream(node, ignore) {
          node.state = 0;
          for (var i = 0; i < node.sources.length; i += 1) {
            var source = node.sources[i];
            if (source.sources) {
              var state = source.state;
              if (state === STALE) {
                if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
              } else if (state === PENDING) lookUpstream(source, ignore);
            }
          }
        }
        function markDownstream(node) {
          for (var i = 0; i < node.observers.length; i += 1) {
            var o = node.observers[i];
            if (!o.state) {
              o.state = PENDING;
              if (o.pure) Updates.push(o);else Effects.push(o);
              o.observers && markDownstream(o);
            }
          }
        }
        function cleanNode(node) {
          var i;
          if (node.sources) {
            while (node.sources.length) {
              var source = node.sources.pop(),
                index = node.sourceSlots.pop(),
                obs = source.observers;
              if (obs && obs.length) {
                var n = obs.pop(),
                  s = source.observerSlots.pop();
                if (index < obs.length) {
                  n.sourceSlots[s] = index;
                  obs[index] = n;
                  source.observerSlots[index] = s;
                }
              }
            }
          }
          if (node.tOwned) {
            for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
            delete node.tOwned;
          }
          if (node.owned) {
            for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
            node.owned = null;
          }
          if (node.cleanups) {
            for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
            node.cleanups = null;
          }
          node.state = 0;
        }
        function castError(err) {
          if (err instanceof Error) return err;
          return new Error(typeof err === "string" ? err : "Unknown error", {
            cause: err
          });
        }
        function handleError(err) {
          var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Owner;
          var error = castError(err);
          throw error;
        }
        function resolveChildren(children) {
          if (typeof children === "function" && !children.length) return resolveChildren(children());
          if (Array.isArray(children)) {
            var results = [];
            for (var i = 0; i < children.length; i++) {
              var result = resolveChildren(children[i]);
              Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
            }
            return results;
          }
          return children;
        }
        function createProvider(id, options) {
          return function provider(props) {
            var res;
            createRenderEffect(function () {
              return res = untrack(function () {
                Owner.context = _objectSpread(_objectSpread({}, Owner.context), {}, _defineProperty({}, id, props.value));
                return children(function () {
                  return props.children;
                });
              });
            }, undefined);
            return res;
          };
        }
        var FALLBACK = Symbol("fallback");
        function dispose(d) {
          for (var i = 0; i < d.length; i++) d[i]();
        }
        function mapArray(list, mapFn) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var items = [],
            mapped = [],
            disposers = [],
            len = 0,
            indexes = mapFn.length > 1 ? [] : null;
          onCleanup(function () {
            return dispose(disposers);
          });
          return function () {
            var newItems = list() || [],
              newLen = newItems.length,
              i,
              j;
            newItems[$TRACK];
            return untrack(function () {
              var newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
              if (newLen === 0) {
                if (len !== 0) {
                  dispose(disposers);
                  disposers = [];
                  items = [];
                  mapped = [];
                  len = 0;
                  indexes && (indexes = []);
                }
                if (options.fallback) {
                  items = [FALLBACK];
                  mapped[0] = createRoot(function (disposer) {
                    disposers[0] = disposer;
                    return options.fallback();
                  });
                  len = 1;
                }
              } else if (len === 0) {
                mapped = new Array(newLen);
                for (j = 0; j < newLen; j++) {
                  items[j] = newItems[j];
                  mapped[j] = createRoot(mapper);
                }
                len = newLen;
              } else {
                temp = new Array(newLen);
                tempdisposers = new Array(newLen);
                indexes && (tempIndexes = new Array(newLen));
                for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
                for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
                  temp[newEnd] = mapped[end];
                  tempdisposers[newEnd] = disposers[end];
                  indexes && (tempIndexes[newEnd] = indexes[end]);
                }
                newIndices = new Map();
                newIndicesNext = new Array(newEnd + 1);
                for (j = newEnd; j >= start; j--) {
                  item = newItems[j];
                  i = newIndices.get(item);
                  newIndicesNext[j] = i === undefined ? -1 : i;
                  newIndices.set(item, j);
                }
                for (i = start; i <= end; i++) {
                  item = items[i];
                  j = newIndices.get(item);
                  if (j !== undefined && j !== -1) {
                    temp[j] = mapped[i];
                    tempdisposers[j] = disposers[i];
                    indexes && (tempIndexes[j] = indexes[i]);
                    j = newIndicesNext[j];
                    newIndices.set(item, j);
                  } else disposers[i]();
                }
                for (j = start; j < newLen; j++) {
                  if (j in temp) {
                    mapped[j] = temp[j];
                    disposers[j] = tempdisposers[j];
                    if (indexes) {
                      indexes[j] = tempIndexes[j];
                      indexes[j](j);
                    }
                  } else mapped[j] = createRoot(mapper);
                }
                mapped = mapped.slice(0, len = newLen);
                items = newItems.slice(0);
              }
              return mapped;
            });
            function mapper(disposer) {
              disposers[j] = disposer;
              if (indexes) {
                var _createSignal7 = createSignal(j),
                  _createSignal8 = _slicedToArray(_createSignal7, 2),
                  s = _createSignal8[0],
                  set = _createSignal8[1];
                indexes[j] = set;
                return mapFn(newItems[j], s);
              }
              return mapFn(newItems[j]);
            }
          };
        }
        function indexArray(list, mapFn) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var items = [],
            mapped = [],
            disposers = [],
            signals = [],
            len = 0,
            i;
          onCleanup(function () {
            return dispose(disposers);
          });
          return function () {
            var newItems = list() || [],
              newLen = newItems.length;
            newItems[$TRACK];
            return untrack(function () {
              if (newLen === 0) {
                if (len !== 0) {
                  dispose(disposers);
                  disposers = [];
                  items = [];
                  mapped = [];
                  len = 0;
                  signals = [];
                }
                if (options.fallback) {
                  items = [FALLBACK];
                  mapped[0] = createRoot(function (disposer) {
                    disposers[0] = disposer;
                    return options.fallback();
                  });
                  len = 1;
                }
                return mapped;
              }
              if (items[0] === FALLBACK) {
                disposers[0]();
                disposers = [];
                items = [];
                mapped = [];
                len = 0;
              }
              for (i = 0; i < newLen; i++) {
                if (i < items.length && items[i] !== newItems[i]) {
                  signals[i](function () {
                    return newItems[i];
                  });
                } else if (i >= items.length) {
                  mapped[i] = createRoot(mapper);
                }
              }
              for (; i < items.length; i++) {
                disposers[i]();
              }
              len = signals.length = disposers.length = newLen;
              items = newItems.slice(0);
              return mapped = mapped.slice(0, len);
            });
            function mapper(disposer) {
              disposers[i] = disposer;
              var _createSignal9 = createSignal(newItems[i]),
                _createSignal10 = _slicedToArray(_createSignal9, 2),
                s = _createSignal10[0],
                set = _createSignal10[1];
              signals[i] = set;
              return mapFn(s, i);
            }
          };
        }
        function createComponent$1(Comp, props) {
          return untrack(function () {
            return Comp(props || {});
          });
        }
        function trueFn() {
          return true;
        }
        var propTraps = {
          get: function get(_, property, receiver) {
            if (property === $PROXY) return receiver;
            return _.get(property);
          },
          has: function has(_, property) {
            if (property === $PROXY) return true;
            return _.has(property);
          },
          set: trueFn,
          deleteProperty: trueFn,
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_, property) {
            return {
              configurable: true,
              enumerable: true,
              get: function get() {
                return _.get(property);
              },
              set: trueFn,
              deleteProperty: trueFn
            };
          },
          ownKeys: function ownKeys(_) {
            return _.keys();
          }
        };
        function resolveSource(s) {
          return !(s = typeof s === "function" ? s() : s) ? {} : s;
        }
        function resolveSources() {
          for (var i = 0, length = this.length; i < length; ++i) {
            var v = this[i]();
            if (v !== undefined) return v;
          }
        }
        function mergeProps$1() {
          for (var _len15 = arguments.length, sources = new Array(_len15), _key37 = 0; _key37 < _len15; _key37++) {
            sources[_key37] = arguments[_key37];
          }
          var proxy = false;
          for (var i = 0; i < sources.length; i++) {
            var s = sources[i];
            proxy = proxy || !!s && $PROXY in s;
            sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
          }
          if (SUPPORTS_PROXY$1 && proxy) {
            return new Proxy({
              get: function get(property) {
                for (var _i16 = sources.length - 1; _i16 >= 0; _i16--) {
                  var v = resolveSource(sources[_i16])[property];
                  if (v !== undefined) return v;
                }
              },
              has: function has(property) {
                for (var _i17 = sources.length - 1; _i17 >= 0; _i17--) {
                  if (property in resolveSource(sources[_i17])) return true;
                }
                return false;
              },
              keys: function keys() {
                var keys = [];
                for (var _i18 = 0; _i18 < sources.length; _i18++) keys.push.apply(keys, _toConsumableArray(Object.keys(resolveSource(sources[_i18]))));
                return _toConsumableArray(new Set(keys));
              }
            }, propTraps);
          }
          var sourcesMap = {};
          var defined = Object.create(null);
          for (var _i19 = sources.length - 1; _i19 >= 0; _i19--) {
            var source = sources[_i19];
            if (!source) continue;
            var sourceKeys = Object.getOwnPropertyNames(source);
            var _loop12 = function _loop12() {
              var key = sourceKeys[_i20];
              if (key === "__proto__" || key === "constructor") return 1; // continue
              var desc = Object.getOwnPropertyDescriptor(source, key);
              if (!defined[key]) {
                defined[key] = desc.get ? {
                  enumerable: true,
                  configurable: true,
                  get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
                } : desc.value !== undefined ? desc : undefined;
              } else {
                var _sources = sourcesMap[key];
                if (_sources) {
                  if (desc.get) _sources.push(desc.get.bind(source));else if (desc.value !== undefined) _sources.push(function () {
                    return desc.value;
                  });
                }
              }
            };
            for (var _i20 = sourceKeys.length - 1; _i20 >= 0; _i20--) {
              if (_loop12()) continue;
            }
          }
          var target = {};
          var definedKeys = Object.keys(defined);
          for (var _i21 = definedKeys.length - 1; _i21 >= 0; _i21--) {
            var _key38 = definedKeys[_i21],
              desc = defined[_key38];
            if (desc && desc.get) Object.defineProperty(target, _key38, desc);else target[_key38] = desc ? desc.value : undefined;
          }
          return target;
        }
        function splitProps(props) {
          for (var _len16 = arguments.length, keys = new Array(_len16 > 1 ? _len16 - 1 : 0), _key39 = 1; _key39 < _len16; _key39++) {
            keys[_key39 - 1] = arguments[_key39];
          }
          if (SUPPORTS_PROXY$1 && $PROXY in props) {
            var blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
            var res = keys.map(function (k) {
              return new Proxy({
                get: function get(property) {
                  return k.includes(property) ? props[property] : undefined;
                },
                has: function has(property) {
                  return k.includes(property) && property in props;
                },
                keys: function keys() {
                  return k.filter(function (property) {
                    return property in props;
                  });
                }
              }, propTraps);
            });
            res.push(new Proxy({
              get: function get(property) {
                return blocked.has(property) ? undefined : props[property];
              },
              has: function has(property) {
                return blocked.has(property) ? false : property in props;
              },
              keys: function keys() {
                return Object.keys(props).filter(function (k) {
                  return !blocked.has(k);
                });
              }
            }, propTraps));
            return res;
          }
          var otherObject = {};
          var objects = keys.map(function () {
            return {};
          });
          var _iterator18 = _createForOfIteratorHelper(Object.getOwnPropertyNames(props)),
            _step18;
          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var propName = _step18.value;
              var desc = Object.getOwnPropertyDescriptor(props, propName);
              var isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
              var _blocked = false;
              var objectIndex = 0;
              var _iterator19 = _createForOfIteratorHelper(keys),
                _step19;
              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  var k = _step19.value;
                  if (k.includes(propName)) {
                    _blocked = true;
                    isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
                  }
                  ++objectIndex;
                }
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }
              if (!_blocked) {
                isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
              }
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }
          return [].concat(_toConsumableArray(objects), [otherObject]);
        }
        function lazy(fn) {
          var comp;
          var p;
          var wrap = function wrap(props) {
            var ctx = sharedConfig.context;
            if (ctx) {
              var _createSignal11 = createSignal(),
                _createSignal12 = _slicedToArray(_createSignal11, 2),
                s = _createSignal12[0],
                set = _createSignal12[1];
              sharedConfig.count || (sharedConfig.count = 0);
              sharedConfig.count++;
              (p || (p = fn())).then(function (mod) {
                !sharedConfig.done && setHydrateContext(ctx);
                sharedConfig.count--;
                set(function () {
                  return mod.default;
                });
                setHydrateContext();
              });
              comp = s;
            } else if (!comp) {
              var _createResource = createResource(function () {
                  return (p || (p = fn())).then(function (mod) {
                    return mod.default;
                  });
                }),
                _createResource2 = _slicedToArray(_createResource, 1),
                _s = _createResource2[0];
              comp = _s;
            }
            var Comp;
            return createMemo(function () {
              return (Comp = comp()) ? untrack(function () {
                if (false) ;
                if (!ctx || sharedConfig.done) return Comp(props);
                var c = sharedConfig.context;
                setHydrateContext(ctx);
                var r = Comp(props);
                setHydrateContext(c);
                return r;
              }) : "";
            });
          };
          wrap.preload = function () {
            return p || ((p = fn()).then(function (mod) {
              return comp = function comp() {
                return mod.default;
              };
            }), p);
          };
          return wrap;
        }
        var narrowedError = function narrowedError(name) {
          return "Stale read from <".concat(name, ">.");
        };
        function For(props) {
          var fallback = "fallback" in props && {
            fallback: function fallback() {
              return props.fallback;
            }
          };
          return createMemo(mapArray(function () {
            return props.each;
          }, props.children, fallback || undefined));
        }
        function Index(props) {
          var fallback = "fallback" in props && {
            fallback: function fallback() {
              return props.fallback;
            }
          };
          return createMemo(indexArray(function () {
            return props.each;
          }, props.children, fallback || undefined));
        }
        function Show(props) {
          var keyed = props.keyed;
          var condition = createMemo(function () {
            return props.when;
          }, undefined, {
            equals: function equals(a, b) {
              return keyed ? a === b : !a === !b;
            }
          });
          return createMemo(function () {
            var c = condition();
            if (c) {
              var child = props.children;
              var fn = typeof child === "function" && child.length > 0;
              return fn ? untrack(function () {
                return child(keyed ? c : function () {
                  if (!untrack(condition)) throw narrowedError("Show");
                  return props.when;
                });
              }) : child;
            }
            return props.fallback;
          }, undefined, undefined);
        }
        var _createSignal13 = createSignal(undefined),
          _createSignal14 = _slicedToArray(_createSignal13, 2),
          activeElement = _createSignal14[0],
          setActiveElement = _createSignal14[1];
        exports("q", activeElement);
        function hexColor() {
          var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          if (isInteger(color)) {
            return color;
          }
          if (typeof color === "string") {
            if (color.startsWith("#")) {
              return Number(color.replace("#", "0x") + (color.length === 7 ? "ff" : ""));
            }
            if (color.startsWith("0x")) {
              return Number(color);
            }
            return Number("0x" + (color.length === 6 ? color + "ff" : color));
          }
          return 0;
        }
        function combineStyles(style1, style2) {
          if (!style1) {
            return style2;
          }
          if (!style2) {
            return style1;
          }
          return _objectSpread(_objectSpread({}, style2), style1);
        }
        function createRenderer$1(_ref36) {
          var createElement = _ref36.createElement,
            createTextNode = _ref36.createTextNode,
            isTextNode = _ref36.isTextNode,
            replaceText = _ref36.replaceText,
            insertNode = _ref36.insertNode,
            removeNode = _ref36.removeNode,
            setProperty = _ref36.setProperty,
            getParentNode = _ref36.getParentNode,
            getFirstChild = _ref36.getFirstChild,
            getNextSibling = _ref36.getNextSibling;
          function insert(parent, accessor, marker, initial) {
            if (marker !== undefined && !initial) initial = [];
            if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
            createRenderEffect(function (current) {
              return insertExpression(parent, accessor(), current, marker);
            }, initial);
          }
          function insertExpression(parent, value, current, marker, unwrapArray) {
            while (typeof current === "function") current = current();
            if (value === current) return current;
            var t = _typeof(value),
              multi = marker !== undefined;
            if (t === "string" || t === "number") {
              if (t === "number") value = value.toString();
              if (multi) {
                var node = current[0];
                if (node && isTextNode(node)) {
                  replaceText(node, value);
                } else node = createTextNode(value);
                current = cleanChildren(parent, current, marker, node);
              } else {
                if (current !== "" && typeof current === "string") {
                  replaceText(getFirstChild(parent), current = value);
                } else {
                  cleanChildren(parent, current, marker, createTextNode(value));
                  current = value;
                }
              }
            } else if (value == null || t === "boolean") {
              current = cleanChildren(parent, current, marker);
            } else if (t === "function") {
              createRenderEffect(function () {
                var v = value();
                while (typeof v === "function") v = v();
                current = insertExpression(parent, v, current, marker);
              });
              return function () {
                return current;
              };
            } else if (Array.isArray(value)) {
              var array = [];
              if (normalizeIncomingArray(array, value, unwrapArray)) {
                createRenderEffect(function () {
                  return current = insertExpression(parent, array, current, marker, true);
                });
                return function () {
                  return current;
                };
              }
              if (array.length === 0) {
                var replacement = cleanChildren(parent, current, marker);
                if (multi) return current = replacement;
              } else {
                if (Array.isArray(current)) {
                  if (current.length === 0) {
                    appendNodes(parent, array, marker);
                  } else reconcileArrays(parent, current, array);
                } else if (current == null || current === "") {
                  appendNodes(parent, array);
                } else {
                  reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
                }
              }
              current = array;
            } else {
              if (Array.isArray(current)) {
                if (multi) return current = cleanChildren(parent, current, marker, value);
                cleanChildren(parent, current, null, value);
              } else if (current == null || current === "" || !getFirstChild(parent)) {
                insertNode(parent, value);
              } else replaceNode(parent, value, getFirstChild(parent));
              current = value;
            }
            return current;
          }
          function normalizeIncomingArray(normalized, array, unwrap) {
            var dynamic = false;
            for (var i = 0, len = array.length; i < len; i++) {
              var item = array[i],
                t = void 0;
              if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {
                dynamic = normalizeIncomingArray(normalized, item) || dynamic;
              } else if ((t = _typeof(item)) === "string" || t === "number") {
                normalized.push(createTextNode(item));
              } else if (t === "function") {
                if (unwrap) {
                  while (typeof item === "function") item = item();
                  dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
                } else {
                  normalized.push(item);
                  dynamic = true;
                }
              } else normalized.push(item);
            }
            return dynamic;
          }
          function reconcileArrays(parentNode, a, b) {
            var bLength = b.length,
              aEnd = a.length,
              bEnd = bLength,
              aStart = 0,
              bStart = 0,
              after = getNextSibling(a[aEnd - 1]),
              map = null;
            while (aStart < aEnd || bStart < bEnd) {
              if (a[aStart] === b[bStart]) {
                aStart++;
                bStart++;
                continue;
              }
              while (a[aEnd - 1] === b[bEnd - 1]) {
                aEnd--;
                bEnd--;
              }
              if (aEnd === aStart) {
                var node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
                while (bStart < bEnd) insertNode(parentNode, b[bStart++], node);
              } else if (bEnd === bStart) {
                while (aStart < aEnd) {
                  if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
                  aStart++;
                }
              } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
                var _node = getNextSibling(a[--aEnd]);
                insertNode(parentNode, b[bStart++], getNextSibling(a[aStart++]));
                insertNode(parentNode, b[--bEnd], _node);
                a[aEnd] = b[bEnd];
              } else {
                if (!map) {
                  map = new Map();
                  var i = bStart;
                  while (i < bEnd) map.set(b[i], i++);
                }
                var index = map.get(a[aStart]);
                if (index != null) {
                  if (bStart < index && index < bEnd) {
                    var _i22 = aStart,
                      sequence = 1,
                      t = void 0;
                    while (++_i22 < aEnd && _i22 < bEnd) {
                      if ((t = map.get(a[_i22])) == null || t !== index + sequence) break;
                      sequence++;
                    }
                    if (sequence > index - bStart) {
                      var _node2 = a[aStart];
                      while (bStart < index) insertNode(parentNode, b[bStart++], _node2);
                    } else replaceNode(parentNode, b[bStart++], a[aStart++]);
                  } else aStart++;
                } else removeNode(parentNode, a[aStart++]);
              }
            }
          }
          function cleanChildren(parent, current, marker, replacement) {
            if (marker === undefined) {
              var removed;
              while (removed = getFirstChild(parent)) removeNode(parent, removed);
              replacement && insertNode(parent, replacement);
              return "";
            }
            var node = replacement || createTextNode("");
            if (current.length) {
              var inserted = false;
              for (var i = current.length - 1; i >= 0; i--) {
                var el = current[i];
                if (node !== el) {
                  var isParent = getParentNode(el) === parent;
                  if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode(parent, node, marker);else isParent && removeNode(parent, el);
                } else inserted = true;
              }
            } else insertNode(parent, node, marker);
            return [node];
          }
          function appendNodes(parent, array, marker) {
            for (var i = 0, len = array.length; i < len; i++) insertNode(parent, array[i], marker);
          }
          function replaceNode(parent, newNode, oldNode) {
            insertNode(parent, newNode, oldNode);
            removeNode(parent, oldNode);
          }
          function spreadExpression(node, props) {
            var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var skipChildren = arguments.length > 3 ? arguments[3] : undefined;
            props || (props = {});
            if (!skipChildren) {
              createRenderEffect(function () {
                return prevProps.children = insertExpression(node, props.children, prevProps.children);
              });
            }
            createRenderEffect(function () {
              return props.ref && props.ref(node);
            });
            createRenderEffect(function () {
              for (var prop in props) {
                if (prop === "children" || prop === "ref") continue;
                var value = props[prop];
                if (value === prevProps[prop]) continue;
                setProperty(node, prop, value, prevProps[prop]);
                prevProps[prop] = value;
              }
            });
            return prevProps;
          }
          return {
            render: function render(code, element) {
              var disposer;
              createRoot(function (dispose) {
                disposer = dispose;
                insert(element, code());
              });
              return disposer;
            },
            insert: insert,
            spread: function spread(node, accessor, skipChildren) {
              if (typeof accessor === "function") {
                createRenderEffect(function (current) {
                  return spreadExpression(node, accessor(), current, skipChildren);
                });
              } else spreadExpression(node, accessor, undefined, skipChildren);
            },
            createElement: createElement,
            createTextNode: createTextNode,
            insertNode: insertNode,
            setProp: function setProp(node, name, value, prev) {
              setProperty(node, name, value, prev);
              return value;
            },
            mergeProps: mergeProps$1,
            effect: createRenderEffect,
            memo: createMemo,
            createComponent: createComponent$1,
            use: function use(fn, element, arg) {
              return untrack(function () {
                return fn(element, arg);
              });
            }
          };
        }
        function createRenderer$2(options) {
          var renderer = createRenderer$1(options);
          renderer.mergeProps = mergeProps$1;
          return renderer;
        }
        var nodeOpts = {
          createElement: function createElement(name) {
            return new ElementNode(name);
          },
          createTextNode: function createTextNode(text) {
            return {
              _type: NodeType.Text,
              text: text
            };
          },
          replaceText: function replaceText(node, value) {
            node.text = value;
            var parent = node.parent;
            parent.text = parent.getText();
          },
          setProperty: function setProperty(node, name) {
            var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            node[name] = value;
          },
          insertNode: function insertNode(parent, node, anchor) {
            parent.insertChild(node, anchor);
            node._queueDelete = false;
            if (node instanceof ElementNode) {
              parent.rendered && node.render(true);
            } else if (isElementText(parent)) {
              parent.text = parent.getText();
            }
          },
          isTextNode: function isTextNode(node) {
            return isElementText(node);
          },
          removeNode: function removeNode(parent, node) {
            parent.removeChild(node);
            node._queueDelete = true;
            if (node instanceof ElementNode) {
              queueMicrotask(function () {
                return node.destroy();
              });
            }
          },
          getParentNode: function getParentNode(node) {
            return node.parent;
          },
          getFirstChild: function getFirstChild(node) {
            return node.children[0];
          },
          getNextSibling: function getNextSibling(node) {
            var children = node.parent.children || [];
            var index = children.indexOf(node) + 1;
            if (index < children.length) {
              return children[index];
            }
            return undefined;
          }
        };
        var solidRenderer = createRenderer$2(nodeOpts);
        var renderer$1;
        var rootNode = nodeOpts.createElement("App");
        var render$1 = function render$1(code) {
          return solidRenderer.render(code, rootNode);
        };
        function createRenderer(rendererOptions, node) {
          var options = Config.rendererOptions;
          renderer$1 = startLightningRenderer(options, "app");
          Config.setActiveElement = setActiveElement;
          rootNode.lng = renderer$1.root;
          rootNode.rendered = true;
          renderer$1.on("idle", function () {
            tasksEnabled = true;
            processTasks();
          });
          return {
            renderer: renderer$1,
            rootNode: rootNode,
            render: render$1
          };
        }
        var effect = solidRenderer.effect,
          memo = solidRenderer.memo,
          createComponent = solidRenderer.createComponent,
          createElement = solidRenderer.createElement,
          createTextNode = solidRenderer.createTextNode,
          insertNode = solidRenderer.insertNode,
          insert = solidRenderer.insert,
          spread = solidRenderer.spread,
          setProp = solidRenderer.setProp,
          mergeProps = solidRenderer.mergeProps,
          use = solidRenderer.use;
        exports({
          y: memo,
          h: createComponent,
          m: mergeProps
        });
        var taskQueue = [];
        var tasksEnabled = false;
        createRenderEffect(function () {
          activeElement();
          tasksEnabled = false;
        });
        function processTasks() {
          if (tasksEnabled && taskQueue.length) {
            setTimeout(function () {
              var task = taskQueue.shift();
              if (task) {
                task();
                processTasks();
              }
            }, 0);
          }
        }
        function Dynamic(props) {
          var _splitProps = splitProps(props, ["component"]),
            _splitProps2 = _slicedToArray(_splitProps, 2),
            p = _splitProps2[0],
            others = _splitProps2[1];
          var cached = createMemo(function () {
            return p.component;
          });
          return createMemo(function () {
            var component = cached();
            switch (_typeof(component)) {
              case "function":
                return untrack(function () {
                  return component(others);
                });
              case "string":
                {
                  var el = createElement(component);
                  spread(el, others);
                  return el;
                }
            }
          });
        }
        var View = exports("V", function (props) {
          var el = createElement("node");
          spread(el, props, false);
          return el;
        });
        var Text$4 = exports("T", function (props) {
          var el = createElement("text");
          spread(el, props, false);
          return el;
        });

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Number of floating point numbers that represent a single glyph in the SDF vertex buffer.
         *
         * @remarks
         * The vertex buffer contains:
         *  - 6 vertex positions
         *  - 6 texture coordinates
         *  - = 12 positions/coordinates per glyph
         *
         * Each vertex position and texture coordinate consist of 2 floating point numbers (x/y).
         * So there are 12 * 2 = 24 floating point numbers that make up a single glyph.
         */
        var FLOATS_PER_GLYPH = 24;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Gets the start conditions for the layout loop.
         *
         * @remarks
         * Returns `undefined` if the layout loop should not be run.
         *
         * @param fontSize
         * @param fontSizeRatio
         * @param sdfLineHeight
         * @param renderWindow
         * @param lineCache
         * @param textH
         * @returns
         */
        function getStartConditions(sdfFontSize, sdfLineHeight, fontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH) {
          // State variables
          var startLineIndex = Math.min(Math.max(renderWindow.firstLineIdx, 0), lineCache.length);
          var sdfStartX = 0;
          var metrics = fontFace.metrics;
          assertTruthy(fontFace.data);
          /**
           * Bare line height is the distance between the ascender and descender of the font.
           * without the line gap metric.
           */
          var sdfBareLineHeight = (metrics.ascender - metrics.descender) * sdfFontSize;
          var sdfVerticalAlignYOffset = 0;
          if (verticalAlign === 'middle') {
            sdfVerticalAlignYOffset = (sdfLineHeight - sdfBareLineHeight) / 2;
          } else if (verticalAlign === 'bottom') {
            sdfVerticalAlignYOffset = sdfLineHeight - sdfBareLineHeight;
          }
          var sdfOffsetY = offsetY / fontSizeRatio;
          /**
           * This is the position from the top of the text drawing line to where the
           * baseline of the text will be according to the encoded positioning data for
           * each glyph in the SDF data. This also happens to be the ascender value
           * that is encoded into the font data.
           */
          var sdfEncodedAscender = fontFace.data.common.base;
          /**
           * This is the ascender that is configured and overridable in the font face.
           */
          var sdfConfiguredAscender = metrics.ascender * sdfFontSize;
          /**
           * If the configured ascender is different from the SDF data's encoded
           * ascender, the offset of the text will be adjusted by the difference.
           */
          var sdfAscenderAdjOffset = sdfConfiguredAscender - sdfEncodedAscender;
          var sdfStartY = sdfOffsetY + sdfAscenderAdjOffset + startLineIndex * sdfLineHeight + sdfVerticalAlignYOffset; // TODO: Figure out what determines the initial y offset of text.
          // Don't attempt to render anything if we know we're starting past the established end of the text
          if (textH && sdfStartY >= textH / fontSizeRatio) {
            return;
          }
          return {
            sdfX: sdfStartX,
            sdfY: sdfStartY,
            lineIndex: startLineIndex
          };
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * A wrapper Generator class that makes a generator peekable.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var PeekableIterator = /*#__PURE__*/function () {
          function PeekableIterator(iterator) {
            var indexBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, PeekableIterator);
            _defineProperty(this, "iterator", void 0);
            _defineProperty(this, "peekBuffer", []);
            _defineProperty(this, "_lastIndex", void 0);
            this.iterator = iterator;
            this.iterator = iterator;
            this._lastIndex = indexBase - 1;
            this.peekBuffer = [];
          }
          return _createClass(PeekableIterator, [{
            key: "next",
            value: function next() {
              var nextResult = this.peekBuffer.length > 0 ?
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              this.peekBuffer.pop() : this.iterator.next();
              if (nextResult.done) {
                this._lastIndex = -1;
              } else {
                this._lastIndex++;
              }
              return nextResult;
            }
          }, {
            key: "peek",
            value: function peek() {
              if (this.peekBuffer.length > 0) {
                // We know that the buffer is not empty, so we can safely use the
                // non-null assertion operator
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return this.peekBuffer[0];
              }
              var result = this.iterator.next();
              this.peekBuffer.push(result);
              return result;
            }
          }, {
            key: "lastIndex",
            get: function get() {
              return this._lastIndex;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // Reversible Generator Wrapper Class
        /**
         * Generator function that yields each Unicode code point in the given string.
         */
        function getUnicodeCodepoints(text) {
          var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
            var i, codePoint;
            return _regeneratorRuntime().wrap(function _callee17$(_context18) {
              while (1) switch (_context18.prev = _context18.next) {
                case 0:
                  i = start;
                case 1:
                  if (!(i < text.length)) {
                    _context18.next = 10;
                    break;
                  }
                  codePoint = text.codePointAt(i);
                  if (!(codePoint === undefined)) {
                    _context18.next = 5;
                    break;
                  }
                  throw new Error('Invalid Unicode code point');
                case 5:
                  _context18.next = 7;
                  return codePoint;
                case 7:
                  i += codePoint <= 0xffff ? 1 : 2;
                  _context18.next = 1;
                  break;
                case 10:
                case "end":
                  return _context18.stop();
              }
            }, _callee17);
          })();
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Measures a single-line of text width ignoring any unmapped glyphs including line breaks
         *
         * @param text
         * @param shaperProps
         * @param shaper
         * @returns
         */
        function measureText(text, shaperProps, shaper) {
          var glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, 0), 0));
          var width = 0;
          var _iterator20 = _createForOfIteratorHelper(glyphs),
            _step20;
          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var glyph = _step20.value;
              if (glyph.mapped && glyph.codepoint !== 8203) {
                // Skip ZWSP (\u200B)
                width += glyph.xAdvance;
              }
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }
          return width;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function layoutText(curLineIndex, startX, startY, text, textAlign, width, height, fontSize, lineHeight, letterSpacing,
        /**
         * Mutated
         */
        vertexBuffer, contain,
        /**
         * Mutated
         */
        lineCache, rwSdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines) {
          assertTruthy(trFontFace.loaded);
          assertTruthy(trFontFace.data);
          assertTruthy(trFontFace.shaper);
          // Regardless of fontSize (or other scaling properties), we layout the vertices of each glyph
          // using the fixed coordinate space determined by font size used to produce the atlas.
          // Scaling for display is handled by shader uniforms inexpensively.
          // So we have:
          //  - vertex space: the space in which the vertices of each glyph are laid out
          //  - screen space: the screen pixel space
          // Input properties such as x, y, w, fontSize, letterSpacing, etc. are all expressed in screen space.
          // We convert these to the vertex space by dividing them the `fontSizeRatio` factor.
          /**
           * See above
           */
          var fontSizeRatio = fontSize / trFontFace.data.info.size;
          /**
           * `lineHeight` in vertex coordinates
           */
          var vertexLineHeight = lineHeight / fontSizeRatio;
          /**
           * `w` in vertex coordinates
           */
          var vertexW = width / fontSizeRatio;
          /**
           * `letterSpacing` in vertex coordinates
           */
          var vertexLSpacing = letterSpacing / fontSizeRatio;
          var startingLineCacheEntry = lineCache[curLineIndex];
          var startingCodepointIndex = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.codepointIndex) || 0;
          var startingMaxX = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.maxX) || 0;
          var startingMaxY = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.maxY) || 0;
          var maxX = startingMaxX;
          var maxY = startingMaxY;
          var curX = startX;
          var curY = startY;
          var bufferOffset = 0;
          /**
           * Buffer offset to last word boundry. This is -1 when we aren't in a word boundry.
           */
          var lastWord = {
            codepointIndex: -1,
            bufferOffset: -1,
            xStart: -1
          };
          var shaper = trFontFace.shaper;
          var shaperProps = {
            letterSpacing: vertexLSpacing
          };
          // HACK: The space is used as a word boundary. When a text ends with a space, we need to
          // add an extra space to ensure the space is included in the line width calculation.
          if (text.endsWith(' ')) {
            text += ' ';
          }
          // Get glyphs
          var glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, startingCodepointIndex), startingCodepointIndex));
          var glyphResult;
          var curLineBufferStart = -1;
          var bufferLineInfos = [];
          var vertexTruncateHeight = height / fontSizeRatio;
          var overflowSuffVertexWidth = measureText(overflowSuffix, shaperProps, shaper);
          // Line-by-line layout
          var moreLines = true;
          while (moreLines) {
            var nextLineWillFit = (maxLines === 0 || curLineIndex + 1 < maxLines) && (contain !== 'both' || scrollable || curY + vertexLineHeight + trFontFace.maxCharHeight <= vertexTruncateHeight);
            var lineVertexW = nextLineWillFit ? vertexW : vertexW - overflowSuffVertexWidth;
            /**
             * Vertex X position to the beginning of the last word boundary. This becomes -1 when we start traversing a word.
             */
            var xStartLastWordBoundary = 0;
            var lineIsBelowWindowTop = curY + trFontFace.maxCharHeight >= rwSdf.y1;
            var lineIsAboveWindowBottom = curY <= rwSdf.y2;
            var lineIsWithinWindow = lineIsBelowWindowTop && lineIsAboveWindowBottom;
            // Layout glyphs in this line
            // Any break statements in this while loop will trigger a line break
            while ((glyphResult = glyphs.next()) && !glyphResult.done) {
              var glyph = glyphResult.value;
              if (curLineIndex === lineCache.length) {
                lineCache.push({
                  codepointIndex: glyph.cluster,
                  maxY: maxY,
                  maxX: maxX
                });
              } else if (curLineIndex > lineCache.length) {
                throw new Error('Unexpected lineCache length');
              }
              // If we encounter a word boundary (white space or newline) we invalidate
              // the lastWord and set the xStartLastWordBoundary if we haven't already.
              if (glyph.codepoint === 32 || glyph.codepoint === 10 || glyph.codepoint === 8203) {
                if (lastWord.codepointIndex !== -1) {
                  lastWord.codepointIndex = -1;
                  xStartLastWordBoundary = curX;
                }
              } else if (lastWord.codepointIndex === -1) {
                lastWord.codepointIndex = glyph.cluster;
                lastWord.bufferOffset = bufferOffset;
                lastWord.xStart = xStartLastWordBoundary;
              }
              if (glyph.mapped) {
                // Mapped glyph
                var charEndX = curX + glyph.xOffset + glyph.width;
                // Word wrap check
                if (
                // We are containing the text
                contain !== 'none' &&
                // The current glyph reaches outside the contained width
                charEndX >= lineVertexW &&
                // There is a last word that we can break to the next line
                lastWord.codepointIndex !== -1 &&
                // Prevents infinite loop when a single word is longer than the width
                lastWord.xStart > 0) {
                  // The current word is about to go off the edge of the container width
                  // Reinitialize the iterator starting at the last word
                  // and proceeding to the next line
                  if (nextLineWillFit) {
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, lastWord.codepointIndex), lastWord.codepointIndex));
                    bufferOffset = lastWord.bufferOffset;
                    break;
                  } else {
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
                    curX = lastWord.xStart;
                    bufferOffset = lastWord.bufferOffset;
                    // HACK: For the rest of the line when inserting the overflow suffix,
                    // set contain = 'none' to prevent an infinite loop.
                    contain = 'none';
                  }
                } else {
                  // This glyph fits, so we can add it to the buffer
                  var quadX = curX + glyph.xOffset;
                  var quadY = curY + glyph.yOffset;
                  // Only add to buffer for rendering if the line is within the render window
                  if (lineIsWithinWindow) {
                    if (curLineBufferStart === -1) {
                      curLineBufferStart = bufferOffset;
                    }
                    var atlasEntry = trFontFace.getAtlasEntry(glyph.glyphId);
                    // Add texture coordinates
                    var u = atlasEntry.x / trFontFace.data.common.scaleW;
                    var v = atlasEntry.y / trFontFace.data.common.scaleH;
                    var uvWidth = atlasEntry.width / trFontFace.data.common.scaleW;
                    var uvHeight = atlasEntry.height / trFontFace.data.common.scaleH;
                    // TODO: (Performance) We can optimize this by using ELEMENT_ARRAY_BUFFER
                    // eliminating the need to duplicate vertices
                    // Top-left
                    vertexBuffer[bufferOffset++] = quadX;
                    vertexBuffer[bufferOffset++] = quadY;
                    vertexBuffer[bufferOffset++] = u;
                    vertexBuffer[bufferOffset++] = v;
                    // Top-right
                    vertexBuffer[bufferOffset++] = quadX + glyph.width;
                    vertexBuffer[bufferOffset++] = quadY;
                    vertexBuffer[bufferOffset++] = u + uvWidth;
                    vertexBuffer[bufferOffset++] = v;
                    // Bottom-left
                    vertexBuffer[bufferOffset++] = quadX;
                    vertexBuffer[bufferOffset++] = quadY + glyph.height;
                    vertexBuffer[bufferOffset++] = u;
                    vertexBuffer[bufferOffset++] = v + uvHeight;
                    // Bottom-right
                    vertexBuffer[bufferOffset++] = quadX + glyph.width;
                    vertexBuffer[bufferOffset++] = quadY + glyph.height;
                    vertexBuffer[bufferOffset++] = u + uvWidth;
                    vertexBuffer[bufferOffset++] = v + uvHeight;
                  }
                  maxY = Math.max(maxY, quadY + glyph.height);
                  maxX = Math.max(maxX, quadX + glyph.width);
                  curX += glyph.xAdvance;
                }
              } else {
                // Unmapped character
                // Handle newlines
                if (glyph.codepoint === 10) {
                  if (nextLineWillFit) {
                    // The whole line fit, so we can break to the next line
                    break;
                  } else {
                    // The whole line won't fit, so we need to add the overflow suffix
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
                    // HACK: For the rest of the line when inserting the overflow suffix,
                    // set contain = 'none' to prevent an infinite loop.
                    contain = 'none';
                  }
                }
              }
            }
            // Prepare for the next line...
            if (curLineBufferStart !== -1) {
              bufferLineInfos.push({
                bufferStart: curLineBufferStart,
                bufferEnd: bufferOffset
              });
              curLineBufferStart = -1;
            }
            curX = 0;
            curY += vertexLineHeight;
            curLineIndex++;
            lastWord.codepointIndex = -1;
            xStartLastWordBoundary = 0;
            // Figure out if there are any more lines to render...
            if (!forceFullLayoutCalc && contain === 'both' && curY > rwSdf.y2) {
              // Stop layout calculation early (for performance purposes) if:
              // - We're not forcing a full layout calculation (for width/height calculation)
              // - ...and we're containing the text vertically+horizontally (contain === 'both')
              // - ...and we have a render window
              // - ...and the next line is below the bottom of the render window
              moreLines = false;
            } else if (glyphResult && glyphResult.done) {
              // If we've reached the end of the text, we know we're done
              moreLines = false;
            } else if (!nextLineWillFit) {
              // If we're contained vertically+horizontally (contain === 'both')
              // but not scrollable and the next line won't fit, we're done.
              moreLines = false;
            }
          }
          // Use textAlign to determine if we need to adjust the x position of the text
          // in the buffer line by line
          if (textAlign === 'center') {
            var vertexTextW = contain === 'none' ? maxX : vertexW;
            for (var i = 0; i < bufferLineInfos.length; i++) {
              var line = bufferLineInfos[i];
              // - 4 = the x position of a rightmost vertex
              var lineWidth =
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart];
              var xOffset = (vertexTextW - lineWidth) / 2;
              for (var j = line.bufferStart; j < line.bufferEnd; j += 4) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vertexBuffer[j] += xOffset;
              }
            }
          } else if (textAlign === 'right') {
            var _vertexTextW = contain === 'none' ? maxX : vertexW;
            for (var _i23 = 0; _i23 < bufferLineInfos.length; _i23++) {
              var _line = bufferLineInfos[_i23];
              var _lineWidth = _line.bufferEnd === _line.bufferStart ? 0 :
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              vertexBuffer[_line.bufferEnd - 4] - vertexBuffer[_line.bufferStart];
              var _xOffset = _vertexTextW - _lineWidth;
              for (var _j = _line.bufferStart; _j < _line.bufferEnd; _j += 4) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vertexBuffer[_j] += _xOffset;
              }
            }
          }
          return {
            bufferNumFloats: bufferOffset,
            bufferNumQuads: bufferOffset / 16,
            layoutNumCharacters: glyphResult.done ? text.length - startingCodepointIndex : glyphResult.value.cluster - startingCodepointIndex + 1,
            fullyProcessed: !!glyphResult.done,
            maxX: maxX,
            maxY: maxY,
            numLines: lineCache.length
          };
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Round up to the nearest multiple of the given number.
         *
         * @param value
         * @param multiple
         * @returns
         */
        function roundUpToMultiple(value, multiple) {
          return Math.ceil(value / multiple) * multiple;
        }
        /**
         * Round down to the nearest multiple of the given number.
         *
         * @param value
         * @param multiple
         * @returns
         */
        function roundDownToMultiple(value, multiple) {
          return Math.floor(value / multiple) * multiple;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Create a render window from the given parameters.
         *
         * @remarks
         * The render window is a rectangle that defines the area of the text that
         * should be rendered. It is used to skip rendering parts of the text that
         * are outside of the render window. The render window is relative to the
         * text's top left corner of the overrall text.
         *
         * @param x The x coordinate of the text element's top left corner relative to the screen.
         * @param y The y coordinate of the text element's top left corner relative to the screen.
         * @param scrollY The amount of pixels to scroll the text vertically.
         * @param lineHeight The number of extra lines to render above and below the visible window.
         * @param visibleWindow The visible window of the text element relative to the screen
         * @returns
         */
        function setRenderWindow(outRenderWindow, x, y, scrollY, lineHeight, bufferMargin, visibleWindow, fontSizeRatio) {
          var screen = outRenderWindow.screen,
            sdf = outRenderWindow.sdf;
          if (!isBoundPositive(visibleWindow)) {
            screen.x1 = 0;
            screen.y1 = 0;
            screen.x2 = 0;
            screen.y2 = 0;
            sdf.x1 = 0;
            sdf.y1 = 0;
            sdf.x2 = 0;
            sdf.y2 = 0;
            outRenderWindow.numLines = 0;
            outRenderWindow.firstLineIdx = 0;
          } else {
            var x1 = visibleWindow.x1 - x;
            var x2 = x1 + (visibleWindow.x2 - visibleWindow.x1);
            var y1Base = visibleWindow.y1 - y + scrollY;
            var y1 = roundDownToMultiple(y1Base - bufferMargin, lineHeight || 1);
            var y2 = roundUpToMultiple(y1Base + (visibleWindow.y2 - visibleWindow.y1) + bufferMargin, lineHeight || 1);
            screen.x1 = x1;
            screen.y1 = y1;
            screen.x2 = x2;
            screen.y2 = y2;
            sdf.x1 = x1 / fontSizeRatio;
            sdf.y1 = y1 / fontSizeRatio;
            sdf.x2 = x2 / fontSizeRatio;
            sdf.y2 = y2 / fontSizeRatio;
            outRenderWindow.numLines = Math.ceil((y2 - y1) / lineHeight);
            outRenderWindow.firstLineIdx = lineHeight ? Math.floor(y1 / lineHeight) : 0;
          }
          outRenderWindow.valid = true;
        }

        /**
         * Calculate the default line height given normalized font metrics
         *
         * @remarks
         * This method may be used for both the WebTrFontFace and SdfTrFontFace font types.
         *
         * @param metrics
         * @param fontSize
         * @returns
         */
        function calcDefaultLineHeight(metrics, fontSize) {
          return fontSize * (metrics.ascender - metrics.descender + metrics.lineGap);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Ephemeral rect object used for calculations
         */
        var tmpRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        /**
         * Singleton class for rendering text using signed distance fields.
         *
         * @remarks
         * SdfTextRenderer supports both single-channel and multi-channel signed distance fields.
         */
        var SdfTextRenderer = /*#__PURE__*/function (_TextRenderer2) {
          function SdfTextRenderer(stage) {
            var _this69;
            _classCallCheck(this, SdfTextRenderer);
            _this69 = _callSuper(this, SdfTextRenderer, [stage]);
            /**
             * Map of font family names to a set of font faces.
             */
            _defineProperty(_this69, "ssdfFontFamilies", {});
            _defineProperty(_this69, "msdfFontFamilies", {});
            _defineProperty(_this69, "fontFamilyArray", [_this69.ssdfFontFamilies, _this69.msdfFontFamilies]);
            _defineProperty(_this69, "sdfShader", void 0);
            _defineProperty(_this69, "rendererBounds", void 0);
            _defineProperty(_this69, "type", 'sdf');
            _this69.sdfShader = _this69.stage.shManager.loadShader('SdfShader', {
              transform: new Float32Array(),
              color: 0,
              size: 0,
              scrollY: 0,
              distanceRange: 0,
              debug: false
            }).shader;
            _this69.rendererBounds = {
              x1: 0,
              y1: 0,
              x2: _this69.stage.options.appWidth,
              y2: _this69.stage.options.appHeight
            };
            return _this69;
          }
          //#region Overrides
          _inherits(SdfTextRenderer, _TextRenderer2);
          return _createClass(SdfTextRenderer, [{
            key: "getPropertySetters",
            value: function getPropertySetters() {
              var _this70 = this;
              return {
                fontFamily: function fontFamily(state, value) {
                  state.props.fontFamily = value;
                  _this70.releaseFontFace(state);
                  _this70.invalidateLayoutCache(state);
                },
                fontWeight: function fontWeight(state, value) {
                  state.props.fontWeight = value;
                  _this70.releaseFontFace(state);
                  _this70.invalidateLayoutCache(state);
                },
                fontStyle: function fontStyle(state, value) {
                  state.props.fontStyle = value;
                  _this70.releaseFontFace(state);
                  _this70.invalidateLayoutCache(state);
                },
                fontStretch: function fontStretch(state, value) {
                  state.props.fontStretch = value;
                  _this70.releaseFontFace(state);
                  _this70.invalidateLayoutCache(state);
                },
                fontSize: function fontSize(state, value) {
                  state.props.fontSize = value;
                  _this70.invalidateLayoutCache(state);
                },
                text: function text(state, value) {
                  state.props.text = value;
                  _this70.invalidateLayoutCache(state);
                },
                textAlign: function textAlign(state, value) {
                  state.props.textAlign = value;
                  _this70.invalidateLayoutCache(state);
                },
                color: function color(state, value) {
                  state.props.color = value;
                },
                x: function x(state, value) {
                  state.props.x = value;
                  if (state.elementBounds.valid) {
                    _this70.setElementBoundsX(state);
                    // Only schedule an update if the text is not already rendered
                    // (renderWindow is invalid) and the element possibly overlaps the screen
                    // This is to avoid unnecessary updates when we know text is off-screen
                    if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, _this70.rendererBounds)) {
                      _this70.scheduleUpdateState(state);
                    }
                  }
                },
                y: function y(state, value) {
                  state.props.y = value;
                  if (state.elementBounds.valid) {
                    _this70.setElementBoundsY(state);
                    // See x() for explanation
                    if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, _this70.rendererBounds)) {
                      _this70.scheduleUpdateState(state);
                    }
                  }
                },
                contain: function contain(state, value) {
                  state.props.contain = value;
                  _this70.invalidateLayoutCache(state);
                },
                width: function width(state, value) {
                  state.props.width = value;
                  // Only invalidate layout cache if we're containing in the horizontal direction
                  if (state.props.contain !== 'none') {
                    _this70.invalidateLayoutCache(state);
                  }
                },
                height: function height(state, value) {
                  state.props.height = value;
                  // Only invalidate layout cache if we're containing in the vertical direction
                  if (state.props.contain === 'both') {
                    _this70.invalidateLayoutCache(state);
                  }
                },
                offsetY: function offsetY(state, value) {
                  state.props.offsetY = value;
                  _this70.invalidateLayoutCache(state);
                },
                scrollable: function scrollable(state, value) {
                  state.props.scrollable = value;
                  _this70.invalidateLayoutCache(state);
                },
                scrollY: function scrollY(state, value) {
                  state.props.scrollY = value;
                  // Scrolling doesn't need to invalidate any caches, but it does need to
                  // schedule an update
                  _this70.scheduleUpdateState(state);
                },
                letterSpacing: function letterSpacing(state, value) {
                  state.props.letterSpacing = value;
                  _this70.invalidateLayoutCache(state);
                },
                lineHeight: function lineHeight(state, value) {
                  state.props.lineHeight = value;
                  state.resLineHeight = undefined;
                  _this70.invalidateLayoutCache(state);
                },
                maxLines: function maxLines(state, value) {
                  state.props.maxLines = value;
                  _this70.invalidateLayoutCache(state);
                },
                textBaseline: function textBaseline(state, value) {
                  state.props.textBaseline = value;
                  _this70.invalidateLayoutCache(state);
                },
                verticalAlign: function verticalAlign(state, value) {
                  state.props.verticalAlign = value;
                  _this70.invalidateLayoutCache(state);
                },
                overflowSuffix: function overflowSuffix(state, value) {
                  state.props.overflowSuffix = value;
                  _this70.invalidateLayoutCache(state);
                },
                debug: function debug(state, value) {
                  state.props.debug = value;
                }
              };
            }
          }, {
            key: "canRenderFont",
            value: function canRenderFont(props) {
              // TODO: Support matching on font stretch, weight and style (if/when needed)
              // For now we just match on the font family name
              // '$$SDF_FAILURE_TEST$$' is used to test the 'failure' event coming from text
              var fontFamily = props.fontFamily;
              return fontFamily in this.ssdfFontFamilies || fontFamily in this.msdfFontFamilies || fontFamily === '$$SDF_FAILURE_TEST$$';
            }
          }, {
            key: "isFontFaceSupported",
            value: function isFontFaceSupported(fontFace) {
              return fontFace instanceof SdfTrFontFace;
            }
          }, {
            key: "addFontFace",
            value: function addFontFace(fontFace) {
              var familyName = fontFace.fontFamily;
              var fontFamiles = fontFace.type === 'ssdf' ? this.ssdfFontFamilies : fontFace.type === 'msdf' ? this.msdfFontFamilies : undefined;
              if (!fontFamiles) {
                console.warn("Invalid font face type: ".concat(fontFace.type));
                return;
              }
              var faceSet = fontFamiles[familyName];
              if (!faceSet) {
                faceSet = new Set();
                fontFamiles[familyName] = faceSet;
              }
              faceSet.add(fontFace);
            }
          }, {
            key: "createState",
            value: function createState(props) {
              return {
                props: props,
                status: 'initialState',
                updateScheduled: false,
                emitter: new EventEmitter(),
                lineCache: [],
                forceFullLayoutCalc: false,
                renderWindow: {
                  screen: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                  },
                  sdf: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                  },
                  firstLineIdx: 0,
                  numLines: 0,
                  valid: false
                },
                elementBounds: {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  valid: false
                },
                clippingRect: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
                  valid: false
                },
                bufferNumFloats: 0,
                bufferNumQuads: 0,
                vertexBuffer: undefined,
                webGlBuffers: null,
                bufferUploaded: false,
                textH: undefined,
                textW: undefined,
                distanceRange: 0,
                trFontFace: undefined,
                isRenderable: false,
                resLineHeight: undefined,
                debugData: {
                  updateCount: 0,
                  layoutCount: 0,
                  lastLayoutNumCharacters: 0,
                  layoutSum: 0,
                  drawSum: 0,
                  drawCount: 0,
                  bufferSize: 0
                }
              };
            }
          }, {
            key: "updateState",
            value: function updateState(state) {
              var _this71 = this;
              var trFontFace = state.trFontFace;
              var textH = state.textH,
                lineCache = state.lineCache,
                debugData = state.debugData,
                forceFullLayoutCalc = state.forceFullLayoutCalc;
              debugData.updateCount++;
              // On the first update call we need to set the status to loading
              if (state.status === 'initialState') {
                this.setStatus(state, 'loading');
              }
              // Resolve font face if we haven't yet
              if (trFontFace === undefined) {
                trFontFace = this.resolveFontFace(state.props);
                state.trFontFace = trFontFace;
                if (trFontFace === undefined) {
                  var msg = "SdfTextRenderer: Could not resolve font face for family: '".concat(state.props.fontFamily, "'");
                  console.error(msg);
                  this.setStatus(state, 'failed', new Error(msg));
                  return;
                }
                trFontFace.texture.setRenderableOwner(state, true);
              }
              // If the font hasn't been loaded yet, stop here.
              // Listen for the 'loaded' event and forward fontLoaded event
              if (trFontFace.loaded === false) {
                trFontFace.once('loaded', function () {
                  _this71.scheduleUpdateState(state);
                });
                return;
              }
              // If the font is loaded then so should the data
              assertTruthy(trFontFace.data);
              assertTruthy(trFontFace.metrics);
              var _state$props = state.props,
                text = _state$props.text,
                fontSize = _state$props.fontSize,
                x = _state$props.x,
                y = _state$props.y,
                contain = _state$props.contain,
                width = _state$props.width,
                height = _state$props.height,
                verticalAlign = _state$props.verticalAlign,
                scrollable = _state$props.scrollable,
                overflowSuffix = _state$props.overflowSuffix,
                maxLines = _state$props.maxLines;
              // scrollY only has an effect when contain === 'both' and scrollable === true
              var scrollY = contain === 'both' && scrollable ? state.props.scrollY : 0;
              var renderWindow = state.renderWindow;
              /**
               * The font size of the SDF font face (the basis for SDF space units)
               */
              var sdfFontSize = trFontFace.data.info.size;
              /**
               * Divide screen space units by this to get the SDF space units
               * Mulitple SDF space units by this to get screen space units
               */
              var fontSizeRatio = fontSize / sdfFontSize;
              // If not already resolved, resolve the line height and store it in the state
              var resLineHeight = state.resLineHeight;
              if (resLineHeight === undefined) {
                var lineHeight = state.props.lineHeight;
                // If lineHeight is undefined, use the maxCharHeight from the font face
                if (lineHeight === undefined) {
                  resLineHeight = calcDefaultLineHeight(trFontFace.metrics, fontSize);
                } else {
                  resLineHeight = lineHeight;
                }
                state.resLineHeight = resLineHeight;
              }
              // Needed in renderWindow calculation
              var sdfLineHeight = resLineHeight / fontSizeRatio;
              state.distanceRange = fontSizeRatio * trFontFace.data.distanceField.distanceRange;
              // Allocate buffers if needed
              var neededLength = text.length * FLOATS_PER_GLYPH;
              var vertexBuffer = state.vertexBuffer;
              if (!vertexBuffer || vertexBuffer.length < neededLength) {
                vertexBuffer = new Float32Array(neededLength * 2);
              }
              var elementBounds = state.elementBounds;
              if (!elementBounds.valid) {
                this.setElementBoundsX(state);
                this.setElementBoundsY(state);
                elementBounds.valid = true;
              }
              // Return early if we're still viewing inside the established render window
              // No need to re-render what we've already rendered
              // (Only if there's an established renderWindow and we're not suppressing early exit)
              if (!forceFullLayoutCalc && renderWindow.valid) {
                var rwScreen = renderWindow.screen;
                if (x + rwScreen.x1 <= elementBounds.x1 && x + rwScreen.x2 >= elementBounds.x2 && y - scrollY + rwScreen.y1 <= elementBounds.y1 && y - scrollY + rwScreen.y2 >= elementBounds.y2) {
                  this.setStatus(state, 'loaded');
                  return;
                }
                // Otherwise invalidate the renderWindow so it can be redone
                renderWindow.valid = false;
                this.setStatus(state, 'loading');
              }
              var _state$props2 = state.props,
                offsetY = _state$props2.offsetY,
                textAlign = _state$props2.textAlign;
              // Create a new renderWindow if needed
              if (!renderWindow.valid) {
                var isPossiblyOnScreen = boundsOverlap(elementBounds, this.rendererBounds);
                if (!isPossiblyOnScreen) {
                  // If the element is not possibly on screen, we can skip the layout and rendering completely
                  return;
                }
                setRenderWindow(renderWindow, x, y, scrollY, resLineHeight, contain === 'both' ? elementBounds.y2 - elementBounds.y1 : 0, elementBounds, fontSizeRatio);
                // console.log('newRenderWindow', renderWindow);
              }
              var start = getStartConditions(sdfFontSize, sdfLineHeight, trFontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH);
              if (!start) {
                // Nothing to render, return early, but still mark as loaded (since the text is just scrolled
                // out of view)
                this.setStatus(state, 'loaded');
                return;
              }
              var letterSpacing = state.props.letterSpacing;
              var out2 = layoutText(start.lineIndex, start.sdfX, start.sdfY, text, textAlign, width, height, fontSize, resLineHeight, letterSpacing, vertexBuffer, contain, lineCache, renderWindow.sdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines);
              state.bufferUploaded = false;
              state.bufferNumFloats = out2.bufferNumFloats;
              state.bufferNumQuads = out2.bufferNumQuads;
              state.vertexBuffer = vertexBuffer;
              state.renderWindow = renderWindow;
              debugData.lastLayoutNumCharacters = out2.layoutNumCharacters;
              debugData.bufferSize = vertexBuffer.byteLength;
              // If we didn't exit early, we know we have completely computed w/h
              if (out2.fullyProcessed) {
                state.textW = out2.maxX * fontSizeRatio;
                state.textH = out2.numLines * sdfLineHeight * fontSizeRatio;
              }
              // if (state.props.debug.printLayoutTime) {
              //   debugData.layoutSum += performance.now() - updateStartTime;
              //   debugData.layoutCount++;
              // }
              this.setStatus(state, 'loaded');
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(state, transform, clippingRect, alpha, parentHasRenderTexture, framebufferDimensions) {
              var _trFontFace$data, _state$trFontFace;
              if (!state.vertexBuffer) {
                // Nothing to draw
                return;
              }
              var renderer = this.stage.renderer;
              var _state$props3 = state.props,
                fontSize = _state$props3.fontSize,
                color = _state$props3.color,
                contain = _state$props3.contain,
                scrollable = _state$props3.scrollable,
                zIndex = _state$props3.zIndex,
                debug = _state$props3.debug;
              // scrollY only has an effect when contain === 'both' and scrollable === true
              var scrollY = contain === 'both' && scrollable ? state.props.scrollY : 0;
              var _state$textW = state.textW,
                textW = _state$textW === void 0 ? 0 : _state$textW,
                _state$textH = state.textH,
                textH = _state$textH === void 0 ? 0 : _state$textH,
                distanceRange = state.distanceRange,
                vertexBuffer = state.vertexBuffer,
                bufferUploaded = state.bufferUploaded,
                trFontFace = state.trFontFace,
                elementBounds = state.elementBounds;
              var webGlBuffers = state.webGlBuffers;
              if (!webGlBuffers) {
                var glw = renderer.glw;
                var stride = 4 * Float32Array.BYTES_PER_ELEMENT;
                var webGlBuffer = glw.createBuffer();
                state.webGlBuffers = new BufferCollection([{
                  buffer: webGlBuffer,
                  attributes: {
                    a_position: {
                      name: 'a_position',
                      size: 2,
                      // 2 components per iteration
                      type: glw.FLOAT,
                      // the data is 32bit floats
                      normalized: false,
                      // don't normalize the data
                      stride: stride,
                      // 0 = move forward size * sizeof(type) each iteration to get the next position
                      offset: 0 // start at the beginning of the buffer
                    },
                    a_textureCoordinate: {
                      name: 'a_textureCoordinate',
                      size: 2,
                      type: glw.FLOAT,
                      normalized: false,
                      stride: stride,
                      offset: 2 * Float32Array.BYTES_PER_ELEMENT
                    }
                  }
                }]);
                state.bufferUploaded = false;
                assertTruthy(state.webGlBuffers);
                webGlBuffers = state.webGlBuffers;
              }
              if (!bufferUploaded) {
                var _webGlBuffers$getBuff, _webGlBuffers;
                var _glw = renderer.glw;
                var buffer = (_webGlBuffers$getBuff = (_webGlBuffers = webGlBuffers) === null || _webGlBuffers === void 0 ? void 0 : _webGlBuffers.getBuffer('a_textureCoordinate')) !== null && _webGlBuffers$getBuff !== void 0 ? _webGlBuffers$getBuff : null;
                _glw.arrayBufferData(buffer, vertexBuffer, _glw.STATIC_DRAW);
                state.bufferUploaded = true;
              }
              if (scrollable && contain === 'both') {
                assertTruthy(elementBounds.valid);
                var elementRect = convertBoundToRect(elementBounds, tmpRect);
                if (clippingRect.valid) {
                  state.clippingRect.valid = true;
                  clippingRect = intersectRect(clippingRect, elementRect, state.clippingRect);
                } else {
                  state.clippingRect.valid = true;
                  clippingRect = copyRect(elementRect, state.clippingRect);
                }
              }
              var renderOp = new WebGlCoreRenderOp(renderer.glw, renderer.options, webGlBuffers, this.sdfShader, {
                transform: transform.getFloatArr(),
                // IMPORTANT: The SDF Shader expects the color NOT to be premultiplied
                // for the best blending results. Which is why we use `mergeColorAlpha`
                // instead of `mergeColorAlphaPremultiplied` here.
                color: mergeColorAlpha(color, alpha),
                size: fontSize / (((_trFontFace$data = trFontFace.data) === null || _trFontFace$data === void 0 ? void 0 : _trFontFace$data.info.size) || 0),
                scrollY: scrollY,
                distanceRange: distanceRange,
                debug: debug.sdfShaderDebug
              }, alpha, clippingRect, {
                height: textH,
                width: textW
              }, 0, zIndex, false, parentHasRenderTexture, framebufferDimensions);
              var texture = (_state$trFontFace = state.trFontFace) === null || _state$trFontFace === void 0 ? void 0 : _state$trFontFace.texture;
              var ctxTexture = texture.ctxTexture;
              renderOp.addTexture(ctxTexture);
              renderOp.length = state.bufferNumFloats;
              renderOp.numQuads = state.bufferNumQuads;
              renderer.addRenderOp(renderOp);
              // if (!debug.disableScissor) {
              //   renderer.enableScissor(
              //     visibleRect.x,
              //     visibleRect.y,
              //     visibleRect.w,
              //     visibleRect.h,
              //   );
              // }
              // Draw the arrays
              // gl.drawArrays(
              //   gl.TRIANGLES, // Primitive type
              //   0,
              //   bufferNumVertices, // Number of verticies
              // );
              // renderer.disableScissor();
              // if (debug.showElementRect) {
              //   this.renderer.drawBorder(
              //     Colors.Blue,
              //     elementRect.x,
              //     elementRect.y,
              //     elementRect.w,
              //     elementRect.h,
              //   );
              // }
              // if (debug.showVisibleRect) {
              //   this.renderer.drawBorder(
              //     Colors.Green,
              //     visibleRect.x,
              //     visibleRect.y,
              //     visibleRect.w,
              //     visibleRect.h,
              //   );
              // }
              // if (debug.showRenderWindow && renderWindow) {
              //   this.renderer.drawBorder(
              //     Colors.Red,
              //     x + renderWindow.x1,
              //     y + renderWindow.y1 - scrollY,
              //     x + renderWindow.x2 - (x + renderWindow.x1),
              //     y + renderWindow.y2 - scrollY - (y + renderWindow.y1 - scrollY),
              //   );
              // }
              // if (debug.printLayoutTime) {
              //   debugData.drawSum += performance.now() - drawStartTime;
              //   debugData.drawCount++;
              // }
            }
          }, {
            key: "setIsRenderable",
            value: function setIsRenderable(state, renderable) {
              var _state$trFontFace2;
              _superPropGet(SdfTextRenderer, "setIsRenderable", this, 3)([state, renderable]);
              (_state$trFontFace2 = state.trFontFace) === null || _state$trFontFace2 === void 0 || _state$trFontFace2.texture.setRenderableOwner(state, renderable);
            }
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              var _state$trFontFace3;
              _superPropGet(SdfTextRenderer, "destroyState", this, 3)([state]);
              // If there's a Font Face assigned we must free the owner relation to its texture
              (_state$trFontFace3 = state.trFontFace) === null || _state$trFontFace3 === void 0 || _state$trFontFace3.texture.setRenderableOwner(state, false);
            }
            //#endregion Overrides
          }, {
            key: "resolveFontFace",
            value: function resolveFontFace(props) {
              return this.stage.fontManager.resolveFontFace(this.fontFamilyArray, props, 'sdf');
            }
            /**
             * Release the loaded SDF font face
             *
             * @param state
             */
          }, {
            key: "releaseFontFace",
            value: function releaseFontFace(state) {
              state.resLineHeight = undefined;
              if (state.trFontFace) {
                state.trFontFace.texture.setRenderableOwner(state, false);
                state.trFontFace = undefined;
              }
            }
            /**
             * Invalidate the layout cache stored in the state. This will cause the text
             * to be re-layed out on the next update.
             *
             * @remarks
             * This also invalidates the visible window cache.
             *
             * @param state
             */
          }, {
            key: "invalidateLayoutCache",
            value: function invalidateLayoutCache(state) {
              state.renderWindow.valid = false;
              state.elementBounds.valid = false;
              state.textH = undefined;
              state.textW = undefined;
              state.lineCache = [];
              this.setStatus(state, 'loading');
              this.scheduleUpdateState(state);
            }
          }, {
            key: "setElementBoundsX",
            value: function setElementBoundsX(state) {
              var _state$props4 = state.props,
                x = _state$props4.x,
                contain = _state$props4.contain,
                width = _state$props4.width;
              var elementBounds = state.elementBounds;
              elementBounds.x1 = x;
              elementBounds.x2 = contain !== 'none' ? x + width : Infinity;
            }
          }, {
            key: "setElementBoundsY",
            value: function setElementBoundsY(state) {
              var _state$props5 = state.props,
                y = _state$props5.y,
                contain = _state$props5.contain,
                height = _state$props5.height;
              var elementBounds = state.elementBounds;
              elementBounds.y1 = y;
              elementBounds.y2 = contain === 'both' ? y + height : Infinity;
            }
          }]);
        }(TextRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Returns CSS font setting string for use in canvas context.
         *
         * @param fontFace
         * @param fontStyle
         * @param fontSize
         * @param precision
         * @param defaultFontFace
         * @returns
         */
        /**
         * Returns true if the given character is a zero-width space.
         *
         * @param space
         */
        function isZeroWidthSpace(space) {
          return space === '' || space === "\u200B";
        }
        /**
         * Get the font metrics for a font face.
         *
         * @remarks
         * This function will attempt to grab the explicitly defined metrics from the
         * font face first. If the font face does not have metrics defined, it will
         * attempt to calculate the metrics using the browser's measureText method.
         *
         * If the browser does not support the font metrics API, it will use some
         * default values.
         *
         * @param context
         * @param fontFace
         * @param fontSize
         * @returns
         */
        function getWebFontMetrics(context, fontFace, fontSize) {
          if (fontFace.metrics) {
            return fontFace.metrics;
          }
          // If the font face doesn't have metrics defined, we fallback to using the
          // browser's measureText method to calculate take a best guess at the font
          // actual font's metrics.
          // - fontBoundingBox[Ascent|Descent] is the best estimate but only supported
          //   in Chrome 87+ (2020), Firefox 116+ (2023), and Safari 11.1+ (2018).
          //   - It is an estimate as it can vary between browsers.
          // - actualBoundingBox[Ascent|Descent] is less accurate and supported in
          //   Chrome 77+ (2019), Firefox 74+ (2020), and Safari 11.1+ (2018).
          // - If neither are supported, we'll use some default values which will
          //   get text on the screen but likely not be great.
          // NOTE: It's been decided not to rely on fontBoundingBox[Ascent|Descent]
          // as it's browser support is limited and it also tends to produce higher than
          // expected values. It is instead HIGHLY RECOMMENDED that developers provide
          // explicit metrics in the font face definition.
          var browserMetrics = context.measureText('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz');
          console.warn("Font metrics not provided for Canvas Web font ".concat(fontFace.fontFamily, ". ") + 'Using fallback values. It is HIGHLY recommended you use the latest ' + 'version of the Lightning 3 `msdf-generator` tool to extract the default ' + 'metrics for the font and provide them in the Canvas Web font definition.');
          var metrics;
          if (browserMetrics.actualBoundingBoxDescent && browserMetrics.actualBoundingBoxAscent) {
            metrics = {
              ascender: browserMetrics.actualBoundingBoxAscent / fontSize,
              descender: -browserMetrics.actualBoundingBoxDescent / fontSize,
              lineGap: 0.2
            };
          } else {
            // If the browser doesn't support the font metrics API, we'll use some
            // default values.
            metrics = {
              ascender: 0.8,
              descender: -0.2,
              lineGap: 0.2
            };
          }
          // Save the calculated metrics to the font face for future use.
          fontFace.metrics = metrics;
          return metrics;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        var MAX_TEXTURE_DIMENSION = 2048;
        /**
         * Calculate height for the canvas
         *
         * @param textBaseline
         * @param fontSize
         * @param lineHeight
         * @param numLines
         * @param offsetY
         * @returns
         */
        function calcHeight(textBaseline, fontSize, lineHeight, numLines, offsetY) {
          var baselineOffset = textBaseline !== 'bottom' ? 0.5 * fontSize : 0;
          return lineHeight * (numLines - 1) + baselineOffset + Math.max(lineHeight, fontSize) + (offsetY || 0);
        }
        var LightningTextTextureRenderer = /*#__PURE__*/function () {
          function LightningTextTextureRenderer(canvas, context) {
            _classCallCheck(this, LightningTextTextureRenderer);
            _defineProperty(this, "_canvas", void 0);
            _defineProperty(this, "_context", void 0);
            _defineProperty(this, "_settings", void 0);
            this._canvas = canvas;
            this._context = context;
            this._settings = this.mergeDefaults({});
          }
          return _createClass(LightningTextTextureRenderer, [{
            key: "settings",
            get: function get() {
              return this._settings;
            },
            set: function set(v) {
              this._settings = this.mergeDefaults(v);
            }
          }, {
            key: "getPrecision",
            value: function getPrecision() {
              return this._settings.precision;
            }
          }, {
            key: "setFontProperties",
            value: function setFontProperties() {
              this._context.font = this._getFontSetting();
              this._context.textBaseline = this._settings.textBaseline;
            }
          }, {
            key: "_getFontSetting",
            value: function _getFontSetting() {
              var ff = [this._settings.fontFamily];
              var ffs = [];
              for (var i = 0, n = ff.length; i < n; i++) {
                if (ff[i] === 'serif' || ff[i] === 'sans-serif') {
                  ffs.push(ff[i]);
                } else {
                  ffs.push("\"".concat(ff[i], "\""));
                }
              }
              return "".concat(this._settings.fontStyle, " ").concat(this._settings.fontSize * this.getPrecision(), "px ").concat(ffs.join(','));
            }
          }, {
            key: "_load",
            value: function _load() {
              var _this72 = this;
              if (document.fonts) {
                var fontSetting = this._getFontSetting();
                try {
                  if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(function (err) {
                      // Just load the fallback font.
                      console.warn('[Lightning] Font load error', err, fontSetting);
                    }).then(function () {
                      if (!document.fonts.check(fontSetting, _this72._settings.text)) {
                        console.warn('[Lightning] Font not found', fontSetting);
                      }
                    });
                  }
                } catch (e) {
                  console.warn("[Lightning] Can't check font loading for " + fontSetting);
                }
              }
            }
          }, {
            key: "calculateRenderInfo",
            value: function calculateRenderInfo() {
              var renderInfo = {};
              var precision = this.getPrecision();
              var paddingLeft = this._settings.paddingLeft * precision;
              var paddingRight = this._settings.paddingRight * precision;
              var fontSize = this._settings.fontSize * precision;
              var offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision;
              var w = this._settings.w * precision;
              var h = this._settings.h * precision;
              var wordWrapWidth = this._settings.wordWrapWidth * precision;
              var cutSx = this._settings.cutSx * precision;
              var cutEx = this._settings.cutEx * precision;
              var cutSy = this._settings.cutSy * precision;
              var cutEy = this._settings.cutEy * precision;
              var letterSpacing = (this._settings.letterSpacing || 0) * precision;
              var textIndent = this._settings.textIndent * precision;
              var trFontFace = this._settings.trFontFace;
              // Set font properties.
              this.setFontProperties();
              var metrics = getWebFontMetrics(this._context, trFontFace, fontSize);
              var defLineHeight = calcDefaultLineHeight(metrics, fontSize) * precision;
              var lineHeight = this._settings.lineHeight !== null ? this._settings.lineHeight * precision : defLineHeight;
              var maxHeight = this._settings.maxHeight;
              var containedMaxLines = maxHeight !== null && lineHeight > 0 ? Math.floor(maxHeight / lineHeight) : 0;
              var setMaxLines = this._settings.maxLines;
              var calcMaxLines = containedMaxLines > 0 && setMaxLines > 0 ? Math.min(containedMaxLines, setMaxLines) : Math.max(containedMaxLines, setMaxLines);
              // Total width.
              var width = w || 2048 / this.getPrecision();
              // Inner width.
              var innerWidth = width - paddingLeft;
              if (innerWidth < 10) {
                width += 10 - innerWidth;
                innerWidth = 10;
              }
              if (!wordWrapWidth) {
                wordWrapWidth = innerWidth;
              }
              // Text overflow
              if (this._settings.textOverflow && !this._settings.wordWrap) {
                var suffix;
                switch (this._settings.textOverflow) {
                  case 'clip':
                    suffix = '';
                    break;
                  case 'ellipsis':
                    suffix = this._settings.overflowSuffix;
                    break;
                  default:
                    suffix = this._settings.textOverflow;
                }
                this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
              }
              // word wrap
              // preserve original text
              var linesInfo;
              if (this._settings.wordWrap) {
                linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
              } else {
                linesInfo = {
                  l: this._settings.text.split(/(?:\r\n|\r|\n)/),
                  n: []
                };
                var n = linesInfo.l.length;
                for (var i = 0; i < n - 1; i++) {
                  linesInfo.n.push(i);
                }
              }
              var lines = linesInfo.l;
              if (calcMaxLines && lines.length > calcMaxLines) {
                var usedLines = lines.slice(0, calcMaxLines);
                var otherLines = null;
                if (this._settings.overflowSuffix) {
                  // Wrap again with max lines suffix enabled.
                  var _w = this._settings.overflowSuffix ? this.measureText(this._settings.overflowSuffix) : 0;
                  var al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - _w, letterSpacing, textIndent);
                  usedLines[usedLines.length - 1] = "".concat(al.l[0]).concat(this._settings.overflowSuffix);
                  otherLines = [al.l.length > 1 ? al.l[1] : ''];
                } else {
                  otherLines = [''];
                }
                // Re-assemble the remaining text.
                var _i24;
                var _n = lines.length;
                var j = 0;
                var m = linesInfo.n.length;
                for (_i24 = calcMaxLines; _i24 < _n; _i24++) {
                  otherLines[j] += "".concat(otherLines[j] ? ' ' : '').concat(lines[_i24]);
                  if (_i24 + 1 < m && linesInfo.n[_i24 + 1]) {
                    j++;
                  }
                }
                renderInfo.remainingText = otherLines.join('\n');
                renderInfo.moreTextLines = true;
                lines = usedLines;
              } else {
                renderInfo.moreTextLines = false;
                renderInfo.remainingText = '';
              }
              // calculate text width
              var maxLineWidth = 0;
              var lineWidths = [];
              for (var _i25 = 0; _i25 < lines.length; _i25++) {
                var lineWidth = this.measureText(lines[_i25], letterSpacing) + (_i25 === 0 ? textIndent : 0);
                lineWidths.push(lineWidth);
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
              }
              renderInfo.lineWidths = lineWidths;
              if (!w) {
                // Auto-set width to max text length.
                width = maxLineWidth + paddingLeft + paddingRight;
                innerWidth = maxLineWidth;
              }
              // If word wrap is enabled the width needs to be the width of the text.
              if (this._settings.wordWrap && w > maxLineWidth && this._settings.textAlign === 'left' && lines.length === 1) {
                width = maxLineWidth + paddingLeft + paddingRight;
              }
              var height;
              if (h) {
                height = h;
              } else {
                height = calcHeight(this._settings.textBaseline, fontSize, lineHeight, lines.length, offsetY);
              }
              if (offsetY === null) {
                offsetY = fontSize;
              }
              renderInfo.w = width;
              renderInfo.h = height;
              renderInfo.lines = lines;
              renderInfo.precision = precision;
              if (!width) {
                // To prevent canvas errors.
                width = 1;
              }
              if (!height) {
                // To prevent canvas errors.
                height = 1;
              }
              if (cutSx || cutEx) {
                width = Math.min(width, cutEx - cutSx);
              }
              if (cutSy || cutEy) {
                height = Math.min(height, cutEy - cutSy);
              }
              renderInfo.width = width;
              renderInfo.innerWidth = innerWidth;
              renderInfo.height = height;
              renderInfo.fontSize = fontSize;
              renderInfo.cutSx = cutSx;
              renderInfo.cutSy = cutSy;
              renderInfo.cutEx = cutEx;
              renderInfo.cutEy = cutEy;
              renderInfo.lineHeight = lineHeight;
              renderInfo.defLineHeight = defLineHeight;
              renderInfo.lineWidths = lineWidths;
              renderInfo.offsetY = offsetY;
              renderInfo.paddingLeft = paddingLeft;
              renderInfo.paddingRight = paddingRight;
              renderInfo.letterSpacing = letterSpacing;
              renderInfo.textIndent = textIndent;
              renderInfo.metrics = metrics;
              return renderInfo;
            }
          }, {
            key: "draw",
            value: function draw(renderInfo, linesOverride) {
              var precision = this.getPrecision();
              // Allow lines to be overriden for partial rendering.
              var lines = (linesOverride === null || linesOverride === void 0 ? void 0 : linesOverride.lines) || renderInfo.lines;
              var lineWidths = (linesOverride === null || linesOverride === void 0 ? void 0 : linesOverride.lineWidths) || renderInfo.lineWidths;
              var height = linesOverride ? calcHeight(this._settings.textBaseline, renderInfo.fontSize, renderInfo.lineHeight, linesOverride.lines.length, this._settings.offsetY === null ? null : this._settings.offsetY * precision) : renderInfo.height;
              // Add extra margin to prevent issue with clipped text when scaling.
              this._canvas.width = Math.min(Math.ceil(renderInfo.width + this._settings.textRenderIssueMargin), MAX_TEXTURE_DIMENSION);
              this._canvas.height = Math.min(Math.ceil(height), MAX_TEXTURE_DIMENSION);
              // Canvas context has been reset.
              this.setFontProperties();
              if (renderInfo.fontSize >= 128) {
                // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
                this._context.globalAlpha = 0.01;
                this._context.fillRect(0, 0, 0.01, 0.01);
                this._context.globalAlpha = 1.0;
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
              }
              var linePositionX;
              var linePositionY;
              var drawLines = [];
              var metrics = renderInfo.metrics;
              /**
               * Ascender (in pixels)
               */
              var ascenderPx = metrics ? metrics.ascender * renderInfo.fontSize : renderInfo.fontSize;
              /**
               * Bare line height is the distance between the ascender and descender of the font.
               * without the line gap metric.
               */
              var bareLineHeightPx = (metrics.ascender - metrics.descender) * renderInfo.fontSize;
              // Draw lines line by line.
              for (var i = 0, n = lines.length; i < n; i++) {
                linePositionX = i === 0 ? renderInfo.textIndent : 0;
                // By default, text is aligned to top
                linePositionY = i * renderInfo.lineHeight + ascenderPx;
                if (this._settings.verticalAlign == 'middle') {
                  linePositionY += (renderInfo.lineHeight - bareLineHeightPx) / 2;
                } else if (this._settings.verticalAlign == 'bottom') {
                  linePositionY += renderInfo.lineHeight - bareLineHeightPx;
                }
                if (this._settings.textAlign === 'right') {
                  linePositionX += renderInfo.innerWidth - lineWidths[i];
                } else if (this._settings.textAlign === 'center') {
                  linePositionX += (renderInfo.innerWidth - lineWidths[i]) / 2;
                }
                linePositionX += renderInfo.paddingLeft;
                drawLines.push({
                  text: lines[i],
                  x: linePositionX,
                  y: linePositionY,
                  w: lineWidths[i]
                });
              }
              // Highlight.
              if (this._settings.highlight) {
                var color = this._settings.highlightColor;
                var hlHeight = this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5;
                var offset = this._settings.highlightOffset * precision;
                var hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft;
                var hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight;
                this._context.fillStyle = getRgbaString(color);
                for (var _i26 = 0; _i26 < drawLines.length; _i26++) {
                  var drawLine = drawLines[_i26];
                  this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
                }
              }
              // Text shadow.
              var prevShadowSettings = null;
              if (this._settings.shadow) {
                prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
                this._context.shadowColor = getRgbaString(this._settings.shadowColor);
                this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
                this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
                this._context.shadowBlur = this._settings.shadowBlur * precision;
              }
              this._context.fillStyle = getRgbaString(this._settings.textColor);
              for (var _i27 = 0, _n2 = drawLines.length; _i27 < _n2; _i27++) {
                var _drawLine = drawLines[_i27];
                if (renderInfo.letterSpacing === 0) {
                  this._context.fillText(_drawLine.text, _drawLine.x, _drawLine.y);
                } else {
                  var textSplit = _drawLine.text.split('');
                  var x = _drawLine.x;
                  for (var _i28 = 0, j = textSplit.length; _i28 < j; _i28++) {
                    this._context.fillText(textSplit[_i28], x, _drawLine.y);
                    x += this.measureText(textSplit[_i28], renderInfo.letterSpacing);
                  }
                }
              }
              if (prevShadowSettings) {
                this._context.shadowColor = prevShadowSettings[0];
                this._context.shadowOffsetX = prevShadowSettings[1];
                this._context.shadowOffsetY = prevShadowSettings[2];
                this._context.shadowBlur = prevShadowSettings[3];
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
              }
            }
          }, {
            key: "wrapWord",
            value: function wrapWord(word, wordWrapWidth, suffix) {
              var suffixWidth = this._context.measureText(suffix).width;
              var wordLen = word.length;
              var wordWidth = this._context.measureText(word).width;
              /* If word fits wrapWidth, do nothing */
              if (wordWidth <= wordWrapWidth) {
                return word;
              }
              /* Make initial guess for text cuttoff */
              var cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
              var truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
              /* In case guess was overestimated, shrink it letter by letter. */
              if (truncWordWidth > wordWrapWidth) {
                while (cutoffIndex > 0) {
                  truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                  if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                  } else {
                    break;
                  }
                }
                /* In case guess was underestimated, extend it letter by letter. */
              } else {
                while (cutoffIndex < wordLen) {
                  truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                  if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                  } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -= 1;
                    break;
                  }
                }
              }
              /* If wrapWidth is too short to even contain suffix alone, return empty string */
              return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
            }
            /**
             * Applies newlines to a string to have it optimally fit into the horizontal
             * bounds set by the Text object's wordWrapWidth property.
             */
          }, {
            key: "wrapText",
            value: function wrapText(text, wordWrapWidth, letterSpacing) {
              var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var spaceRegex = / |\u200B/g; // ZWSP and spaces
              var lines = text.split(/\r?\n/g);
              var allLines = [];
              var realNewlines = [];
              for (var i = 0; i < lines.length; i++) {
                var resultLines = [];
                var result = '';
                var spaceLeft = wordWrapWidth - indent;
                // Split the line into words, considering ZWSP
                var words = lines[i].split(spaceRegex);
                var spaces = lines[i].match(spaceRegex) || [];
                for (var j = 0; j < words.length; j++) {
                  var space = spaces[j - 1] || '';
                  var word = words[j];
                  var wordWidth = this.measureText(word, letterSpacing);
                  var wordWidthWithSpace = isZeroWidthSpace(space) ? wordWidth : wordWidth + this.measureText(space, letterSpacing);
                  if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                      resultLines.push(result);
                      result = '';
                    }
                    result += word;
                    spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                  } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += space + word;
                  }
                }
                resultLines.push(result);
                result = '';
                allLines = allLines.concat(resultLines);
                if (i < lines.length - 1) {
                  realNewlines.push(allLines.length);
                }
              }
              return {
                l: allLines,
                n: realNewlines
              };
            }
          }, {
            key: "measureText",
            value: function measureText(word) {
              var _this73 = this;
              var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              if (!space) {
                return this._context.measureText(word).width;
              }
              // Split word into characters, but skip ZWSP in the width calculation
              return word.split('').reduce(function (acc, char) {
                // Check if the character is a zero-width space and skip it
                if (isZeroWidthSpace(char)) {
                  return acc;
                }
                return acc + _this73._context.measureText(char).width + space;
              }, 0);
            }
          }, {
            key: "mergeDefaults",
            value: function mergeDefaults(settings) {
              return _objectSpread({
                text: '',
                w: 0,
                h: 0,
                fontStyle: 'normal',
                fontSize: 40,
                fontFamily: null,
                trFontFace: null,
                wordWrap: true,
                wordWrapWidth: 0,
                wordBreak: false,
                textOverflow: '',
                lineHeight: null,
                textBaseline: 'alphabetic',
                textAlign: 'left',
                verticalAlign: 'top',
                offsetY: null,
                maxLines: 0,
                maxHeight: null,
                overflowSuffix: '...',
                textColor: [1.0, 1.0, 1.0, 1.0],
                paddingLeft: 0,
                paddingRight: 0,
                shadow: false,
                shadowColor: [0.0, 0.0, 0.0, 1.0],
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 5,
                highlight: false,
                highlightHeight: 0,
                highlightColor: [0.0, 0.0, 0.0, 1.0],
                highlightOffset: 0,
                highlightPaddingLeft: 0,
                highlightPaddingRight: 0,
                letterSpacing: 0,
                textIndent: 0,
                cutSx: 0,
                cutEx: 0,
                cutSy: 0,
                cutEy: 0,
                advancedRenderer: false,
                fontBaselineRatio: 0,
                precision: 1,
                textRenderIssueMargin: 0
              }, settings);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var resolvedGlobal = typeof self === 'undefined' ? globalThis : self;
        /**
         * Global font set regardless of if run in the main thread or a web worker
         */
        var globalFontSet = ((_resolvedGlobal$docum = resolvedGlobal.document) === null || _resolvedGlobal$docum === void 0 ? void 0 : _resolvedGlobal$docum.fonts) || resolvedGlobal.fonts;
        function getFontCssString(props) {
          var fontFamily = props.fontFamily,
            fontStyle = props.fontStyle,
            fontWeight = props.fontWeight,
            fontStretch = props.fontStretch,
            fontSize = props.fontSize;
          return [fontStyle, fontWeight, fontStretch, "".concat(fontSize, "px"), fontFamily].join(' ');
        }
        var CanvasTextRenderer = /*#__PURE__*/function (_TextRenderer3) {
          function CanvasTextRenderer(stage) {
            var _this74;
            _classCallCheck(this, CanvasTextRenderer);
            _this74 = _callSuper(this, CanvasTextRenderer, [stage]);
            _defineProperty(_this74, "canvas", void 0);
            _defineProperty(_this74, "context", void 0);
            /**
             * Font family map used to store web font faces that were added to the
             * canvas text renderer.
             */
            _defineProperty(_this74, "fontFamilies", {});
            _defineProperty(_this74, "fontFamilyArray", [_this74.fontFamilies]);
            _defineProperty(_this74, "type", 'canvas');
            _defineProperty(_this74, "loadFont", function (state) {
              var cssString = getFontCssString(state.props);
              var trFontFace = _this74.stage.fontManager.resolveFontFace(_this74.fontFamilyArray, state.props, 'canvas');
              state.fontInfo = {
                fontFace: trFontFace,
                cssString: cssString,
                // TODO: For efficiency we would use this here but it's not reliable on WPE -> document.fonts.check(cssString),
                loaded: false
              };
              // If font is not loaded, set up a handler to update the font info when the font loads
              if (!state.fontInfo.loaded) {
                globalFontSet.load(cssString).then(_this74.onFontLoaded.bind(_this74, state, cssString)).catch(_this74.onFontLoadError.bind(_this74, state, cssString));
                return;
              }
            });
            if (typeof OffscreenCanvas !== 'undefined') {
              _this74.canvas = new OffscreenCanvas(0, 0);
            } else {
              _this74.canvas = document.createElement('canvas');
            }
            var context = _this74.canvas.getContext('2d', {
              willReadFrequently: true
            });
            if (!context) {
              // A browser may appear to support OffscreenCanvas but not actually support the Canvas '2d' context
              // Here we try getting the context again after falling back to an HTMLCanvasElement.
              // See: https://github.com/lightning-js/renderer/issues/26#issuecomment-1750438486
              _this74.canvas = document.createElement('canvas');
              context = _this74.canvas.getContext('2d', {
                willReadFrequently: true
              });
            }
            _this74.context = context;
            // Install the default 'san-serif' font face
            _this74.addFontFace(new WebTrFontFace({
              fontFamily: 'sans-serif',
              descriptors: {},
              fontUrl: ''
            }));
            return _this74;
          }
          //#region Overrides
          _inherits(CanvasTextRenderer, _TextRenderer3);
          return _createClass(CanvasTextRenderer, [{
            key: "getPropertySetters",
            value: function getPropertySetters() {
              var _this75 = this;
              return {
                fontFamily: function fontFamily(state, value) {
                  state.props.fontFamily = value;
                  state.fontInfo = undefined;
                  _this75.invalidateLayoutCache(state);
                },
                fontWeight: function fontWeight(state, value) {
                  state.props.fontWeight = value;
                  state.fontInfo = undefined;
                  _this75.invalidateLayoutCache(state);
                },
                fontStyle: function fontStyle(state, value) {
                  state.props.fontStyle = value;
                  state.fontInfo = undefined;
                  _this75.invalidateLayoutCache(state);
                },
                fontStretch: function fontStretch(state, value) {
                  state.props.fontStretch = value;
                  state.fontInfo = undefined;
                  _this75.invalidateLayoutCache(state);
                },
                fontSize: function fontSize(state, value) {
                  state.props.fontSize = value;
                  state.fontInfo = undefined;
                  _this75.invalidateLayoutCache(state);
                },
                text: function text(state, value) {
                  state.props.text = value;
                  _this75.invalidateLayoutCache(state);
                },
                textAlign: function textAlign(state, value) {
                  state.props.textAlign = value;
                  _this75.invalidateLayoutCache(state);
                },
                color: function color(state, value) {
                  state.props.color = value;
                  _this75.invalidateLayoutCache(state);
                },
                x: function x(state, value) {
                  state.props.x = value;
                },
                y: function y(state, value) {
                  state.props.y = value;
                },
                contain: function contain(state, value) {
                  state.props.contain = value;
                  _this75.invalidateLayoutCache(state);
                },
                width: function width(state, value) {
                  state.props.width = value;
                  // Only invalidate layout cache if we're containing in the horizontal direction
                  if (state.props.contain !== 'none') {
                    _this75.invalidateLayoutCache(state);
                  }
                },
                height: function height(state, value) {
                  state.props.height = value;
                  // Only invalidate layout cache if we're containing in the vertical direction
                  if (state.props.contain === 'both') {
                    _this75.invalidateLayoutCache(state);
                  }
                },
                offsetY: function offsetY(state, value) {
                  state.props.offsetY = value;
                  _this75.invalidateLayoutCache(state);
                },
                scrollY: function scrollY(state, value) {
                  state.props.scrollY = value;
                },
                letterSpacing: function letterSpacing(state, value) {
                  state.props.letterSpacing = value;
                  _this75.invalidateLayoutCache(state);
                },
                lineHeight: function lineHeight(state, value) {
                  state.props.lineHeight = value;
                  _this75.invalidateLayoutCache(state);
                },
                maxLines: function maxLines(state, value) {
                  state.props.maxLines = value;
                  _this75.invalidateLayoutCache(state);
                },
                textBaseline: function textBaseline(state, value) {
                  state.props.textBaseline = value;
                  _this75.invalidateLayoutCache(state);
                },
                verticalAlign: function verticalAlign(state, value) {
                  state.props.verticalAlign = value;
                  _this75.invalidateLayoutCache(state);
                },
                overflowSuffix: function overflowSuffix(state, value) {
                  state.props.overflowSuffix = value;
                  _this75.invalidateLayoutCache(state);
                }
              };
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
          }, {
            key: "canRenderFont",
            value: function canRenderFont(props) {
              // The canvas renderer can render any font because it automatically
              // falls back to system fonts. The CanvasTextRenderer should be
              // checked last if other renderers are preferred.
              return true;
            }
          }, {
            key: "isFontFaceSupported",
            value: function isFontFaceSupported(fontFace) {
              return fontFace instanceof WebTrFontFace;
            }
          }, {
            key: "addFontFace",
            value: function addFontFace(fontFace) {
              var fontFamily = fontFace.fontFamily;
              // Add the font face to the document
              // Except for the 'sans-serif' font family, which the Renderer provides
              // as a special default fallback.
              if (fontFamily !== 'sans-serif') {
                // @ts-expect-error `add()` method should be available from a FontFaceSet
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                globalFontSet.add(fontFace.fontFace);
              }
              var faceSet = this.fontFamilies[fontFamily];
              if (!faceSet) {
                faceSet = new Set();
                this.fontFamilies[fontFamily] = faceSet;
              }
              faceSet.add(fontFace);
            }
          }, {
            key: "createState",
            value: function createState(props, node) {
              return {
                node: node,
                props: props,
                status: 'initialState',
                updateScheduled: false,
                emitter: new EventEmitter(),
                textureNode: undefined,
                lightning2TextRenderer: new LightningTextTextureRenderer(this.canvas, this.context),
                renderInfo: undefined,
                forceFullLayoutCalc: false,
                textW: 0,
                textH: 0,
                fontInfo: undefined,
                isRenderable: false,
                debugData: {
                  updateCount: 0,
                  layoutCount: 0,
                  drawCount: 0,
                  lastLayoutNumCharacters: 0,
                  layoutSum: 0,
                  drawSum: 0,
                  bufferSize: 0
                }
              };
            }
          }, {
            key: "updateState",
            value: function updateState(state) {
              // On the first update call we need to set the status to loading
              if (state.status === 'initialState') {
                this.setStatus(state, 'loading');
                // check if we're on screen
                // if (this.isValidOnScreen(state) === true) {
                //   this.setStatus(state, 'loading');
                // }
              }
              if (state.status === 'loaded') {
                // If we're loaded, we don't need to do anything
                return;
              }
              // If fontInfo is invalid, we need to establish it
              if (!state.fontInfo) {
                return this.loadFont(state);
              }
              // If we're waiting for a font face to load, don't render anything
              if (!state.fontInfo.loaded) {
                return;
              }
              if (!state.renderInfo) {
                state.renderInfo = this.calculateRenderInfo(state);
                state.textH = state.renderInfo.lineHeight * state.renderInfo.lines.length;
                state.textW = state.renderInfo.width;
                this.renderSingleCanvasPage(state);
              }
              // handle scrollable text !!!
              // if (state.isScrollable === true) {
              //   return this.renderScrollableCanvasPages(state);
              // }
              // handle single page text
            }
          }, {
            key: "renderSingleCanvasPage",
            value: function renderSingleCanvasPage(state) {
              assertTruthy(state.renderInfo);
              var node = state.node;
              var texture = this.stage.txManager.createTexture('ImageTexture', {
                premultiplyAlpha: true,
                src: function (lightning2TextRenderer, renderInfo) {
                  lightning2TextRenderer.draw(renderInfo, {
                    lines: renderInfo.lines,
                    lineWidths: renderInfo.lineWidths
                  });
                  if (this.canvas.width === 0 || this.canvas.height === 0) {
                    return null;
                  }
                  return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                }.bind(this, state.lightning2TextRenderer, state.renderInfo)
              });
              if (state.textureNode) {
                // Use the existing texture node
                state.textureNode.texture = texture;
                // Update the alpha
                state.textureNode.alpha = getNormalizedAlphaComponent(state.props.color);
              } else {
                // Create a new texture node
                var textureNode = this.stage.createNode({
                  parent: node,
                  texture: texture,
                  autosize: true,
                  // The alpha channel of the color is ignored when rasterizing the text
                  // texture so we need to pass it directly to the texture node.
                  alpha: getNormalizedAlphaComponent(state.props.color)
                });
                state.textureNode = textureNode;
              }
              this.setStatus(state, 'loaded');
            }
          }, {
            key: "calculateRenderInfo",
            value: function calculateRenderInfo(state) {
              var _state$fontInfo, _state$props$lineHeig;
              state.lightning2TextRenderer.settings = {
                text: state.props.text,
                textAlign: state.props.textAlign,
                fontFamily: state.props.fontFamily,
                trFontFace: (_state$fontInfo = state.fontInfo) === null || _state$fontInfo === void 0 ? void 0 : _state$fontInfo.fontFace,
                fontSize: state.props.fontSize,
                fontStyle: [state.props.fontStretch, state.props.fontStyle, state.props.fontWeight].join(' '),
                textColor: getNormalizedRgbaComponents(state.props.color),
                offsetY: state.props.offsetY,
                wordWrap: state.props.contain !== 'none',
                wordWrapWidth: state.props.contain === 'none' ? undefined : state.props.width,
                letterSpacing: state.props.letterSpacing,
                lineHeight: (_state$props$lineHeig = state.props.lineHeight) !== null && _state$props$lineHeig !== void 0 ? _state$props$lineHeig : null,
                maxLines: state.props.maxLines,
                maxHeight: state.props.contain === 'both' ? state.props.height - state.props.offsetY : null,
                textBaseline: state.props.textBaseline,
                verticalAlign: state.props.verticalAlign,
                overflowSuffix: state.props.overflowSuffix,
                w: state.props.contain !== 'none' ? state.props.width : undefined
              };
              state.renderInfo = state.lightning2TextRenderer.calculateRenderInfo();
              return state.renderInfo;
            }
          }, {
            key: "renderQuads",
            value: function renderQuads() {
              // Do nothing. The renderer will render the child node(s) that were created
              // in the state update.
              return;
            }
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              if (state.status === 'destroyed') {
                return;
              }
              _superPropGet(CanvasTextRenderer, "destroyState", this, 3)([state]);
              if (state.textureNode) {
                state.textureNode.destroy();
                delete state.textureNode;
              }
              delete state.renderInfo;
            }
            //#endregion Overrides
            /**
             * Invalidate the layout cache stored in the state. This will cause the text
             * to be re-rendered on the next update.
             *
             * @remarks
             * This also invalidates the visible window cache.
             *
             * @param state
             */
          }, {
            key: "invalidateLayoutCache",
            value: function invalidateLayoutCache(state) {
              state.renderInfo = undefined;
              this.setStatus(state, 'loading');
              this.scheduleUpdateState(state);
            }
          }, {
            key: "onFontLoaded",
            value: function onFontLoaded(state, cssString) {
              var _state$fontInfo2;
              if (cssString !== ((_state$fontInfo2 = state.fontInfo) === null || _state$fontInfo2 === void 0 ? void 0 : _state$fontInfo2.cssString) || !state.fontInfo) {
                return;
              }
              state.fontInfo.loaded = true;
              this.scheduleUpdateState(state);
            }
          }, {
            key: "onFontLoadError",
            value: function onFontLoadError(state, cssString, error) {
              var _state$fontInfo3;
              if (cssString !== ((_state$fontInfo3 = state.fontInfo) === null || _state$fontInfo3 === void 0 ? void 0 : _state$fontInfo3.cssString) || !state.fontInfo) {
                return;
              }
              // Font didn't actually load, but we'll log the error and mark it as loaded
              // because the browser can still render with a fallback font.
              state.fontInfo.loaded = true;
              console.error("CanvasTextRenderer: Error loading font '".concat(state.fontInfo.cssString, "'"), error);
              this.scheduleUpdateState(state);
            }
          }]);
        }(TextRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WHITE = {
          isWhite: true,
          a: 1,
          r: 0xff,
          g: 0xff,
          b: 0xff
        };
        /**
         * Extract color components
         */
        function parseColor(abgr) {
          if (abgr === 0xffffffff) {
            return WHITE;
          }
          var a = (abgr >>> 24 & 0xff) / 255;
          var b = abgr >>> 16 & 0xff & 0xff;
          var g = abgr >>> 8 & 0xff & 0xff;
          var r = abgr & 0xff & 0xff;
          return {
            isWhite: false,
            a: a,
            r: r,
            g: g,
            b: b
          };
        }
        /**
         * Extract color components
         */
        function parseColorRgba(rgba) {
          if (rgba === 0xffffffff) {
            return WHITE;
          }
          var r = rgba >>> 24 & 0xff;
          var g = rgba >>> 16 & 0xff & 0xff;
          var b = rgba >>> 8 & 0xff & 0xff;
          var a = (rgba & 0xff & 0xff) / 255;
          return {
            isWhite: false,
            r: r,
            g: g,
            b: b,
            a: a
          };
        }
        /**
         * Format a parsed color into a rgba CSS color
         */
        function formatRgba(_ref37) {
          var a = _ref37.a,
            r = _ref37.r,
            g = _ref37.g,
            b = _ref37.b;
          return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CanvasCoreTexture = /*#__PURE__*/function (_CoreContextTexture3) {
          function CanvasCoreTexture() {
            var _this76;
            _classCallCheck(this, CanvasCoreTexture);
            for (var _len17 = arguments.length, args = new Array(_len17), _key40 = 0; _key40 < _len17; _key40++) {
              args[_key40] = arguments[_key40];
            }
            _this76 = _callSuper(this, CanvasCoreTexture, [].concat(args));
            _defineProperty(_this76, "image", void 0);
            _defineProperty(_this76, "tintCache", void 0);
            return _this76;
          }
          _inherits(CanvasCoreTexture, _CoreContextTexture3);
          return _createClass(CanvasCoreTexture, [{
            key: "load",
            value: function load() {
              var _this77 = this;
              this.textureSource.setState('loading');
              this.onLoadRequest().then(function (size) {
                _this77.textureSource.setState('loaded', size);
                _this77.textureSource.freeTextureData();
                _this77.updateMemSize();
              }).catch(function (err) {
                _this77.textureSource.setState('failed', err);
                _this77.textureSource.freeTextureData();
              });
            }
          }, {
            key: "free",
            value: function free() {
              this.image = undefined;
              this.tintCache = undefined;
              this.textureSource.setState('freed');
              this.setTextureMemUse(0);
              this.textureSource.freeTextureData();
            }
          }, {
            key: "updateMemSize",
            value: function updateMemSize() {
              // Counting memory usage for:
              // - main image
              // - tinted image
              var mult = this.tintCache ? 8 : 4;
              if (this.textureSource.dimensions) {
                var _this$textureSource$d = this.textureSource.dimensions,
                  width = _this$textureSource$d.width,
                  height = _this$textureSource$d.height;
                this.setTextureMemUse(width * height * mult);
              }
            }
          }, {
            key: "hasImage",
            value: function hasImage() {
              return this.image !== undefined;
            }
          }, {
            key: "getImage",
            value: function getImage(color) {
              var _this$tintCache;
              var image = this.image;
              if (color.isWhite) {
                if (this.tintCache) {
                  this.tintCache = undefined;
                  this.updateMemSize();
                }
                return image;
              }
              var key = formatRgba(color);
              if (((_this$tintCache = this.tintCache) === null || _this$tintCache === void 0 ? void 0 : _this$tintCache.key) === key) {
                return this.tintCache.image;
              }
              var tintedImage = this.tintTexture(image, key);
              this.tintCache = {
                key: key,
                image: tintedImage
              };
              this.updateMemSize();
              return tintedImage;
            }
          }, {
            key: "tintTexture",
            value: function tintTexture(source, color) {
              var width = source.width,
                height = source.height;
              var canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
              var ctx = canvas.getContext('2d');
              if (ctx) {
                // fill with target color
                ctx.fillStyle = color;
                ctx.globalCompositeOperation = 'copy';
                ctx.fillRect(0, 0, width, height);
                // multiply with image, resulting in non-transparent tinted image
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
                // apply original image alpha
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
              }
              return canvas;
            }
          }, {
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest4 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
                var _this$textureSource2;
                var data, canvas, ctx;
                return _regeneratorRuntime().wrap(function _callee18$(_context19) {
                  while (1) switch (_context19.prev = _context19.next) {
                    case 0:
                      assertTruthy((_this$textureSource2 = this.textureSource) === null || _this$textureSource2 === void 0 || (_this$textureSource2 = _this$textureSource2.textureData) === null || _this$textureSource2 === void 0 ? void 0 : _this$textureSource2.data);
                      data = this.textureSource.textureData.data; // TODO: canvas from text renderer should be able to provide the canvas directly
                      // instead of having to re-draw it into a new canvas...
                      if (!(data instanceof ImageData)) {
                        _context19.next = 12;
                        break;
                      }
                      canvas = document.createElement('canvas');
                      canvas.width = data.width;
                      canvas.height = data.height;
                      ctx = canvas.getContext('2d');
                      if (ctx) ctx.putImageData(data, 0, 0);
                      this.image = canvas;
                      return _context19.abrupt("return", {
                        width: data.width,
                        height: data.height
                      });
                    case 12:
                      if (!(typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || data instanceof HTMLImageElement)) {
                        _context19.next = 15;
                        break;
                      }
                      this.image = data;
                      return _context19.abrupt("return", {
                        width: data.width,
                        height: data.height
                      });
                    case 15:
                      return _context19.abrupt("return", {
                        width: 0,
                        height: 0
                      });
                    case 16:
                    case "end":
                      return _context19.stop();
                  }
                }, _callee18, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest4.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }]);
        }(CoreContextTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Extract `RoundedRectangle` shader radius to apply as a clipping
         */
        function getRadius(quad) {
          if (quad.shader instanceof UnsupportedShader) {
            var shType = quad.shader.shType;
            if (shType === ROUNDED_RECTANGLE_SHADER_TYPE) {
              var _quad$shaderProps$rad, _quad$shaderProps;
              return (_quad$shaderProps$rad = (_quad$shaderProps = quad.shaderProps) === null || _quad$shaderProps === void 0 ? void 0 : _quad$shaderProps.radius) !== null && _quad$shaderProps$rad !== void 0 ? _quad$shaderProps$rad : 0;
            } else if (shType === 'DynamicShader') {
              var _quad$shaderProps2;
              var effects = (_quad$shaderProps2 = quad.shaderProps) === null || _quad$shaderProps2 === void 0 ? void 0 : _quad$shaderProps2.effects;
              if (effects) {
                var _effect4 = effects.find(function (effect) {
                  var _effect$props;
                  return effect.type === 'radius' && (effect === null || effect === void 0 || (_effect$props = effect.props) === null || _effect$props === void 0 ? void 0 : _effect$props.radius);
                });
                return _effect4 && _effect4.type === 'radius' && _effect4.props.radius || 0;
              }
            }
          }
          return 0;
        }
        /**
         * Extract `RoundedRectangle` shader radius to apply as a clipping */
        function getBorder(quad) {
          var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          if (quad.shader instanceof UnsupportedShader) {
            var shType = quad.shader.shType;
            if (shType === 'DynamicShader') {
              var _quad$shaderProps3;
              var effects = (_quad$shaderProps3 = quad.shaderProps) === null || _quad$shaderProps3 === void 0 ? void 0 : _quad$shaderProps3.effects;
              if (effects && effects.length) {
                var _effect5 = effects.find(function (effect) {
                  return effect.type === "border".concat(direction) && effect.props && effect.props.width;
                });
                return _effect5 && _effect5.props;
              }
            }
          }
          return undefined;
        }
        function roundRect(x, y, width, height, radius) {
          var context = Object.getPrototypeOf(this);
          if (!context.roundRect) {
            var fixOverlappingCorners = function fixOverlappingCorners(radii) {
              var maxRadius = Math.min(width / 2, height / 2);
              var totalHorizontal = radii.topLeft + radii.topRight + radii.bottomRight + radii.bottomLeft;
              if (totalHorizontal > width || totalHorizontal > height) {
                var scale = maxRadius / Math.max(radii.topLeft, radii.topRight, radii.bottomRight, radii.bottomLeft);
                radii.topLeft *= scale;
                radii.topRight *= scale;
                radii.bottomRight *= scale;
                radii.bottomLeft *= scale;
              }
            };
            var radii = typeof radius === 'number' ? {
              topLeft: radius,
              topRight: radius,
              bottomRight: radius,
              bottomLeft: radius
            } : _objectSpread({
              topLeft: 0,
              topRight: 0,
              bottomRight: 0,
              bottomLeft: 0
            }, radius);
            fixOverlappingCorners(radii);
            this.moveTo(x + radii.topLeft, y);
            this.lineTo(x + width - radii.topRight, y);
            this.ellipse(x + width - radii.topRight, y + radii.topRight, radii.topRight, radii.topRight, 0, 1.5 * Math.PI, 2 * Math.PI);
            this.lineTo(x + width, y + height - radii.bottomRight);
            this.ellipse(x + width - radii.bottomRight, y + height - radii.bottomRight, radii.bottomRight, radii.bottomRight, 0, 0, 0.5 * Math.PI);
            this.lineTo(x + radii.bottomLeft, y + height);
            this.ellipse(x + radii.bottomLeft, y + height - radii.bottomLeft, radii.bottomLeft, radii.bottomLeft, 0, 0.5 * Math.PI, Math.PI);
            this.lineTo(x, y + radii.topLeft);
            this.ellipse(x + radii.topLeft, y + radii.topLeft, radii.topLeft, radii.topLeft, 0, Math.PI, 1.5 * Math.PI);
          } else {
            this.roundRect(x, y, width, height, radius);
          }
        }
        function strokeLine(ctx, x, y, width, height) {
          var lineWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          var color = arguments.length > 6 ? arguments[6] : undefined;
          var direction = arguments.length > 7 ? arguments[7] : undefined;
          if (!lineWidth) {
            return;
          }
          var sx,
            sy = 0;
          var ex,
            ey = 0;
          switch (direction) {
            case 'Top':
              sx = x;
              sy = y;
              ex = width + x;
              ey = y;
              break;
            case 'Right':
              sx = x + width;
              sy = y;
              ex = x + width;
              ey = y + height;
              break;
            case 'Bottom':
              sx = x;
              sy = y + height;
              ex = x + width;
              ey = y + height;
              break;
            case 'Left':
              sx = x;
              sy = y;
              ex = x;
              ey = y + height;
              break;
          }
          ctx.beginPath();
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = formatRgba(parseColorRgba(color !== null && color !== void 0 ? color : 0));
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CanvasCoreRenderer = /*#__PURE__*/function (_CoreRenderer3) {
          function CanvasCoreRenderer(options) {
            var _this78;
            _classCallCheck(this, CanvasCoreRenderer);
            _this78 = _callSuper(this, CanvasCoreRenderer, [options]);
            _defineProperty(_this78, "context", void 0);
            _defineProperty(_this78, "canvas", void 0);
            _defineProperty(_this78, "pixelRatio", void 0);
            _defineProperty(_this78, "clearColor", void 0);
            _defineProperty(_this78, "renderToTextureActive", false);
            _defineProperty(_this78, "activeRttNode", null);
            _defineProperty(_this78, "defShaderCtr", void 0);
            _this78.mode = 'canvas';
            _this78.shManager.renderer = _this78;
            var canvas = options.canvas,
              pixelRatio = options.pixelRatio,
              clearColor = options.clearColor;
            _this78.canvas = canvas;
            _this78.context = canvas.getContext('2d');
            _this78.pixelRatio = pixelRatio;
            _this78.clearColor = clearColor ? getRgbaComponents(clearColor) : undefined;
            // Stub for default shader controller since the canvas renderer does not
            // (really) support the concept of a shader (yet)
            _this78.defShaderCtr = {
              type: 'DefaultShader',
              props: {},
              shader: new UnsupportedShader('DefaultShader'),
              getResolvedProps: function getResolvedProps() {
                return function () {
                  return {};
                };
              }
            };
            return _this78;
          }
          _inherits(CanvasCoreRenderer, _CoreRenderer3);
          return _createClass(CanvasCoreRenderer, [{
            key: "reset",
            value: function reset() {
              this.canvas.width = this.canvas.width; // quick reset canvas
              var ctx = this.context;
              if (this.clearColor) {
                var _this$clearColor = _slicedToArray(this.clearColor, 4),
                  r = _this$clearColor[0],
                  g = _this$clearColor[1],
                  b = _this$clearColor[2],
                  a = _this$clearColor[3];
                ctx.fillStyle = "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a / 255, ")");
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
              }
              ctx.scale(this.pixelRatio, this.pixelRatio);
            }
          }, {
            key: "render",
            value: function render() {
              // noop
            }
          }, {
            key: "addQuad",
            value: function addQuad(quad) {
              var _texture2;
              var ctx = this.context;
              var tx = quad.tx,
                ty = quad.ty,
                width = quad.width,
                height = quad.height,
                alpha = quad.alpha,
                colorTl = quad.colorTl,
                colorTr = quad.colorTr,
                colorBr = quad.colorBr,
                ta = quad.ta,
                tb = quad.tb,
                tc = quad.tc,
                td = quad.td,
                clippingRect = quad.clippingRect;
              var texture = quad.texture;
              var ctxTexture = undefined;
              var frame;
              var textureType = (_texture2 = texture) === null || _texture2 === void 0 ? void 0 : _texture2.type;
              // The Canvas2D renderer only supports image and color textures and subTexture images
              if (textureType !== TextureType.image && textureType !== TextureType.color && textureType !== TextureType.subTexture && textureType !== TextureType.noise) {
                return;
              }
              if (texture) {
                if (texture instanceof SubTexture) {
                  frame = texture.props;
                  texture = texture.parentTexture;
                }
                ctxTexture = texture.ctxTexture;
                if (texture.state === 'freed') {
                  return;
                }
                if (texture.state !== 'loaded') {
                  return;
                }
              }
              var color = parseColor(colorTl);
              var hasTransform = ta !== 1;
              var hasClipping = clippingRect.width !== 0 && clippingRect.height !== 0;
              var hasGradient = colorTl !== colorTr || colorTl !== colorBr;
              var hasQuadShader = Boolean(quad.shader);
              var radius = hasQuadShader ? getRadius(quad) : 0;
              var border = hasQuadShader ? getBorder(quad) : undefined;
              if (hasTransform || hasClipping || radius) {
                ctx.save();
              }
              if (hasClipping) {
                var path = new Path2D();
                var x = clippingRect.x,
                  y = clippingRect.y,
                  _width2 = clippingRect.width,
                  _height2 = clippingRect.height;
                path.rect(x, y, _width2, _height2);
                ctx.clip(path);
              }
              if (hasTransform) {
                // Quad transform:
                // | ta tb tx |
                // | tc td ty |
                // | 0  0  1  |
                // C2D transform:
                // | a  c  e  |
                // | b  d  f  |
                // | 0  0  1  |
                var scale = this.pixelRatio;
                ctx.setTransform(ta, tc, tb, td, tx * scale, ty * scale);
                ctx.scale(scale, scale);
                ctx.translate(-tx, -ty);
              }
              if (radius) {
                var _path = new Path2D();
                roundRect.call(_path, tx, ty, width, height, radius);
                ctx.clip(_path);
              }
              if ((textureType === TextureType.image || textureType === TextureType.subTexture || textureType === TextureType.noise) && ctxTexture) {
                var _color$a;
                var image = ctxTexture.getImage(color);
                ctx.globalAlpha = (_color$a = color.a) !== null && _color$a !== void 0 ? _color$a : alpha;
                if (frame) {
                  ctx.drawImage(image, frame.x, frame.y, frame.width, frame.height, tx, ty, width, height);
                } else {
                  try {
                    ctx.drawImage(image, tx, ty, width, height);
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  } catch (error) {
                    // noop
                  }
                }
                ctx.globalAlpha = 1;
              } else if (textureType === TextureType.color && hasGradient) {
                var endX = tx;
                var endY = ty;
                var endColor;
                if (colorTl === colorTr) {
                  // vertical
                  endX = tx;
                  endY = ty + height;
                  endColor = parseColor(colorBr);
                } else {
                  // horizontal
                  endX = tx + width;
                  endY = ty;
                  endColor = parseColor(colorTr);
                }
                var gradient = ctx.createLinearGradient(tx, ty, endX, endY);
                gradient.addColorStop(0, formatRgba(color));
                gradient.addColorStop(1, formatRgba(endColor));
                ctx.fillStyle = gradient;
                ctx.fillRect(tx, ty, width, height);
              } else if (textureType === TextureType.color) {
                ctx.fillStyle = formatRgba(color);
                ctx.fillRect(tx, ty, width, height);
              }
              if (border && border.width) {
                var _border$color;
                var borderWidth = border.width;
                var borderInnerWidth = border.width / 2;
                var borderColor = formatRgba(parseColorRgba((_border$color = border.color) !== null && _border$color !== void 0 ? _border$color : 0));
                ctx.beginPath();
                ctx.lineWidth = borderWidth;
                ctx.strokeStyle = borderColor;
                ctx.globalAlpha = alpha;
                if (radius) {
                  roundRect.call(ctx, tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth, radius);
                  ctx.stroke();
                } else {
                  ctx.strokeRect(tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth);
                }
                ctx.globalAlpha = 1;
              } else if (hasQuadShader) {
                var borderTop = getBorder(quad, 'Top');
                var borderRight = getBorder(quad, 'Right');
                var borderBottom = getBorder(quad, 'Bottom');
                var borderLeft = getBorder(quad, 'Left');
                if (borderTop) {
                  strokeLine(ctx, tx, ty, width, height, borderTop.width, borderTop.color, 'Top');
                }
                if (borderRight) {
                  strokeLine(ctx, tx, ty, width, height, borderRight.width, borderRight.color, 'Right');
                }
                if (borderBottom) {
                  strokeLine(ctx, tx, ty, width, height, borderBottom.width, borderBottom.color, 'Bottom');
                }
                if (borderLeft) {
                  strokeLine(ctx, tx, ty, width, height, borderLeft.width, borderLeft.color, 'Left');
                }
              }
              if (hasTransform || hasClipping || radius) {
                ctx.restore();
              }
            }
          }, {
            key: "createCtxTexture",
            value: function createCtxTexture(textureSource) {
              return new CanvasCoreTexture(this.txMemManager, textureSource);
            }
          }, {
            key: "getShaderManager",
            value: function getShaderManager() {
              return this.shManager;
            }
          }, {
            key: "getDefShaderCtr",
            value: function getDefShaderCtr() {
              return this.defShaderCtr;
            }
          }, {
            key: "renderRTTNodes",
            value: function renderRTTNodes() {
              // noop
            }
          }, {
            key: "removeRTTNode",
            value: function removeRTTNode(node) {
              // noop
            }
          }, {
            key: "renderToTexture",
            value: function renderToTexture(node) {
              // noop
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              return null;
            }
          }, {
            key: "getQuadCount",
            value: function getQuadCount() {
              return null;
            }
            /**
             * Updates the clear color of the canvas renderer.
             *
             * @param color - The color to set as the clear color.
             */
          }, {
            key: "updateClearColor",
            value: function updateClearColor(color) {
              this.clearColor = color ? getRgbaComponents(color) : undefined;
            }
          }]);
        }(CoreRenderer);
        var _createSignal15 = createSignal([]),
          _createSignal16 = _slicedToArray(_createSignal15, 2),
          focusPath = _createSignal16[0],
          setFocusPath = _createSignal16[1];
        var useFocusManager = function useFocusManager(userKeyMap, keyHoldOptions) {
          var owner = getOwner();
          var ownerContext = runWithOwner.bind(undefined, owner);
          Config.setActiveElement = function (activeElm) {
            return ownerContext(function () {
              return setActiveElement(activeElm);
            });
          };
          var _useFocusManager$ = useFocusManager$1({
              userKeyMap: userKeyMap,
              keyHoldOptions: keyHoldOptions,
              ownerContext: ownerContext
            }),
            cleanup = _useFocusManager$.cleanup,
            focusPathCore = _useFocusManager$.focusPath;
          createEffect(on(activeElement, function () {
            setFocusPath(_toConsumableArray(focusPathCore()));
          }, {
            defer: true
          }));
          onCleanup(cleanup);
        };
        function flattenStrings() {
          var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var flattenedSeries = [];
          var i;
          for (i = 0; i < series.length; i++) {
            var s = series[i];
            if (typeof s === "string" && !s.includes("PAUSE-")) {
              flattenedSeries.push(series[i]);
            } else {
              break;
            }
          }
          return [flattenedSeries.join(",\b ")].concat(series.slice(i));
        }
        function delay(pause) {
          return new Promise(function (resolve) {
            setTimeout(resolve, pause);
          });
        }
        function speak(phrase, utterances) {
          var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en-US";
          var synth = window.speechSynthesis;
          return new Promise(function (resolve, reject) {
            var utterance = new SpeechSynthesisUtterance(phrase);
            utterance.lang = lang;
            utterance.onend = function () {
              resolve();
            };
            utterance.onerror = function (e) {
              reject(e);
            };
            utterances.push(utterance);
            synth.speak(utterance);
          });
        }
        function speakSeries(series, lang) {
          var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          var synth = window.speechSynthesis;
          var remainingPhrases = flattenStrings(Array.isArray(series) ? series : [series]);
          var nestedSeriesResults = [];
          var utterances = [];
          var active = true;
          var seriesChain = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
            var phrase, pause, totalRetries, retriesLeft, seriesResult, _seriesResult;
            return _regeneratorRuntime().wrap(function _callee19$(_context20) {
              while (1) switch (_context20.prev = _context20.next) {
                case 0:
                  _context20.prev = 0;
                case 1:
                  if (!(active && remainingPhrases.length)) {
                    _context20.next = 62;
                    break;
                  }
                  _context20.next = 4;
                  return Promise.resolve(remainingPhrases.shift());
                case 4:
                  phrase = _context20.sent;
                  if (active) {
                    _context20.next = 9;
                    break;
                  }
                  return _context20.abrupt("break", 62);
                case 9:
                  if (!(typeof phrase === "string" && phrase.includes("PAUSE-"))) {
                    _context20.next = 16;
                    break;
                  }
                  pause = Number(phrase.split("PAUSE-")[1]) * 1e3;
                  if (isNaN(pause)) {
                    pause = 0;
                  }
                  _context20.next = 14;
                  return delay(pause);
                case 14:
                  _context20.next = 60;
                  break;
                case 16:
                  if (!(typeof phrase === "string" && phrase.length)) {
                    _context20.next = 48;
                    break;
                  }
                  totalRetries = 3;
                  retriesLeft = totalRetries;
                case 19:
                  if (!(active && retriesLeft > 0)) {
                    _context20.next = 46;
                    break;
                  }
                  _context20.prev = 20;
                  _context20.next = 23;
                  return speak(phrase, utterances, lang);
                case 23:
                  retriesLeft = 0;
                  _context20.next = 44;
                  break;
                case 26:
                  _context20.prev = 26;
                  _context20.t0 = _context20["catch"](20);
                  if (!(_context20.t0 instanceof SpeechSynthesisErrorEvent)) {
                    _context20.next = 43;
                    break;
                  }
                  if (!(_context20.t0.error === "network")) {
                    _context20.next = 36;
                    break;
                  }
                  retriesLeft--;
                  console.warn("Speech synthesis network error. Retries left: ".concat(retriesLeft));
                  _context20.next = 34;
                  return delay(500 * (totalRetries - retriesLeft));
                case 34:
                  _context20.next = 41;
                  break;
                case 36:
                  if (!(_context20.t0.error === "canceled" || _context20.t0.error === "interrupted")) {
                    _context20.next = 40;
                    break;
                  }
                  retriesLeft = 0;
                  _context20.next = 41;
                  break;
                case 40:
                  throw new Error("SpeechSynthesisErrorEvent: ".concat(_context20.t0.error));
                case 41:
                  _context20.next = 44;
                  break;
                case 43:
                  throw _context20.t0;
                case 44:
                  _context20.next = 19;
                  break;
                case 46:
                  _context20.next = 60;
                  break;
                case 48:
                  if (!(typeof phrase === "function")) {
                    _context20.next = 55;
                    break;
                  }
                  seriesResult = speakSeries(phrase(), lang, false);
                  nestedSeriesResults.push(seriesResult);
                  _context20.next = 53;
                  return seriesResult.series;
                case 53:
                  _context20.next = 60;
                  break;
                case 55:
                  if (!Array.isArray(phrase)) {
                    _context20.next = 60;
                    break;
                  }
                  _seriesResult = speakSeries(phrase, lang, false);
                  nestedSeriesResults.push(_seriesResult);
                  _context20.next = 60;
                  return _seriesResult.series;
                case 60:
                  _context20.next = 1;
                  break;
                case 62:
                  _context20.prev = 62;
                  active = false;
                  return _context20.finish(62);
                case 65:
                case "end":
                  return _context20.stop();
              }
            }, _callee19, null, [[0,, 62, 65], [20, 26]]);
          }))();
          return {
            series: seriesChain,
            get active() {
              return active;
            },
            append: function append(toSpeak) {
              remainingPhrases.push(toSpeak);
            },
            cancel: function cancel() {
              if (!active) {
                return;
              }
              if (root) {
                synth.cancel();
              }
              nestedSeriesResults.forEach(function (nestedSeriesResults2) {
                nestedSeriesResults2.cancel();
              });
              active = false;
            }
          };
        }
        var currentSeries;
        function SpeechEngine(toSpeak) {
          var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
          currentSeries && currentSeries.cancel();
          currentSeries = speakSeries(toSpeak, lang);
          return currentSeries;
        }
        var voidFn = function voidFn() {
          return undefined;
        };
        var isServer = false;

        // src/index.ts
        var debounce = exports("p", function (callback, wait) {
          var timeoutId;
          var clear = function clear() {
            return clearTimeout(timeoutId);
          };
          if (getOwner()) onCleanup(clear);
          var debounced = function debounced() {
            for (var _len18 = arguments.length, args = new Array(_len18), _key41 = 0; _key41 < _len18; _key41++) {
              args[_key41] = arguments[_key41];
            }
            if (timeoutId !== undefined) clear();
            timeoutId = setTimeout(function () {
              return callback.apply(void 0, args);
            }, wait);
          };
          return Object.assign(debounced, {
            clear: clear
          });
        });
        var resetFocusPathTimer;
        var prevFocusPath = [];
        var currentlySpeaking;
        var voiceOutDisabled = false;
        var fiveMinutes = 3e5;
        function debounceWithFlush(callback, time) {
          var trigger = debounce(callback, time);
          var scopedValue;
          var debounced = function debounced(newValue) {
            scopedValue = newValue;
            trigger(newValue);
          };
          debounced.flush = function () {
            trigger.clear();
            callback(scopedValue);
          };
          debounced.clear = trigger.clear;
          return debounced;
        }
        function getElmName(elm) {
          return elm.id || elm.name;
        }
        function onFocusChangeCore() {
          var focusPath2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          if (!Announcer.onFocusChange || !Announcer.enabled) {
            return;
          }
          var loaded = focusPath2.every(function (elm) {
            return !elm.loading;
          });
          var focusDiff = focusPath2.filter(function (elm) {
            return !prevFocusPath.includes(elm);
          });
          resetFocusPathTimer();
          if (!loaded && Announcer.onFocusChange) {
            Announcer.onFocusChange([]);
            return;
          }
          prevFocusPath = focusPath2.slice(0);
          var toAnnounceText = [];
          var toAnnounce = focusDiff.reduce(function (acc, elm) {
            if (elm.announce) {
              acc.push([getElmName(elm), "Announce", elm.announce]);
              toAnnounceText.push(elm.announce);
            } else if (elm.title) {
              acc.push([getElmName(elm), "Title", elm.title]);
              toAnnounceText.push(elm.title);
            } else {
              acc.push([getElmName(elm), "No Announce", ""]);
            }
            return acc;
          }, []);
          focusDiff.reverse().reduce(function (acc, elm) {
            if (elm.announceContext) {
              acc.push([getElmName(elm), "Context", elm.announceContext]);
              toAnnounceText.push(elm.announceContext);
            } else {
              acc.push([getElmName(elm), "No Context", ""]);
            }
            return acc;
          }, toAnnounce);
          if (Announcer.debug) {
            console.table(toAnnounce);
          }
          if (toAnnounceText.length) {
            return Announcer.speak(toAnnounceText.reduce(function (acc, val) {
              return acc.concat(val);
            }, []));
          }
        }
        function textToSpeech(toSpeak, lang) {
          if (voiceOutDisabled) {
            return;
          }
          return currentlySpeaking = SpeechEngine(toSpeak, lang);
        }
        var Announcer = {
          debug: false,
          enabled: true,
          lang: "en-US",
          cancel: function cancel() {
            currentlySpeaking && currentlySpeaking.cancel();
          },
          clearPrevFocus: function clearPrevFocus() {
            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            prevFocusPath = prevFocusPath.slice(0, depth);
            resetFocusPathTimer();
          },
          speak: function speak(text) {
            var _ref39 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref39$append = _ref39.append,
              append = _ref39$append === void 0 ? false : _ref39$append,
              _ref39$notification = _ref39.notification,
              notification = _ref39$notification === void 0 ? false : _ref39$notification;
            if (Announcer.onFocusChange && Announcer.enabled) {
              Announcer.onFocusChange.flush();
              if (append && currentlySpeaking && currentlySpeaking.active) {
                currentlySpeaking.append(text);
              } else {
                Announcer.cancel();
                textToSpeech(text, Announcer.lang);
              }
              if (notification) {
                var _currentlySpeaking;
                voiceOutDisabled = true;
                (_currentlySpeaking = currentlySpeaking) === null || _currentlySpeaking === void 0 || _currentlySpeaking.series.finally(function () {
                  voiceOutDisabled = false;
                  Announcer.refresh();
                }).catch(console.error);
              }
            }
            return currentlySpeaking;
          },
          refresh: function refresh() {
            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            Announcer.clearPrevFocus(depth);
            Announcer.onFocusChange && Announcer.onFocusChange(untrack(function () {
              return focusPath();
            }));
          },
          setupTimers: function setupTimers() {
            var _ref40 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref40$focusDebounce = _ref40.focusDebounce,
              focusDebounce = _ref40$focusDebounce === void 0 ? 400 : _ref40$focusDebounce,
              _ref40$focusChangeTim = _ref40.focusChangeTimeout,
              focusChangeTimeout = _ref40$focusChangeTim === void 0 ? fiveMinutes : _ref40$focusChangeTim;
            Announcer.onFocusChange = debounceWithFlush(onFocusChangeCore, focusDebounce);
            resetFocusPathTimer = debounceWithFlush(function () {
              prevFocusPath = [];
            }, focusChangeTimeout);
          }
        };
        var useAnnouncer = function useAnnouncer() {
          Announcer.setupTimers();
          createEffect(on(focusPath, Announcer.onFocusChange, {
            defer: true
          }));
          return Announcer;
        };
        function createBeforeLeave() {
          var listeners = new Set();
          function subscribe(listener) {
            listeners.add(listener);
            return function () {
              return listeners.delete(listener);
            };
          }
          var ignore = false;
          function confirm(to, options) {
            if (ignore) return !(ignore = false);
            var e = {
              to: to,
              options: options,
              defaultPrevented: false,
              preventDefault: function preventDefault() {
                return e.defaultPrevented = true;
              }
            };
            var _iterator21 = _createForOfIteratorHelper(listeners),
              _step21;
            try {
              var _loop13 = function _loop13() {
                var l = _step21.value;
                l.listener(_objectSpread(_objectSpread({}, e), {}, {
                  from: l.location,
                  retry: function retry(force) {
                    force && (ignore = true);
                    l.navigate(to, _objectSpread(_objectSpread({}, options), {}, {
                      resolve: false
                    }));
                  }
                }));
              };
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                _loop13();
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }
            return !e.defaultPrevented;
          }
          return {
            subscribe: subscribe,
            confirm: confirm
          };
        }
        // The following supports browser initiated blocking (eg back/forward)
        var depth;
        function saveCurrentDepth() {
          if (!window.history.state || window.history.state._depth == null) {
            window.history.replaceState(_objectSpread(_objectSpread({}, window.history.state), {}, {
              _depth: window.history.length - 1
            }), "");
          }
          depth = window.history.state._depth;
        }
        {
          saveCurrentDepth();
        }
        function keepDepth(state) {
          return _objectSpread(_objectSpread({}, state), {}, {
            _depth: window.history.state && window.history.state._depth
          });
        }
        function notifyIfNotBlocked(notify, block) {
          var ignore = false;
          return function () {
            var prevDepth = depth;
            saveCurrentDepth();
            var delta = prevDepth == null ? null : depth - prevDepth;
            if (ignore) {
              ignore = false;
              return;
            }
            if (delta && block(delta)) {
              ignore = true;
              window.history.go(-delta);
            } else {
              notify();
            }
          };
        }
        var hasSchemeRegex = /^(?:[a-z0-9]+:)?\/\//i;
        var trimPathRegex = /^\/+|(\/)\/+$/g;
        var mockBase = "http://sr";
        function normalizePath(path) {
          var omitSlash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var s = path.replace(trimPathRegex, "$1");
          return s ? omitSlash || /^[?#]/.test(s) ? s : "/" + s : "";
        }
        function _resolvePath(base, path, from) {
          if (hasSchemeRegex.test(path)) {
            return undefined;
          }
          var basePath = normalizePath(base);
          var fromPath = from && normalizePath(from);
          var result = "";
          if (!fromPath || path.startsWith("/")) {
            result = basePath;
          } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {
            result = basePath + fromPath;
          } else {
            result = fromPath;
          }
          return (result || "/") + normalizePath(path, !result);
        }
        function invariant(value, message) {
          if (value == null) {
            throw new Error(message);
          }
          return value;
        }
        function joinPaths(from, to) {
          return normalizePath(from).replace(/\/*(\*.*)?$/g, "") + normalizePath(to);
        }
        function extractSearchParams(url) {
          var params = {};
          url.searchParams.forEach(function (value, key) {
            if (key in params) {
              if (Array.isArray(params[key])) params[key].push(value);else params[key] = [params[key], value];
            } else params[key] = value;
          });
          return params;
        }
        function createMatcher(path, partial, matchFilters) {
          var _path$split = path.split("/*", 2),
            _path$split2 = _slicedToArray(_path$split, 2),
            pattern = _path$split2[0],
            splat = _path$split2[1];
          var segments = pattern.split("/").filter(Boolean);
          var len = segments.length;
          return function (location) {
            var locSegments = location.split("/").filter(Boolean);
            var lenDiff = locSegments.length - len;
            if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {
              return null;
            }
            var match = {
              path: len ? "" : "/",
              params: {}
            };
            var matchFilter = function matchFilter(s) {
              return matchFilters === undefined ? undefined : matchFilters[s];
            };
            for (var i = 0; i < len; i++) {
              var segment = segments[i];
              var dynamic = segment[0] === ":";
              var locSegment = dynamic ? locSegments[i] : locSegments[i].toLowerCase();
              var _key42 = dynamic ? segment.slice(1) : segment.toLowerCase();
              if (dynamic && matchSegment(locSegment, matchFilter(_key42))) {
                match.params[_key42] = locSegment;
              } else if (dynamic || !matchSegment(locSegment, _key42)) {
                return null;
              }
              match.path += "/".concat(locSegment);
            }
            if (splat) {
              var remainder = lenDiff ? locSegments.slice(-lenDiff).join("/") : "";
              if (matchSegment(remainder, matchFilter(splat))) {
                match.params[splat] = remainder;
              } else {
                return null;
              }
            }
            return match;
          };
        }
        function matchSegment(input, filter) {
          var isEqual = function isEqual(s) {
            return s === input;
          };
          if (filter === undefined) {
            return true;
          } else if (typeof filter === "string") {
            return isEqual(filter);
          } else if (typeof filter === "function") {
            return filter(input);
          } else if (Array.isArray(filter)) {
            return filter.some(isEqual);
          } else if (filter instanceof RegExp) {
            return filter.test(input);
          }
          return false;
        }
        function scoreRoute(route) {
          var _route$pattern$split = route.pattern.split("/*", 2),
            _route$pattern$split2 = _slicedToArray(_route$pattern$split, 2),
            pattern = _route$pattern$split2[0],
            splat = _route$pattern$split2[1];
          var segments = pattern.split("/").filter(Boolean);
          return segments.reduce(function (score, segment) {
            return score + (segment.startsWith(":") ? 2 : 3);
          }, segments.length - (splat === undefined ? 0 : 1));
        }
        function createMemoObject(fn) {
          var map = new Map();
          var owner = getOwner();
          return new Proxy({}, {
            get: function get(_, property) {
              if (!map.has(property)) {
                runWithOwner(owner, function () {
                  return map.set(property, createMemo(function () {
                    return fn()[property];
                  }));
                });
              }
              return map.get(property)();
            },
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
              return {
                enumerable: true,
                configurable: true
              };
            },
            ownKeys: function ownKeys() {
              return Reflect.ownKeys(fn());
            }
          });
        }
        function expandOptionals(pattern) {
          var match = /(\/?\:[^\/]+)\?/.exec(pattern);
          if (!match) return [pattern];
          var prefix = pattern.slice(0, match.index);
          var suffix = pattern.slice(match.index + match[0].length);
          var prefixes = [prefix, prefix += match[1]];
          // This section handles adjacent optional params. We don't actually want all permuations since
          // that will lead to equivalent routes which have the same number of params. For example
          // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can
          // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps
          // ensure predictability where earlier params have precidence.
          while (match = /^(\/\:[^\/]+)\?/.exec(suffix)) {
            prefixes.push(prefix += match[1]);
            suffix = suffix.slice(match[0].length);
          }
          return expandOptionals(suffix).reduce(function (results, expansion) {
            return [].concat(_toConsumableArray(results), _toConsumableArray(prefixes.map(function (p) {
              return p + expansion;
            })));
          }, []);
        }
        var MAX_REDIRECTS = 100;
        var RouterContextObj = createContext();
        var RouteContextObj = createContext();
        var useRouter = function useRouter() {
          return invariant(useContext(RouterContextObj), "<A> and 'use' router primitives can be only used inside a Route.");
        };
        /**
         * Retrieves method to do navigation. The method accepts a path to navigate to and an optional object with the following options:
         *
         * - resolve (*boolean*, default `true`): resolve the path against the current route
         * - replace (*boolean*, default `false`): replace the history entry
         * - scroll (*boolean*, default `true`): scroll to top after navigation
         * - state (*any*, default `undefined`): pass custom state to `location.state`
         *
         * **Note**: The state is serialized using the structured clone algorithm which does not support all object types.
         *
         * @example
         * ```js
         * const navigate = useNavigate();
         *
         * if (unauthorized) {
         *   navigate("/login", { replace: true });
         * }
         * ```
         */
        var useNavigate = exports("v", function () {
          return useRouter().navigatorFactory();
        });
        /**
         * Retrieves reactive `location` object useful for getting things like `pathname`.
         *
         * @example
         * ```js
         * const location = useLocation();
         *
         * const pathname = createMemo(() => parsePath(location.pathname));
         * ```
         */
        var useLocation = function useLocation() {
          return useRouter().location;
        };
        /**
         * usePreloadRoute returns a function that can be used to preload a route manual.
         * This is what happens automatically with link hovering and similar focus based behavior, but it is available here as an API.
         *
         * @example
         * ```js
         * const preload = usePreloadRoute();
         *
         * preload(`/users/settings`, { preloadData: true });
         * ```
         */
        var usePreloadRoute = function usePreloadRoute() {
          var pre = useRouter().preloadRoute;
          return function (url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return pre(url instanceof URL ? url : new URL(url, mockBase), options.preloadData);
          };
        };
        /**
         * `useMatch` takes an accessor that returns the path and creates a `Memo` that returns match information if the current path matches the provided path.
         * Useful for determining if a given path matches the current route.
         *
         * @example
         * ```js
         * const match = useMatch(() => props.href);
         *
         * return <div classList={{ active: Boolean(match()) }} />;
         * ```
         */
        var useMatch = function useMatch(path, matchFilters) {
          var location = useLocation();
          var matchers = createMemo(function () {
            return expandOptionals(path()).map(function (path) {
              return createMatcher(path, undefined, matchFilters);
            });
          });
          return createMemo(function () {
            var _iterator22 = _createForOfIteratorHelper(matchers()),
              _step22;
            try {
              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                var matcher = _step22.value;
                var match = matcher(location.pathname);
                if (match) return match;
              }
            } catch (err) {
              _iterator22.e(err);
            } finally {
              _iterator22.f();
            }
          });
        };
        /**
         * Retrieves a reactive, store-like object containing the current route path parameters as defined in the Route.
         *
         * @example
         * ```js
         * const params = useParams();
         *
         * // fetch user based on the id path parameter
         * const [user] = createResource(() => params.id, fetchUser);
         * ```
         */
        var useParams = exports("O", function () {
          return useRouter().params;
        });
        function createRoutes(routeDef) {
          var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var component = routeDef.component,
            preload = routeDef.preload,
            load = routeDef.load,
            children = routeDef.children,
            info = routeDef.info;
          var isLeaf = !children || Array.isArray(children) && !children.length;
          var shared = {
            key: routeDef,
            component: component,
            preload: preload || load,
            info: info
          };
          return asArray(routeDef.path).reduce(function (acc, originalPath) {
            var _iterator23 = _createForOfIteratorHelper(expandOptionals(originalPath)),
              _step23;
            try {
              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                var expandedPath = _step23.value;
                var path = joinPaths(base, expandedPath);
                var pattern = isLeaf ? path : path.split("/*", 1)[0];
                pattern = pattern.split("/").map(function (s) {
                  return s.startsWith(":") || s.startsWith("*") ? s : encodeURIComponent(s);
                }).join("/");
                acc.push(_objectSpread(_objectSpread({}, shared), {}, {
                  originalPath: originalPath,
                  pattern: pattern,
                  matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)
                }));
              }
            } catch (err) {
              _iterator23.e(err);
            } finally {
              _iterator23.f();
            }
            return acc;
          }, []);
        }
        function createBranch(routes) {
          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return {
            routes: routes,
            score: scoreRoute(routes[routes.length - 1]) * 10000 - index,
            matcher: function matcher(location) {
              var matches = [];
              for (var i = routes.length - 1; i >= 0; i--) {
                var route = routes[i];
                var match = route.matcher(location);
                if (!match) {
                  return null;
                }
                matches.unshift(_objectSpread(_objectSpread({}, match), {}, {
                  route: route
                }));
              }
              return matches;
            }
          };
        }
        function asArray(value) {
          return Array.isArray(value) ? value : [value];
        }
        function createBranches(routeDef) {
          var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var branches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var routeDefs = asArray(routeDef);
          for (var i = 0, len = routeDefs.length; i < len; i++) {
            var def = routeDefs[i];
            if (def && _typeof(def) === "object") {
              if (!def.hasOwnProperty("path")) def.path = "";
              var routes = createRoutes(def, base);
              var _iterator24 = _createForOfIteratorHelper(routes),
                _step24;
              try {
                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                  var route = _step24.value;
                  stack.push(route);
                  var isEmptyArray = Array.isArray(def.children) && def.children.length === 0;
                  if (def.children && !isEmptyArray) {
                    createBranches(def.children, route.pattern, stack, branches);
                  } else {
                    var branch = createBranch(_toConsumableArray(stack), branches.length);
                    branches.push(branch);
                  }
                  stack.pop();
                }
              } catch (err) {
                _iterator24.e(err);
              } finally {
                _iterator24.f();
              }
            }
          }
          // Stack will be empty on final return
          return stack.length ? branches : branches.sort(function (a, b) {
            return b.score - a.score;
          });
        }
        function getRouteMatches(branches, location) {
          for (var i = 0, len = branches.length; i < len; i++) {
            var match = branches[i].matcher(location);
            if (match) {
              return match;
            }
          }
          return [];
        }
        function createLocation(path, state, queryWrapper) {
          var origin = new URL(mockBase);
          var url = createMemo(function (prev) {
            var path_ = path();
            try {
              return new URL(path_, origin);
            } catch (err) {
              console.error("Invalid path ".concat(path_));
              return prev;
            }
          }, origin, {
            equals: function equals(a, b) {
              return a.href === b.href;
            }
          });
          var pathname = createMemo(function () {
            return url().pathname;
          });
          var search = createMemo(function () {
            return url().search;
          }, true);
          var hash = createMemo(function () {
            return url().hash;
          });
          var key = function key() {
            return "";
          };
          var queryFn = on(search, function () {
            return extractSearchParams(url());
          });
          return {
            get pathname() {
              return pathname();
            },
            get search() {
              return search();
            },
            get hash() {
              return hash();
            },
            get state() {
              return state();
            },
            get key() {
              return key();
            },
            query: queryWrapper ? queryWrapper(queryFn) : createMemoObject(queryFn)
          };
        }
        var intent;
        function getIntent() {
          return intent;
        }
        function setInPreloadFn(value) {}
        function createRouterContext(integration, branches, getContext) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var _integration$signal = _slicedToArray(integration.signal, 2),
            source = _integration$signal[0],
            setSource = _integration$signal[1],
            _integration$utils = integration.utils,
            utils = _integration$utils === void 0 ? {} : _integration$utils;
          var parsePath = utils.parsePath || function (p) {
            return p;
          };
          var renderPath = utils.renderPath || function (p) {
            return p;
          };
          var beforeLeave = utils.beforeLeave || createBeforeLeave();
          var basePath = _resolvePath("", options.base || "");
          if (basePath === undefined) {
            throw new Error("".concat(basePath, " is not a valid base path"));
          } else if (basePath && !source().value) {
            setSource({
              value: basePath,
              replace: true,
              scroll: false
            });
          }
          var _createSignal17 = createSignal(false),
            _createSignal18 = _slicedToArray(_createSignal17, 2),
            isRouting = _createSignal18[0],
            setIsRouting = _createSignal18[1];
          // Keep track of last target, so that last call to transition wins
          var lastTransitionTarget;
          // Transition the location to a new value
          var transition = function transition(newIntent, newTarget) {
            if (newTarget.value === reference() && newTarget.state === state()) return;
            if (lastTransitionTarget === undefined) setIsRouting(true);
            intent = newIntent;
            lastTransitionTarget = newTarget;
            startTransition(function () {
              if (lastTransitionTarget !== newTarget) return;
              setReference(lastTransitionTarget.value);
              setState(lastTransitionTarget.state);
              submissions[1](function (subs) {
                return subs.filter(function (s) {
                  return s.pending;
                });
              });
            }).finally(function () {
              if (lastTransitionTarget !== newTarget) return;
              // Batch, in order for isRouting and final source update to happen together
              batch(function () {
                intent = undefined;
                if (newIntent === "navigate") navigateEnd(lastTransitionTarget);
                setIsRouting(false);
                lastTransitionTarget = undefined;
              });
            });
          };
          var _createSignal19 = createSignal(source().value),
            _createSignal20 = _slicedToArray(_createSignal19, 2),
            reference = _createSignal20[0],
            setReference = _createSignal20[1];
          var _createSignal21 = createSignal(source().state),
            _createSignal22 = _slicedToArray(_createSignal21, 2),
            state = _createSignal22[0],
            setState = _createSignal22[1];
          var location = createLocation(reference, state, utils.queryWrapper);
          var referrers = [];
          var submissions = createSignal([]);
          var matches = createMemo(function () {
            if (typeof options.transformUrl === "function") {
              return getRouteMatches(branches(), options.transformUrl(location.pathname));
            }
            return getRouteMatches(branches(), location.pathname);
          });
          var buildParams = function buildParams() {
            var m = matches();
            var params = {};
            for (var i = 0; i < m.length; i++) {
              Object.assign(params, m[i].params);
            }
            return params;
          };
          var params = utils.paramsWrapper ? utils.paramsWrapper(buildParams, branches) : createMemoObject(buildParams);
          var baseRoute = {
            pattern: basePath,
            path: function path() {
              return basePath;
            },
            outlet: function outlet() {
              return null;
            },
            resolvePath: function resolvePath(to) {
              return _resolvePath(basePath, to);
            }
          };
          // Create a native transition, when source updates
          createRenderEffect(on(source, function (source) {
            return transition("native", source);
          }, {
            defer: true
          }));
          return {
            base: baseRoute,
            location: location,
            params: params,
            isRouting: isRouting,
            renderPath: renderPath,
            parsePath: parsePath,
            navigatorFactory: navigatorFactory,
            matches: matches,
            beforeLeave: beforeLeave,
            preloadRoute: preloadRoute,
            singleFlight: options.singleFlight === undefined ? true : options.singleFlight,
            submissions: submissions
          };
          function navigateFromRoute(route, to, options) {
            // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths
            untrack(function () {
              if (typeof to === "number") {
                if (!to) {
                  // A delta of 0 means stay at the current location, so it is ignored
                } else if (utils.go) {
                  utils.go(to);
                } else {
                  console.warn("Router integration does not support relative routing");
                }
                return;
              }
              var queryOnly = !to || to[0] === "?";
              var _replace$resolve$scro = _objectSpread({
                  replace: false,
                  resolve: !queryOnly,
                  scroll: true
                }, options),
                replace = _replace$resolve$scro.replace,
                resolve = _replace$resolve$scro.resolve,
                scroll = _replace$resolve$scro.scroll,
                nextState = _replace$resolve$scro.state;
              var resolvedTo = resolve ? route.resolvePath(to) : _resolvePath(queryOnly && location.pathname || "", to);
              if (resolvedTo === undefined) {
                throw new Error("Path '".concat(to, "' is not a routable path"));
              } else if (referrers.length >= MAX_REDIRECTS) {
                throw new Error("Too many redirects");
              }
              var current = reference();
              if (resolvedTo !== current || nextState !== state()) {
                if (isServer) ;else if (beforeLeave.confirm(resolvedTo, options)) {
                  referrers.push({
                    value: current,
                    replace: replace,
                    scroll: scroll,
                    state: state()
                  });
                  transition("navigate", {
                    value: resolvedTo,
                    state: nextState
                  });
                }
              }
            });
          }
          function navigatorFactory(route) {
            // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)
            route = route || useContext(RouteContextObj) || baseRoute;
            return function (to, options) {
              return navigateFromRoute(route, to, options);
            };
          }
          function navigateEnd(next) {
            var first = referrers[0];
            if (first) {
              setSource(_objectSpread(_objectSpread({}, next), {}, {
                replace: first.replace,
                scroll: first.scroll
              }));
              referrers.length = 0;
            }
          }
          function preloadRoute(url, preloadData) {
            var matches = getRouteMatches(branches(), url.pathname);
            var prevIntent = intent;
            intent = "preload";
            var _loop14 = function _loop14() {
              var _matches$match = matches[match],
                route = _matches$match.route,
                params = _matches$match.params;
              route.component && route.component.preload && route.component.preload();
              var preload = route.preload;
              preloadData && preload && runWithOwner(getContext(), function () {
                return preload({
                  params: params,
                  location: {
                    pathname: url.pathname,
                    search: url.search,
                    hash: url.hash,
                    query: extractSearchParams(url),
                    state: null,
                    key: ""
                  },
                  intent: "preload"
                });
              });
            };
            for (var match in matches) {
              _loop14();
            }
            intent = prevIntent;
          }
        }
        function createRouteContext(router, parent, _outlet, match) {
          var base = router.base,
            location = router.location,
            params = router.params;
          var _match$route = match().route,
            pattern = _match$route.pattern,
            component = _match$route.component,
            preload = _match$route.preload;
          var path = createMemo(function () {
            return match().path;
          });
          component && component.preload && component.preload();
          var data = preload ? preload({
            params: params,
            location: location,
            intent: intent || "initial"
          }) : undefined;
          var route = {
            parent: parent,
            pattern: pattern,
            path: path,
            outlet: function outlet() {
              return component ? createComponent$1(component, {
                params: params,
                location: location,
                data: data,
                get children() {
                  return _outlet();
                }
              }) : _outlet();
            },
            resolvePath: function resolvePath(to) {
              return _resolvePath(base.path(), to, path());
            }
          };
          return route;
        }
        var createRouterComponent = function createRouterComponent(router) {
          return function (props) {
            var base = props.base;
            var routeDefs = children(function () {
              return props.children;
            });
            var branches = createMemo(function () {
              return createBranches(routeDefs(), props.base || "");
            });
            var context;
            var routerState = createRouterContext(router, branches, function () {
              return context;
            }, {
              base: base,
              singleFlight: props.singleFlight,
              transformUrl: props.transformUrl
            });
            router.create && router.create(routerState);
            return createComponent(RouterContextObj.Provider, {
              value: routerState,
              get children() {
                return createComponent(Root, {
                  routerState: routerState,
                  get root() {
                    return props.root;
                  },
                  get preload() {
                    return props.rootPreload || props.rootLoad;
                  },
                  get children() {
                    return [memo(function () {
                      return (context = getOwner()) && null;
                    }), createComponent(Routes, {
                      routerState: routerState,
                      get branches() {
                        return branches();
                      }
                    })];
                  }
                });
              }
            });
          };
        };
        function Root(props) {
          var location = props.routerState.location;
          var params = props.routerState.params;
          var data = createMemo(function () {
            return props.preload && untrack(function () {
              setInPreloadFn(true);
              props.preload({
                params: params,
                location: location,
                intent: getIntent() || "initial"
              });
              setInPreloadFn(false);
            });
          });
          return createComponent(Show, {
            get when() {
              return props.root;
            },
            keyed: true,
            get fallback() {
              return props.children;
            },
            children: function children(Root2) {
              return createComponent(Root2, {
                params: params,
                location: location,
                get data() {
                  return data();
                },
                get children() {
                  return props.children;
                }
              });
            }
          });
        }
        function Routes(props) {
          var disposers = [];
          var root;
          var routeStates = createMemo(on(props.routerState.matches, function (nextMatches, prevMatches, prev) {
            var equal = prevMatches && nextMatches.length === prevMatches.length;
            var next = [];
            var _loop15 = function _loop15(i) {
              var prevMatch = prevMatches && prevMatches[i];
              var nextMatch = nextMatches[i];
              if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {
                next[i] = prev[i];
              } else {
                equal = false;
                if (disposers[i]) {
                  disposers[i]();
                }
                createRoot(function (dispose) {
                  disposers[i] = dispose;
                  next[i] = createRouteContext(props.routerState, next[i - 1] || props.routerState.base, createOutlet(function () {
                    return routeStates()[i + 1];
                  }), function () {
                    return props.routerState.matches()[i];
                  });
                });
              }
            };
            for (var i = 0, len = nextMatches.length; i < len; i++) {
              _loop15(i);
            }
            disposers.splice(nextMatches.length).forEach(function (dispose) {
              return dispose();
            });
            if (prev && equal) {
              return prev;
            }
            root = next[0];
            return next;
          }));
          return createOutlet(function () {
            return routeStates() && root;
          })();
        }
        var createOutlet = function createOutlet(child) {
          return function () {
            return createComponent(Show, {
              get when() {
                return child();
              },
              keyed: true,
              children: function children(child2) {
                return createComponent(RouteContextObj.Provider, {
                  value: child2,
                  get children() {
                    return child2.outlet();
                  }
                });
              }
            });
          };
        };
        var Route = function Route(props) {
          var childRoutes = children(function () {
            return props.children;
          });
          return mergeProps$1(props, {
            get children() {
              return childRoutes();
            }
          });
        };
        function intercept(_ref41, get, set) {
          var _ref42 = _slicedToArray(_ref41, 2),
            value = _ref42[0],
            setValue = _ref42[1];
          return [value, function (v) {
            return setValue(set(v));
          }];
        }
        function createRouter(config) {
          var ignore = false;
          var wrap = function wrap(value) {
            return typeof value === "string" ? {
              value: value
            } : value;
          };
          var signal = intercept(createSignal(wrap(config.get()), {
            equals: function equals(a, b) {
              return a.value === b.value && a.state === b.state;
            }
          }), undefined, function (next) {
            !ignore && config.set(next);
            if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = true;
            return next;
          });
          config.init && onCleanup(config.init(function () {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get();
            ignore = true;
            signal[1](wrap(value));
            ignore = false;
          }));
          return createRouterComponent({
            signal: signal,
            create: config.create,
            utils: config.utils
          });
        }
        function hashParser(str) {
          var to = str.replace(/^.*?#/, "");
          if (!to.startsWith("/")) {
            var _window$location$hash = window.location.hash.split("#", 2),
              _window$location$hash2 = _slicedToArray(_window$location$hash, 2),
              _window$location$hash3 = _window$location$hash2[1],
              path = _window$location$hash3 === void 0 ? "/" : _window$location$hash3;
            return "".concat(path, "#").concat(to);
          }
          return to;
        }
        function bindEvent(target, type, handler) {
          target.addEventListener(type, handler);
          return function () {
            return target.removeEventListener(type, handler);
          };
        }
        function HashRouter(props) {
          var getSource = function getSource() {
            return window.location.hash.slice(1);
          };
          var beforeLeave = createBeforeLeave();
          return createRouter({
            get: getSource,
            set: function set(_ref43) {
              var value = _ref43.value,
                replace = _ref43.replace,
                state = _ref43.state;
              if (replace) {
                window.history.replaceState(keepDepth(state), "", "#" + value);
              } else {
                window.history.pushState(state, "", "#" + value);
              }
              saveCurrentDepth();
            },
            init: function init(notify) {
              return bindEvent(window, "hashchange", notifyIfNotBlocked(notify, function (delta) {
                return !beforeLeave.confirm(delta && delta < 0 ? delta : getSource());
              }));
            },
            utils: {
              go: function go(delta) {
                return window.history.go(delta);
              },
              renderPath: function renderPath(path) {
                return "#".concat(path);
              },
              parsePath: hashParser,
              beforeLeave: beforeLeave,
              queryWrapper: props.forceProxy || !SUPPORTS_PROXY ? function (getQuery) {
                return createMemoWithoutProxy(getQuery, props.queryParams);
              } : undefined,
              paramsWrapper: props.forceProxy || !SUPPORTS_PROXY ? function (buildParams, branches) {
                return createMemoWithoutProxy(buildParams, collectDynamicParams(branches()));
              } : undefined
            }
          })(props);
        }
        var SUPPORTS_PROXY = typeof Proxy === "function";
        function createMemoWithoutProxy(fn, allKeys) {
          var map = /* @__PURE__ */new Map();
          var owner = getOwner();
          var target = {};
          var handler = function handler(property) {
            if (!map.has(property)) {
              runWithOwner(owner, function () {
                return map.set(property, createMemo(function () {
                  return fn()[property];
                }));
              });
            }
            return map.get(property)();
          };
          var keys = allKeys ? allKeys : Object.keys(fn());
          keys.forEach(function (key) {
            Object.defineProperty(target, key, {
              get: function get() {
                return handler(key);
              },
              enumerable: true,
              configurable: true
            });
          });
          return target;
        }
        var collectDynamicParams = function collectDynamicParams(branches) {
          var dynamicParams = [];
          branches.forEach(function (branch) {
            branch.routes.forEach(function (route) {
              if (route.pattern) {
                var matches = route.pattern.match(/:(\w+)/g);
                if (matches) {
                  matches.forEach(function (param) {
                    var p = param.slice(1);
                    if (!dynamicParams.includes(p)) dynamicParams.push(p);
                  });
                }
              }
            });
          });
          return dynamicParams;
        };
        function onGridFocus(onSelectedChanged) {
          return function () {
            if (!this || this.children.length === 0) return false;
            this.selected = this.selected || 0;
            var child = this.selected ? this.children[this.selected] : this.selectedNode;
            while ((_child = child) !== null && _child !== void 0 && _child.skipFocus) {
              var _child;
              this.selected++;
              child = this.children[this.selected];
            }
            if (!(child instanceof ElementNode)) return false;
            child.setFocus();
            if (onSelectedChanged) {
              var grid = this;
              onSelectedChanged.call(grid, grid.selected, grid, child);
            }
            return true;
          };
        }
        function handleNavigation(direction) {
          return function () {
            var numChildren = this.children.length;
            var wrap = this.wrap;
            var lastSelected = this.selected || 0;
            if (numChildren === 0) {
              return false;
            }
            if (direction === "right" || direction === "down") {
              do {
                var _this$children$this$s;
                this.selected = (this.selected || 0) % numChildren + 1;
                if (this.selected >= numChildren) {
                  if (!wrap) {
                    this.selected = -1;
                    break;
                  }
                  this.selected = 0;
                }
              } while ((_this$children$this$s = this.children[this.selected]) !== null && _this$children$this$s !== void 0 && _this$children$this$s.skipFocus);
            } else if (direction === "left" || direction === "up") {
              do {
                var _this$children$this$s2;
                this.selected = (this.selected || 0) % numChildren - 1;
                if (this.selected < 0) {
                  if (!wrap) {
                    this.selected = -1;
                    break;
                  }
                  this.selected = numChildren - 1;
                }
              } while ((_this$children$this$s2 = this.children[this.selected]) !== null && _this$children$this$s2 !== void 0 && _this$children$this$s2.skipFocus);
            }
            if (this.selected === -1) {
              var _this$children$this$s3;
              this.selected = lastSelected;
              if ((_this$children$this$s3 = this.children[this.selected]) !== null && _this$children$this$s3 !== void 0 && _this$children$this$s3.states.has(Config.focusStateKey || "$focus")) {
                return false;
              }
            }
            var active = this.children[this.selected || 0];
            var navigableThis = this;
            navigableThis.onSelectedChanged && navigableThis.onSelectedChanged.call(navigableThis, navigableThis.selected, navigableThis, active, lastSelected);
            if (this.plinko) {
              var lastSelectedChild = this.children[lastSelected];
              var num = lastSelectedChild.selected || 0;
              active.selected = num < active.children.length ? num : active.children.length - 1;
            }
            active.setFocus();
            return true;
          };
        }
        var InViewPort = 8;
        var isNotShown = function isNotShown(node) {
          return node.lng.renderState !== InViewPort;
        };
        function withScrolling(isRow) {
          var dimension = isRow ? "width" : "height";
          var axis = isRow ? "x" : "y";
          return function (selected, component, selectedElement, lastSelected) {
            var _componentRef$_target, _componentRef$offset2, _selectedElement$axis, _selectedElement$dime, _ref44, _selectedElement$scal, _selectedElement$styl, _componentRef$dimensi;
            var componentRef = component;
            if (typeof selected !== "number") {
              componentRef = selected;
              selected = componentRef.selected || 0;
            }
            if (!componentRef || componentRef.scroll === "none" || !componentRef.children.length) return;
            var lng = componentRef.lng;
            var screenSize = isRow ? lng.stage.root.width : lng.stage.root.height;
            var isIncrementing = lastSelected === undefined || lastSelected - 1 !== selected;
            if (componentRef._screenOffset === undefined) {
              var _componentRef$offset;
              if (componentRef.parent.clipping) {
                var p = componentRef.parent;
                componentRef.endOffset = screenSize - ((isRow ? p.absX : p.absY) || 0) - p[dimension];
              }
              componentRef._screenOffset = (_componentRef$offset = componentRef.offset) !== null && _componentRef$offset !== void 0 ? _componentRef$offset : (isRow ? lng.absX : lng.absY) - componentRef[axis];
            }
            var screenOffset = componentRef._screenOffset;
            var gap = componentRef.gap || 0;
            var scroll = componentRef.scroll || "auto";
            var targetPosition = (_componentRef$_target = componentRef._targetPosition) !== null && _componentRef$_target !== void 0 ? _componentRef$_target : componentRef[axis];
            var rootPosition = isIncrementing ? Math.min(targetPosition, componentRef[axis]) : Math.max(targetPosition, componentRef[axis]);
            componentRef.offset = (_componentRef$offset2 = componentRef.offset) !== null && _componentRef$offset2 !== void 0 ? _componentRef$offset2 : rootPosition;
            var offset = componentRef.offset;
            selectedElement = selectedElement || componentRef.children[selected];
            if (!selectedElement) {
              return;
            }
            var selectedPosition = (_selectedElement$axis = selectedElement[axis]) !== null && _selectedElement$axis !== void 0 ? _selectedElement$axis : 0;
            var selectedSize = (_selectedElement$dime = selectedElement[dimension]) !== null && _selectedElement$dime !== void 0 ? _selectedElement$dime : 0;
            var selectedScale = (_ref44 = (_selectedElement$scal = selectedElement.scale) !== null && _selectedElement$scal !== void 0 ? _selectedElement$scal : (_selectedElement$styl = selectedElement.style) === null || _selectedElement$styl === void 0 || (_selectedElement$styl = _selectedElement$styl.focus) === null || _selectedElement$styl === void 0 ? void 0 : _selectedElement$styl.scale) !== null && _ref44 !== void 0 ? _ref44 : 1;
            var selectedSizeScaled = selectedSize * selectedScale;
            var containerSize = (_componentRef$dimensi = componentRef[dimension]) !== null && _componentRef$dimensi !== void 0 ? _componentRef$dimensi : 0;
            var maxOffset = Math.min(screenSize - containerSize - screenOffset - (componentRef.endOffset || 2 * gap), offset);
            var nextIndex = isIncrementing ? selected + 1 : selected - 1;
            var nextElement = componentRef.children[nextIndex] || null;
            var nextPosition = rootPosition;
            if (selectedElement.centerScroll) {
              nextPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2;
            } else if (scroll === "always") {
              nextPosition = -selectedPosition + offset;
            } else if (scroll === "center") {
              var centerPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2 - screenOffset;
              nextPosition = Math.min(Math.max(centerPosition, maxOffset), offset);
            } else if (!nextElement) {
              nextPosition = isIncrementing ? maxOffset : offset;
            } else if (scroll === "auto") {
              if (componentRef.scrollIndex && componentRef.scrollIndex > 0) {
                var totalItems = componentRef.children.length;
                var nearEndIndex = totalItems - componentRef.scrollIndex;
                if (isIncrementing && componentRef.selected >= componentRef.scrollIndex) {
                  nextPosition = rootPosition - selectedSize - gap;
                } else if (!isIncrementing && componentRef.selected < nearEndIndex) {
                  nextPosition = rootPosition + selectedSize + gap;
                }
              } else if (isIncrementing) {
                nextPosition = -selectedPosition + offset;
              } else {
                nextPosition = rootPosition + selectedSize + gap;
              }
            } else if (isIncrementing && isNotShown(nextElement)) {
              nextPosition = rootPosition - selectedSize - gap;
            } else if (isNotShown(nextElement)) {
              nextPosition = -selectedPosition + offset;
            }
            nextPosition = isIncrementing && scroll !== "always" ? Math.max(nextPosition, maxOffset) : Math.min(nextPosition, offset);
            if (componentRef[axis] !== nextPosition) {
              componentRef[axis] = nextPosition;
              componentRef._targetPosition = nextPosition;
            }
          };
        }
        function chainFunctions() {
          for (var _len19 = arguments.length, args = new Array(_len19), _key43 = 0; _key43 < _len19; _key43++) {
            args[_key43] = arguments[_key43];
          }
          var onlyFunctions = args.filter(function (func) {
            return typeof func === "function";
          });
          if (onlyFunctions.length === 0) {
            return undefined;
          }
          if (onlyFunctions.length === 1) {
            return onlyFunctions[0];
          }
          return function () {
            var result;
            for (var _len20 = arguments.length, innerArgs = new Array(_len20), _key44 = 0; _key44 < _len20; _key44++) {
              innerArgs[_key44] = arguments[_key44];
            }
            var _iterator25 = _createForOfIteratorHelper(onlyFunctions),
              _step25;
            try {
              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                var func = _step25.value;
                result = func.apply(this, innerArgs);
                if (result === true) {
                  return result;
                }
              }
            } catch (err) {
              _iterator25.e(err);
            } finally {
              _iterator25.f();
            }
            return result;
          };
        }
        var ColumnStyles = {
          display: "flex",
          flexDirection: "column",
          gap: 30,
          transition: {
            y: {
              duration: 250,
              easing: "ease-in-out"
            }
          }
        };
        var onUp = handleNavigation("up");
        var onDown = handleNavigation("down");
        var scroll$1 = withScrolling(false);
        function scrollToIndex$1(index) {
          this.selected = index;
          scroll$1(index, this);
          this.setFocus();
        }
        var Column = exports("C", function (props) {
          return createComponent(View, mergeProps(props, {
            onUp: chainFunctions(props.onUp, onUp),
            onDown: chainFunctions(props.onDown, onDown),
            get selected() {
              return props.selected || 0;
            },
            scrollToIndex: scrollToIndex$1,
            get forwardFocus() {
              return /* once */onGridFocus(props.onSelectedChanged);
            },
            onLayout: props.selected ? chainFunctions(props.onLayout, scroll$1) : props.onLayout,
            onSelectedChanged: chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scroll$1 : undefined),
            style: combineStyles(props.style, ColumnStyles)
          }));
        });
        var RowStyles = {
          display: "flex",
          gap: 30,
          transition: {
            x: {
              duration: 250,
              easing: "ease-in-out"
            }
          }
        };
        var onLeft = handleNavigation("left");
        var onRight = handleNavigation("right");
        var scroll = withScrolling(true);
        function scrollToIndex(index) {
          this.selected = index;
          scroll(index, this);
          this.setFocus();
        }
        var Row = exports("R", function (props) {
          return createComponent(View, mergeProps(props, {
            get selected() {
              return props.selected || 0;
            },
            onLeft: chainFunctions(props.onLeft, onLeft),
            onRight: chainFunctions(props.onRight, onRight),
            get forwardFocus() {
              return /* once */onGridFocus(props.onSelectedChanged);
            },
            scrollToIndex: scrollToIndex,
            onLayout: props.selected ? chainFunctions(props.onLayout, scroll) : props.onLayout,
            onSelectedChanged: chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scroll : undefined),
            style: combineStyles(props.style, RowStyles)
          }));
        });
        function createSpriteMap(src, subTextures) {
          var spriteMapTexture = renderer$2.createTexture("ImageTexture", {
            src: src
          });
          return subTextures.reduce(function (acc, t) {
            var x = t.x,
              y = t.y,
              width = t.width,
              height = t.height;
            acc[t.name] = renderer$2.createTexture("SubTexture", {
              texture: spriteMapTexture,
              x: x,
              y: y,
              width: width,
              height: height
            });
            return acc;
          }, {});
        }
        var _createSignal23 = createSignal(""),
          _createSignal24 = _slicedToArray(_createSignal23, 2),
          globalBackground = _createSignal24[0],
          setGlobalBackground = _createSignal24[1];
        exports("s", setGlobalBackground);
        var theme = exports("t", {
          name: 'Base Lightning TV',
          alpha: {
            primary: 1,
            secondary: 0.7,
            tertiary: 0.1,
            inactive: 0.5,
            full: 1,
            none: 0,
            alpha1: 0.1,
            alpha2: 0.3,
            alpha3: 0.5,
            alpha4: 0.7,
            alpha5: 0.9,
            alpha6: 0.95
          },
          animation: {
            duration: {
              none: 0,
              xfast: 100,
              fast: 250,
              normal: 500,
              slow: 750,
              xslow: 900
            },
            delay: {
              none: 0,
              xfast: 10,
              fast: 25,
              normal: 50,
              slow: 75,
              xslow: 90
            },
            expressive: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            expressiveEntrance: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            expressiveExit: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            standard: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            standardEntrance: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            standardExit: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            utility: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            utilityEntrance: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            },
            utilityExit: {
              timingFunction: 'cubic-bezier(0, 0, 1, 1)',
              delay: 0,
              duration: 0.25
            }
          },
          asset: {
            arrowLeft: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAi0lEQVRIDWNgGAWjIfD//38JID5Fk5AAGqwKxPeA+D/VLQCaaQLEr0CGgwBVLQCa5wbEn0EGwwDVLAAaGA3Ev2AGw2iqWAA0rBiI/8EMRaYptgBoWDeygehsci1gIlcjWfqArqZdEMFcBLSEdpGMZAntkimSJbTLaEiW0K6oQLKEdoUdzJJRemiHAAD4n+yzPWCs7QAAAABJRU5ErkJggg==',
            arrowRight: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAGKADAAQAAAABAAAAGAAAAADiNXWtAAAAg0lEQVRIDWNgGAWjIYArBP7//38KiCVwyVMsDjQcBO4BsSrFhmEzAGw8hHgFpEywqaFIDMkCEPMzELtRZCC6ZjQLQNxfQByNro5sPhYLQEL/gLiYbEORNeKwACbcDVPLBGMMOhrmVDSapkFE00imaTKlaUajaVFB28Ju0CXrUQfhDAEAEgHss6NhpLQAAAAASUVORK5CYII=',
            backspaceOutline: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC',
            check: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAOCAYAAAAi2ky3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACtSURBVHgBvdPdDcIgEAfwoy8Nb45QN3AGF2s36Ahu4gpuIDoBfSgfpdoTlCbEWEMh6T8hFzjyg5AAkBHOcQe5UWqspRx435sDpMYj6IYQwwVSEiJ2MKVUBWuzLSLl2HL+uxmNCGFO8yaL7RHxve6qRZoAuS4hxac8735elWVx7jrtMKL1o0Gcat9jhExHSukN/kUIFZ7MpDRtzE1isDRkAUtDvrA8ZI597FUf8gWH9P0b4gko9wAAAABJRU5ErkJggg=='
          },
          color: {
            palette: {},
            white: '0xffffffff',
            black: '0x000000ff',
            grey: '0x929096ff',
            red: '0xe74c3cff',
            orange: '0xdc7633ff',
            yellow: '0xf7dc6fff',
            green: '0x2ecc71ff',
            blue: '0x93a9fdff',
            purple: '0x663399ff',
            overlay: '0x181819b3',
            material: '0x181819ff',
            materialNeutral: '0x181819ff',
            materialNeutralElevated: '0x373639ff',
            materialInverse: '0xf8f7faff',
            materialInverseElevated: '0xffffffff',
            materialBrand: '0x000033ff',
            materialBrandElevated: '0x242a65ff',
            textNeutral: '0xf8f7faff',
            textNeutralSecondary: '0xf8f7fab3',
            textNeutralTertiary: '0xf8f7fa1a',
            textNeutralDisabled: '0xf8f7fa80',
            textInverse: '0x181819ff',
            textInverseSecondary: '0x181819b3',
            textInverseTertiary: '0x1818191a',
            textInverseDisabled: '0x18181980',
            textBrand: '0x93a9fdff',
            textBrandSecondary: '0x93a9fdb3',
            textBrandTertiary: '0x93a9fd1a',
            textBrandDisabled: '0x93a9fd80',
            textPositive: '0x2ecc71ff',
            textNegative: '0xe74c3cff',
            textInfo: '0x93a9fdff',
            textCaution: '0xdc7633ff',
            fillTransparent: '0xffffff0',
            fillNeutral: '0xf8f7faff',
            fillNeutralSecondary: '0xf8f7fab3',
            fillNeutralTertiary: '0xf8f7fa1a',
            fillNeutralDisabled: '0xf8f7fa80',
            fillInverse: '0x181819ff',
            fillInverseSecondary: '0x181819b3',
            fillInverseTertiary: '0x1818191a',
            fillInverseDisabled: '0x18181980',
            fillBrand: '0x93a9fdff',
            fillBrandSecondary: '0x93a9fdb3',
            fillBrandTertiary: '0x93a9fd1a',
            fillBrandDisabled: '0x93a9fd80',
            fillPositive: '0x2ecc71ff',
            fillNegative: '0xe74c3cff',
            fillInfo: '0x93a9fdff',
            fillCaution: '0xdc7633ff',
            strokeNeutral: '0xf8f7faff',
            strokeNeutralSecondary: '0xf8f7fab3',
            strokeNeutralTertiary: '0xf8f7fa1a',
            strokeNeutralDisabled: '0xf8f7fa80',
            strokeInverse: '0x181819ff',
            strokeInverseSecondary: '0x181819b3',
            strokeInverseTertiary: '0x1818191a',
            strokeInverseDisabled: '0x18181980',
            strokeBrand: '0x93a9fdff',
            strokeBrandSecondary: '0x93a9fdb3',
            strokeBrandTertiary: '0x93a9fd1a',
            strokeBrandDisabled: '0x93a9fd80',
            strokePositive: '0x2ecc71ff',
            strokeNegative: '0xe74c3cff',
            strokeInfo: '0x93a9fdff',
            strokeCaution: '0xdc7633ff',
            interactiveNeutral: '0xffffff1a',
            interactiveNeutralFocus: '0xffffffff',
            interactiveNeutralFocusSoft: '0xffffff1a',
            interactiveInverse: '0x48474b1a',
            interactiveInverseFocus: '0x48474bff',
            interactiveInverseFocusSoft: '0x48474b1a',
            interactiveBrand: '0xbecffe1a',
            interactiveBrandFocus: '0xbecffeff',
            interactiveBrandFocusSoft: '0xbecffe1a',
            shadowNeutral: '0x000000b3',
            shadowNeutralFocus: '0x000000b3',
            shadowNeutralFocusSoft: '0x000000b3',
            shadowNeutralText: '0x000000ff',
            shadowInverse: '0x000000b3',
            shadowInverseFocus: '0x000000b3',
            shadowInverseFocusSoft: '0x000000b3',
            shadowInverseText: '0x000000ff',
            shadowBrand: '0x000000b3',
            shadowBrandFocus: '0x000000b3',
            shadowBrandFocusSoft: '0x000000b3',
            shadowBrandText: '0x000000ff'
          },
          font: [],
          layout: {
            columnCount: 10,
            focusScale: 1.2,
            gutterX: 20,
            gutterY: 20,
            marginX: 150,
            marginY: 150,
            safe: 50,
            screenW: 1920,
            screenH: 1080
          },
          radius: {
            none: 0,
            xs: 2,
            sm: 4,
            md: 8,
            lg: 16,
            xl: 24
          },
          spacer: {
            none: 0,
            xxs: 2,
            xs: 4,
            sm: 8,
            md: 10,
            lg: 20,
            xl: 30,
            xxl: 40,
            xxxl: 50
          },
          stroke: {
            none: 0,
            sm: 2,
            md: 4,
            lg: 6,
            xl: 8
          },
          typography: {
            display1: {
              fontFamily: 'Arial',
              fontSize: 75,
              lineHeight: 85,
              fontWeight: 500,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            display2: {
              fontFamily: 'Arial',
              fontSize: 50,
              lineHeight: 60,
              fontWeight: 500,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            display3: {
              fontFamily: 'Arial',
              fontSize: 56,
              fontWeight: 400,
              lineHeight: 68,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            display4: {
              fontFamily: 'Arial',
              fontSize: 48,
              fontWeight: 400,
              lineHeight: 64,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            headline1: {
              fontFamily: 'Arial',
              fontSize: 35,
              fontWeight: 500,
              lineHeight: 48,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            headline2: {
              fontFamily: 'Arial',
              fontSize: 30,
              fontWeight: 500,
              lineHeight: 40,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            headline3: {
              fontFamily: 'Arial',
              fontSize: 25,
              fontWeight: 500,
              lineHeight: 36,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            body1: {
              fontFamily: 'Arial',
              fontSize: 25,
              fontWeight: 300,
              lineHeight: 40,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            body2: {
              fontFamily: 'Arial',
              fontSize: 22,
              fontWeight: 300,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            body3: {
              fontFamily: 'Arial',
              fontSize: 20,
              fontWeight: 300,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            button1: {
              fontFamily: 'Arial',
              fontSize: 25,
              fontWeight: 500,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            button2: {
              fontFamily: 'Arial',
              fontSize: 20,
              fontWeight: 500,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            callout1: {
              fontFamily: 'Arial',
              fontSize: 20,
              fontWeight: 500,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            caption1: {
              fontFamily: 'Arial',
              fontSize: 15,
              fontWeight: 500,
              lineHeight: 24,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            tag1: {
              fontFamily: 'Arial',
              fontSize: 20,
              fontWeight: 500,
              lineHeight: 24,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            footnote1: {
              fontFamily: 'Arial',
              fontSize: 22,
              fontWeight: 300,
              lineHeight: 30,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            subtitle1: {
              fontFamily: 'Arial',
              fontSize: 32,
              fontWeight: 400,
              lineHeight: 36,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            subtitle2: {
              fontFamily: 'Arial',
              fontSize: 28,
              fontWeight: 500,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            },
            navigation: {
              fontFamily: 'Arial',
              fontSize: 28,
              fontWeight: 400,
              lineHeight: 32,
              verticalAlign: 'middle',
              textBaseline: 'bottom'
            }
          },
          componentConfig: {
            Keyboard: {
              base: {
                keyProps: {
                  delete: {
                    title: null,
                    icon: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAAXNSR0IArs4c6QAACmpJREFUeF7tnVmoZUcVhv/feY4gBEVEH/KgCCZxCK2itNo4xQQH+kUN0TjEiDGKKBqnaExwBjUaR6KY+NQgiQkOMSYhYEScIopGJOqDE2hHjfP0y4p1Oqdv33v2qr32Prv2Paug6Ye7Vu2qv75TtWvtGohMqUBAAQZ80zUVQAKUEIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypXMClAyEFEiAQvKlcwKUDIQUSIBC8qVzApQMhBRIgELypfPsAJJ0NYC92XRHKPB3AAfLv18BuBLAFSR/NKZWswJI0vkA3jCmILsw75sAvIfkR8eo22wAknQSgMvGEGFD8vwxgFeQvGrI+s4CIEnHAPgugHsMWfkNzevDAM4i+Z8h6t88QJLuXOB5yBAVzjxuVeBaAM8ieXNUjzkAdAmA50Yrmv5HKPATACeQ/GNEm6YBkvRyANblZhpHAXsfekpkOGsWIEmPAHA9gDuOo13mWhS4gOSZfdVoEiBJ9wFwA4D7961Y+lUpsK/v7KxVgL4K4ElOCS4l+Uyn7a41k3Q0gMcC2ANgH4CHV1T2OyStx69OzQEk6TwAZztr8lMAx5P8s9N+Y8wk2cTjfQDu66z080h+zml7yKwpgCSdCOByZyX+BuBRJH/otN84M0kWN/s0gOc4Kv8Nko922B1m0gxAkh4I4AcVwcL9JA/UVnjT7CXdHYD9yEzfVUkAjib5uxqNmgCoBAu/CeBhzsJ/kORZTtuNN5Nk70bXAZ0Hy59G8qIawVoB6LMAnu8suE3tH0/y3077NAMg6esAuoaoC0la7M2dJgdI0ssAXOgs8W8BHEvS/s9UoYCkdwN4bYfL5STto7U7TQpQZbDQehzreawHylSpgKSTAVza4XYDyeNqsp4MoB7BwteQfH9N5dL2NgWK3l0vyAdJWhDXnSYBSNLtANh3GO/KwgMk97trlYbbKiDJPpzea5U8JKuYqDIeql0kvQPAG5352ZLMR5L8q9M+zXZQYFcAJOnJAL7sbGWLMFuk2SLOmYIKzB6gEiz8HoB7O7U4meQXnLZp1qGApD8BuOcsh7AewcL3kuyadg4OjSSbhRxH0j4BjJok2Ufga0j+YdQHlcznDlBNsPAa+xpP8r/rEHbxjAKPbRuyHvKFY0Ik6QUALOprPfIT1gHRbAGSdDoA77aSX5Zg4e8nhGfx6FEgWoJn8Zy1QCTplq5vjc3NwnoEC/eQ/HYD8IwC0TbwrA2i2QHUI1h4JskLGoJnUIhWwLMWiGYFkCSLMX2t5WDhlneeLm5Dw5kDntEhkmRhEVvesWNqZgiTdC6AN3W1Svn72oOFkuxF+WcVIQUrai+IKuA5BBHJ453auc1mA1AJFn7Jsf7EKj9ZsLBHw1ZDtI5neAmaBUBzCxaO2cBj5u2FZtlO0l8A3K3ZIaxHsPB8kt5vYn00c/mM0dBj5OmqzAqjOQDUfLBwJ32HbPAh84pCM5seSNJLAHzcWeFJgoVdZRui4YfIo6ucff8uyVY03LW5IawyWPgvW5u77mChV/QIABFfb/kidk0CVKbDth3Huw35dJLeniqiV2/fniDYx1f7vlWTeoUFah6wZQhrqwcqwUKbrtsaH0+6mOQpHsOpbXpCVFPstcJjBZNkmzHv0swQJultAN7iVO375TyafzjtJzcbEaK1w9McQJXBQlvvYmtsfjE5FZUFGAGiSeBpCqDKYKFtmX0qya9Utl0z5gNCNBk8BSA7CtiODNwxjf4trEew8BySNtTNOg0A0aTwtARQTbDQeh3rfawXmn0KQDQ5PC0B9EkAL3LSkAD9X6hWALIJzJ3mNoSdS9I7U3NyuX6zQO+zKOzkEEmaHqDSFdpZM97tOfkSfRvvk0LUDEAFIgseetf85DS+AYgk/bPr1NvRZ2HLg4ektwI4xzmgZCBxYohaBMjWPeenDOcvaIvZ2oez5gAqQ5mtLbb3oa4z+Bb6nTHW1UP92vFIr54vzJ8BcGplGdYKkSRbCXGHSWdh2z1ckp1taGccroxyFt9cznG4iGuDqFmASk9kZxxakNGTckHZBBA1DVCB6BMAXuwhyA4VmGL/+05l6zlsbdt7DJmXU0uXmSQ7JvD2zQ1hiwJJsotRvlVxXO87SU5+heUYDT5Gni5KVhg1D1DphWqCjOYy6RlAYzb0mHn3gWkWABWIaoKMubHwSBpGebGWZNdc2vmUO6a1BhJXFUSSff/yLuOYamvzzwEcVfFr7tWwPXqi6uN2PXWYG0C1Qca1n8RaDlewl3kPRL3gWXo/XBwo1dXWdk/a3jEOnJoVQGUoqw0yvpLkh7oUHvLvTohC8FRANBo8pT3sxLeVJ/M2M4QtiVYTZJzkNPoOiAaBxwHRqPDMFqBS8Jog4yT3YewA0aDwrIBodHhmDVApvG0mtO3PnjTJjTxbIBoFnm0gWgs8pQ06lxY3N4QtCWZBRgPDezdnHvPr+alV2EiaL0DlF2Dbn20bdB40XtHwQ5nOHqAC0SyCjEM1Wkv57AqACkRvBvB2p7hrDzI6yzU7s90EUPNBxtnR4SjwrgGo9EK1Qca8cM4ByU4mkuz++F93ZHELyZX3iW31n+S+sKWZWfNBxkCbNeUq6ekArugo1I0kH1xT8EkBKj1R80HGGkFbtZVkZ3bb2d2r0tUkn1hTh8kBKhB9DMBLnQWfJMjoLFuTZpJsO/ONAB7UUcBLSHqvX781q1YAqg0yfoDkq5psrQYLJeldAF7nKFr1x+wmACq9kAUZLazvvTV4P8kDDlE22kTSQ4uuK9dCF5HuR/I3NYI1A1CBaB+AK50VsAMj7TJeixNl2kYBSccCsB/ZMQ6Brif5GIfdYSZNAVQg8rzsLSphl/Hapby2LDZTUaBcq/56ALb1fOVxLkuinULy4loRmwOoQGQX7T7DWZnPk3y203bXmkl6AIA91isDOBGADV3e1HsJbasA1QYZvUKl3fYKPI2knXFQnZoEqPRCNUHG6oqnwyEFLiJ5Wl89mgWoQFQTZOyrwSb7WUztcSRtu0+v1DRABaKPADijV+3SaZUCNgE5geTNEZnmAFBtkDGix6b4Xld2BNvJcaHUPEClF6oNMoZE2eXOtm3q1ZFha1mfWQBUINoL4Kqurbm7vPEj1bOAqx3udW0kk62+swGoQHQ2gPOGFGAD8roJgF0t+qkx6jorgApElwE4aQwxZp6n3YNxsPyzA7yst/4iSdvEMFqaHUCjKZEZ91IgAeolWzotFEiAkoWQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnROgJKBkAIJUEi+dE6AkoGQAglQSL50ToCSgZACCVBIvnT+H0jPT81J3xWWAAAAAElFTkSuQmCC'
                  }
                }
              }
            }
          }
        });
        function Background() {
          var params = new URLSearchParams(window.location.search);
          var disableBG = params.get("disableBG") === "true";
          var bg1, bg2, heroMask;
          var active = 0;
          var alpha = 1;
          var animationSettings = {
            duration: 550,
            easing: "ease-in-out"
          };
          var bgStyles = {
            alpha: alpha,
            color: 4294967295
          };
          onMount(function () {
            if (disableBG) {
              heroMask.src = "";
              heroMask.colorLeft = 0x000000FF;
              heroMask.colorRight = 0x00000000;
              return;
            }
          });
          function changeBackgrounds(img) {
            if (disableBG) {
              heroMask.src = "";
              heroMask.colorLeft = 0x000000FF;
              heroMask.colorRight = 0x00000000;
              return;
            }
            if (typeof img !== "string") {
              bg1.color = img;
              bg1.src = "";
              bg1.alpha = 1;
              active = 1;
              bg2.alpha = 0;
              heroMask.alpha = 0;
              return;
            } else {
              bg1.color = 4294967295;
              heroMask.alpha = 1;
            }
            var currentBg = active === 1 ? bg2 : bg1;
            var nextBg = active === 1 ? bg1 : bg2;
            currentBg.src = img;
            if (active === 0) {
              currentBg.alpha = 1;
            } else {
              currentBg.alpha = 0.01;
              currentBg.animate({
                alpha: 1
              }, animationSettings).start();
            }
            nextBg.animate({
              alpha: 0.01
            }, animationSettings).start();
            active = active === 1 ? 2 : 1;
          }
          createEffect(on(globalBackground, function (img) {
            changeBackgrounds(img);
          }, {
            defer: true
          }));
          return createComponent(View, {
            width: 1920,
            height: 1080,
            zIndex: -5,
            get children() {
              return [createComponent(View, {
                ref: function ref(r$) {
                  var _ref$ = bg1;
                  typeof _ref$ === "function" ? _ref$(r$) : bg1 = r$;
                },
                style: bgStyles
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$2 = bg2;
                  typeof _ref$2 === "function" ? _ref$2(r$) : bg2 = r$;
                },
                style: bgStyles,
                alpha: 0
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$3 = heroMask;
                  typeof _ref$3 === "function" ? _ref$3(r$) : heroMask = r$;
                },
                src: "./assets/hero-mask-inverted.png",
                get color() {
                  return hexColor(theme.color.materialBrand);
                },
                width: 1920,
                height: 1080
              })];
            }
          });
        }
        var styles$7 = {
          Column: {
            flexDirection: "column",
            display: "flex",
            width: 140,
            height: 600,
            y: 360,
            gap: 20,
            zIndex: 101,
            transition: {
              x: {
                duration: 250,
                easing: "ease-in-out"
              }
            },
            x: 8,
            $focus: {
              width: 500,
              x: theme.layout.marginX
            }
          },
          Gradient: {
            zIndex: 99,
            color: 0x000000FF,
            src: "./assets/sidenav.png",
            alpha: 0,
            width: 200,
            height: 1080,
            $focus: {
              alpha: 1,
              width: 1600
            },
            transition: {
              alpha: true,
              width: true
            }
          },
          NavButton: {
            zIndex: 102,
            height: 70,
            width: 100,
            borderRadius: 8,
            color: 0,
            $focus: {
              color: 0x424242FF
            },
            $active: {
              width: 328,
              height: 70
            }
          }
        };
        var basePath$1 = "/solid-demo-app/";
        var icons = [{
          name: "experiment",
          width: 81,
          height: 100,
          x: 0,
          y: 0
        }, {
          name: "trending",
          width: 100,
          height: 56,
          x: 81,
          y: 0
        }, {
          name: "tv",
          width: 100,
          height: 68,
          x: 181,
          y: 0
        }, {
          name: "movie",
          width: 94,
          height: 100,
          x: 282,
          y: 0
        }];
        var sprite;
        function Icon(props) {
          sprite = sprite || createSpriteMap(basePath$1 + "assets/icons_white.png", icons);
          return createComponent(View, mergeProps(props, {
            get texture() {
              return sprite[props.name];
            },
            get width() {
              return sprite[props.name].props.width;
            },
            get height() {
              return sprite[props.name].props.height;
            },
            get x() {
              return (100 - (sprite[props.name].props.width || 0)) / 2;
            },
            get y() {
              return (100 - (sprite[props.name].props.height || 0)) / 2;
            }
          }));
        }
        var NavButtonTextStyles = {
          fontSize: 38,
          x: 116,
          y: 18,
          height: 50,
          alpha: 0,
          $active: {
            alpha: 1
          }
        };
        function NavButton(props) {
          return createComponent(View, mergeProps(props, {
            forwardStates: true,
            get style() {
              return styles$7.NavButton;
            },
            get children() {
              return [createComponent(View, {
                y: -16,
                get children() {
                  return createComponent(Icon, {
                    scale: 0.5,
                    get name() {
                      return props.icon;
                    }
                  });
                }
              }), createComponent(Text$4, {
                style: NavButtonTextStyles,
                get children() {
                  return props.children;
                }
              })];
            }
          }));
        }
        function NavDrawer(props) {
          var backdrop;
          var navigate = useNavigate();
          function onFocus() {
            backdrop.states.add("$focus");
            this.children.forEach(function (c) {
              return c.states.add("$active");
            });
            this.children[this.selected || 0].setFocus();
          }
          function onBlur() {
            backdrop.states.remove("$focus");
            this.selected = 0;
            this.children.forEach(function (c) {
              return c.states.remove("$active");
            });
          }
          function handleNavigate(page) {
            var isOnPage = useMatch(function () {
              return page;
            });
            if (isOnPage()) {
              return props.focusPage();
            }
            navigate(page);
          }
          return [createComponent(View, {
            flexItem: false,
            width: 300,
            height: 150,
            x: 30,
            y: 15,
            zIndex: 105,
            get alpha() {
              return props.showWidgets ? 1 : 0.01;
            },
            get children() {
              return [createComponent(Text$4, {
                x: 80,
                fontSize: 28,
                color: 4143380036,
                children: "Built With:"
              }), createComponent(View, {
                y: 22,
                src: "./assets/solidWord.png",
                width: 280,
                height: 52
              }), createComponent(View, {
                x: 0,
                y: 110,
                src: "./assets/tmdb.png",
                width: 80,
                height: 41
              }), createComponent(Text$4, {
                x: 90,
                y: 110,
                contain: "width",
                width: 160,
                fontSize: 12,
                color: 4143380036,
                children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
              })];
            }
          }), createComponent(Column, mergeProps(props, {
            onFocus: onFocus,
            onBlur: onBlur,
            get style() {
              return styles$7.Column;
            },
            scroll: "none",
            get children() {
              return [createComponent(NavButton, {
                onEnter: function onEnter() {
                  return handleNavigate("/browse/all");
                },
                icon: "trending",
                children: "Trending"
              }), createComponent(NavButton, {
                icon: "movie",
                onEnter: function onEnter() {
                  return handleNavigate("/browse/movie");
                },
                children: "Movies"
              }), createComponent(NavButton, {
                icon: "tv",
                onEnter: function onEnter() {
                  return handleNavigate("/browse/tv");
                },
                children: "TV"
              }), createComponent(NavButton, {
                icon: "experiment",
                onEnter: function onEnter() {
                  return handleNavigate("/examples");
                },
                children: "Examples"
              })];
            }
          })), createComponent(View, {
            skipFocus: true,
            ref: function ref(r$) {
              var _ref$ = backdrop;
              typeof _ref$ === "function" ? _ref$(r$) : backdrop = r$;
            },
            get style() {
              return styles$7.Gradient;
            }
          })];
        }

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /**
         * Object.fromEntries is added in chrome 74, we need to support 63 where possible
         */
        function objectFromEntries(entries) {
          if (!entries || !entries[Symbol.iterator]) {
            throw new Error('objectFromEntries requires a single iterable argument');
          }
          var obj = {};
          var _iterator26 = _createForOfIteratorHelper(entries),
            _step26;
          try {
            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
              var _step26$value = _slicedToArray(_step26.value, 2),
                _key45 = _step26$value[0],
                value = _step26$value[1];
              obj[_key45] = value;
            }
          } catch (err) {
            _iterator26.e(err);
          } finally {
            _iterator26.f();
          }
          return obj;
        }

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        // TODO types, sub components
        // TODO these are configurable per component, move to theme?
        var defaultModeKeys = ['focus', 'disabled'];
        var defaultToneKeys = ['brand', 'inverse', 'neutral'];
        function makeComponentStyles(_ref45) {
          var themeKeys = _ref45.themeKeys,
            base = _ref45.base,
            themeStyles = _ref45.themeStyles,
            _ref45$modes = _ref45.modes,
            modes = _ref45$modes === void 0 ? {} : _ref45$modes,
            _ref45$tones = _ref45.tones,
            tones = _ref45$tones === void 0 ? {} : _ref45$tones,
            _ref45$modeKeys = _ref45.modeKeys,
            modeKeys = _ref45$modeKeys === void 0 ? defaultModeKeys : _ref45$modeKeys,
            _ref45$toneKeys = _ref45.toneKeys,
            toneKeys = _ref45$toneKeys === void 0 ? defaultToneKeys : _ref45$toneKeys;
          var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          /**
           * creates the object of tone styles
           *
           * for each key in the tone object, pass its set of styles to mapModeConfigToSolidStyle for formatting
           */
          var makeToneStyles = function makeToneStyles(tones, themeComponentStyles, modeStyles) {
            var toneStyles = toneKeys.map(function (tone) {
              var _tones$tone, _themeComponentStyles;
              var styles = {};
              // get list of style keys across both style file and theme component config
              // TODO a better way to do this
              var styleList = new Set(
              // eslint-disable-next-line prefer-spread
              [].concat.apply([], [(_tones$tone = tones === null || tones === void 0 ? void 0 : tones[tone]) !== null && _tones$tone !== void 0 ? _tones$tone : {}, (_themeComponentStyles = themeComponentStyles === null || themeComponentStyles === void 0 ? void 0 : themeComponentStyles[tone]) !== null && _themeComponentStyles !== void 0 ? _themeComponentStyles : {}].map(Object.keys)));
              // combine style file tones and theme component config tones, ignoring tone modes(added below)
              styleList.forEach(function (styleKey) {
                // if the style isn't a mode
                if (!modeKeys.includes(styleKey)) {
                  var _themeComponentStyles2, _themeComponentStyles3, _tones$tone2;
                  styles[styleKey] = (_themeComponentStyles2 = themeComponentStyles === null || themeComponentStyles === void 0 || (_themeComponentStyles3 = themeComponentStyles[tone]) === null || _themeComponentStyles3 === void 0 ? void 0 : _themeComponentStyles3[styleKey]) !== null && _themeComponentStyles2 !== void 0 ? _themeComponentStyles2 : tones === null || tones === void 0 || (_tones$tone2 = tones[tone]) === null || _tones$tone2 === void 0 ? void 0 : _tones$tone2[styleKey];
                }
              });
              /**
               *  merge tone modes with the following priority(lowest to highest):
               * - base.mode
               * - style file tone.mode
               * - theme component config tone.mode
               */
              modeKeys.forEach(function (mode) {
                var _tones$tone3, _themeComponentStyles4;
                styles[mode] = _objectSpread(_objectSpread(_objectSpread({}, modeStyles[mode]), tones === null || tones === void 0 || (_tones$tone3 = tones[tone]) === null || _tones$tone3 === void 0 ? void 0 : _tones$tone3[mode]), themeComponentStyles === null || themeComponentStyles === void 0 || (_themeComponentStyles4 = themeComponentStyles[tone]) === null || _themeComponentStyles4 === void 0 ? void 0 : _themeComponentStyles4[mode]);
              });
              return [tone, styles];
            });
            return objectFromEntries(toneStyles);
          };
          /**
           * creates the object of mode(state-controlled) styles
           *
           * for each key in the mode object, pass its set of styles to mapModeConfigToSolidStyle for formatting
           */
          var makeModeStyles = function makeModeStyles(modes, themeComponentStyles) {
            var modeStyles = modeKeys.map(function (mode) {
              return [mode, _objectSpread(_objectSpread({}, modes === null || modes === void 0 ? void 0 : modes[mode]), themeComponentStyles === null || themeComponentStyles === void 0 ? void 0 : themeComponentStyles[mode])];
            });
            var modeObject = objectFromEntries(modeStyles);
            return modeObject;
          };
          /**
           * creates a base style object
           *
           * if a property has a themeable value(has a corresponding themeKey in the themeKeys object) check the
           * componentConfig for a base value. if one exists use it, otherwise use the value from the defaults object
           */
          var makeBaseStyles = function makeBaseStyles(base, themeComponentStyles) {
            var baseStyles = _objectSpread(_objectSpread({}, base), themeComponentStyles.base);
            return baseStyles;
          };
          /**
           * uses the themeKey map to assign themed values to solid style properties
           * `themeKeys` is globally available
           */
          var mapThemeKeysToSolid = function mapThemeKeysToSolid(stylesToMap) {
            return objectFromEntries(Object.entries(themeKeys).filter(function (_ref46) {
              var _ref47 = _slicedToArray(_ref46, 2),
                _ = _ref47[0],
                themeKey = _ref47[1];
              return stylesToMap[themeKey];
            }).map(function (_ref48) {
              var _ref49 = _slicedToArray(_ref48, 2),
                solidKey = _ref49[0],
                themeKey = _ref49[1];
              return [solidKey, stylesToMap[themeKey]];
            }));
          };
          var convertComponentConfig = function convertComponentConfig(themeStyles) {
            var convertedThemeStyles = objectFromEntries(
            // iterate through each variant
            Object.entries(themeStyles).map(function (_ref50) {
              var _ref51 = _slicedToArray(_ref50, 2),
                variantName = _ref51[0],
                styles = _ref51[1];
              // within each variant, assign the theme value to the correct solid style property for each theme key
              var convertedStyles = mapThemeKeysToSolid(styles);
              // repeat the above for each mode within a variant
              Object.entries(styles).filter(function (_ref52) {
                var _ref53 = _slicedToArray(_ref52, 2),
                  styleName = _ref53[0],
                  _ = _ref53[1];
                return modeKeys.includes(styleName);
              }).forEach(function (_ref54) {
                var _ref55 = _slicedToArray(_ref54, 2),
                  modeName = _ref55[0],
                  modeStyles = _ref55[1];
                convertedStyles[modeName] = mapThemeKeysToSolid(modeStyles);
              });
              return [variantName, convertedStyles];
            }));
            return convertedThemeStyles;
          };
          var generateSolidStylesFromLookupObject = function generateSolidStylesFromLookupObject(base, modes, tones) {
            var themeComponentStyles = convertComponentConfig(themeStyles);
            debug && console.log(themeComponentStyles);
            var baseStyles = makeBaseStyles(base, themeComponentStyles);
            debug && console.log(baseStyles);
            var modeStyles = makeModeStyles(modes, themeComponentStyles);
            debug && console.log(modeStyles);
            var toneStyles = makeToneStyles(tones, themeComponentStyles, modeStyles);
            debug && console.log(toneStyles);
            return {
              base: _objectSpread(_objectSpread({}, baseStyles), modeStyles),
              tones: toneStyles
            };
          };
          return generateSolidStylesFromLookupObject(base, modes, tones);
        }

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        function getWidthByUpCount() {
          var upCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
          var screenW = theme.layout.screenW;
          var columnCount = theme.layout.columnCount;
          var marginX = theme.layout.marginX;
          var gutterX = theme.layout.gutterX;
          if (upCount < 1 || upCount > columnCount) {
            console.error("getWidthByUpCount expects an upCount between 1 & ".concat(columnCount, ", received ").concat(upCount, ". Defaulting to upCount 1."));
            upCount = 1;
          }
          // the screen width, minus the margin x on each side
          var columnWidth = screenW - marginX * 2;
          // the total space of column gaps in between items
          var columnGapTotal = (upCount - 1) * gutterX;
          // the remaining amount of space left for all items
          var totalColumnsWidth = columnWidth - columnGapTotal;
          // the width of each item in that remaining width
          return totalColumnsWidth / upCount;
        }

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi2 = _theme$componentConfi.Artwork,
          _theme$componentConfi3 = _theme$componentConfi2 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi2,
          defaultTone$e = _theme$componentConfi3.defaultTone,
          themeStyles$e = _objectWithoutProperties(_theme$componentConfi3, _excluded);
        var container$e = {
          themeKeys: {
            borderRadius: 'radius',
            fallbackSrc: 'fallbackSrc',
            fillColor: 'fillColor',
            gradientColor: 'gradientColor',
            pivotX: 'imageScalePivotX',
            pivotY: 'imageScalePivotY',
            scale: 'imageScale'
          },
          base: {
            fallbackSrc: undefined,
            fillColor: theme.color.overlay,
            gradientColor: theme.color.material,
            pivotX: 0.5,
            pivotY: 0.5,
            scale: undefined,
            borderRadius: theme.radius.md
          },
          themeStyles: themeStyles$e
        };
        makeComponentStyles(container$e);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi4 = theme.componentConfig.Badge,
          _theme$componentConfi5 = _theme$componentConfi4 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi4,
          defaultTone$d = _theme$componentConfi5.defaultTone,
          themeStyles$d = _objectWithoutProperties(_theme$componentConfi5, _excluded2);
        var container$d = {
          themeKeys: {
            color: 'backgroundColor',
            borderRadius: 'radius',
            gap: 'contentSpacing'
          },
          base: {
            // TODO clew uses strokeColor, but we currently don't account for nested properties (border.color)
            // TODO clew uses strokeWidth, but we currently don't account for nested properties (border.width)
            color: theme.color.fillInverseSecondary,
            borderRadius: theme.radius.sm,
            // borderRadius must be applied _before_ border to prevent the node from breaking
            border: {
              color: theme.color.strokeInverse,
              width: theme.stroke.sm
            },
            gap: theme.spacer.xs,
            display: 'flex',
            justifyContent: 'flexStart',
            alignItems: 'center'
          },
          tones: {
            inverse: {
              color: theme.color.fillNeutralSecondary,
              borderRadius: theme.radius.sm,
              border: {
                color: theme.color.strokeInverseSecondary,
                width: theme.stroke.sm
              }
            },
            brand: {
              color: theme.color.fillBrand,
              borderRadius: theme.radius.sm,
              border: {
                color: theme.color.strokeInverseSecondary,
                width: theme.stroke.sm
              }
            }
          },
          themeStyles: themeStyles$d
        };
        var text$5 = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread(_objectSpread({}, theme.typography.tag1), {}, {
            color: theme.color.textNeutral,
            lineHeight: theme.typography.tag1.lineHeight + 12,
            marginRight: theme.spacer.md + theme.stroke.sm,
            marginLeft: theme.spacer.md + theme.stroke.sm
          }),
          tones: {
            inverse: {
              color: theme.color.textInverse
            },
            brand: {
              color: theme.color.textNeutral
            }
          },
          themeStyles: themeStyles$d
        };
        var icon$1 = {
          themeKeys: {
            color: 'iconColor'
          },
          base: {
            color: theme.color.textNeutral
          },
          tones: {
            inverse: {
              color: theme.color.textInverse
            },
            brand: {
              color: theme.color.textNeutral
            }
          },
          themeStyles: themeStyles$d
        };
        makeComponentStyles(container$d);
        makeComponentStyles(icon$1);
        makeComponentStyles(text$5);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi6 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi7 = _theme$componentConfi6.Button,
          _theme$componentConfi8 = _theme$componentConfi7 === void 0 ? {
            buttonThemeStyles: {}
          } : _theme$componentConfi7,
          defaultTone$c = _theme$componentConfi8.defaultTone,
          buttonThemeStyles = _objectWithoutProperties(_theme$componentConfi8, _excluded3);
        /* @ts-expect-error next-line see above */
        var _theme$componentConfi9 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi10 = _theme$componentConfi9.Surface,
          _theme$componentConfi11 = _theme$componentConfi10 === void 0 ? {
            surfaceThemeStyles: {}
          } : _theme$componentConfi10,
          surfaceDefaultTone = _theme$componentConfi11.surfaceDefaultTone,
          surfaceThemeStyles = _objectWithoutProperties(_theme$componentConfi11, _excluded4);
        var themeStyles$c = _objectSpread(_objectSpread({}, buttonThemeStyles), surfaceThemeStyles);
        var container$c = {
          themeKeys: {
            borderRadius: 'radius',
            color: 'backgroundColor',
            justifyContent: 'justify',
            itemSpacing: 'contentSpacing'
          },
          base: {
            height: theme.typography.button1.lineHeight + theme.spacer.xl * 2,
            display: 'flex',
            padding: [theme.spacer.xxxl, theme.spacer.xl],
            color: theme.color.interactiveNeutral,
            justifyContent: 'center',
            alignItems: 'center',
            flexBoundary: 'fixed',
            borderRadius: theme.radius.sm,
            contentColor: theme.color.fillNeutral
          },
          modes: {
            focus: {
              color: theme.color.interactiveNeutralFocus,
              contentColor: theme.color.fillInverse
            },
            disabled: {
              color: theme.color.fillNeutralDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.interactiveInverse
            },
            brand: {
              color: theme.color.interactiveBrand,
              focus: {
                color: theme.color.fillNeutral
              }
            }
          },
          themeStyles: themeStyles$c
        };
        var content = {
          themeKeys: {
            color: 'contentColor'
          },
          base: {
            color: theme.color.textNeutral
          },
          modes: {
            focus: {
              color: theme.color.textInverse
            },
            disabled: {
              color: theme.color.textNeutralDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.fillNeutral
            },
            brand: {
              color: theme.color.fillBrand,
              focus: {
                color: theme.color.fillBrand
              }
            }
          },
          themeStyles: themeStyles$c
        };
        var text$4 = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread(_objectSpread({
            color: theme.color.textNeutral
          }, theme.typography.button1), {}, {
            textAlign: 'center',
            contain: 'none'
          }),
          modes: {
            focus: {
              color: theme.color.textInverse
            },
            disabled: {
              color: theme.color.textNeutralDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.fillNeutral
            },
            brand: {
              color: theme.color.fillBrand,
              focus: {
                color: theme.color.fillBrand
              }
            }
          },
          themeStyles: themeStyles$c
        };
        var Container$5 = makeComponentStyles(container$c);
        var Content = makeComponentStyles(content);
        var Text$3 = makeComponentStyles(text$4);
        var styles$6 = exports("Z", {
          tone: defaultTone$c || surfaceDefaultTone || 'neutral',
          Container: Container$5,
          Content: Content,
          Text: Text$3
        });

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi12 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi13 = _theme$componentConfi12.Checkbox,
          _theme$componentConfi14 = _theme$componentConfi13 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi13,
          defaultTone$b = _theme$componentConfi14.defaultTone,
          themeStyles$b = _objectWithoutProperties(_theme$componentConfi14, _excluded5);
        var container$b = {
          themeKeys: {
            color: 'backgroundColor',
            borderRadius: 'radius',
            border: 'border',
            justifyContent: 'justifyContent'
          },
          base: {
            width: theme.spacer.xxl,
            height: theme.spacer.xxl,
            display: 'flex',
            justifyContent: 'center',
            color: theme.color.fillNeutral,
            alignItems: 'center',
            borderRadius: theme.spacer.xxl / 4,
            border: {
              color: theme.color.strokeInverse,
              width: theme.stroke.sm
            }
          },
          modes: {
            disabled: {
              alpha: theme.alpha.inactive
            }
          },
          tones: {
            brand: {
              borderRadius: theme.spacer.xxl / 4,
              border: {
                color: theme.color.strokeNeutralSecondary,
                width: theme.stroke.sm
              },
              color: theme.color.fillNeutralSecondary,
              checked: {
                borderRadius: theme.spacer.xxl / 4,
                border: {
                  color: theme.color.strokeNeutralSecondary,
                  width: theme.stroke.sm
                },
                color: theme.color.fillBrand
              }
            },
            neutral: {
              borderRadius: theme.spacer.xxl / 4,
              border: {
                color: theme.color.strokeNeutralSecondary,
                width: theme.stroke.sm
              },
              color: theme.color.fillInverseSecondary,
              checked: {
                borderRadius: theme.spacer.xxl / 4,
                border: {
                  color: theme.color.strokeNeutralSecondary,
                  width: theme.stroke.sm
                },
                color: theme.color.fillNeutral
              }
            },
            inverse: {
              borderRadius: theme.spacer.xxl / 4,
              border: {
                color: theme.color.strokeInverseSecondary,
                width: theme.stroke.sm
              },
              color: theme.color.fillNeutralSecondary,
              checked: {
                borderRadius: theme.spacer.xxl / 4,
                border: {
                  color: theme.color.strokeInverseSecondary,
                  width: theme.stroke.sm
                },
                color: theme.color.fillInverse
              }
            }
          },
          modeKeys: ['focus', 'disabled', 'checked'],
          themeStyles: themeStyles$b
        };
        var icon = {
          themeKeys: {
            // color: 'strokeColor', see types 58 for TODO
            width: 'checkWidth',
            height: 'checkHeight'
          },
          base: {
            width: theme.spacer.lg,
            height: theme.spacer.lg,
            src: theme.asset.check
          },
          tones: {
            neutral: {
              color: theme.color.fillInverse
            },
            inverse: {
              color: theme.color.fillNeutral
            },
            brand: {
              color: theme.color.fillInverse
            }
          },
          themeStyles: themeStyles$b
        };
        makeComponentStyles(container$b);
        makeComponentStyles(icon);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi15 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi16 = _theme$componentConfi15.Icon,
          _theme$componentConfi17 = _theme$componentConfi16 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi16,
          defaultTone$a = _theme$componentConfi17.defaultTone,
          themeStyles$a = _objectWithoutProperties(_theme$componentConfi17, _excluded6);
        var container$a = {
          themeKeys: {
            color: 'color'
          },
          base: {
            width: 100,
            height: 100,
            color: theme.color.fillNeutral
          },
          tones: {
            inverse: {
              color: theme.color.fillInverse
            },
            brand: {
              color: theme.color.fillBrand
            }
          },
          themeStyles: themeStyles$a
        };
        makeComponentStyles(container$a);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi18 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi19 = _theme$componentConfi18.Column,
          _theme$componentConfi20 = _theme$componentConfi19 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi19,
          defaultTone$9 = _theme$componentConfi20.defaultTone,
          themeStyles$9 = _objectWithoutProperties(_theme$componentConfi20, _excluded7);
        var container$9 = {
          themeKeys: {
            gap: 'itemSpacing',
            scrollIndex: 'scrollIndex',
            transition: 'itemTransition'
          },
          base: {
            display: 'flex',
            flexDirection: 'column',
            gap: theme.layout.gutterY,
            transition: {
              y: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
                duration: theme.animation.duration.fast
              })
            }
          },
          themeStyles: themeStyles$9
        };
        var Container$4 = makeComponentStyles(container$9);
        var styles$5 = exports("Q", {
          tone: defaultTone$9 || 'neutral',
          Container: Container$4
        });

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi21 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi22 = _theme$componentConfi21.FocusRing,
          _theme$componentConfi23 = _theme$componentConfi22 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi22,
          defaultTone$8 = _theme$componentConfi23.defaultTone,
          themeStyles$8 = _objectWithoutProperties(_theme$componentConfi23, _excluded8);
        var container$8 = {
          themeKeys: {
            borderRadius: 'radius'
          },
          base: {
            x: 0,
            y: 0,
            borderRadius: theme.radius.lg,
            border: {
              color: theme.color.interactiveNeutralFocus,
              width: theme.stroke.md
            }
          },
          themeStyles: themeStyles$8
        };
        makeComponentStyles(container$8);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi24 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi25 = _theme$componentConfi24.Input,
          _theme$componentConfi26 = _theme$componentConfi25 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi25,
          defaultTone$7 = _theme$componentConfi26.defaultTone,
          themeStyles$7 = _objectWithoutProperties(_theme$componentConfi26, _excluded9);
        var container$7 = {
          themeKeys: {
            borderRadius: 'radius',
            color: 'backgroundColor',
            justifyContent: 'justify'
          },
          base: {
            // TODO clew uses strokeColor, but we currently don't account for nested properties (border.color)
            // TODO clew uses strokeWidth, but we currently don't account for nested properties (border.width)
            width: getWidthByUpCount(4),
            height: 100,
            padding: [theme.spacer.xxxl, theme.spacer.xl],
            color: theme.color.interactiveNeutral,
            contentColor: theme.color.fillInverse,
            borderRadius: theme.radius.sm,
            marginX: theme.spacer.xxxl,
            actualTitle: ''
          },
          themeStyles: themeStyles$7
        };
        var text$3 = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread({
            textAlign: 'left',
            color: theme.color.textNeutral
          }, theme.typography.button1),
          themeStyles: themeStyles$7
        };
        var Container$3 = makeComponentStyles(container$7);
        var Text$2 = makeComponentStyles(text$3);
        var styles$4 = exports("U", {
          tone: defaultTone$7 || 'neutral',
          Container: Container$3,
          Text: Text$2
        });

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi27 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi28 = _theme$componentConfi27.Key,
          _theme$componentConfi29 = _theme$componentConfi28 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi28,
          defaultTone$6 = _theme$componentConfi29.defaultTone,
          themeStyles$6 = _objectWithoutProperties(_theme$componentConfi29, _excluded10);
        var container$6 = {
          themeKeys: {
            keySpacing: 'keySpacing',
            borderRadius: 'borderRadius',
            color: 'backgroundColor',
            justifyContent: 'justify',
            baseWidth: 'baseWidth',
            sizes: 'sizes',
            contentColor: 'contentColor'
          },
          base: {
            keySpacing: theme.spacer.md,
            height: theme.spacer.md * 9,
            paddingX: theme.spacer.md,
            contentColor: theme.color.fillNeutral,
            sizes: {
              sm: 1,
              md: 2,
              lg: 3,
              xl: 4,
              xxl: 5
            },
            padding: [theme.spacer.md],
            baseWidth: theme.spacer.md * 7,
            color: theme.color.interactiveNeutral,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            borderRadius: theme.radius.sm
          },
          modes: {
            focus: {
              color: theme.color.interactiveNeutralFocus,
              contentColor: theme.color.fillInverse
            },
            disabled: {
              color: theme.color.fillNeutralDisabled,
              contentColor: theme.color.fillNeutralDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.interactiveInverse,
              focus: {
                color: theme.color.interactiveInverseFocus,
                contentColor: theme.color.fillNeutral
              }
            },
            brand: {
              focus: {
                contentColor: theme.color.fillNeutral
              }
            }
          },
          themeStyles: themeStyles$6
        };
        var text$2 = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread(_objectSpread({
            color: theme.color.textNeutral
          }, theme.typography.headline2), {}, {
            textAlign: 'center',
            contain: 'none'
          }),
          modes: {
            focus: {
              color: theme.color.textInverse
            },
            disabled: {
              color: theme.color.textNeutralDisabled
            }
          },
          tones: {
            inverse: {
              focus: {
                color: theme.color.textNeutral
              }
            }
          },
          themeStyles: themeStyles$6
        };
        var Container$2 = makeComponentStyles(container$6);
        var Text$1 = makeComponentStyles(text$2);
        var styles$3 = exports("W", {
          tone: defaultTone$6 || 'neutral',
          Container: Container$2,
          Text: Text$1
        });

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi30 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi31 = _theme$componentConfi30.Row,
          _theme$componentConfi32 = _theme$componentConfi31 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi31,
          defaultTone$5 = _theme$componentConfi32.defaultTone,
          themeStyles$5 = _objectWithoutProperties(_theme$componentConfi32, _excluded11);
        var container$5 = {
          themeKeys: {
            gap: 'itemSpacing',
            scrollIndex: 'scrollIndex',
            transition: 'itemTransition'
          },
          base: {
            display: 'flex',
            flexDirection: 'row',
            gap: theme.layout.gutterX,
            transition: {
              x: _objectSpread(_objectSpread({}, theme.animation.standardEntrance), {}, {
                duration: theme.animation.duration.fast
              })
            }
          },
          themeStyles: themeStyles$5
        };
        var Container$1 = makeComponentStyles(container$5);
        var styles$2 = exports("X", {
          tone: defaultTone$5,
          Container: Container$1
        });

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi33 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi34 = _theme$componentConfi33.Keyboard,
          _theme$componentConfi35 = _theme$componentConfi34 === void 0 ? {} : _theme$componentConfi34,
          defaultTone$4 = _theme$componentConfi35.defaultTone,
          themeStyles$4 = _objectWithoutProperties(_theme$componentConfi35, _excluded12);
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi36 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi37 = _theme$componentConfi36.Key,
          _theme$componentConfi38 = _theme$componentConfi37 === void 0 ? {} : _theme$componentConfi37,
          keyThemeStyles = Object.assign({}, (_objectDestructuringEmpty(_theme$componentConfi38), _theme$componentConfi38)); // TODO default tone for sub-components
        var container$4 = {
          themeKeys: {
            gap: 'keySpacing',
            width: 'screenW',
            marginX: 'marginX',
            keyHeight: 'keyHeight'
          },
          base: {
            gap: theme.spacer.md,
            width: theme.layout.screenW,
            display: 'flex',
            marginX: theme.layout.marginX,
            keyHeight: 100,
            flexBoundary: 'contain'
          },
          // @ts-expect-error TODO fix style types for component configs
          themeStyles: themeStyles$4
        };
        var key = {
          themeKeys: {
            gap: 'keySpacing',
            borderRadius: 'borderRadius',
            color: 'backgroundColor',
            justifyContent: 'justify',
            baseWidth: 'baseWidth',
            sizes: 'sizes',
            contentColor: 'contentColor' // what is this used for
          },
          base: {
            gap: theme.spacer.md,
            height: theme.spacer.md * 9,
            sizes: {
              sm: 1,
              md: 2,
              lg: 3,
              xl: 4,
              xxl: 5
            },
            contentColor: theme.color.fillNeutral,
            padding: [theme.spacer.xxxl, theme.spacer.xl],
            baseWidth: theme.spacer.md * 7,
            color: theme.color.interactiveNeutral,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            borderRadius: theme.radius.sm
          },
          modes: {
            focus: {
              color: theme.color.interactiveNeutralFocus,
              contentColor: theme.color.fillInverse
            },
            disabled: {
              color: theme.color.fillNeutralDisabled,
              contentColor: theme.color.fillNeutralDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.interactiveInverse,
              focus: {
                color: theme.color.interactiveInverseFocus,
                contentColor: theme.color.fillNeutral
              }
            },
            brand: {
              focus: {
                contentColor: theme.color.fillNeutral
              }
            }
          },
          themeStyles: keyThemeStyles
        };
        var text$1 = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread({
            color: theme.color.textNeutral
          }, theme.typography.headline2),
          modes: {
            focus: {
              color: theme.color.textInverse
            },
            disabled: {
              color: theme.color.textNeutralDisabled
            }
          },
          tones: {
            inverse: {
              focus: {
                color: theme.color.textNeutral
              }
            }
          },
          // @ts-expect-error TODO fix style types for component configs
          themeStyles: themeStyles$4
        };
        var Container = makeComponentStyles(container$4);
        var Key = makeComponentStyles(key);
        var Text = makeComponentStyles(text$1);
        var styles$1 = exports("Y", {
          tone: defaultTone$4,
          Container: Container,
          Key: Key,
          Text: Text
        });

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi39 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi40 = _theme$componentConfi39.Label,
          _theme$componentConfi41 = _theme$componentConfi40 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi40,
          defaultTone$3 = _theme$componentConfi41.defaultTone,
          themeStyles$3 = _objectWithoutProperties(_theme$componentConfi41, _excluded13);
        var container$3 = {
          themeKeys: {
            color: 'backgroundColor',
            borderRadius: 'radius'
          },
          base: {
            display: 'flex',
            justifyContent: 'flexStart',
            color: theme.color.textNeutral,
            padding: [theme.spacer.md, theme.spacer.lg],
            // TODO themed padding values
            height: theme.typography.caption1.lineHeight + theme.spacer.md * 2,
            borderRadius: [theme.radius.md, theme.radius.md, theme.radius.md, theme.radius.none],
            neutral: {
              backgroundColor: theme.color.fillNeutral
            }
          },
          tones: {
            inverse: {
              color: theme.color.fillInverse
            },
            brand: {
              color: theme.color.fillBrand,
              focus: {
                color: theme.color.orange
              }
            }
          },
          themeStyles: themeStyles$3
        };
        var text = {
          themeKeys: {
            color: 'textColor'
          },
          base: _objectSpread(_objectSpread({}, theme.typography.caption1), {}, {
            color: theme.color.textInverse,
            lineHeight: theme.typography.caption1.lineHeight + theme.spacer.md * 2,
            marginRight: theme.spacer.lg,
            marginLeft: theme.spacer.lg
          }),
          tones: {
            inverse: {
              color: theme.color.textNeutral
            },
            brand: {
              color: theme.color.textNeutral
            }
          },
          themeStyles: themeStyles$3
        };
        makeComponentStyles(container$3);
        makeComponentStyles(text);

        /*
         * Copyright 2023 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi42 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi43 = _theme$componentConfi42.ProgressBar,
          _theme$componentConfi44 = _theme$componentConfi43 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi43,
          defaultTone$2 = _theme$componentConfi44.defaultTone,
          themeStyles$2 = _objectWithoutProperties(_theme$componentConfi44, _excluded14);
        var container$2 = {
          themeKeys: {
            color: 'barColor',
            borderRadius: 'radius'
          },
          base: {
            height: theme.spacer.md,
            color: theme.color.fillNeutralTertiary,
            borderRadius: theme.radius.xs
          },
          tones: {
            inverse: {
              color: theme.color.fillInverseTertiary
            }
          },
          themeStyles: themeStyles$2
        };
        var progress = {
          themeKeys: {
            color: 'progressColor',
            borderRadius: 'radius'
          },
          base: {
            borderRadius: theme.radius.xs,
            color: theme.color.fillNeutral
          },
          tones: {
            inverse: {
              color: theme.color.fillInverse
            },
            brand: {
              color: theme.color.fillBrand
            }
          },
          themeStyles: themeStyles$2
        };
        makeComponentStyles(container$2);
        makeComponentStyles(progress);

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi45 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi46 = _theme$componentConfi45.Radio,
          _theme$componentConfi47 = _theme$componentConfi46 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi46,
          defaultTone$1 = _theme$componentConfi47.defaultTone,
          themeStyles$1 = _objectWithoutProperties(_theme$componentConfi47, _excluded15);
        var container$1 = {
          themeKeys: {
            borderRadius: 'radius',
            color: 'backgroundColor',
            colorChecked: 'backgroundColorChecked'
          },
          base: {
            color: theme.color.fillNeutralSecondary,
            height: theme.spacer.xxl + theme.stroke.sm * 2,
            width: theme.spacer.xxl + theme.stroke.sm * 2,
            borderRadius: theme.spacer.xxl / 2 + theme.stroke.sm,
            border: {
              color: theme.color.strokeNeutralSecondary,
              width: theme.stroke.sm
            }
          },
          tones: {
            inverse: {
              border: {
                color: theme.color.strokeInverseSecondary,
                width: theme.stroke.sm
              }
            },
            brand: {
              border: {
                color: theme.color.fillBrand,
                width: theme.stroke.sm
              }
            }
          },
          modeKeys: ['focus', 'disabled', 'checked'],
          themeStyles: themeStyles$1
        };
        var knob$1 = {
          themeKeys: {
            width: 'knobWidth',
            height: 'knobHeight',
            borderRadius: 'knobRadius',
            color: 'knobColor',
            colorChecked: 'knobColorChecked'
          },
          base: {
            color: theme.color.fillInverse,
            colorChecked: theme.color.fillInverse,
            width: theme.spacer.xxl,
            height: theme.spacer.xxl,
            borderRadius: theme.spacer.xxl / 2
          },
          tones: {
            inverse: {
              color: theme.color.fillNeutral
            }
          },
          themeStyles: themeStyles$1
        };
        makeComponentStyles(container$1);
        makeComponentStyles(knob$1);

        /*
         * Copyright 2024 Comcast Cable Communications Management, LLC
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         *
         * SPDX-License-Identifier: Apache-2.0
         */
        /* @ts-expect-error next-line themes are supplied by client applications so this setup is necessary */
        var _theme$componentConfi48 = theme === null || theme === void 0 ? void 0 : theme.componentConfig,
          _theme$componentConfi49 = _theme$componentConfi48.Toggle,
          _theme$componentConfi50 = _theme$componentConfi49 === void 0 ? {
            themeStyles: {}
          } : _theme$componentConfi49,
          defaultTone = _theme$componentConfi50.defaultTone,
          themeStyles = _objectWithoutProperties(_theme$componentConfi50, _excluded16);
        var knobSize = theme.spacer.xl;
        var knobPadding = theme.spacer.xs;
        var strokeWidth = theme.stroke.sm;
        var container = {
          themeKeys: {
            borderRadius: 'strokeRadius',
            color: 'backgroundColor',
            colorChecked: 'backgroundColorChecked'
          },
          base: {
            color: theme.color.fillInverseTertiary,
            colorChecked: theme.color.fillNeutral,
            height: knobSize + (knobPadding + strokeWidth) * 2,
            width: (strokeWidth + knobPadding * 2 + knobSize) * 2,
            borderRadius: knobSize / 2 + knobPadding + strokeWidth,
            border: {
              // TODO- strokeWidth, strokeColor, and strokeColorChecked map to border object with themeKeys
              color: theme.color.fillNeutral,
              width: strokeWidth
            }
          },
          modes: {
            focus: {},
            disabled: {
              borderRadius: knobSize / 2 + knobPadding + strokeWidth,
              border: {
                color: theme.color.fillNeutralDisabled,
                width: strokeWidth
              },
              color: theme.color.fillInverseDisabled,
              colorChecked: theme.color.fillNeutralDisabled
            }
          },
          tones: {
            inverse: {
              borderRadius: knobSize / 2 + knobPadding + strokeWidth,
              border: {
                color: theme.color.fillInverse,
                width: strokeWidth
              },
              color: theme.color.fillNeutralTertiary,
              colorChecked: theme.color.fillInverse,
              disabled: {
                borderRadius: knobSize / 2 + knobPadding + strokeWidth,
                border: {
                  color: theme.color.fillInverseDisabled,
                  width: strokeWidth
                },
                color: theme.color.fillNeutralDisabled,
                colorChecked: theme.color.fillInverseDisabled
              }
            },
            brand: {
              borderRadius: knobSize / 2 + knobPadding + strokeWidth,
              border: {
                color: theme.color.fillBrand,
                width: strokeWidth
              },
              color: theme.color.fillBrandTertiary,
              colorChecked: theme.color.fillBrand,
              disabled: {
                borderRadius: knobSize / 2 + knobPadding + strokeWidth,
                border: {
                  color: theme.color.fillNeutralDisabled,
                  width: strokeWidth
                },
                color: theme.color.fillInverseDisabled,
                colorChecked: theme.color.fillNeutralDisabled
              }
            }
          },
          // TODO: figure out checked state
          themeStyles: themeStyles
        };
        var knob = {
          themeKeys: {
            width: 'knobWidth',
            height: 'knobHeight',
            padding: 'knobPadding',
            borderRadius: 'knobRadius',
            color: 'knobColor',
            colorChecked: 'knobColorChecked'
          },
          base: {
            color: theme.color.fillNeutral,
            colorChecked: theme.color.fillInverse,
            width: knobSize,
            height: knobSize,
            borderRadius: knobSize / 2,
            padding: knobPadding
          },
          modes: {
            focus: {},
            disabled: {
              color: theme.color.fillNeutralDisabled,
              colorChecked: theme.color.fillInverseDisabled
            }
          },
          tones: {
            inverse: {
              color: theme.color.fillInverse,
              colorChecked: theme.color.fillNeutral,
              disabled: {
                color: theme.color.fillInverseDisabled,
                colorChecked: theme.color.fillNeutralDisabled
              }
            },
            brand: {
              color: theme.color.fillBrand,
              colorChecked: theme.color.fillInverse,
              disabled: {
                color: theme.color.fillNeutralDisabled,
                colorChecked: theme.color.fillInverseDisabled
              }
            }
          },
          themeStyles: themeStyles
        };
        makeComponentStyles(container);
        makeComponentStyles(knob);
        var fpsStyle = {
          color: 255,
          height: 180,
          width: 330,
          x: 1900,
          y: 6,
          mountX: 1,
          alpha: 0.8,
          zIndex: 100
        };
        var fpsLabel = {
          x: 10,
          fontSize: 20,
          textColor: 4143380223
        };
        var fpsValue = {
          fontSize: 22,
          textColor: 4143380223
        };
        var _createSignal25 = createSignal(0),
          _createSignal26 = _slicedToArray(_createSignal25, 2),
          fps = _createSignal26[0],
          setFps = _createSignal26[1];
        var _createSignal27 = createSignal(0),
          _createSignal28 = _slicedToArray(_createSignal27, 2),
          avgFps = _createSignal28[0],
          setAvgFps = _createSignal28[1];
        var _createSignal29 = createSignal(99),
          _createSignal30 = _slicedToArray(_createSignal29, 2),
          minFps = _createSignal30[0],
          setMinFps = _createSignal30[1];
        var _createSignal31 = createSignal(0),
          _createSignal32 = _slicedToArray(_createSignal31, 2),
          maxFps = _createSignal32[0],
          setMaxFps = _createSignal32[1];
        var _createSignal33 = createSignal(""),
          _createSignal34 = _slicedToArray(_createSignal33, 2),
          criticalThresholdSignal = _createSignal34[0],
          setCriticalThresholdSignal = _createSignal34[1];
        var _createSignal35 = createSignal(""),
          _createSignal36 = _slicedToArray(_createSignal35, 2),
          targetThresholdSignal = _createSignal36[0],
          setTargetThresholdSignal = _createSignal36[1];
        var _createSignal37 = createSignal(""),
          _createSignal38 = _slicedToArray(_createSignal37, 2),
          renderableMemUsedSignal = _createSignal38[0],
          setRenderableMemUsedSignal = _createSignal38[1];
        var _createSignal39 = createSignal(""),
          _createSignal40 = _slicedToArray(_createSignal39, 2),
          memUsedSignal = _createSignal40[0],
          setMemUsedSignal = _createSignal40[1];
        var _createSignal41 = createSignal(0),
          _createSignal42 = _slicedToArray(_createSignal41, 2),
          renderableTexturesLoadedSignal = _createSignal42[0],
          setRenderableTexturesLoadedSignal = _createSignal42[1];
        var _createSignal43 = createSignal(0),
          _createSignal44 = _slicedToArray(_createSignal43, 2),
          loadedTexturesSignal = _createSignal44[0],
          setLoadedTexturesSignal = _createSignal44[1];
        var count = 0;
        var totalFps = 0;
        var infoFontSize = 14;
        function bytesToMb(bytes) {
          return (bytes / 1024 / 1024).toFixed(2) + " Mb";
        }
        var calcFps = function calcFps(fps2) {
          if (!fps2) return;
          setFps(fps2);
          setMinFps(function (prev) {
            return Math.min(fps2, prev);
          });
          setMaxFps(function (prev) {
            return Math.max(fps2, prev);
          });
          totalFps += fps2;
          count++;
          setAvgFps(Math.round(totalFps / count));
        };
        function updateMemoryInfo(stage) {
          var memInfo = stage.txMemManager.getMemoryInfo();
          setCriticalThresholdSignal(bytesToMb(memInfo.criticalThreshold));
          setTargetThresholdSignal(bytesToMb(memInfo.targetThreshold));
          setRenderableMemUsedSignal(bytesToMb(memInfo.renderableMemUsed));
          setMemUsedSignal(bytesToMb(memInfo.memUsed));
          setRenderableTexturesLoadedSignal(memInfo.renderableTexturesLoaded);
          setLoadedTexturesSignal(memInfo.loadedTextures);
        }
        var frameCount = 0;
        function setupFPS(root) {
          root.renderer.on("fpsUpdate", function (target, fpsData) {
            var fps2 = typeof fpsData === "number" ? fpsData : fpsData.fps;
            if (fps2 > 5) {
              calcFps(fps2);
              if (frameCount % 10 === 0) {
                updateMemoryInfo(target.stage);
                frameCount = 0;
              }
              frameCount++;
            }
          });
        }
        var FPSCounter = function FPSCounter(props) {
          return createComponent(View, mergeProps(props, {
            style: fpsStyle,
            get children() {
              return [createComponent(View, {
                y: 6,
                get children() {
                  return [createComponent(Text$4, {
                    style: fpsLabel,
                    children: "FPS:"
                  }), createComponent(Text$4, {
                    style: fpsValue,
                    x: 90,
                    get children() {
                      return fps().toString();
                    }
                  })];
                }
              }), createComponent(View, {
                y: 6,
                x: 160,
                get children() {
                  return [createComponent(Text$4, {
                    style: fpsLabel,
                    children: "AVG:"
                  }), createComponent(Text$4, {
                    style: fpsValue,
                    x: 100,
                    get children() {
                      return avgFps().toString();
                    }
                  })];
                }
              }), createComponent(View, {
                x: 0,
                y: 26,
                get children() {
                  return [createComponent(Text$4, {
                    style: fpsLabel,
                    children: "MIN:"
                  }), createComponent(Text$4, {
                    style: fpsValue,
                    x: 90,
                    get children() {
                      return minFps().toString();
                    }
                  })];
                }
              }), createComponent(View, {
                x: 160,
                y: 26,
                get children() {
                  return [createComponent(Text$4, {
                    style: fpsLabel,
                    children: "MAX:"
                  }), createComponent(Text$4, {
                    style: fpsValue,
                    x: 100,
                    get children() {
                      return maxFps().toString();
                    }
                  })];
                }
              }), createComponent(View, {
                display: "flex",
                flexDirection: "column",
                y: 58,
                gap: 4,
                get children() {
                  return [createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "criticalThreshold:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return criticalThresholdSignal();
                        }
                      })];
                    }
                  }), createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "targetThreshold:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return targetThresholdSignal();
                        }
                      })];
                    }
                  }), createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "renderableMemUsed:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return renderableMemUsedSignal();
                        }
                      })];
                    }
                  }), createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "memUsed:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return memUsedSignal();
                        }
                      })];
                    }
                  }), createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "renderableTexturesLoaded:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return renderableTexturesLoadedSignal().toString();
                        }
                      })];
                    }
                  }), createComponent(View, {
                    height: infoFontSize,
                    get children() {
                      return [createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        children: "loadedTextures:"
                      }), createComponent(Text$4, {
                        fontSize: infoFontSize,
                        style: fpsLabel,
                        x: 230,
                        get children() {
                          return loadedTexturesSignal().toString();
                        }
                      })];
                    }
                  })];
                }
              })];
            }
          }));
        };
        var App = function App(props) {
          useFocusManager({
            Announcer: ["a"],
            Menu: ["m"],
            Escape: ["Escape", 27],
            Backspace: ["Backspace", 8],
            Left: ["ArrowLeft", 37],
            Right: ["ArrowRight", 39],
            Up: ["ArrowUp", 38],
            Down: ["ArrowDown", 40],
            Enter: ["Enter", 13]
          }, {
            userKeyHoldMap: {
              EnterHold: ["Enter", 13],
              BackHold: ["b", 66]
            },
            holdThreshold: 1e3
          });
          var announcer = useAnnouncer();
          announcer.enabled = false;
          var navigate = useNavigate();
          var navDrawer, lastFocused;
          setupFPS({
            renderer: renderer$2
          });
          function focusNavDrawer() {
            if (navDrawer.states.has("focus")) {
              return false;
            }
            lastFocused = activeElement();
            return navDrawer.setFocus();
          }
          var _createSignal45 = createSignal(true),
            _createSignal46 = _slicedToArray(_createSignal45, 2),
            showWidgets = _createSignal46[0],
            setShowWidgets = _createSignal46[1];
          var location = useLocation();
          var showOnPaths = ["/browse", "/entity"];
          createEffect(function () {
            var currentPath = location.pathname;
            var matchesPartial = showOnPaths.some(function (path) {
              return currentPath.startsWith(path);
            });
            if (currentPath === "/") {
              matchesPartial = true;
            }
            setShowWidgets(matchesPartial);
          });
          var _createSignal47 = createSignal(),
            _createSignal48 = _slicedToArray(_createSignal47, 2),
            lastKey = _createSignal48[0],
            setLastKey = _createSignal48[1];
          var _createSignal49 = createSignal(),
            _createSignal50 = _slicedToArray(_createSignal49, 2),
            lastError = _createSignal50[0],
            setLastError = _createSignal50[1];
          var keyPressHandler = function keyPressHandler(e) {
            setLastKey("Last key: ".concat(e.key, ", Code: ").concat(e.keyCode));
          };
          document.addEventListener("keydown", keyPressHandler);
          var displayError = function displayError(e) {
            setLastError(function (p) {
              return (p || "") + "\n" + e.message;
            });
          };
          document.addEventListener("onerror", displayError);
          onCleanup(function () {
            document.removeEventListener("onerror", displayError);
            document.removeEventListener("keydown", keyPressHandler);
          });
          var pageContainer;
          return createComponent(View, {
            ref: function ref(r$) {
              var _ref$ = window.APP;
              typeof _ref$ === "function" ? _ref$(r$) : window.APP = r$;
            },
            onAnnouncer: function onAnnouncer() {
              return announcer.enabled = !announcer.enabled;
            },
            onLast: function onLast() {
              return history.back();
            },
            onMenu: function onMenu() {
              return navigate("/");
            },
            style: {
              width: 1920,
              height: 1080
            },
            onBackspace: focusNavDrawer,
            onLeft: focusNavDrawer,
            onRight: function onRight() {
              return navDrawer.states.has("focus") && (lastFocused || pageContainer).setFocus();
            },
            get children() {
              return [createComponent(Background, {}), createComponent(FPSCounter, {
                mountX: 1,
                x: 1910,
                y: 10,
                get alpha() {
                  return showWidgets() ? 1 : 0.01;
                }
              }), createComponent(View, {
                mountX: 1,
                width: 330,
                height: 28,
                x: 1910,
                y: 190,
                color: 255,
                get hidden() {
                  return !showWidgets();
                },
                get children() {
                  return createComponent(Text$4, {
                    fontSize: 20,
                    y: 4,
                    x: 4,
                    get children() {
                      return lastKey();
                    }
                  });
                }
              }), createComponent(Text$4, {
                x: 270,
                y: 20,
                fontSize: 24,
                contain: "width",
                width: 800,
                get children() {
                  return lastError();
                }
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$2 = pageContainer;
                  typeof _ref$2 === "function" ? _ref$2(r$) : pageContainer = r$;
                },
                forwardFocus: 0,
                get children() {
                  return props.children;
                }
              }), createComponent(NavDrawer, {
                ref: function ref(r$) {
                  var _ref$3 = navDrawer;
                  typeof _ref$3 === "function" ? _ref$3(r$) : navDrawer = r$;
                },
                focusPage: function focusPage() {
                  return lastFocused.setFocus();
                },
                get showWidgets() {
                  return showWidgets();
                }
              })];
            }
          });
        };
        var params = new URLSearchParams(window.location.search);
        var roundPoster = params.get("roundPoster") !== "false";
        var styles = exports("G", {
          Page: {
            width: 1920,
            height: 1080
          },
          headlineText: {
            width: 1200,
            height: 240,
            x: 360,
            // lineHeight: 170, // TODO: Add back when lineHeight is supported
            y: 455,
            contain: "both",
            fontSize: 66,
            textAlign: "center"
          },
          headlineSubText: {
            width: 960,
            height: 170,
            // lineHeight: 170, // TODO: Add back when lineHeight is supported
            x: 530,
            y: 655,
            contain: "both",
            fontSize: 48,
            textAlign: "center"
          },
          itemsContainer: {
            width: theme.layout.screenW,
            height: 800,
            y: 560,
            x: 0,
            zIndex: 2
          },
          Thumbnail: {
            borderRadius: roundPoster ? 16 : 0,
            width: 185,
            height: 278,
            scale: 1,
            zIndex: 2,
            transition: {
              scale: {
                duration: 250,
                easing: "ease-in-out"
              }
            },
            border: {
              width: 0,
              color: 0
            },
            $focus: {
              scale: 1.1,
              border: {
                color: 0x2C4F7CE8,
                width: 8
              }
            }
          },
          FocusRing: {
            borderRadius: 16,
            width: 194,
            height: 286,
            y: -5,
            x: -5,
            zIndex: -1
          },
          FPS: {
            color: 255,
            height: 42,
            width: 140,
            x: 20,
            y: 20,
            zIndex: 100
          },
          FPSLabel: {
            x: 10,
            y: 0,
            fontSize: 36,
            textColor: 0xFFFFFFFF
          },
          FPSValue: {
            x: 90,
            y: 0,
            fontSize: 36,
            textColor: 0xFFFFFFFF
          },
          showHeadline: {
            x: 70,
            y: 20
          },
          headlineBlur: {
            width: 1920,
            height: 150,
            x: 0,
            y: 0,
            zIndex: 14,
            alpha: 0.9,
            color: 0x000000FF
          },
          RowTitle: {
            height: 60,
            width: 300,
            marginBottom: -40,
            fontSize: 36,
            color: 0xF0F0F0FF,
            zIndex: 2
          },
          Row: {
            display: "flex",
            justifyContent: "spaceBetween",
            height: 300
          },
          Column: {
            display: "flex",
            flexDirection: "column",
            justifyContent: "flexStart",
            flexBoundary: "contain",
            gap: 64,
            width: theme.layout.screenW - 2 * theme.layout.marginX,
            x: theme.layout.marginX + theme.layout.gutterX,
            y: 48,
            transition: {
              y: {
                duration: 250,
                easing: "ease-in-out"
              }
            },
            zIndex: 2
          },
          Rect: {
            width: 250,
            height: 100,
            y: 10,
            x: 300,
            color: 0x0000FFFF
          },
          peopleBio: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
            fontFamily: "Roboto",
            fontWeight: "normal",
            contain: "both",
            width: 780,
            height: 340
          })
        });
        var Button$1 = {
          width: 300,
          height: 90,
          color: 0x323232CC,
          $focus: {
            color: 0xFFFFFFFF
          }
        };
        var TopBar = {
          color: 0x00A699FF,
          height: 8,
          y: 2,
          x: -4,
          width: Button$1.width + 8
        };
        var ButtonText = {
          fontSize: 26,
          lineHeight: Button$1.height,
          contain: "width",
          textAlign: "center",
          height: Button$1.height,
          width: Button$1.width,
          color: 0xFFFFFFFF,
          $focus: {
            color: 0x000000FF
          }
        };
        var buttonStyles = {
          container: Button$1,
          topBar: TopBar,
          text: ButtonText
        };
        var MaterialButton = {
          width: 386,
          height: 136,
          color: 0x715CABFF,
          $focus: {
            color: 0x5A39A2FF
          },
          $disabled: {
            color: 0x291D43FF
          }
        };
        var MaterialButtonText = exports("M", {
          fontSize: 32,
          contain: "width",
          textAlign: "center",
          mountY: -0.35,
          color: 0xFFFFFFFF,
          height: MaterialButton.height,
          width: MaterialButton.width,
          // lineHeight: MaterialButton.height, // TODO: Add back when lineHeight is supported
          $focus: {
            fontSize: 40
          },
          $disabled: {
            color: 0x909090FF
          }
        });
        function Thumbnail(props) {
          return createComponent(View, mergeProps(props, {
            get src() {
              return props.item.src;
            },
            get item() {
              return props.item;
            },
            get style() {
              return styles.Thumbnail;
            }
          }));
        }
        function TileRow(props) {
          return createComponent(Row, mergeProps(props, {
            get style() {
              return styles.Row;
            },
            get children() {
              return createComponent(Index, {
                get each() {
                  return props.items;
                },
                children: function children(item) {
                  return createComponent(Thumbnail, {
                    get item() {
                      return item();
                    }
                  });
                }
              });
            }
          }));
        }
        function Button(props) {
          return createComponent(View, mergeProps(props, {
            forwardStates: true,
            get style() {
              return buttonStyles.container;
            },
            get children() {
              return createComponent(Text$4, {
                get style() {
                  return buttonStyles.text;
                },
                get children() {
                  return props.children;
                }
              });
            }
          }));
        }
        var heroTransition = {
          duration: 300,
          easing: "cubic-bezier(0.20, 1.00, 0.80, 1.00)"
        };
        var posterStyles = {
          width: 185,
          height: 278,
          scale: 1,
          zIndex: 2,
          color: 0xB0B0B0FF,
          //borderRadius: 8,
          transition: {
            scale: {
              duration: 200,
              easing: "linear"
            }
          },
          $focus: {
            scale: 1.1,
            color: 0xFFFFFFFF
          }
        };
        function Poster(props) {
          return createComponent(View, mergeProps({
            get src() {
              var _props$item;
              return (_props$item = props.item) === null || _props$item === void 0 ? void 0 : _props$item.src;
            },
            get backdrop() {
              var _props$item2;
              return (_props$item2 = props.item) === null || _props$item2 === void 0 ? void 0 : _props$item2.backdrop;
            }
          }, props, {
            onFail: function onFail(node) {
              return node.src = "failback.png";
            },
            style: posterStyles
          }));
        }
        var heroStyles = {
          width: 1280,
          height: 720,
          scale: 1,
          zIndex: 2,
          colorTop: 0xFFFFFFFF,
          colorBottom: 0x000000FF,
          //borderRadius: 8,
          transition: {
            scale: heroTransition
          },
          $focus: {
            scale: 1.05
          }
        };
        var heroTextStyles = {
          fontFamily: "Raleway",
          contain: "width"
        };
        function Hero(props) {
          var _createSignal51 = createSignal(false),
            _createSignal52 = _slicedToArray(_createSignal51, 2),
            hasFocus = _createSignal52[0],
            setHasFocus = _createSignal52[1];
          return createComponent(View, mergeProps(props, {
            get src() {
              return props.item.backdrop;
            },
            style: heroStyles,
            onFocusChanged: setHasFocus,
            forwardStates: true,
            get children() {
              return createComponent(View, {
                transition: {
                  alpha: heroTransition
                },
                get alpha() {
                  return hasFocus() ? 1 : 0;
                },
                get children() {
                  return [createComponent(View, {
                    width: 185,
                    height: 278,
                    x: 54,
                    y: 220,
                    get src() {
                      return props.item.src;
                    }
                  }), createComponent(Text$4, {
                    y: 520,
                    x: 54,
                    fontSize: 64,
                    width: 1e3,
                    maxLines: 1,
                    style: heroTextStyles,
                    get children() {
                      return props.item.title;
                    }
                  }), createComponent(Text$4, {
                    y: 620,
                    x: 60,
                    fontSize: 21,
                    width: 1e3,
                    maxLines: 2,
                    lineHeight: 36,
                    color: 0xCCCCCCFF,
                    style: heroTextStyles,
                    get children() {
                      return props.item.overview;
                    }
                  })];
                }
              });
            }
          }));
        }
        var BlockStyle = {
          alpha: 0.85,
          border: {
            width: 0,
            color: 0x000000FF
          },
          $focus: {
            border: {
              width: 4,
              color: 0xFFFFFFFF
            },
            alpha: 1
          }
        };
        function Block(props) {
          return createComponent(View, mergeProps(props, {
            width: 100,
            height: 100,
            style: BlockStyle,
            get color() {
              return props.color || 0xE0E0E0FF;
            }
          }));
        }
        function createInfiniteScroll(fetcher) {
          var _createSignal53 = createSignal([]),
            _createSignal54 = _slicedToArray(_createSignal53, 2),
            pages = _createSignal54[0],
            setPages = _createSignal54[1];
          var _createSignal55 = createSignal(1),
            _createSignal56 = _slicedToArray(_createSignal55, 2),
            page = _createSignal56[0],
            setPage = _createSignal56[1];
          var _createSignal57 = createSignal(false),
            _createSignal58 = _slicedToArray(_createSignal57, 2),
            end = _createSignal58[0],
            setEnd = _createSignal58[1];
          var _createResource3 = createResource(page, fetcher),
            _createResource4 = _slicedToArray(_createResource3, 1),
            contents = _createResource4[0];
          createComputed(function () {
            var content = contents();
            if (!content) return;
            batch(function () {
              if (content.length === 0) setEnd(true);
              setPages(function (p) {
                return [].concat(_toConsumableArray(p), _toConsumableArray(content));
              });
            });
          });
          return {
            pages: pages,
            page: page,
            setPage: setPage,
            setPages: setPages,
            end: end,
            setEnd: setEnd
          };
        }
        var blockWidth = 900;
        var ContentBlockStyle = {
          display: "flex",
          flexDirection: "column",
          flexBoundary: "fixed",
          width: blockWidth,
          height: 220,
          gap: 16
        };
        var HeadlineStyles = _objectSpread(_objectSpread({}, theme.typography.display2), {}, {
          fontFamily: "Roboto",
          fontWeight: 700,
          maxLines: 1,
          width: blockWidth,
          contain: "width"
        });
        var Headline = function Headline(props) {
          return createComponent(Text$4, mergeProps(props, {
            style: HeadlineStyles
          }));
        };
        var DescriptionStyles = _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
          fontFamily: "Roboto",
          fontWeight: 400,
          lineHeight: 32,
          width: blockWidth,
          maxLines: 3,
          contain: "width"
        });
        var BadgeStyle = {
          fontSize: 16,
          lineHeight: 20,
          marginLeft: 13,
          marginRight: 13
        };
        var Description = function Description(props) {
          return createComponent(Text$4, mergeProps(props, {
            style: DescriptionStyles,
            get children() {
              return props.children;
            }
          }));
        };
        var Badge = function Badge(props) {
          return createComponent(View, mergeProps(props, {
            style: {
              color: "0x00000099",
              borderRadius: 8,
              border: {
                width: 2,
                color: "0xffffffff"
              },
              display: "flex",
              height: 36
            },
            get children() {
              return createComponent(Text$4, {
                lineHeight: 36,
                style: BadgeStyle,
                get children() {
                  return props.children;
                }
              });
            }
          }));
        };
        var MetaTextStyle = _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          fontFamily: "Roboto",
          fontWeight: 400
        });
        var Metadata = function Metadata(props) {
          return createComponent(View, {
            style: {
              display: "flex",
              flexDirection: "row",
              gap: 18,
              width: blockWidth,
              height: 48
            },
            get children() {
              return [createComponent(View, {
                y: -4,
                src: "./assets/stars.png",
                width: 188,
                height: 31
              }), createComponent(View, {
                y: -4,
                flexItem: false,
                clipping: true,
                get width() {
                  return 188 * props.voteAverage / 10;
                },
                height: 31,
                get children() {
                  return createComponent(View, {
                    src: "./assets/stars-full.png",
                    width: 188,
                    height: 31
                  });
                }
              }), createComponent(Text$4, {
                style: MetaTextStyle,
                get children() {
                  return [memo(function () {
                    return props.voteCount;
                  }), " reviews"];
                }
              }), createComponent(Text$4, {
                style: MetaTextStyle,
                get children() {
                  return props.metaText;
                }
              }), createComponent(For, {
                get each() {
                  return props.badges;
                },
                children: function children(item) {
                  return createComponent(Badge, {
                    y: -5,
                    children: item
                  });
                }
              })];
            }
          });
        };
        var ContentBlock = exports("r", function (props) {
          return createComponent(View, mergeProps({
            id: "contentBlock",
            style: ContentBlockStyle
          }, props, {
            get children() {
              return [createComponent(Headline, {
                get children() {
                  return props.content.title;
                }
              }), createComponent(Description, {
                get children() {
                  return props.content.description;
                }
              }), createComponent(Show, {
                get when() {
                  return props.content.voteCount;
                },
                get children() {
                  return createComponent(Metadata, {
                    get metaText() {
                      return props.content.metaText;
                    },
                    get badges() {
                      return props.content.badges;
                    },
                    get voteCount() {
                      return props.content.voteCount;
                    },
                    get voteAverage() {
                      return props.content.voteAverage;
                    }
                  });
                }
              })];
            }
          }));
        });
        var Browse = function Browse(props) {
          var _createSignal59 = createSignal(0),
            _createSignal60 = _slicedToArray(_createSignal59, 2),
            columnY = _createSignal60[0],
            setcolumnY = _createSignal60[1];
          var preload = usePreloadRoute();
          var _createSignal61 = createSignal({}),
            _createSignal62 = _slicedToArray(_createSignal61, 2),
            heroContent = _createSignal62[0],
            setHeroContent = _createSignal62[1];
          var navigate = useNavigate();
          var firstRun = true;
          var provider = createMemo(function () {
            return createInfiniteScroll(props.data());
          });
          var delayedBackgrounds = debounce(function (img) {
            return setGlobalBackground(img);
          }, 800);
          var delayedHero = debounce(function (content) {
            return setHeroContent(content || {});
          }, 600);
          createEffect(on(activeElement, function (elm) {
            if (!elm) return;
            var item = elm.item || {};
            if (firstRun) {
              if (item.backdrop) {
                setGlobalBackground(item.backdrop);
              }
              if (item.heroContent) {
                setHeroContent(item.heroContent);
              }
              preload("/browse/tv", {
                preloadData: true
              });
              preload("/browse/movie", {
                preloadData: true
              });
              firstRun = false;
              return;
            }
            if (item.href) {
              preload(item.href, {
                preloadData: true
              });
            }
            if (item.backdrop) {
              delayedBackgrounds(item.backdrop);
            }
            if (item.heroContent) {
              delayedHero(item.heroContent);
            }
          }, {
            defer: true
          }));
          function onRowFocus() {
            this.children[this.selected || 0].setFocus();
            setcolumnY((this.y || 0) * -1 + 24);
            var numPages = provider().pages().length;
            this.parent.selected = this.parent.children.indexOf(this);
            if (numPages === 0 || this.parent.selected && this.parent.selected >= numPages - 2) {
              provider().setPage(function (p) {
                return p + 1;
              });
            }
          }
          function onEnter() {
            var _entity$item;
            this.display = "flex";
            var entity = this.children.find(function (c) {
              return c.states.has("focus");
            });
            assertTruthy(entity && ((_entity$item = entity.item) === null || _entity$item === void 0 ? void 0 : _entity$item.href));
            navigate(entity.item.href);
            return true;
          }
          return createComponent(Show, {
            get when() {
              return provider().pages().length;
            },
            get children() {
              return [createComponent(ContentBlock, {
                y: 360,
                x: 162,
                get content() {
                  return heroContent();
                }
              }), createComponent(View, {
                clipping: true,
                get style() {
                  return styles.itemsContainer;
                },
                get children() {
                  return createComponent(Column, {
                    id: "BrowseColumn",
                    plinko: true,
                    announce: "All Trending - Week",
                    get y() {
                      return columnY();
                    },
                    scroll: "none",
                    autofocus: true,
                    get style() {
                      return styles.Column;
                    },
                    get children() {
                      return createComponent(For, {
                        get each() {
                          return provider().pages();
                        },
                        children: function children(items) {
                          return createComponent(TileRow, {
                            items: items,
                            width: 1620,
                            onFocus: onRowFocus,
                            onEnter: onEnter
                          });
                        }
                      });
                    }
                  });
                }
              })];
            }
          });
        };
        var TMDB = function TMDB(props) {
          var _createSignal63 = createSignal({}),
            _createSignal64 = _slicedToArray(_createSignal63, 2),
            heroContent = _createSignal64[0],
            setHeroContent = _createSignal64[1];
          var contentBlock,
            solidLogo,
            firstRun = true;
          var delayedBackgrounds = debounce(setGlobalBackground, 800);
          var delayedHero = debounce(function (content) {
            return setHeroContent(content || {});
          }, 600);
          createEffect(on(activeElement, function (elm) {
            if (!elm) return;
            if (firstRun) {
              elm.backdrop && setGlobalBackground(elm.backdrop);
              elm.heroContent && setHeroContent(elm.heroContent);
              firstRun = false;
            } else {
              elm.backdrop && delayedBackgrounds(elm.backdrop);
              elm.heroContent && delayedHero(elm.heroContent);
            }
          }, {
            defer: true
          }));
          return [createComponent(View, {
            ref: function ref(r$) {
              var _ref$ = solidLogo;
              typeof _ref$ === "function" ? _ref$(r$) : solidLogo = r$;
            },
            width: 300,
            height: 150,
            x: 162,
            y: 80,
            zIndex: 105,
            get children() {
              return [createComponent(Text$4, {
                x: 80,
                fontSize: 28,
                color: 4143380121,
                children: "Built With:"
              }), createComponent(View, {
                y: 32,
                src: "./assets/solidWord.png",
                width: 280,
                height: 52
              }), createComponent(View, {
                x: 0,
                y: 110,
                src: "./assets/tmdb.png",
                width: 80,
                height: 41
              }), createComponent(Text$4, {
                x: 90,
                y: 110,
                contain: "width",
                width: 160,
                fontSize: 12,
                color: 4143380121,
                children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
              })];
            }
          }), createComponent(ContentBlock, {
            ref: function ref(r$) {
              var _ref$2 = contentBlock;
              typeof _ref$2 === "function" ? _ref$2(r$) : contentBlock = r$;
            },
            y: 300,
            x: 162,
            get content() {
              return heroContent();
            }
          })];
        };
        var Destroy = function Destroy(props) {
          var _createSignal65 = createSignal(),
            _createSignal66 = _slicedToArray(_createSignal65, 2),
            heroContent = _createSignal66[0],
            setHeroContent = _createSignal66[1];
          var _createSignal67 = createSignal(0),
            _createSignal68 = _slicedToArray(_createSignal67, 2),
            heroIndex = _createSignal68[0],
            setHeroIndex = _createSignal68[1];
          onMount(function () {
            return setGlobalBackground(0x333333FF);
          });
          createEffect(on([props.data.heroRow.items, heroIndex], function (_ref56) {
            var _ref57 = _slicedToArray(_ref56, 2),
              heros = _ref57[0],
              index = _ref57[1];
            if (heros) setHeroContent(heros[index]);
            if (heros && index < heros.length - 1) {
              var img = new Image();
              img.crossOrigin = "anonymous";
              img.src = heros[index + 1].backdrop;
            }
          }));
          function onDown() {
            if (heroIndex() >= 19) return false;
            setHeroIndex(function (p) {
              return p + 1;
            });
          }
          function onUp() {
            if (heroIndex() === 0) return false;
            setHeroIndex(function (p) {
              return p - 1;
            });
            return true;
          }
          function animateOut(node) {
            return node.animate({
              y: 200,
              alpha: 0
            }, {
              duration: 500,
              easing: "ease-in-out"
            }).start().waitUntilStopped();
          }
          function animateIn(node) {
            node.alpha = 0;
            node.y = -100;
            return node.animate({
              y: 0,
              alpha: 1
            }, {
              duration: 500,
              easing: "ease-in-out"
            }).start().waitUntilStopped();
          }
          return createComponent(View, {
            x: 300,
            y: 200,
            onDown: onDown,
            onUp: onUp,
            get children() {
              return [createComponent(View, {
                src: "assets/up.svg",
                width: 350,
                height: 200,
                x: 450,
                y: -200,
                get rotation() {
                  return Math.PI;
                }
              }), createComponent(Show, {
                get when() {
                  return heroContent();
                },
                keyed: true,
                get children() {
                  return createComponent(Hero, {
                    id: "Hero",
                    autofocus: true,
                    onDestroy: animateOut,
                    onCreate: animateIn,
                    get item() {
                      return heroContent();
                    },
                    get title() {
                      return heroContent().title;
                    }
                  });
                }
              })];
            }
          });
        };
        var API_KEY_V4 = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZDE4YjEwMTA0YjdiZTlkNjFiMWYwYjVlMGEwNzM2OCIsInN1YiI6IjYwZTVjMTdlNGNhNjc2MDA3NTA4Njc3MSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.D_nqH9kd-bhhWzeVsTDPYhHnsUaNAuyAa6YATmKHqsA";
        var API_BASE = "https://api.themoviedb.org/3";
        var tmdbConfig;
        var baseImageUrl;
        var basePosterSize = "w185";
        var defaultFetchParams = {
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + API_KEY_V4
          }
        };
        function getImageUrl(path) {
          var posterSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : basePosterSize;
          return baseImageUrl + posterSize + path;
        }
        function get(path) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (tmdbConfig) {
            return _get(path, params);
          } else {
            return loadConfig().then(function () {
              return _get(path, params);
            });
          }
        }
        function _get(path) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return fetch(API_BASE + path, _objectSpread(_objectSpread({}, defaultFetchParams), params)).then(function (r) {
            return r.json();
          });
        }
        function loadConfig() {
          return _get("/configuration").then(function (data) {
            var _data$images;
            tmdbConfig = data;
            baseImageUrl = (_data$images = data.images) === null || _data$images === void 0 ? void 0 : _data$images.secure_base_url;
            return data;
          });
        }
        var api = exports("K", {
          get: get,
          loadConfig: loadConfig
        });
        function truncateString(str, maxLength) {
          if (str.length > maxLength) {
            return str.substring(0, maxLength - 3) + "...";
          }
          return str;
        }
        function chunkArray(array) {
          var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
          var result = [];
          for (var i = 0, j = array.length; i < j; i += size) {
            result.push(array.slice(i, i + size));
          }
          return result;
        }
        function convertItemsToTiles() {
          var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return items.map(function (item) {
            return {
              src: getImageUrl(item.poster_path || item.profile_path),
              tileSrc: getImageUrl(item.backdrop_path || item.profile_path, "w300"),
              backdrop: getImageUrl(item.backdrop_path, "w1280"),
              href: "/entity/".concat(item.media_type || "people", "/").concat(item.id),
              shortTitle: truncateString(item.title || item.name, 30),
              title: item.title || item.name,
              overview: item.overview,
              item: item,
              entityInfo: {
                type: item.media_type || "people",
                id: item.id
              },
              heroContent: {
                title: item.title || item.name,
                description: item.overview
              }
            };
          });
        }
        var handleResults = function handleResults(response) {
          return response.then(function (_ref58) {
            var results = _ref58.results;
            var filteredItems = results.filter(function (r) {
              return !r.adult;
            });
            return convertItemsToTiles(filteredItems);
          });
        };
        var fetchPopular = function fetchPopular(type) {
          return handleResults(api.get("/".concat(type, "/popular")));
        };
        var genreListCache;
        var fetchGenreMovies = function fetchGenreMovies(genres) {
          var genreList = genreListCache || (genreListCache = api.get("/genre/movie/list"));
          var targetGenre = Array.isArray(genres) ? genres : [genres];
          return genreList.then(function (_ref59) {
            var genres2 = _ref59.genres;
            var targetGenreIds = [];
            genres2.forEach(function (item) {
              if (targetGenre.includes(item.name)) targetGenreIds.push(item.id);
            });
            return handleResults(api.get("/discover/movie?with_genres=".concat(targetGenreIds.join())));
          });
        };
        function destroyData() {
          var heroRow = {
            title: "Best Adventure and Action movies",
            items: createResource(function () {
              return fetchGenreMovies(["adventure", "action"]);
            })[0],
            type: "Hero",
            height: 800
          };
          return {
            heroRow: heroRow
          };
        }
        function tmdbData() {
          var rows = [];
          var popularMovies = createResource(function () {
            return fetchPopular("movie");
          });
          rows.push({
            title: "Popular Movies",
            items: popularMovies[0],
            setItems: popularMovies[1].mutate,
            type: "Poster",
            height: 328
          });
          rows.push({
            title: "Best Western movies",
            items: createResource(function () {
              return fetchGenreMovies(["Western"]);
            })[0],
            type: "Hero",
            height: 720
          });
          rows.push({
            title: "Best Comedy movies",
            items: createResource(function () {
              return fetchGenreMovies(["Comedy"]);
            })[0],
            type: "PosterTitle",
            height: 400
          });
          rows.push({
            title: "Popular TV shows",
            items: createResource(function () {
              return fetchPopular("tv");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          var heroRow = {
            title: "Best Adventure and Action movies",
            items: createResource(function () {
              return fetchGenreMovies(["adventure", "action"]);
            })[0],
            type: "Hero",
            height: 720
          };
          rows.push(heroRow);
          rows.push({
            title: "Best Documentaries",
            items: createResource(function () {
              return fetchGenreMovies("Documentary");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          rows.push({
            title: "Best Western movies 2",
            items: createResource(function () {
              return fetchGenreMovies("Western");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          return {
            rows: rows
          };
        }
        var NotFound = function NotFound() {
          return function () {
            var _el$ = createElement("node");
            setProp(_el$, "style", {
              width: 1920,
              height: 1080,
              color: 868483072
            });
            return _el$;
          }();
        };
        var basePath = "/solid-demo-app/";
        var fonts = [{
          type: "msdf",
          fontFamily: "Roboto",
          descriptors: {
            weight: 700
          },
          atlasDataUrl: basePath + "fonts/Roboto-Bold.msdf.json",
          atlasUrl: basePath + "fonts/Roboto-Bold.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Roboto",
          descriptors: {
            weight: 400
          },
          atlasDataUrl: basePath + "fonts/Roboto-Regular.msdf.json",
          atlasUrl: basePath + "fonts/Roboto-Regular.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Arial",
          descriptors: {
            weight: 500
          },
          atlasDataUrl: basePath + "fonts/Roboto-Regular.msdf.json",
          atlasUrl: basePath + "fonts/Roboto-Regular.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Raleway",
          descriptors: {
            weight: 800
          },
          atlasDataUrl: basePath + "fonts/Raleway-ExtraBold.msdf.json",
          atlasUrl: basePath + "fonts/Raleway-ExtraBold.msdf.png"
        }, {
          fontFamily: "Roboto",
          fontUrl: basePath + "fonts/Roboto-Regular.ttf"
        }];
        var cache = /* @__PURE__ */new Map();
        var leftoverTiles = /* @__PURE__ */new Map();
        function browseProvider(filter) {
          return function (pageIndex) {
            var url = "/trending/".concat(filter, "/week?page=").concat(pageIndex);
            if (cache.has(url)) {
              return cache.get(url);
            }
            var result = api.get(url).then(function (trending) {
              var results = trending.results.filter(function (r) {
                return !r.adult;
              });
              var tiles = (leftoverTiles.has(filter) ? leftoverTiles.get(filter) : []).concat(convertItemsToTiles(results));
              var chunks = chunkArray(tiles);
              if (chunks[chunks.length - 1].length < 7) {
                leftoverTiles.set(filter, chunks.pop());
              } else {
                leftoverTiles.delete(filter);
              }
              return chunks;
            });
            cache.set(url, result);
            return result;
          };
        }
        function browsePreload(_ref60) {
          var params = _ref60.params;
          return createMemo(function () {
            var provider = browseProvider(params.filter || "all");
            provider(1);
            return provider;
          });
        }
        function minutesToHMM(minutes) {
          var hours = Math.floor(minutes / 60);
          var remainingMinutes = minutes % 60;
          return hours + "h " + (remainingMinutes < 10 ? "0" : "") + remainingMinutes + "min";
        }
        function formatDate(dateString) {
          var parts = dateString.split("-");
          return parts[1] + "/" + parts[2] + "/" + parts[0];
        }
        function justYear(dateString) {
          var parts = (dateString === null || dateString === void 0 ? void 0 : dateString.split("-")) || [];
          return parts[0] || "";
        }
        function ensureItems(items, minCount) {
          var remainingCount = minCount - items.length;
          if (remainingCount > 0) {
            return items.concat(Array(remainingCount).fill({}));
          }
          return items;
        }
        function getRecommendations(_ref61) {
          var type = _ref61.type,
            id = _ref61.id;
          return api.get("/".concat(type, "/").concat(id, "/recommendations")).then(function (_ref62) {
            var results = _ref62.results;
            if (results.length) {
              return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
            }
            return api.get("/trending/".concat(type, "/week?page=1")).then(function (_ref63) {
              var results = _ref63.results;
              return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
            });
          });
        }
        function getCredits(_ref64) {
          var type = _ref64.type,
            id = _ref64.id;
          return api.get("/".concat(type, "/").concat(id, "/credits")).then(function (_ref65) {
            var cast = _ref65.cast;
            return ensureItems(convertItemsToTiles(cast.slice(0, 7)), 7);
          });
        }
        function getInfo(_ref66) {
          var type = _ref66.type,
            id = _ref66.id;
          var rt = type === "movie" ? {
            rtCrit: 86,
            rtFan: 92
          } : {};
          return api.get("/".concat(type, "/").concat(id)).then(function (data) {
            return _objectSpread({
              backgroundImage: getImageUrl(data.backdrop_path, "w1280"),
              heroContent: {
                title: data.title || data.name,
                description: data.overview,
                badges: ["HD", "CC"],
                voteAverage: data.vote_average,
                voteCount: data.vote_count,
                metaText: type === "movie" ? minutesToHMM(data.runtime) + "   " + formatDate(data.release_date) : "".concat(justYear(data.first_air_date), " - ").concat(justYear(data.last_air_date)),
                reviews: rt
              }
            }, data);
          });
        }
        function entityPreload(_ref67) {
          var params = _ref67.params,
            intent = _ref67.intent;
          var _createResource5 = createResource(function () {
              return _objectSpread({}, params);
            }, getInfo),
            _createResource6 = _slicedToArray(_createResource5, 1),
            entity = _createResource6[0];
          if (intent === "preload") {
            return;
          }
          var _createResource7 = createResource(function () {
              return _objectSpread({}, params);
            }, getCredits),
            _createResource8 = _slicedToArray(_createResource7, 1),
            credits = _createResource8[0];
          var _createResource9 = createResource(function () {
              return _objectSpread({}, params);
            }, getRecommendations),
            _createResource10 = _slicedToArray(_createResource9, 1),
            recommendations = _createResource10[0];
          return {
            entity: entity,
            credits: credits,
            recommendations: recommendations
          };
        }
        var Grid = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Grid-legacy-C7VnGQ0j.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var Loops = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Loops-legacy-Bz2LJoy7.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var Infinite = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Infinite-legacy-xHlhlJVE.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var TMDBGrid = lazy(function () {
          return __vitePreload(function () {
            return module.import('./TMDBGrid-legacy-tIrTcMnE.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var Portal = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Portal-legacy-NjIohLCh.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var TextPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Text-legacy-CQ6npCty.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var TextPosterPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./TextPoster-legacy-VhwSGK1c.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var CreatePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Create-legacy-I02EUefY.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var ViewportPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Viewport-legacy-DY5pYdkM.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var PositioningPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Positioning-legacy-BaOpq2ig.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var LayoutPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Layout-legacy-CwZJAtdR.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FocusBasicsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FocusBasics-legacy-BsqUqBju.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var KeyHandlingPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./KeyHandling-legacy-JpDLoPPS.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var TransitionsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Transitions-legacy-BLInKH51.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var ComponentsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Components-legacy-BBdteuX5.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FocusHandlingPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FocusHandling-legacy-DXSn84hD.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var GradientsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Gradients-legacy-DGOk086A.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FlexPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Flex-legacy-Ba9hXuqI.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FlexGrowPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexGrow-legacy-CvmCCh-A.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FlexSizePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexSize-legacy-BfCYzdla.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FlexColumnSizePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexColumnSize-legacy-DIfSyO74.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FlexColumnPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexColumn-legacy-BloTBJmF.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var ButtonsMaterialPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./ButtonsMaterial-legacy-Yd_Ku_TT.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var SuperFlexPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./SuperFlex-legacy-C_Qi5cbx.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var Entity = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Entity-legacy-T8NBrctf.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var People = lazy(function () {
          return __vitePreload(function () {
            return module.import('./People-legacy-G_7E-fcd.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var LoginPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Login-legacy-DBeLei-D.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var FireboltPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Firebolt-legacy-COSMOxAB.js');
          }, false ? __VITE_PRELOAD__ : undefined);
        });
        var urlParams = new URLSearchParams(window.location.search);
        var numImageWorkers = 3;
        var numWorkers = urlParams.get("numImageWorkers");
        var screenSize = urlParams.get("size") || "default";
        var rendererMode = urlParams.get("mode") || "webgl";
        var animationsEnabled = urlParams.get("animate") || "true";
        if (numWorkers) {
          numImageWorkers = parseInt(numWorkers);
        }
        var deviceLogicalPixelRatio = {
          "720": 0.666667,
          "1080": 1,
          "4k": 2,
          default: window.innerHeight / 1080
        }[screenSize];
        Config.debug = false;
        Config.animationsEnabled = animationsEnabled === "true";
        Config.fontSettings.fontFamily = "Roboto";
        Config.fontSettings.color = 4143380223;
        Config.fontSettings.fontSize = 32;
        Config.rendererOptions = {
          fpsUpdateInterval: 1e3,
          inspector: undefined,
          // textureMemory: {
          //   criticalThreshold: 80e6,
          // },
          numImageWorkers: numImageWorkers,
          // temp fix for renderer bug
          // Set the resolution based on window height
          // 720p = 0.666667, 1080p = 1, 1440p = 1.5, 2160p = 2
          deviceLogicalPixelRatio: deviceLogicalPixelRatio,
          devicePhysicalPixelRatio: 1,
          createImageBitmapSupport: "auto"
        };
        if (rendererMode === "canvas") {
          Config.rendererOptions.fontEngines = [CanvasTextRenderer];
          Config.rendererOptions.renderEngine = CanvasCoreRenderer;
        } else {
          Config.rendererOptions.fontEngines = [SdfTextRenderer];
          Config.rendererOptions.renderEngine = WebGlCoreRenderer;
        }
        var _createRenderer = createRenderer(),
          renderer = _createRenderer.renderer,
          render = _createRenderer.render;
        loadFonts(fonts);
        render(function () {
          return createComponent(HashRouter, {
            root: function root(props) {
              return createComponent(App, props);
            },
            get children() {
              return [createComponent(Route, {
                path: "",
                component: Browse,
                preload: browsePreload
              }), createComponent(Route, {
                path: "examples",
                component: Portal
              }), createComponent(Route, {
                path: "browse/:filter",
                component: Browse,
                preload: browsePreload
              }), createComponent(Route, {
                path: "tmdb",
                component: TMDB,
                preload: tmdbData
              }), createComponent(Route, {
                path: "loops",
                component: Loops,
                preload: tmdbData
              }), createComponent(Route, {
                path: "infinite",
                component: Infinite,
                preload: tmdbData
              }), createComponent(Route, {
                path: "tmdbgrid",
                component: TMDBGrid,
                preload: tmdbData
              }), createComponent(Route, {
                path: "destroy",
                component: Destroy,
                preload: destroyData
              }), createComponent(Route, {
                path: "grid",
                component: Grid
              }), createComponent(Route, {
                path: "text",
                component: TextPage
              }), createComponent(Route, {
                path: "firebolt",
                component: FireboltPage
              }), createComponent(Route, {
                path: "textposter",
                component: TextPosterPage
              }), createComponent(Route, {
                path: "login",
                component: LoginPage
              }), createComponent(Route, {
                path: "positioning",
                component: PositioningPage
              }), createComponent(Route, {
                path: "layout",
                component: LayoutPage
              }), createComponent(Route, {
                path: "focusbasics",
                component: FocusBasicsPage
              }), createComponent(Route, {
                path: "transitions",
                component: TransitionsPage
              }), createComponent(Route, {
                path: "components",
                component: ComponentsPage
              }), createComponent(Route, {
                path: "focushandling",
                component: FocusHandlingPage
              }), createComponent(Route, {
                path: "keyhandling",
                component: KeyHandlingPage
              }), createComponent(Route, {
                path: "gradients",
                component: GradientsPage
              }), createComponent(Route, {
                path: "flex",
                component: FlexPage
              }), createComponent(Route, {
                path: "create",
                component: CreatePage
              }), createComponent(Route, {
                path: "viewport",
                component: ViewportPage
              }), createComponent(Route, {
                path: "flexsize",
                component: FlexSizePage
              }), createComponent(Route, {
                path: "flexcolumnsize",
                component: FlexColumnSizePage
              }), createComponent(Route, {
                path: "flexcolumn",
                component: FlexColumnPage
              }), createComponent(Route, {
                path: "flexgrow",
                component: FlexGrowPage
              }), createComponent(Route, {
                path: "superflex",
                component: SuperFlexPage
              }), createComponent(Route, {
                path: "buttonsmaterial",
                component: ButtonsMaterialPage
              }), createComponent(Route, {
                path: "entity/people/:id",
                component: People
              }), createComponent(Route, {
                path: "entity/:type/:id",
                component: Entity,
                preload: entityPreload
              }), createComponent(Route, {
                path: "*all",
                component: NotFound
              })];
            }
          });
        });
      }
    };
  });
})();
