;
(function () {
  function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  function _superPropGet(t, o, e, r) { var p = _get2(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _get2() { return _get2 = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get2.apply(null, arguments); }
  function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
  function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
  function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
  function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
  function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
  function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
  function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2)); }, _regeneratorDefine2(e, r, n, t); }
  function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
  function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
  function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
  function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
  function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
  function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
  function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
  function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
  function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
  function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
  function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
  function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n3 = 0, F = function F() {}; return { s: F, n: function n() { return _n3 >= r.length ? { done: !0 } : { done: !1, value: r[_n3++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  System.register([], function (exports, module) {
    'use strict';

    return {
      execute: function execute() {
        var _resolvedGlobal$docum;
        var __vite_style__ = document.createElement('style');
        __vite_style__.textContent = "html,\nbody,\n* {\n  padding: 0;\n  margin: 0;\n}\nhtml,\nbody {\n  height: 100%;\n  overflow: hidden;\n}\nvideo {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2;\n  outline: none;\n}\n.center-element {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n/*$vite$:1*/";
        document.head.appendChild(__vite_style__);
        exports({
          $: chainFunctions,
          D: assertTruthy,
          F: For,
          G: combineStyles,
          H: onCleanup,
          I: Index,
          J: Block,
          K: untrack,
          L: LazyRow,
          M: createRoot,
          N: Dynamic,
          O: Button,
          P: Poster,
          S: Show,
          W: TileRow,
          Y: getImageUrl,
          Z: convertItemsToTiles,
          a: createSignal,
          a0: Switch,
          a1: Match,
          a2: LazyColumn,
          a3: TitleRow,
          a6: getOwner,
          a9: Suspense,
          b: createResource,
          d: createComputed,
          e: batch,
          f: createSelector,
          g: createEffect,
          h: hexColor,
          i: on,
          j: List,
          k: createMemo,
          o: onMount,
          y: useFocusStack,
          z: children
        });
        false              && function polyfill() {
          var relList = document.createElement("link").relList;
          if (relList && relList.supports && relList.supports("modulepreload")) return;
          var _iterator = _createForOfIteratorHelper(document.querySelectorAll("link[rel=\"modulepreload\"]")),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var link = _step.value;
              processPreload(link);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          new MutationObserver(function (mutations) {
            var _iterator2 = _createForOfIteratorHelper(mutations),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var mutation = _step2.value;
                if (mutation.type !== "childList") continue;
                var _iterator3 = _createForOfIteratorHelper(mutation.addedNodes),
                  _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var node = _step3.value;
                    if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }).observe(document, {
            childList: true,
            subtree: true
          });
          function getFetchOpts(link) {
            var fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";else fetchOpts.credentials = "same-origin";
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            var fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        }();
        var scriptRel = 'modulepreload';
        var assetsURL = function assetsURL(dep) {
          return "/solid-demo-app/" + dep;
        };
        var seen = {};
        var __vitePreload = function preload(baseModule, deps, importerUrl) {
          var promise = Promise.resolve();
          if (false              && deps && deps.length > 0) {
            var allSettled = function allSettled(promises$2) {
              return Promise.all(promises$2.map(function (p) {
                return Promise.resolve(p).then(function (value$1) {
                  return {
                    status: "fulfilled",
                    value: value$1
                  };
                }, function (reason) {
                  return {
                    status: "rejected",
                    reason: reason
                  };
                });
              }));
            };
            document.getElementsByTagName("link");
            var cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
            var cspNonce = (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta === null || cspNonceMeta === void 0 ? void 0 : cspNonceMeta.getAttribute("nonce"));
            promise = allSettled(deps.map(function (dep) {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              var isCss = dep.endsWith(".css");
              var cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
              if (document.querySelector("link[href=\"".concat(dep, "\"]").concat(cssSelector))) return;
              var link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) link.as = "script";
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) link.setAttribute("nonce", cspNonce);
              document.head.appendChild(link);
              if (isCss) return new Promise(function (res, rej) {
                link.addEventListener("load", res);
                link.addEventListener("error", function () {
                  return rej(/* @__PURE__ */new Error("Unable to preload CSS for ".concat(dep)));
                });
              });
            }));
          }
          function handlePreloadError(err$2) {
            var e$1 = new Event("vite:preloadError", {
              cancelable: true
            });
            e$1.payload = err$2;
            window.dispatchEvent(e$1);
            if (!e$1.defaultPrevented) throw err$2;
          }
          return promise.then(function (res) {
            var _iterator4 = _createForOfIteratorHelper(res || []),
              _step4;
            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var item = _step4.value;
                if (item.status !== "rejected") continue;
                handlePreloadError(item.reason);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
            return baseModule().catch(handlePreloadError);
          });
        };
        function createWebGLContext(canvas) {
          var forceWebGL2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var contextSpy = arguments.length > 2 ? arguments[2] : undefined;
          var config = {
            alpha: true,
            antialias: false,
            depth: false,
            stencil: true,
            desynchronized: false,
            // Disabled because it prevents Visual Regression Tests from working
            // failIfMajorPerformanceCaveat: true,
            powerPreference: "high-performance",
            premultipliedAlpha: true,
            preserveDrawingBuffer: false
          };
          var gl =
          // TODO: Remove this assertion once this issue is fixed in TypeScript
          // https://github.com/microsoft/TypeScript/issues/53614
          canvas.getContext(forceWebGL2 ? "webgl2" : "webgl", config) || canvas.getContext("experimental-webgl", config);
          if (!gl) {
            throw new Error("Unable to create WebGL context");
          }
          if (contextSpy) {
            return new Proxy(gl, {
              get: function get(target, prop) {
                var value = target[prop];
                if (typeof value === "function") {
                  contextSpy.increment(String(prop));
                  return value.bind(target);
                }
                return value;
              }
            });
          }
          return gl;
        }
        function assertTruthy(condition, message) {
          return;
        }
        function mergeColorProgress(rgba1, rgba2, p) {
          var r1 = Math.trunc(rgba1 >>> 24);
          var g1 = Math.trunc(rgba1 >>> 16 & 255);
          var b1 = Math.trunc(rgba1 >>> 8 & 255);
          var a1 = Math.trunc(rgba1 & 255);
          var r2 = Math.trunc(rgba2 >>> 24);
          var g2 = Math.trunc(rgba2 >>> 16 & 255);
          var b2 = Math.trunc(rgba2 >>> 8 & 255);
          var a2 = Math.trunc(rgba2 & 255);
          var r = Math.round(r2 * p + r1 * (1 - p));
          var g = Math.round(g2 * p + g1 * (1 - p));
          var b = Math.round(b2 * p + b1 * (1 - p));
          var a = Math.round(a2 * p + a1 * (1 - p));
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        function mergeColorAlpha(rgba, alpha) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 255;
          var b = rgba >>> 8 & 255;
          var a = Math.trunc((rgba & 255) * alpha);
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        var premultiplyRGB = true;
        function setPremultiplyMode(mode) {
          premultiplyRGB = mode === "webgl";
        }
        function mergeColorAlphaPremultiplied(rgba, alpha) {
          var flipEndianess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var newAlpha = (rgba & 255) / 255 * alpha;
          var rgbAlpha = premultiplyRGB ? newAlpha : 1;
          var r = Math.trunc((rgba >>> 24) * rgbAlpha);
          var g = Math.trunc((rgba >>> 16 & 255) * rgbAlpha);
          var b = Math.trunc((rgba >>> 8 & 255) * rgbAlpha);
          var a = Math.trunc(newAlpha * 255);
          if (flipEndianess) {
            return (a << 24 | b << 16 | g << 8 | r) >>> 0;
          }
          return (r << 24 | g << 16 | b << 8 | a) >>> 0;
        }
        function hasOwn(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        var isProductionEnvironment = true;
        var nextId = 1;
        function getNewId() {
          return nextId++;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * EventEmitter base class
         */
        var EventEmitter = /*#__PURE__*/function () {
          function EventEmitter() {
            _classCallCheck(this, EventEmitter);
            _defineProperty(this, "eventListeners", {});
          }
          return _createClass(EventEmitter, [{
            key: "on",
            value: function on(event, listener) {
              var listeners = this.eventListeners[event];
              if (!listeners) {
                listeners = [];
              }
              listeners.push(listener);
              this.eventListeners[event] = listeners;
            }
          }, {
            key: "off",
            value: function off(event, listener) {
              var listeners = this.eventListeners[event];
              if (!listeners) {
                return;
              }
              if (!listener) {
                delete this.eventListeners[event];
                return;
              }
              var index = listeners.indexOf(listener);
              if (index >= 0) {
                listeners.splice(index, 1);
              }
            }
          }, {
            key: "once",
            value: function once(event, listener) {
              var _this = this;
              var _onceListener = function onceListener(target, data) {
                _this.off(event, _onceListener);
                listener(target, data);
              };
              this.on(event, _onceListener);
            }
          }, {
            key: "emit",
            value: function emit(event, data) {
              var _this2 = this;
              var listeners = this.eventListeners[event];
              if (!listeners) {
                return;
              }
              _toConsumableArray(listeners).forEach(function (listener) {
                listener(_this2, data);
              });
            }
          }, {
            key: "removeAllListeners",
            value: function removeAllListeners() {
              this.eventListeners = {};
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TextureType;
        (function (TextureType) {
          TextureType[TextureType["generic"] = 0] = "generic";
          TextureType[TextureType["color"] = 1] = "color";
          TextureType[TextureType["image"] = 2] = "image";
          TextureType[TextureType["noise"] = 3] = "noise";
          TextureType[TextureType["renderToTexture"] = 4] = "renderToTexture";
          TextureType[TextureType["subTexture"] = 5] = "subTexture";
        })(TextureType || (TextureType = {}));
        /**
         * Represents a source of texture data for a CoreContextTexture.
         *
         * @remarks
         * Texture sources are used to populate a CoreContextTexture when that texture
         * is loaded. Texture data retrieved by the CoreContextTexture by the
         * `getTextureData` method. It's the responsibility of the concerete `Texture`
         * subclass to implement this method appropriately.
         */
        var Texture = /*#__PURE__*/function (_EventEmitter2) {
          // 2 seconds
          function Texture(txManager) {
            var _this3;
            _classCallCheck(this, Texture);
            _this3 = _callSuper(this, Texture);
            _defineProperty(_this3, "txManager", void 0);
            /**
             * The dimensions of the texture
             *
             * @remarks
             * Until the texture data is loaded for the first time the value will be
             * `null`.
             */
            _defineProperty(_this3, "_dimensions", null);
            _defineProperty(_this3, "_error", null);
            // aggregate state
            _defineProperty(_this3, "state", 'initial');
            _defineProperty(_this3, "renderableOwners", []);
            _defineProperty(_this3, "renderable", false);
            _defineProperty(_this3, "type", TextureType.generic);
            _defineProperty(_this3, "preventCleanup", false);
            _defineProperty(_this3, "ctxTexture", void 0);
            _defineProperty(_this3, "textureData", null);
            /**
             * Memory used by this texture in bytes
             *
             * @remarks
             * This is tracked by the TextureMemoryManager and updated when the texture
             * is loaded/freed. Set to 0 when texture is not loaded.
             */
            _defineProperty(_this3, "memUsed", 0);
            _defineProperty(_this3, "retryCount", 0);
            _defineProperty(_this3, "maxRetryCount", void 0);
            /**
             * Timestamp when texture was created (for startup grace period)
             */
            _defineProperty(_this3, "createdAt", Date.now());
            /**
             * Flag to track if grace period has expired to avoid repeated Date.now() calls
             */
            _defineProperty(_this3, "gracePeriodExpired", false);
            _this3.txManager = txManager;
            _this3.maxRetryCount = txManager.maxRetryCount;
            return _this3;
          }
          _inherits(Texture, _EventEmitter2);
          return _createClass(Texture, [{
            key: "dimensions",
            get: function get() {
              return this._dimensions;
            }
          }, {
            key: "error",
            get: function get() {
              return this._error;
            }
            /**
             * Checks if the texture is within the startup grace period.
             * During this period, textures are protected from cleanup to prevent
             * race conditions during app initialization.
             */
          }, {
            key: "isWithinStartupGracePeriod",
            value: function isWithinStartupGracePeriod() {
              // If grace period already expired, return false immediately
              if (this.gracePeriodExpired) {
                return false;
              }
              // Check if grace period has expired now
              var hasExpired = Date.now() - this.createdAt >= Texture.STARTUP_GRACE_PERIOD;
              if (hasExpired) {
                // Cache the result to avoid future Date.now() calls
                this.gracePeriodExpired = true;
                return false;
              }
              return true;
            }
            /**
             * Checks if the texture can be safely cleaned up.
             * Considers the renderable state, startup grace period, and renderable owners.
             */
          }, {
            key: "canBeCleanedUp",
            value: function canBeCleanedUp() {
              // Never cleanup if explicitly prevented
              if (this.preventCleanup) {
                return false;
              }
              // Don't cleanup if still within startup grace period
              if (this.isWithinStartupGracePeriod()) {
                return false;
              }
              // Don't cleanup if not renderable
              if (this.renderable === true) {
                return false;
              }
              // Don't cleanup if there are still renderable owners
              if (this.renderableOwners.length > 0) {
                return false;
              }
              // Safe to cleanup
              return true;
            }
            /**
             * Add/remove an owner to/from the Texture based on its renderability.
             *
             * @remarks
             * Any object can own a texture, be it a CoreNode or even the state object
             * from a Text Renderer.
             *
             * When the reference to the texture that an owner object holds is replaced
             * or cleared it must call this with `renderable=false` to release the owner
             * association.
             *
             * @param owner
             * @param renderable
             */
          }, {
            key: "setRenderableOwner",
            value: function setRenderableOwner(owner, renderable) {
              var oldSize = this.renderableOwners.length;
              var hasOwnerIndex = this.renderableOwners.indexOf(owner);
              if (renderable === true) {
                if (hasOwnerIndex === -1) {
                  // Add the owner to the set
                  this.renderableOwners.push(owner);
                }
                var newSize = this.renderableOwners.length;
                if (oldSize !== newSize && newSize === 1) {
                  var _this$onChangeIsRende;
                  this.renderable = true;
                  (_this$onChangeIsRende = this.onChangeIsRenderable) === null || _this$onChangeIsRende === void 0 || _this$onChangeIsRende.call(this, true);
                  this.load();
                }
              } else {
                if (hasOwnerIndex !== -1) {
                  this.renderableOwners.splice(hasOwnerIndex, 1);
                }
                var _newSize = this.renderableOwners.length;
                if (oldSize !== _newSize && _newSize === 0) {
                  var _this$onChangeIsRende2;
                  this.renderable = false;
                  (_this$onChangeIsRende2 = this.onChangeIsRenderable) === null || _this$onChangeIsRende2 === void 0 || _this$onChangeIsRende2.call(this, false);
                  // note, not doing a cleanup here, cleanup is managed by the Stage/TextureMemoryManager
                  // when it deems appropriate based on memory pressure
                }
              }
            }
          }, {
            key: "load",
            value: function load() {
              if (this.retryCount > this.maxRetryCount) {
                // We've exceeded the max retry count, do not attempt to load again
                return;
              }
              this.txManager.loadTexture(this);
            }
            /**
             * Load the core context texture for this Texture.
             * The ctxTexture is created by the renderer and lives on the GPU.
             *
             * @returns
             */
          }, {
            key: "loadCtxTexture",
            value: function loadCtxTexture() {
              if (this.ctxTexture === undefined) {
                this.ctxTexture = this.txManager.renderer.createCtxTexture(this);
              }
              return this.ctxTexture;
            }
            /**
             * Free the core context texture for this Texture.
             *
             * @remarks
             * The ctxTexture is created by the renderer and lives on the GPU.
             */
          }, {
            key: "free",
            value: function free() {
              var _this$ctxTexture;
              (_this$ctxTexture = this.ctxTexture) === null || _this$ctxTexture === void 0 || _this$ctxTexture.free();
            }
            /**
             * Release the texture data and core context texture for this Texture without changing state.
             *
             * @remarks
             * The ctxTexture is created by the renderer and lives on the GPU.
             */
          }, {
            key: "release",
            value: function release() {
              var _this$ctxTexture2;
              (_this$ctxTexture2 = this.ctxTexture) === null || _this$ctxTexture2 === void 0 || _this$ctxTexture2.release();
              this.ctxTexture = undefined;
              this.freeTextureData();
            }
            /**
             * Destroy the texture.
             *
             * @remarks
             * This method is called when the texture is no longer needed and should be
             * cleaned up.
             */
          }, {
            key: "destroy",
            value: function destroy() {
              // Only free GPU resources if we're in a state where they exist
              if (this.state === 'loaded') {
                this.free();
              }
              // Always free texture data regardless of state
              this.freeTextureData();
            }
            /**
             * Free the source texture data for this Texture.
             *
             * @remarks
             * The texture data is the source data that is used to populate the CoreContextTexture.
             * e.g. ImageData that is downloaded from a URL.
             */
          }, {
            key: "freeTextureData",
            value: function freeTextureData() {
              var _this4 = this;
              queueMicrotask(function () {
                _this4.textureData = null;
              });
            }
          }, {
            key: "setState",
            value: function setState(state, errorOrDimensions) {
              var _this5 = this;
              if (this.state === state) {
                return;
              }
              var payload = null;
              if (state === 'loaded') {
                // Clear any previous error when successfully loading
                this._error = null;
                if (errorOrDimensions !== undefined && 'width' in errorOrDimensions === true && 'height' in errorOrDimensions === true && errorOrDimensions.width !== undefined && errorOrDimensions.height !== undefined) {
                  this._dimensions = errorOrDimensions;
                }
                payload = this._dimensions;
              } else if (state === 'failed') {
                this._error = errorOrDimensions;
                payload = this._error;
                // increment the retry count for the texture
                // this is used to compare against maxRetryCount, if set
                // to determine if we should try loading again
                this.retryCount += 1;
                queueMicrotask(function () {
                  _this5.release();
                });
              } else if (state === 'loading') {
                // Clear error and reset dimensions when starting to load
                // This ensures stale dimensions from previous loads don't persist
                this._error = null;
                this._dimensions = null;
              } else {
                this._error = null;
              }
              // emit the new state
              this.state = state;
              this.emit(state, payload);
            }
            /**
             * Get the texture data for this texture.
             *
             * @remarks
             * This method is called by the CoreContextTexture when the texture is loaded.
             * The texture data is then used to populate the CoreContextTexture.
             *
             * @returns
             * The texture data for this texture.
             */
          }, {
            key: "getTextureData",
            value: (function () {
              var _getTextureData = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
                return _regenerator().w(function (_context) {
                  while (1) switch (_context.n) {
                    case 0:
                      if (!(this.textureData === null)) {
                        _context.n = 2;
                        break;
                      }
                      _context.n = 1;
                      return this.getTextureSource();
                    case 1:
                      this.textureData = _context.v;
                    case 2:
                      return _context.a(2, this.textureData);
                  }
                }, _callee, this);
              }));
              function getTextureData() {
                return _getTextureData.apply(this, arguments);
              }
              return getTextureData;
            }()
            /**
             * Make a cache key for this texture.
             *
             * @remarks
             * Each concrete `Texture` subclass must implement this method to provide an
             * appropriate cache key for the texture type including the texture's
             * properties that uniquely identify a copy of the texture. If the texture
             * type does not support caching, then this method should return `false`.
             *
             * @param props
             * @returns
             * A cache key for this texture or `false` if the texture type does not
             * support caching.
             */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            )
          }, {
            key: "retry",
            value:
            /**
             * Retry the texture by resetting retryCount and setting state to 'initial'.
             *
             * @remarks
             * This allows the texture to be loaded again.
             */
            function retry() {
              this.release();
              this.retryCount = 0;
              this.load();
            }
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              return false;
            }
            /**
             * Resolve the default values for the texture's properties.
             *
             * @remarks
             * Each concrete `Texture` subclass must implement this method to provide
             * default values for the texture's optional properties.
             *
             * @param props
             * @returns
             * The default values for the texture's properties.
             */
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            props) {
              return {};
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Grace period in milliseconds to prevent premature cleanup during app startup
         * This helps prevent race conditions when bounds calculation is delayed
         */
        _defineProperty(Texture, "STARTUP_GRACE_PERIOD", 2000);
        var PROTOCOL_REGEX = /^(data|ftps?|https?):/;
        var getNormalizedRgbaComponents = function getNormalizedRgbaComponents(rgba) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 0xff;
          var b = rgba >>> 8 & 0xff;
          var a = rgba & 0xff;
          return [r / 255, g / 255, b / 255, a / 255];
        };
        var getRgbaComponents = function getRgbaComponents(rgba) {
          var r = rgba >>> 24;
          var g = rgba >>> 16 & 0xff;
          var b = rgba >>> 8 & 0xff;
          var a = rgba & 0xff;
          return [r, g, b, a];
        };
        function getNormalizedAlphaComponent(rgba) {
          return (rgba & 0xff) / 255.0;
        }
        /**
         * Get a CSS color string from a RGBA color
         *
         * @param color
         * @returns
         */
        function getRgbaString(color) {
          var r = Math.floor(color[0] * 255.0);
          var g = Math.floor(color[1] * 255.0);
          var b = Math.floor(color[2] * 255.0);
          var a = Math.floor(color[3] * 255.0);
          return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a.toFixed(4), ")");
        }
        function createBound(x1, y1, x2, y2, out) {
          if (out) {
            out.x1 = x1;
            out.y1 = y1;
            out.x2 = x2;
            out.y2 = y2;
            return out;
          }
          return {
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2
          };
        }
        function boundsOverlap(a, b) {
          return a.x1 < b.x2 && a.x2 > b.x1 && a.y1 < b.y2 && a.y2 > b.y1;
        }
        function convertBoundToRect(bound, out) {
          if (out) {
            out.x = bound.x1;
            out.y = bound.y1;
            out.width = bound.x2 - bound.x1;
            out.height = bound.y2 - bound.y1;
            return out;
          }
          return {
            x: bound.x1,
            y: bound.y1,
            width: bound.x2 - bound.x1,
            height: bound.y2 - bound.y1
          };
        }
        function intersectRect(a, b, out) {
          var x = Math.max(a.x, b.x);
          var y = Math.max(a.y, b.y);
          var width = Math.min(a.x + a.width, b.x + b.width) - x;
          var height = Math.min(a.y + a.height, b.y + b.height) - y;
          if (width > 0 && height > 0) {
            if (out) {
              out.x = x;
              out.y = y;
              out.width = width;
              out.height = height;
              return out;
            }
            return {
              x: x,
              y: y,
              width: width,
              height: height
            };
          }
          if (out) {
            out.x = 0;
            out.y = 0;
            out.width = 0;
            out.height = 0;
            return out;
          }
          return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        function copyRect(a, out) {
          if (out) {
            out.x = a.x;
            out.y = a.y;
            out.width = a.width;
            out.height = a.height;
            return out;
          }
          return {
            x: a.x,
            y: a.y,
            width: a.width,
            height: a.height
          };
        }
        function compareRect(a, b) {
          if (a === b) {
            return true;
          }
          if (a === null || b === null) {
            return false;
          }
          return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
        }
        function boundInsideBound(bound1, bound2) {
          return bound1.x1 <= bound2.x2 && bound1.y1 <= bound2.y2 && bound1.x2 >= bound2.x1 && bound1.y2 >= bound2.y1;
        }
        function boundLargeThanBound(bound1, bound2) {
          return bound1.x1 < bound2.x1 && bound1.x2 > bound2.x2 && bound1.y1 < bound2.y1 && bound1.y2 > bound2.y2;
        }
        function pointInBound(x, y, bound) {
          return !(x < bound.x1 || x > bound.x2 || y < bound.y1 || y > bound.y2);
        }
        function isBoundPositive(bound) {
          return bound.x1 < bound.x2 && bound.y1 < bound.y2;
        }
        /**
         * Create a preload bounds from a strict bound
         *
         * @param strictBound The strict boundary of the node
         * @param boundsMargin Boundary margin to apply to the strictBound
         * @returns
         */
        function createPreloadBounds(strictBound, boundsMargin) {
          return createBound(strictBound.x1 - boundsMargin[3], strictBound.y1 - boundsMargin[0], strictBound.x2 + boundsMargin[1], strictBound.y2 + boundsMargin[2]);
        }
        function convertUrlToAbsolute(url) {
          // handle local file imports if the url isn't remote resource or data blob
          if (self.location.protocol === 'file:' && !PROTOCOL_REGEX.test(url)) {
            var path = self.location.pathname.split('/');
            path.pop();
            var _basePath = path.join('/');
            var baseUrl = self.location.protocol + '//' + _basePath;
            // check if url has a leading dot
            if (url.charAt(0) === '.') {
              url = url.slice(1);
            }
            // check if url has a leading slash
            if (url.charAt(0) === '/') {
              url = url.slice(1);
            }
            return baseUrl + '/' + url;
          }
          var absoluteUrl = new URL(url, self.location.href);
          return absoluteUrl.href;
        }
        function isBase64Image(src) {
          return src.startsWith('data:') === true;
        }
        function dataURIToBlob(dataURI) {
          var _dataURI$match;
          dataURI = dataURI.replace(/^data:/, '');
          var type = ((_dataURI$match = dataURI.match(/image\/[^;]+/)) === null || _dataURI$match === void 0 ? void 0 : _dataURI$match[0]) || '';
          var base64 = dataURI.replace(/^[^,]+,/, '');
          var sliceSize = 1024;
          var byteCharacters = atob(base64);
          var bytesLength = byteCharacters.length;
          var slicesCount = Math.ceil(bytesLength / sliceSize);
          var byteArrays = new Array(slicesCount);
          for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {
            var begin = sliceIndex * sliceSize;
            var end = Math.min(begin + sliceSize, bytesLength);
            var bytes = new Array(end - begin);
            for (var offset = begin, i = 0; offset < end; ++i, ++offset) {
              var _byteCharacters$offse;
              bytes[i] = (_byteCharacters$offse = byteCharacters[offset]) === null || _byteCharacters$offse === void 0 ? void 0 : _byteCharacters$offse.charCodeAt(0);
            }
            byteArrays[sliceIndex] = new Uint8Array(bytes);
          }
          return new Blob(byteArrays, {
            type: type
          });
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * A 3D matrix representing a 2D graphics transformation
         *
         * @remarks
         * For convenience, entries in the first two rows can be accessed by the following
         * properties:
         * | ta tb tx |
         * | tc td ty |
         * | 0  0  1  |
         *
         * This matrix is optimized for 2D transformations and hence the last row will
         * always be considered [0, 0 ,1].
         *
         * To access a column major array for WebGL, use the {@link getFloatArr} method.
         */
        var Matrix3d = /*#__PURE__*/function () {
          /**
           * Creates a new 3x3 matrix.
           *
           * @param entries Row-major 3x3 matrix
           */
          function Matrix3d() {
            _classCallCheck(this, Matrix3d);
            _defineProperty(this, "ta", void 0);
            _defineProperty(this, "tb", void 0);
            _defineProperty(this, "tx", void 0);
            _defineProperty(this, "tc", void 0);
            _defineProperty(this, "td", void 0);
            _defineProperty(this, "ty", void 0);
            _defineProperty(this, "_floatArr", null);
            /**
             * Potential Mutation Flag
             *
             * @remarks
             * This flag is set to true whenever the matrix is potentially modified.
             * We don't waste CPU trying to identify if each operation actually modifies
             * the matrix. Instead, we set this flag to true whenever we think the matrix
             * is modified. This signals that the `floatArr` should to be updated.
             */
            _defineProperty(this, "mutation", void 0);
            this.ta = 0;
            this.tb = 0;
            this.tx = 0;
            this.tc = 0;
            this.td = 0;
            this.ty = 0;
            this.mutation = true;
          }
          /**
           * Returns a temporary matrix that can be used for calculations.
           *
           * @remarks
           * This is useful for avoiding allocations in tight loops.
           *
           * The matrix is not guaranteed to be the same between calls.
           *
           * @returns
           */
          return _createClass(Matrix3d, [{
            key: "translate",
            value: function translate(x, y) {
              this.tx = this.ta * x + this.tb * y + this.tx;
              this.ty = this.tc * x + this.td * y + this.ty;
              this.mutation = true;
              return this;
            }
          }, {
            key: "scale",
            value: function scale(sx, sy) {
              this.ta = this.ta * sx;
              this.tb = this.tb * sy;
              this.tc = this.tc * sx;
              this.td = this.td * sy;
              this.mutation = true;
              return this;
            }
          }, {
            key: "rotate",
            value: function rotate(angle) {
              if (angle === 0 || !(angle % Math.PI * 2)) {
                return this;
              }
              var cos = Math.cos(angle);
              var sin = Math.sin(angle);
              var e0 = this.ta * cos + this.tb * sin;
              var e1 = this.tb * cos - this.ta * sin;
              var e3 = this.tc * cos + this.td * sin;
              var e4 = this.td * cos - this.tc * sin;
              this.ta = e0;
              this.tb = e1;
              this.tc = e3;
              this.td = e4;
              this.mutation = true;
              return this;
            }
          }, {
            key: "multiply",
            value: function multiply(other) {
              return Matrix3d.multiply(this, other, this);
            }
            /**
             * Returns the matrix as a Float32Array in column-major order.
             *
             * @remarks
             * This method is optimized to avoid unnecessary allocations. The same array
             * is returned every time this method is called, and is updated in place.
             *
             * WARNING: Use the array only for passing directly to a WebGL shader uniform
             * during a frame render. Do not modify or hold onto the array for longer than
             * a frame.
             */
          }, {
            key: "getFloatArr",
            value: function getFloatArr() {
              if (!this._floatArr) {
                this._floatArr = new Float32Array(9);
              }
              if (this.mutation) {
                this._floatArr[0] = this.ta;
                this._floatArr[1] = this.tc;
                this._floatArr[2] = 0;
                this._floatArr[3] = this.tb;
                this._floatArr[4] = this.td;
                this._floatArr[5] = 0;
                this._floatArr[6] = this.tx;
                this._floatArr[7] = this.ty;
                this._floatArr[8] = 1;
                this.mutation = false;
              }
              return this._floatArr;
            }
          }], [{
            key: "temp",
            get: function get() {
              return tempMatrix;
            }
          }, {
            key: "multiply",
            value: function multiply(a, b, out) {
              var e0 = a.ta * b.ta + a.tb * b.tc;
              var e1 = a.ta * b.tb + a.tb * b.td;
              var e2 = a.ta * b.tx + a.tb * b.ty + a.tx;
              var e3 = a.tc * b.ta + a.td * b.tc;
              var e4 = a.tc * b.tb + a.td * b.td;
              var e5 = a.tc * b.tx + a.td * b.ty + a.ty;
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = e0;
              out.tb = e1;
              out.tx = e2;
              out.tc = e3;
              out.td = e4;
              out.ty = e5;
              out.mutation = true;
              return out;
            }
          }, {
            key: "identity",
            value: function identity(out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = 1;
              out.tb = 0;
              out.tx = 0;
              out.tc = 0;
              out.td = 1;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "translate",
            value: function translate(x, y, out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = 1;
              out.tb = 0;
              out.tx = x;
              out.tc = 0;
              out.td = 1;
              out.ty = y;
              out.mutation = true;
              return out;
            }
          }, {
            key: "scale",
            value: function scale(sx, sy, out) {
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = sx;
              out.tb = 0;
              out.tx = 0;
              out.tc = 0;
              out.td = sy;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "rotate",
            value: function rotate(angle, out) {
              var cos = Math.cos(angle);
              var sin = Math.sin(angle);
              if (!out) {
                out = new Matrix3d();
              }
              out.ta = cos;
              out.tb = -sin;
              out.tx = 0;
              out.tc = sin;
              out.td = cos;
              out.ty = 0;
              out.mutation = true;
              return out;
            }
          }, {
            key: "copy",
            value: function copy(src, dst) {
              if (!dst) {
                dst = new Matrix3d();
              }
              dst.ta = src.ta;
              dst.tc = src.tc;
              dst.tb = src.tb;
              dst.td = src.td;
              dst.tx = src.tx;
              dst.ty = src.ty;
              dst.mutation = true;
              return dst;
            }
          }]);
        }();
        var tempMatrix = new Matrix3d();
        var rx1 = 0;
        var rx2 = 2;
        var rx3 = 4;
        var rx4 = 6;
        var ry1 = 1;
        var ry2 = 3;
        var ry3 = 5;
        var ry4 = 7;
        var RenderCoords = /*#__PURE__*/function () {
          function RenderCoords(entries) {
            _classCallCheck(this, RenderCoords);
            _defineProperty(this, "data", void 0);
            this.data = new Float32Array(8);
            if (entries) {
              this.data[rx1] = entries[rx1];
              this.data[rx2] = entries[rx2];
              this.data[rx3] = entries[rx3];
              this.data[rx4] = entries[rx4];
              this.data[ry1] = entries[ry1];
              this.data[ry2] = entries[ry2];
              this.data[ry3] = entries[ry3];
              this.data[ry4] = entries[ry4];
            }
          }
          return _createClass(RenderCoords, [{
            key: "x1",
            get: function get() {
              return this.data[rx1];
            }
          }, {
            key: "x2",
            get: function get() {
              return this.data[rx2];
            }
          }, {
            key: "x3",
            get: function get() {
              return this.data[rx3];
            }
          }, {
            key: "x4",
            get: function get() {
              return this.data[rx4];
            }
          }, {
            key: "y1",
            get: function get() {
              return this.data[ry1];
            }
          }, {
            key: "y2",
            get: function get() {
              return this.data[ry2];
            }
          }, {
            key: "y3",
            get: function get() {
              return this.data[ry3];
            }
          }, {
            key: "y4",
            get: function get() {
              return this.data[ry4];
            }
          }], [{
            key: "translate",
            value: function translate(x1, y1, x2, y2, x3, y3, x4, y4, out) {
              if (!out) {
                out = new RenderCoords();
              }
              out.data[rx1] = x1;
              out.data[rx2] = x2;
              out.data[rx3] = x3;
              out.data[rx4] = x4;
              out.data[ry1] = y1;
              out.data[ry2] = y2;
              out.data[ry3] = y3;
              out.data[ry4] = y4;
              return out;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Core Utility Functions
         *
         * @module
         */
        var getTimingBezier = function getTimingBezier(a, b, c, d) {
          var xc = 3.0 * a;
          var xb = 3.0 * (c - a) - xc;
          var xa = 1.0 - xc - xb;
          var yc = 3.0 * b;
          var yb = 3.0 * (d - b) - yc;
          var ya = 1.0 - yc - yb;
          return function (time) {
            if (time >= 1.0) {
              return 1;
            }
            if (time <= 0) {
              return 0;
            }
            var t = 0.5,
              cbx,
              cbxd,
              dx;
            for (var it = 0; it < 20; it++) {
              cbx = t * (t * (t * xa + xb) + xc);
              dx = time - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                return t * (t * (t * ya + yb) + yc);
              }
              // Cubic bezier derivative.
              cbxd = t * (t * (3 * xa) + 2 * xb) + xc;
              if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
              }
              t += dx / cbxd;
            }
            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            var minT = 0;
            var maxT = 1;
            for (var _it = 0; _it < 20; _it++) {
              t = 0.5 * (minT + maxT);
              cbx = t * (t * (t * xa + xb) + xc);
              dx = time - cbx;
              if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc);
              }
              if (dx < 0) {
                maxT = t;
              } else {
                minT = t;
              }
            }
          };
        };
        var timingMapping = {};
        var timingLookup = {
          ease: [0.25, 0.1, 0.25, 1.0],
          'ease-in': [0.42, 0, 1.0, 1.0],
          'ease-out': [0, 0, 0.58, 1.0],
          'ease-in-out': [0.42, 0, 0.58, 1.0],
          'ease-in-sine': [0.12, 0, 0.39, 0],
          'ease-out-sine': [0.12, 0, 0.39, 0],
          'ease-in-out-sine': [0.37, 0, 0.63, 1],
          'ease-in-cubic': [0.32, 0, 0.67, 0],
          'ease-out-cubic': [0.33, 1, 0.68, 1],
          'ease-in-out-cubic': [0.65, 0, 0.35, 1],
          'ease-in-circ': [0.55, 0, 1, 0.45],
          'ease-out-circ': [0, 0.55, 0.45, 1],
          'ease-in-out-circ': [0.85, 0, 0.15, 1],
          'ease-in-back': [0.36, 0, 0.66, -0.56],
          'ease-out-back': [0.34, 1.56, 0.64, 1],
          'ease-in-out-back': [0.68, -0.6, 0.32, 1.6]
        };
        var defaultTiming = function defaultTiming(t) {
          return t;
        };
        var parseCubicBezier = function parseCubicBezier(str) {
          //cubic-bezier(0.84, 0.52, 0.56, 0.6)
          var regex = /-?\d*\.?\d+/g;
          var match = str.match(regex);
          if (match) {
            var _match = _slicedToArray(match, 4),
              num1 = _match[0],
              num2 = _match[1],
              num3 = _match[2],
              num4 = _match[3];
            var a = parseFloat(num1 || '0.42');
            var b = parseFloat(num2 || '0');
            var c = parseFloat(num3 || '1');
            var d = parseFloat(num4 || '1');
            var timing = getTimingBezier(a, b, c, d);
            timingMapping[str] = timing;
            return timing;
          }
          // parse failed, return linear
          console.warn('Unknown cubic-bezier timing: ' + str);
          return defaultTiming;
        };
        var getTimingFunction = function getTimingFunction(str) {
          if (str === 'linear') {
            return defaultTiming;
          }
          if (timingMapping[str] !== undefined) {
            return timingMapping[str] || defaultTiming;
          }
          if (str === 'step-start') {
            return function () {
              return 1;
            };
          }
          if (str === 'step-end') {
            return function (time) {
              return time === 1 ? 1 : 0;
            };
          }
          var lookup = timingLookup[str];
          if (lookup !== undefined) {
            var _lookup = _slicedToArray(lookup, 4),
              a = _lookup[0],
              b = _lookup[1],
              c = _lookup[2],
              d = _lookup[3];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore - TS doesn't understand that we've checked for undefined
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            var timing = getTimingBezier(a, b, c, d);
            timingMapping[str] = timing;
            return timing;
          }
          if (str.startsWith('cubic-bezier')) {
            return parseCubicBezier(str);
          }
          console.warn('Unknown timing function: ' + str);
          return defaultTiming;
        };
        /**
         * Convert bytes to string of megabytes with 2 decimal points
         *
         * @param bytes
         * @returns
         */
        function bytesToMb$1(bytes) {
          return (bytes / 1024 / 1024).toFixed(2);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreAnimation = /*#__PURE__*/function (_EventEmitter3) {
          function CoreAnimation(node, props, settings) {
            var _settings$delay, _settings$duration, _settings$loop, _settings$repeat, _settings$repeatDelay, _settings$stopMethod;
            var _this6;
            _classCallCheck(this, CoreAnimation);
            _this6 = _callSuper(this, CoreAnimation);
            _defineProperty(_this6, "node", void 0);
            _defineProperty(_this6, "props", void 0);
            _defineProperty(_this6, "settings", void 0);
            _defineProperty(_this6, "progress", 0);
            _defineProperty(_this6, "delayFor", 0);
            _defineProperty(_this6, "delay", 0);
            _defineProperty(_this6, "timingFunction", void 0);
            _defineProperty(_this6, "propValuesMap", {});
            _defineProperty(_this6, "dynPropValuesMap", undefined);
            _this6.node = node;
            _this6.props = props;
            for (var key in props) {
              if (key !== 'shaderProps') {
                if (_this6.propValuesMap['props'] === undefined) {
                  _this6.propValuesMap['props'] = {};
                }
                _this6.propValuesMap['props'][key] = {
                  start: node[key] || 0,
                  target: props[key]
                };
              } else if (node.shader.type !== 'DynamicShader') {
                _this6.propValuesMap['shaderProps'] = {};
                for (var _key2 in props.shaderProps) {
                  _this6.propValuesMap['shaderProps'][_key2] = {
                    start: node.shader.props[_key2],
                    target: props.shaderProps[_key2]
                  };
                }
              } else {
                var shaderPropKeys = Object.keys(props.shaderProps);
                var spLength = shaderPropKeys.length;
                _this6.dynPropValuesMap = {};
                for (var j = 0; j < spLength; j++) {
                  var effectName = shaderPropKeys[j];
                  var _effect = props.shaderProps[effectName];
                  _this6.dynPropValuesMap[effectName] = {};
                  var effectProps = Object.entries(_effect);
                  var eLength = effectProps.length;
                  for (var k = 0; k < eLength; k++) {
                    var _effectProps$k = _slicedToArray(effectProps[k], 2),
                      _key3 = _effectProps$k[0],
                      value = _effectProps$k[1];
                    _this6.dynPropValuesMap[effectName][_key3] = {
                      start: node.shader.props[effectName][_key3],
                      target: value
                    };
                  }
                }
              }
            }
            var easing = settings.easing || 'linear';
            var delay = (_settings$delay = settings.delay) !== null && _settings$delay !== void 0 ? _settings$delay : 0;
            _this6.settings = {
              duration: (_settings$duration = settings.duration) !== null && _settings$duration !== void 0 ? _settings$duration : 0,
              delay: delay,
              easing: easing,
              loop: (_settings$loop = settings.loop) !== null && _settings$loop !== void 0 ? _settings$loop : false,
              repeat: (_settings$repeat = settings.repeat) !== null && _settings$repeat !== void 0 ? _settings$repeat : 0,
              repeatDelay: (_settings$repeatDelay = settings.repeatDelay) !== null && _settings$repeatDelay !== void 0 ? _settings$repeatDelay : 0,
              stopMethod: (_settings$stopMethod = settings.stopMethod) !== null && _settings$stopMethod !== void 0 ? _settings$stopMethod : false
            };
            _this6.timingFunction = getTimingFunction(easing);
            _this6.delayFor = delay;
            _this6.delay = delay;
            return _this6;
          }
          _inherits(CoreAnimation, _EventEmitter3);
          return _createClass(CoreAnimation, [{
            key: "reset",
            value: function reset() {
              this.progress = 0;
              this.delayFor = this.settings.delay || 0;
              this.update(0);
            }
          }, {
            key: "restoreValues",
            value: function restoreValues(target, valueMap) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i = _slicedToArray(entries[i], 2),
                  key = _entries$i[0],
                  value = _entries$i[1];
                target[key] = value.start;
              }
            }
          }, {
            key: "restore",
            value: function restore() {
              this.reset();
              if (this.propValuesMap['props'] !== undefined) {
                this.restoreValues(this.node, this.propValuesMap['props']);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.restoreValues(this.node.shader.props, this.propValuesMap['shaderProps']);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var key = dynEntries[i];
                    this.restoreValues(this.node.shader.props[key], this.dynPropValuesMap[key]);
                  }
                }
              }
            }
          }, {
            key: "reverseValues",
            value: function reverseValues(valueMap) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i2 = _slicedToArray(entries[i], 2),
                  key = _entries$i2[0],
                  value = _entries$i2[1];
                valueMap[key] = {
                  start: value.target,
                  target: value.start
                };
              }
            }
          }, {
            key: "reverse",
            value: function reverse() {
              this.progress = 0;
              if (this.propValuesMap['props'] !== undefined) {
                this.reverseValues(this.propValuesMap['props']);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.reverseValues(this.propValuesMap['shaderProps']);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var key = dynEntries[i];
                    this.reverseValues(this.dynPropValuesMap[key]);
                  }
                }
              }
              // restore stop method if we are not looping
              if (!this.settings.loop) {
                this.settings.stopMethod = false;
              }
            }
          }, {
            key: "applyEasing",
            value: function applyEasing(p, s, e) {
              return (this.timingFunction(p) || p) * (e - s) + s;
            }
          }, {
            key: "updateValue",
            value: function updateValue(propName, propValue, startValue, easing) {
              if (this.progress === 1) {
                return propValue;
              }
              if (this.progress === 0) {
                return startValue;
              }
              var endValue = propValue;
              if (propName.indexOf('color') !== -1) {
                if (startValue === endValue) {
                  return startValue;
                }
                if (easing) {
                  var easingProgressValue = this.timingFunction(this.progress) || this.progress;
                  return mergeColorProgress(startValue, endValue, easingProgressValue);
                }
                return mergeColorProgress(startValue, endValue, this.progress);
              }
              if (easing) {
                return this.applyEasing(this.progress, startValue, endValue);
              }
              return startValue + (endValue - startValue) * this.progress;
            }
          }, {
            key: "updateValues",
            value: function updateValues(target, valueMap, easing) {
              var entries = Object.entries(valueMap);
              var eLength = entries.length;
              for (var i = 0; i < eLength; i++) {
                var _entries$i3 = _slicedToArray(entries[i], 2),
                  key = _entries$i3[0],
                  value = _entries$i3[1];
                target[key] = this.updateValue(key, value.target, value.start, easing);
              }
            }
          }, {
            key: "update",
            value: function update(dt) {
              var _this$settings = this.settings,
                duration = _this$settings.duration,
                loop = _this$settings.loop,
                easing = _this$settings.easing,
                stopMethod = _this$settings.stopMethod;
              var delayFor = this.delayFor;
              if (this.node.destroyed) {
                // cleanup
                this.emit('destroyed', {});
                return;
              }
              if (duration === 0 && delayFor === 0) {
                this.emit('finished', {});
                return;
              }
              if (this.delayFor > 0) {
                this.delayFor -= dt;
                if (this.delayFor >= 0) {
                  // Either no or more delay left. Exit.
                  return;
                } else {
                  // We went beyond the delay time, add it back to dt so we can continue
                  // with the animation.
                  dt = -this.delayFor;
                  this.delayFor = 0;
                }
              }
              if (duration === 0) {
                // No duration, we are done.
                this.emit('finished', {});
                return;
              }
              if (this.progress === 0) {
                // Progress is 0, we are starting the post-delay part of the animation.
                this.emit('animating', {});
              }
              this.progress += dt / duration;
              if (this.progress > 1) {
                this.progress = loop ? 0 : 1;
                this.delayFor = this.delay;
                if (stopMethod) {
                  // If there's a stop method emit finished so the stop method can be applied.
                  // TODO: We should probably reevaluate how stopMethod is implemented as currently
                  // stop method 'reset' does not work when looping.
                  this.emit('finished', {});
                  return;
                }
              }
              if (this.propValuesMap['props'] !== undefined) {
                this.updateValues(this.node, this.propValuesMap['props'], easing);
              }
              if (this.propValuesMap['shaderProps'] !== undefined) {
                this.updateValues(this.node.shader.props, this.propValuesMap['shaderProps'], easing);
              }
              if (this.dynPropValuesMap !== undefined) {
                var dynEntries = Object.keys(this.dynPropValuesMap);
                var dynEntriesL = dynEntries.length;
                if (dynEntriesL > 0) {
                  for (var i = 0; i < dynEntriesL; i++) {
                    var key = dynEntries[i];
                    this.updateValues(this.node.shader.props[key], this.dynPropValuesMap[key], easing);
                  }
                }
              }
              if (this.progress < 1) {
                this.emit('tick', {
                  progress: this.progress
                });
              }
              if (this.progress === 1) {
                this.emit('finished', {});
              }
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreAnimationController = /*#__PURE__*/function (_EventEmitter4) {
          function CoreAnimationController(manager, animation) {
            var _this7;
            _classCallCheck(this, CoreAnimationController);
            _this7 = _callSuper(this, CoreAnimationController);
            _defineProperty(_this7, "manager", void 0);
            _defineProperty(_this7, "animation", void 0);
            _defineProperty(_this7, "stoppedPromise", void 0);
            /**
             * If this is null, then the animation is in a finished / stopped state.
             */
            _defineProperty(_this7, "stoppedResolve", null);
            _defineProperty(_this7, "state", void 0);
            _this7.manager = manager;
            _this7.animation = animation;
            _this7.state = 'stopped';
            // Initial stopped promise is resolved (since the animation is stopped)
            _this7.stoppedPromise = Promise.resolve();
            // Bind event handlers
            _this7.onAnimating = _this7.onAnimating.bind(_this7);
            _this7.onFinished = _this7.onFinished.bind(_this7);
            _this7.onTick = _this7.onTick.bind(_this7);
            _this7.onDestroy = _this7.onDestroy.bind(_this7);
            return _this7;
          }
          _inherits(CoreAnimationController, _EventEmitter4);
          return _createClass(CoreAnimationController, [{
            key: "start",
            value: function start() {
              if (this.state !== 'running' && this.state !== 'scheduled') {
                this.makeStoppedPromise();
                this.registerAnimation();
                this.state = 'scheduled';
              }
              return this;
            }
          }, {
            key: "stop",
            value: function stop() {
              this.unregisterAnimation();
              if (this.stoppedResolve !== null) {
                this.stoppedResolve();
                this.stoppedResolve = null;
                this.emit('stopped', this);
              }
              this.animation.reset();
              this.state = 'stopped';
              return this;
            }
          }, {
            key: "pause",
            value: function pause() {
              this.unregisterAnimation();
              this.state = 'paused';
              return this;
            }
          }, {
            key: "restore",
            value: function restore() {
              this.stoppedResolve = null;
              this.animation.restore();
              return this;
            }
          }, {
            key: "waitUntilStopped",
            value: function waitUntilStopped() {
              return this.stoppedPromise;
            }
          }, {
            key: "registerAnimation",
            value: function registerAnimation() {
              // Hook up event listeners
              this.animation.once('finished', this.onFinished);
              this.animation.on('animating', this.onAnimating);
              this.animation.on('tick', this.onTick);
              this.animation.on('destroyed', this.onDestroy);
              // Then register the animation
              this.manager.registerAnimation(this.animation);
            }
          }, {
            key: "unregisterAnimation",
            value: function unregisterAnimation() {
              // First unregister the animation
              this.manager.unregisterAnimation(this.animation);
              // Then unhook event listeners
              this.animation.off('finished', this.onFinished);
              this.animation.off('animating', this.onAnimating);
              this.animation.off('tick', this.onTick);
              this.animation.off('destroy', this.onDestroy);
            }
          }, {
            key: "makeStoppedPromise",
            value: function makeStoppedPromise() {
              var _this8 = this;
              if (this.stoppedResolve === null) {
                this.stoppedPromise = new Promise(function (resolve) {
                  _this8.stoppedResolve = resolve;
                });
              }
            }
          }, {
            key: "onDestroy",
            value: function onDestroy() {
              this.unregisterAnimation();
              this.state = 'stopped';
            }
          }, {
            key: "onFinished",
            value: function onFinished() {
              // If the animation is looping, then we need to restart it.
              var _this$animation$setti = this.animation.settings,
                loop = _this$animation$setti.loop,
                stopMethod = _this$animation$setti.stopMethod;
              if (stopMethod === 'reverse') {
                this.animation.once('finished', this.onFinished);
                this.animation.reverse();
                return;
              }
              if (loop) {
                return;
              }
              // unregister animation
              this.unregisterAnimation();
              // resolve promise
              if (this.stoppedResolve !== null) {
                this.stoppedResolve();
                this.stoppedResolve = null;
              }
              this.emit('stopped', this);
              this.state = 'stopped';
            }
          }, {
            key: "onAnimating",
            value: function onAnimating() {
              this.state = 'running';
              this.emit('animating', this);
            }
          }, {
            key: "onTick",
            value: function onTick(_animation, data) {
              this.emit('tick', data);
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreNodeRenderState;
        (function (CoreNodeRenderState) {
          CoreNodeRenderState[CoreNodeRenderState["Init"] = 0] = "Init";
          CoreNodeRenderState[CoreNodeRenderState["OutOfBounds"] = 2] = "OutOfBounds";
          CoreNodeRenderState[CoreNodeRenderState["InBounds"] = 4] = "InBounds";
          CoreNodeRenderState[CoreNodeRenderState["InViewport"] = 8] = "InViewport";
        })(CoreNodeRenderState || (CoreNodeRenderState = {}));
        var CoreNodeRenderStateMap = new Map();
        CoreNodeRenderStateMap.set(CoreNodeRenderState.Init, 'init');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.OutOfBounds, 'outOfBounds');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.InBounds, 'inBounds');
        CoreNodeRenderStateMap.set(CoreNodeRenderState.InViewport, 'inViewport');
        var UpdateType;
        (function (UpdateType) {
          /**
           * Child updates
           */
          UpdateType[UpdateType["Children"] = 1] = "Children";
          /**
           * Scale/Rotate transform update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `scaleRotateTransform`
           */
          UpdateType[UpdateType["ScaleRotate"] = 2] = "ScaleRotate";
          /**
           * Translate transform update (x/y/width/height/pivot/mount)
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `localTransform`
           */
          UpdateType[UpdateType["Local"] = 4] = "Local";
          /**
           * Global Transform update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `globalTransform`
           * - `renderCoords`
           * - `renderBound`
           */
          UpdateType[UpdateType["Global"] = 8] = "Global";
          /**
           * Clipping rect update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `clippingRect`
           */
          UpdateType[UpdateType["Clipping"] = 16] = "Clipping";
          /**
           * Calculated ZIndex update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `calcZIndex`
           */
          UpdateType[UpdateType["CalculatedZIndex"] = 32] = "CalculatedZIndex";
          /**
           * Z-Index Sorted Children update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `children` (sorts children by their `calcZIndex`)
           */
          UpdateType[UpdateType["ZIndexSortedChildren"] = 64] = "ZIndexSortedChildren";
          /**
           * Premultiplied Colors update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `premultipliedColorTl`
           * - `premultipliedColorTr`
           * - `premultipliedColorBl`
           * - `premultipliedColorBr`
           */
          UpdateType[UpdateType["PremultipliedColors"] = 128] = "PremultipliedColors";
          /**
           * World Alpha update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `worldAlpha` = `parent.worldAlpha` * `alpha`
           */
          UpdateType[UpdateType["WorldAlpha"] = 256] = "WorldAlpha";
          /**
           * Render State update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `renderState`
           */
          UpdateType[UpdateType["RenderState"] = 512] = "RenderState";
          /**
           * Is Renderable update
           *
           * @remarks
           * CoreNode Properties Updated:
           * - `isRenderable`
           */
          UpdateType[UpdateType["IsRenderable"] = 1024] = "IsRenderable";
          /**
           * Render Texture update
           */
          UpdateType[UpdateType["RenderTexture"] = 2048] = "RenderTexture";
          /**
           * Track if parent has render texture
           */
          UpdateType[UpdateType["ParentRenderTexture"] = 4096] = "ParentRenderTexture";
          /**
           * Render Bounds update
           */
          UpdateType[UpdateType["RenderBounds"] = 8192] = "RenderBounds";
          /**
           * None
           */
          UpdateType[UpdateType["None"] = 0] = "None";
          /**
           * All
           */
          UpdateType[UpdateType["All"] = 14335] = "All";
        })(UpdateType || (UpdateType = {}));
        /**
         * A visual Node in the Renderer scene graph.
         *
         * @remarks
         * CoreNode is an internally used class that represents a Renderer Node in the
         * scene graph. See INode.ts for the public APIs exposed to Renderer users
         * that include generic types for Shaders.
         */
        var CoreNode = /*#__PURE__*/function (_EventEmitter5) {
          function CoreNode(stage, props) {
            var _this9;
            _classCallCheck(this, CoreNode);
            _this9 = _callSuper(this, CoreNode);
            _defineProperty(_this9, "stage", void 0);
            _defineProperty(_this9, "children", []);
            _defineProperty(_this9, "_id", getNewId());
            _defineProperty(_this9, "props", void 0);
            _defineProperty(_this9, "updateType", UpdateType.All);
            _defineProperty(_this9, "childUpdateType", UpdateType.None);
            _defineProperty(_this9, "globalTransform", void 0);
            _defineProperty(_this9, "scaleRotateTransform", void 0);
            _defineProperty(_this9, "localTransform", void 0);
            _defineProperty(_this9, "sceneGlobalTransform", void 0);
            _defineProperty(_this9, "renderCoords", void 0);
            _defineProperty(_this9, "sceneRenderCoords", void 0);
            _defineProperty(_this9, "renderBound", void 0);
            _defineProperty(_this9, "strictBound", void 0);
            _defineProperty(_this9, "preloadBound", void 0);
            _defineProperty(_this9, "clippingRect", {
              x: 0,
              y: 0,
              width: 0,
              height: 0,
              valid: false
            });
            _defineProperty(_this9, "isRenderable", false);
            _defineProperty(_this9, "renderState", CoreNodeRenderState.Init);
            _defineProperty(_this9, "worldAlpha", 1);
            _defineProperty(_this9, "premultipliedColorTl", 0);
            _defineProperty(_this9, "premultipliedColorTr", 0);
            _defineProperty(_this9, "premultipliedColorBl", 0);
            _defineProperty(_this9, "premultipliedColorBr", 0);
            _defineProperty(_this9, "calcZIndex", 0);
            _defineProperty(_this9, "hasRTTupdates", false);
            _defineProperty(_this9, "parentHasRenderTexture", false);
            _defineProperty(_this9, "rttParent", null);
            _defineProperty(_this9, "destroyed", false);
            _defineProperty(_this9, "onTextureLoaded", function (_, dimensions) {
              var _this9$props$textureO;
              _this9.autosizeNode(dimensions);
              _this9.setUpdateType(UpdateType.IsRenderable);
              // Texture was loaded. In case the RAF loop has already stopped, we request
              // a render to ensure the texture is rendered.
              _this9.stage.requestRender();
              // If parent has a render texture, flag that we need to update
              if (_this9.parentHasRenderTexture) {
                _this9.notifyParentRTTOfUpdate();
              }
              // ignore 1x1 pixel textures
              if (dimensions.width > 1 && dimensions.height > 1) {
                _this9.emit('loaded', {
                  type: 'texture',
                  dimensions: dimensions
                });
              }
              // Trigger a local update if the texture is loaded and the resizeMode is 'contain'
              if (((_this9$props$textureO = _this9.props.textureOptions) === null || _this9$props$textureO === void 0 || (_this9$props$textureO = _this9$props$textureO.resizeMode) === null || _this9$props$textureO === void 0 ? void 0 : _this9$props$textureO.type) === 'contain') {
                _this9.setUpdateType(UpdateType.Local);
              }
            });
            _defineProperty(_this9, "onTextureFailed", function (_, error) {
              // immediately set isRenderable to false, so that we handle the error
              // without waiting for the next frame loop
              _this9.isRenderable = false;
              _this9.updateTextureOwnership(false);
              _this9.setUpdateType(UpdateType.IsRenderable);
              // If parent has a render texture, flag that we need to update
              if (_this9.parentHasRenderTexture) {
                _this9.notifyParentRTTOfUpdate();
              }
              // only emit failed outward if we've exhausted all retry attempts
              if (_this9.texture !== null && _this9.texture.retryCount > _this9.texture.maxRetryCount) {
                _this9.emit('failed', {
                  type: 'texture',
                  error: error
                });
              }
            });
            _defineProperty(_this9, "onTextureFreed", function () {
              // immediately set isRenderable to false, so that we handle the error
              // without waiting for the next frame loop
              _this9.isRenderable = false;
              _this9.updateTextureOwnership(false);
              _this9.setUpdateType(UpdateType.IsRenderable);
              // If parent has a render texture, flag that we need to update
              if (_this9.parentHasRenderTexture) {
                _this9.notifyParentRTTOfUpdate();
              }
              _this9.emit('freed', {
                type: 'texture'
              });
            });
            _this9.stage = stage;
            _this9.props = _objectSpread(_objectSpread({}, props), {}, {
              parent: null,
              texture: null,
              src: null,
              rtt: false
            });
            // Assign props to instance
            _this9.parent = props.parent;
            _this9.texture = props.texture;
            _this9.src = props.src;
            _this9.rtt = props.rtt;
            _this9.interactive = props.interactive;
            if (props.boundsMargin) {
              _this9.boundsMargin = Array.isArray(props.boundsMargin) ? props.boundsMargin : [props.boundsMargin, props.boundsMargin, props.boundsMargin, props.boundsMargin];
            }
            _this9.setUpdateType(UpdateType.ScaleRotate | UpdateType.Local | UpdateType.RenderBounds | UpdateType.RenderState);
            // if the default texture isn't loaded yet, wait for it to load
            // this only happens when the node is created before the stage is ready
            if (_this9.stage.defaultTexture && _this9.stage.defaultTexture.state !== 'loaded') {
              _this9.stage.defaultTexture.once('loaded', function () {
                _this9.setUpdateType(UpdateType.IsRenderable);
              });
            }
            return _this9;
          }
          //#region Textures
          _inherits(CoreNode, _EventEmitter5);
          return _createClass(CoreNode, [{
            key: "loadTexture",
            value: function loadTexture() {
              var _this0 = this;
              var texture = this.props.texture;
              // If texture is already loaded / failed, trigger loaded event manually
              // so that users get a consistent event experience.
              // We do this in a microtask to allow listeners to be attached in the same
              // synchronous task after calling loadTexture()
              queueMicrotask(function () {
                var _this0$props$textureO, _this0$props$textureO2;
                if (_this0.textureOptions.preload === true) {
                  _this0.stage.txManager.loadTexture(texture);
                }
                texture.preventCleanup = (_this0$props$textureO = (_this0$props$textureO2 = _this0.props.textureOptions) === null || _this0$props$textureO2 === void 0 ? void 0 : _this0$props$textureO2.preventCleanup) !== null && _this0$props$textureO !== void 0 ? _this0$props$textureO : false;
                texture.on('loaded', _this0.onTextureLoaded);
                texture.on('failed', _this0.onTextureFailed);
                texture.on('freed', _this0.onTextureFreed);
                if (texture.state === 'loaded') {
                  assertTruthy(texture.dimensions);
                  _this0.onTextureLoaded(texture, texture.dimensions);
                } else if (texture.state === 'failed') {
                  assertTruthy(texture.error);
                  _this0.onTextureFailed(texture, texture.error);
                } else if (texture.state === 'freed') {
                  _this0.onTextureFreed(texture);
                }
                // If the parent is a render texture, the initial texture status
                // will be set to freed until the texture is processed by the
                // Render RTT nodes. So we only need to listen fo changes and
                // no need to check the texture.state until we restructure how
                // textures are being processed.
                if (_this0.parentHasRenderTexture) {
                  _this0.notifyParentRTTOfUpdate();
                  return;
                }
              });
            }
          }, {
            key: "unloadTexture",
            value: function unloadTexture() {
              if (this.texture !== null) {
                this.texture.off('loaded', this.onTextureLoaded);
                this.texture.off('failed', this.onTextureFailed);
                this.texture.off('freed', this.onTextureFreed);
                this.texture.setRenderableOwner(this._id, false);
              }
            }
          }, {
            key: "autosizeNode",
            value: function autosizeNode(dimensions) {
              if (this.autosize) {
                this.width = dimensions.width;
                this.height = dimensions.height;
              }
            }
          }, {
            key: "setUpdateType",
            value:
            //#endregion Textures
            /**
             * Change types types is used to determine the scope of the changes being applied
             *
             * @remarks
             * See {@link UpdateType} for more information on each type
             *
             * @param type
             */
            function setUpdateType(type) {
              this.updateType |= type;
              var parent = this.props.parent;
              if (!parent) return;
              if ((parent.updateType & UpdateType.Children) === 0) {
                // Inform the parent if it doesn’t already have a child update
                parent.setUpdateType(UpdateType.Children);
              }
            }
          }, {
            key: "sortChildren",
            value: function sortChildren() {
              this.children.sort(function (a, b) {
                return a.calcZIndex - b.calcZIndex;
              });
            }
          }, {
            key: "updateScaleRotateTransform",
            value: function updateScaleRotateTransform() {
              var _this$props = this.props,
                rotation = _this$props.rotation,
                scaleX = _this$props.scaleX,
                scaleY = _this$props.scaleY;
              // optimize simple translation cases
              if (rotation === 0 && scaleX === 1 && scaleY === 1) {
                this.scaleRotateTransform = undefined;
                return;
              }
              this.scaleRotateTransform = Matrix3d.rotate(rotation, this.scaleRotateTransform).scale(scaleX, scaleY);
            }
          }, {
            key: "updateLocalTransform",
            value: function updateLocalTransform() {
              var _this$props$textureOp;
              var _this$props2 = this.props,
                x = _this$props2.x,
                y = _this$props2.y,
                width = _this$props2.width,
                height = _this$props2.height;
              var mountTranslateX = this.props.mountX * width;
              var mountTranslateY = this.props.mountY * height;
              if (this.scaleRotateTransform) {
                var pivotTranslateX = this.props.pivotX * width;
                var pivotTranslateY = this.props.pivotY * height;
                this.localTransform = Matrix3d.translate(x - mountTranslateX + pivotTranslateX, y - mountTranslateY + pivotTranslateY, this.localTransform).multiply(this.scaleRotateTransform).translate(-pivotTranslateX, -pivotTranslateY);
              } else {
                this.localTransform = Matrix3d.translate(x - mountTranslateX, y - mountTranslateY, this.localTransform);
              }
              // Handle 'contain' resize mode
              var texture = this.props.texture;
              if (texture && texture.dimensions && ((_this$props$textureOp = this.props.textureOptions) === null || _this$props$textureOp === void 0 || (_this$props$textureOp = _this$props$textureOp.resizeMode) === null || _this$props$textureOp === void 0 ? void 0 : _this$props$textureOp.type) === 'contain') {
                var resizeModeScaleX = 1;
                var resizeModeScaleY = 1;
                var extraX = 0;
                var extraY = 0;
                var _texture$dimensions = texture.dimensions,
                  tw = _texture$dimensions.width,
                  th = _texture$dimensions.height;
                var txAspectRatio = tw / th;
                var nodeAspectRatio = width / height;
                if (txAspectRatio > nodeAspectRatio) {
                  // Texture is wider than node
                  // Center the node vertically (shift down by extraY)
                  // Scale the node vertically to maintain original aspect ratio
                  var scaleX = width / tw;
                  var scaledTxHeight = th * scaleX;
                  extraY = (height - scaledTxHeight) / 2;
                  resizeModeScaleY = scaledTxHeight / height;
                } else {
                  // Texture is taller than node (or equal)
                  // Center the node horizontally (shift right by extraX)
                  // Scale the node horizontally to maintain original aspect ratio
                  var scaleY = height / th;
                  var scaledTxWidth = tw * scaleY;
                  extraX = (width - scaledTxWidth) / 2;
                  resizeModeScaleX = scaledTxWidth / width;
                }
                // Apply the extra translation and scale to the local transform
                this.localTransform.translate(extraX, extraY).scale(resizeModeScaleX, resizeModeScaleY);
              }
              this.setUpdateType(UpdateType.Global);
            }
            /**
             * @todo: test for correct calculation flag
             * @param delta
             */
          }, {
            key: "update",
            value: function update(delta, parentClippingRect) {
              if (this.updateType & UpdateType.ScaleRotate) {
                this.updateScaleRotateTransform();
                this.setUpdateType(UpdateType.Local);
              }
              if (this.updateType & UpdateType.Local) {
                this.updateLocalTransform();
                this.setUpdateType(UpdateType.Global);
              }
              var parent = this.props.parent;
              var renderState = null;
              // Handle specific RTT updates at this node level
              if (this.updateType & UpdateType.RenderTexture && this.rtt) {
                this.hasRTTupdates = true;
              }
              if (this.updateType & UpdateType.Global) {
                assertTruthy(this.localTransform);
                if (this.parentHasRenderTexture === true && (parent === null || parent === void 0 ? void 0 : parent.rtt) === true) {
                  // we are at the start of the RTT chain, so we need to reset the globalTransform
                  // for correct RTT rendering
                  this.globalTransform = Matrix3d.identity();
                  // Maintain a full scene global transform for bounds detection
                  this.sceneGlobalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || Matrix3d.identity()).multiply(this.localTransform);
                } else if (this.parentHasRenderTexture === true && (parent === null || parent === void 0 ? void 0 : parent.rtt) === false) {
                  // we're part of an RTT chain but our parent is not the main RTT node
                  // so we need to propogate the sceneGlobalTransform of the parent
                  // to maintain a full scene global transform for bounds detection
                  this.sceneGlobalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.sceneGlobalTransform) || this.localTransform).multiply(this.localTransform);
                  this.globalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
                } else {
                  this.globalTransform = Matrix3d.copy((parent === null || parent === void 0 ? void 0 : parent.globalTransform) || this.localTransform, this.globalTransform);
                }
                if (parent !== null) {
                  this.globalTransform.multiply(this.localTransform);
                }
                this.calculateRenderCoords();
                this.updateBoundingRect();
                this.setUpdateType(UpdateType.RenderState | UpdateType.Children);
                this.childUpdateType |= UpdateType.Global;
                if (this.clipping === true) {
                  this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds);
                  this.childUpdateType |= UpdateType.RenderBounds;
                }
              }
              if (this.updateType & UpdateType.RenderBounds) {
                this.createRenderBounds();
                this.setUpdateType(UpdateType.RenderState);
                this.setUpdateType(UpdateType.Children);
                this.childUpdateType |= UpdateType.RenderBounds;
              }
              if (this.updateType & UpdateType.RenderState) {
                renderState = this.checkRenderBounds();
                this.setUpdateType(UpdateType.IsRenderable);
                // if we're not going out of bounds, update the render state
                // this is done so the update loop can finish before we mark a node
                // as out of bounds
                if (renderState !== CoreNodeRenderState.OutOfBounds) {
                  this.updateRenderState(renderState);
                }
              }
              if (this.updateType & UpdateType.WorldAlpha) {
                if (parent) {
                  this.worldAlpha = parent.worldAlpha * this.props.alpha;
                } else {
                  this.worldAlpha = this.props.alpha;
                }
                this.setUpdateType(UpdateType.Children | UpdateType.PremultipliedColors | UpdateType.IsRenderable);
                this.childUpdateType |= UpdateType.WorldAlpha;
              }
              if (this.updateType & UpdateType.IsRenderable) {
                this.updateIsRenderable();
              }
              if (this.updateType & UpdateType.Clipping) {
                this.calculateClippingRect(parentClippingRect);
                this.setUpdateType(UpdateType.Children);
                this.childUpdateType |= UpdateType.Clipping;
                this.childUpdateType |= UpdateType.RenderBounds;
              }
              if (this.updateType & UpdateType.PremultipliedColors) {
                this.premultipliedColorTl = mergeColorAlphaPremultiplied(this.props.colorTl, this.worldAlpha, true);
                // If all the colors are the same just sent them all to the same value
                if (this.props.colorTl === this.props.colorTr && this.props.colorBl === this.props.colorBr && this.props.colorTl === this.props.colorBl) {
                  this.premultipliedColorTr = this.premultipliedColorBl = this.premultipliedColorBr = this.premultipliedColorTl;
                } else {
                  this.premultipliedColorTr = mergeColorAlphaPremultiplied(this.props.colorTr, this.worldAlpha, true);
                  this.premultipliedColorBl = mergeColorAlphaPremultiplied(this.props.colorBl, this.worldAlpha, true);
                  this.premultipliedColorBr = mergeColorAlphaPremultiplied(this.props.colorBr, this.worldAlpha, true);
                }
              }
              // No need to update zIndex if there is no parent
              if (parent !== null && this.updateType & UpdateType.CalculatedZIndex) {
                this.calculateZIndex();
                // Tell parent to re-sort children
                parent.setUpdateType(UpdateType.ZIndexSortedChildren);
              }
              if (this.props.strictBounds === true && this.renderState === CoreNodeRenderState.OutOfBounds) {
                this.updateType &= ~UpdateType.RenderBounds; // remove render bounds update
                return;
              }
              if (this.updateType & UpdateType.Children && this.children.length > 0) {
                for (var i = 0, length = this.children.length; i < length; i++) {
                  var child = this.children[i];
                  child.setUpdateType(this.childUpdateType);
                  if (child.updateType === 0) {
                    continue;
                  }
                  var childClippingRect = this.clippingRect;
                  if (this.rtt === true) {
                    childClippingRect = {
                      x: 0,
                      y: 0,
                      width: 0,
                      height: 0,
                      valid: false
                    };
                  }
                  child.update(delta, childClippingRect);
                }
              }
              // If the node has an RTT parent and requires a texture re-render, inform the RTT parent
              // if (this.parentHasRenderTexture && this.updateType & UpdateType.RenderTexture) {
              // @TODO have a more scoped down updateType for RTT updates
              if (this.parentHasRenderTexture && this.updateType > 0) {
                this.notifyParentRTTOfUpdate();
              }
              // Sorting children MUST happen after children have been updated so
              // that they have the oppotunity to update their calculated zIndex.
              if (this.updateType & UpdateType.ZIndexSortedChildren) {
                // reorder z-index
                this.sortChildren();
              }
              // If we're out of bounds, apply the render state now
              // this is done so nodes can finish their entire update loop before
              // being marked as out of bounds
              if (renderState === CoreNodeRenderState.OutOfBounds) {
                this.updateRenderState(renderState);
                this.updateIsRenderable();
                if (this.rtt === true && renderState === CoreNodeRenderState.OutOfBounds) {
                  // notify children that we are going out of bounds
                  // we have to do this now before we stop processing the render tree
                  this.notifyChildrenRTTOfUpdate(renderState);
                  // this.childUpdateType |= UpdateType.RenderState;
                }
              }
              // reset update type
              this.updateType = 0;
              this.childUpdateType = 0;
            }
          }, {
            key: "findParentRTTNode",
            value: function findParentRTTNode() {
              var rttNode = this.parent;
              while (rttNode && !rttNode.rtt) {
                rttNode = rttNode.parent;
              }
              return rttNode;
            }
          }, {
            key: "getRTTParentRenderState",
            value: function getRTTParentRenderState() {
              var rttNode = this.rttParent || this.findParentRTTNode();
              if (!rttNode) {
                return null;
              }
              return rttNode.renderState;
            }
          }, {
            key: "notifyChildrenRTTOfUpdate",
            value: function notifyChildrenRTTOfUpdate(renderState) {
              var _iterator5 = _createForOfIteratorHelper(this.children),
                _step5;
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var child = _step5.value;
                  // force child to update render state
                  child.updateRenderState(renderState);
                  child.updateIsRenderable();
                  child.notifyChildrenRTTOfUpdate(renderState);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            }
          }, {
            key: "notifyParentRTTOfUpdate",
            value: function notifyParentRTTOfUpdate() {
              if (this.parent === null) {
                return;
              }
              var rttNode = this.rttParent || this.findParentRTTNode();
              if (!rttNode) {
                return;
              }
              // If an RTT node is found, mark it for re-rendering
              rttNode.hasRTTupdates = true;
              rttNode.setUpdateType(UpdateType.RenderTexture);
              // if rttNode is nested, also make it update its RTT parent
              if (rttNode.parentHasRenderTexture === true) {
                rttNode.notifyParentRTTOfUpdate();
              }
            }
          }, {
            key: "checkRenderBounds",
            value: function checkRenderBounds() {
              assertTruthy(this.renderBound);
              assertTruthy(this.strictBound);
              assertTruthy(this.preloadBound);
              if (boundInsideBound(this.renderBound, this.strictBound)) {
                return CoreNodeRenderState.InViewport;
              }
              if (boundInsideBound(this.renderBound, this.preloadBound)) {
                return CoreNodeRenderState.InBounds;
              }
              // check if we're larger then our parent, we're definitely in the viewport
              if (boundLargeThanBound(this.renderBound, this.strictBound)) {
                return CoreNodeRenderState.InViewport;
              }
              // check if we dont have dimensions, take our parent's render state
              if (this.parent !== null && (this.props.width === 0 || this.props.height === 0)) {
                return this.parent.renderState;
              }
              return CoreNodeRenderState.OutOfBounds;
            }
          }, {
            key: "updateBoundingRect",
            value: function updateBoundingRect() {
              var transform = this.sceneGlobalTransform || this.globalTransform;
              var renderCoords = this.sceneRenderCoords || this.renderCoords;
              var tb = transform.tb,
                tc = transform.tc;
              var x1 = renderCoords.x1,
                y1 = renderCoords.y1,
                x3 = renderCoords.x3,
                y3 = renderCoords.y3;
              if (tb === 0 || tc === 0) {
                this.renderBound = createBound(x1, y1, x3, y3, this.renderBound);
              } else {
                var x2 = renderCoords.x2,
                  x4 = renderCoords.x4,
                  y2 = renderCoords.y2,
                  y4 = renderCoords.y4;
                this.renderBound = createBound(Math.min(x1, x2, x3, x4), Math.min(y1, y2, y3, y4), Math.max(x1, x2, x3, x4), Math.max(y1, y2, y3, y4), this.renderBound);
              }
            }
          }, {
            key: "createRenderBounds",
            value: function createRenderBounds() {
              assertTruthy(this.stage);
              if (this.parent !== null && this.parent.strictBound !== undefined) {
                // we have a parent with a valid bound, copy it
                var parentBound = this.parent.strictBound;
                this.strictBound = createBound(parentBound.x1, parentBound.y1, parentBound.x2, parentBound.y2);
                this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
              } else {
                // no parent or parent does not have a bound, take the stage boundaries
                this.strictBound = this.stage.strictBound;
                this.preloadBound = this.stage.preloadBound;
              }
              // if clipping is disabled, we're done
              if (this.props.clipping === false) {
                return;
              }
              // only create local clipping bounds if node itself is in bounds
              // this can only be done if we have a render bound already
              if (this.renderBound === undefined) {
                return;
              }
              // if we're out of bounds, we're done
              if (boundInsideBound(this.renderBound, this.strictBound) === false) {
                return;
              }
              // clipping is enabled and we are in bounds create our own bounds
              var _this$props3 = this.props,
                x = _this$props3.x,
                y = _this$props3.y,
                width = _this$props3.width,
                height = _this$props3.height;
              // Pick the global transform if available, otherwise use the local transform
              // global transform is only available if the node in an RTT chain
              var _ref = this.sceneGlobalTransform || this.globalTransform || {},
                tx = _ref.tx,
                ty = _ref.ty;
              var _x = tx !== null && tx !== void 0 ? tx : x;
              var _y = ty !== null && ty !== void 0 ? ty : y;
              this.strictBound = createBound(_x, _y, _x + width, _y + height, this.strictBound);
              this.preloadBound = createPreloadBounds(this.strictBound, this.boundsMargin);
            }
          }, {
            key: "updateRenderState",
            value: function updateRenderState(renderState) {
              if (renderState === this.renderState) {
                return;
              }
              var previous = this.renderState;
              this.renderState = renderState;
              var event = CoreNodeRenderStateMap.get(renderState);
              this.emit(event, {
                previous: previous,
                current: renderState
              });
            }
            /**
             * Updates the `isRenderable` property based on various conditions.
             */
          }, {
            key: "updateIsRenderable",
            value: function updateIsRenderable() {
              var newIsRenderable = false;
              var needsTextureOwnership = false;
              // If the node is out of bounds or has an alpha of 0, it is not renderable
              if (this.checkBasicRenderability() === false) {
                this.updateTextureOwnership(false);
                this.setRenderable(false);
                return;
              }
              if (this.texture !== null) {
                // preemptive check for failed textures this will mark the current node as non-renderable
                // and will prevent further checks until the texture is reloaded or retry is reset on the texture
                if (this.texture.retryCount > this.texture.maxRetryCount) {
                  // texture has failed to load, we cannot render
                  this.updateTextureOwnership(false);
                  this.setRenderable(false);
                  return;
                }
                needsTextureOwnership = true;
                // we're only renderable if the texture state is loaded
                newIsRenderable = this.texture.state === 'loaded';
              } else if ((this.hasShader() || this.hasColorProperties() === true) && this.hasDimensions() === true) {
                // This mean we have dimensions and a color set, so we can render a ColorTexture
                if (this.stage.defaultTexture && this.stage.defaultTexture.state === 'loaded') {
                  newIsRenderable = true;
                }
              }
              this.updateTextureOwnership(needsTextureOwnership);
              this.setRenderable(newIsRenderable);
            }
            /**
             * Checks if the node is renderable based on world alpha, dimensions and out of bounds status.
             */
          }, {
            key: "checkBasicRenderability",
            value: function checkBasicRenderability() {
              if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
                return false;
              } else {
                return true;
              }
            }
            /**
             * Sets the renderable state and triggers changes if necessary.
             * @param isRenderable - The new renderable state
             */
          }, {
            key: "setRenderable",
            value: function setRenderable(isRenderable) {
              this.isRenderable = isRenderable;
            }
            /**
             * Changes the renderable state of the node.
             */
          }, {
            key: "updateTextureOwnership",
            value: function updateTextureOwnership(isRenderable) {
              var _this$texture;
              (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.setRenderableOwner(this._id, isRenderable);
            }
            /**
             * Checks if the node is out of the viewport bounds.
             */
          }, {
            key: "isOutOfBounds",
            value: function isOutOfBounds() {
              return this.renderState <= CoreNodeRenderState.OutOfBounds;
            }
            /**
             * Checks if the node has dimensions (width/height)
             */
          }, {
            key: "hasDimensions",
            value: function hasDimensions() {
              return this.props.width !== 0 && this.props.height !== 0;
            }
            /**
             * Checks if the node has any color properties set.
             */
          }, {
            key: "hasColorProperties",
            value: function hasColorProperties() {
              return this.props.color !== 0 || this.props.colorTop !== 0 || this.props.colorBottom !== 0 || this.props.colorLeft !== 0 || this.props.colorRight !== 0 || this.props.colorTl !== 0 || this.props.colorTr !== 0 || this.props.colorBl !== 0 || this.props.colorBr !== 0;
            }
          }, {
            key: "hasShader",
            value: function hasShader() {
              return this.props.shader !== null;
            }
          }, {
            key: "calculateRenderCoords",
            value: function calculateRenderCoords() {
              var width = this.width,
                height = this.height;
              var _this$globalTransform = this.globalTransform,
                tx = _this$globalTransform.tx,
                ty = _this$globalTransform.ty,
                ta = _this$globalTransform.ta,
                tb = _this$globalTransform.tb,
                tc = _this$globalTransform.tc,
                td = _this$globalTransform.td;
              if (tb === 0 && tc === 0) {
                var minX = tx;
                var maxX = tx + width * ta;
                var minY = ty;
                var maxY = ty + height * td;
                this.renderCoords = RenderCoords.translate(
                //top-left
                minX, minY,
                //top-right
                maxX, minY,
                //bottom-right
                maxX, maxY,
                //bottom-left
                minX, maxY, this.renderCoords);
              } else {
                this.renderCoords = RenderCoords.translate(
                //top-left
                tx, ty,
                //top-right
                tx + width * ta, ty + width * tc,
                //bottom-right
                tx + width * ta + height * tb, ty + width * tc + height * td,
                //bottom-left
                tx + height * tb, ty + height * td, this.renderCoords);
              }
              if (this.sceneGlobalTransform === undefined) {
                return;
              }
              var _this$sceneGlobalTran = this.sceneGlobalTransform,
                stx = _this$sceneGlobalTran.tx,
                sty = _this$sceneGlobalTran.ty,
                sta = _this$sceneGlobalTran.ta,
                stb = _this$sceneGlobalTran.tb,
                stc = _this$sceneGlobalTran.tc,
                std = _this$sceneGlobalTran.td;
              if (stb === 0 && stc === 0) {
                var _minX = stx;
                var _maxX = stx + width * sta;
                var _minY = sty;
                var _maxY = sty + height * std;
                this.sceneRenderCoords = RenderCoords.translate(
                //top-left
                _minX, _minY,
                //top-right
                _maxX, _minY,
                //bottom-right
                _maxX, _maxY,
                //bottom-left
                _minX, _maxY, this.sceneRenderCoords);
              } else {
                this.sceneRenderCoords = RenderCoords.translate(
                //top-left
                stx, sty,
                //top-right
                stx + width * sta, sty + width * stc,
                //bottom-right
                stx + width * sta + height * stb, sty + width * stc + height * std,
                //bottom-left
                stx + height * stb, sty + height * std, this.sceneRenderCoords);
              }
            }
            /**
             * This function calculates the clipping rectangle for a node.
             *
             * The function then checks if the node is rotated. If the node requires clipping and is not rotated, a new clipping rectangle is created based on the node's global transform and dimensions.
             * If a parent clipping rectangle exists, it is intersected with the node's clipping rectangle (if it exists), or replaces the node's clipping rectangle.
             *
             * Finally, the node's parentClippingRect and clippingRect properties are updated.
             */
          }, {
            key: "calculateClippingRect",
            value: function calculateClippingRect(parentClippingRect) {
              assertTruthy(this.globalTransform);
              var clippingRect = this.clippingRect,
                props = this.props,
                gt = this.globalTransform;
              var clipping = props.clipping;
              var isRotated = gt.tb !== 0 || gt.tc !== 0;
              if (clipping === true && isRotated === false) {
                clippingRect.x = gt.tx;
                clippingRect.y = gt.ty;
                clippingRect.width = this.width * gt.ta;
                clippingRect.height = this.height * gt.td;
                clippingRect.valid = true;
              } else {
                clippingRect.valid = false;
              }
              if (parentClippingRect.valid === true && clippingRect.valid === true) {
                // Intersect parent clipping rect with node clipping rect
                intersectRect(parentClippingRect, clippingRect, clippingRect);
              } else if (parentClippingRect.valid === true) {
                // Copy parent clipping rect
                copyRect(parentClippingRect, clippingRect);
                clippingRect.valid = true;
              }
            }
          }, {
            key: "calculateZIndex",
            value: function calculateZIndex() {
              var _props$parent, _props$parent2;
              var props = this.props;
              var z = props.zIndex || 0;
              var p = ((_props$parent = props.parent) === null || _props$parent === void 0 ? void 0 : _props$parent.zIndex) || 0;
              var zIndex = z;
              if ((_props$parent2 = props.parent) !== null && _props$parent2 !== void 0 && _props$parent2.zIndexLocked) {
                zIndex = z < p ? z : p;
              }
              this.calcZIndex = zIndex;
            }
            /**
             * Destroy the node and cleanup all resources
             */
          }, {
            key: "destroy",
            value: function destroy() {
              if (this.destroyed === true) {
                return;
              }
              this.destroyed = true;
              this.unloadTexture();
              this.clippingRect.valid = false;
              this.isRenderable = false;
              this.renderCoords = undefined;
              this.renderBound = undefined;
              this.strictBound = undefined;
              this.preloadBound = undefined;
              this.globalTransform = undefined;
              this.scaleRotateTransform = undefined;
              this.localTransform = undefined;
              this.props.texture = null;
              this.props.shader = this.stage.defShaderCtr;
              while (this.children.length > 0) {
                var _this$children$;
                (_this$children$ = this.children[0]) === null || _this$children$ === void 0 || _this$children$.destroy();
              }
              // This very action will also remove the node from the parent's children array
              this.parent = null;
              if (this.rtt) {
                this.stage.renderer.removeRTTNode(this);
              }
              this.removeAllListeners();
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(renderer) {
              // Prevent quad rendering if parent has a render texture
              // and renderer is not currently rendering to a texture
              if (this.parentHasRenderTexture) {
                if (!renderer.renderToTextureActive) {
                  return;
                }
                // Prevent quad rendering if parent render texture is not the active render texture
                if (this.parentRenderTexture !== renderer.activeRttNode) {
                  return;
                }
              }
              assertTruthy(this.globalTransform);
              assertTruthy(this.renderCoords);
              // add to list of renderables to be sorted before rendering
              renderer.addQuad({
                width: this.props.width,
                height: this.props.height,
                colorTl: this.premultipliedColorTl,
                colorTr: this.premultipliedColorTr,
                colorBl: this.premultipliedColorBl,
                colorBr: this.premultipliedColorBr,
                // if we do not have a texture, use the default texture
                // this assumes any renderable node is either a distinct texture or a ColorTexture
                texture: this.texture || this.stage.defaultTexture,
                textureOptions: this.textureOptions,
                zIndex: this.zIndex,
                shader: this.shader.shader,
                shaderProps: this.shader.getResolvedProps(),
                alpha: this.worldAlpha,
                clippingRect: this.clippingRect,
                tx: this.globalTransform.tx,
                ty: this.globalTransform.ty,
                ta: this.globalTransform.ta,
                tb: this.globalTransform.tb,
                tc: this.globalTransform.tc,
                td: this.globalTransform.td,
                renderCoords: this.renderCoords,
                rtt: this.rtt,
                parentHasRenderTexture: this.parentHasRenderTexture,
                framebufferDimensions: this.framebufferDimensions
              });
            }
            //#region Properties
          }, {
            key: "id",
            get: function get() {
              return this._id;
            }
          }, {
            key: "data",
            get: function get() {
              return this.props.data;
            },
            set: function set(d) {
              this.props.data = d;
            }
          }, {
            key: "x",
            get: function get() {
              return this.props.x;
            },
            set: function set(value) {
              if (this.props.x !== value) {
                this.props.x = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "absX",
            get: function get() {
              var _this$props$parent, _this$props$parent2;
              return this.props.x + -this.props.width * this.props.mountX + (((_this$props$parent = this.props.parent) === null || _this$props$parent === void 0 ? void 0 : _this$props$parent.absX) || ((_this$props$parent2 = this.props.parent) === null || _this$props$parent2 === void 0 || (_this$props$parent2 = _this$props$parent2.globalTransform) === null || _this$props$parent2 === void 0 ? void 0 : _this$props$parent2.tx) || 0);
            }
          }, {
            key: "absY",
            get: function get() {
              var _this$props$parent$ab, _this$props$parent3;
              return this.props.y + -this.props.height * this.props.mountY + ((_this$props$parent$ab = (_this$props$parent3 = this.props.parent) === null || _this$props$parent3 === void 0 ? void 0 : _this$props$parent3.absY) !== null && _this$props$parent$ab !== void 0 ? _this$props$parent$ab : 0);
            }
          }, {
            key: "y",
            get: function get() {
              return this.props.y;
            },
            set: function set(value) {
              if (this.props.y !== value) {
                this.props.y = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              if (this.props.width !== value) {
                this.props.width = value;
                this.setUpdateType(UpdateType.Local);
                if (this.props.rtt) {
                  this.texture = this.stage.txManager.createTexture('RenderTexture', {
                    width: this.width,
                    height: this.height
                  });
                  this.setUpdateType(UpdateType.RenderTexture);
                }
              }
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              if (this.props.height !== value) {
                this.props.height = value;
                this.setUpdateType(UpdateType.Local);
                if (this.props.rtt) {
                  this.texture = this.stage.txManager.createTexture('RenderTexture', {
                    width: this.width,
                    height: this.height
                  });
                  this.setUpdateType(UpdateType.RenderTexture);
                }
              }
            }
          }, {
            key: "scale",
            get: function get() {
              // The CoreNode `scale` property is only used by Animations.
              // Unlike INode, `null` should never be possibility for Animations.
              return this.scaleX;
            },
            set: function set(value) {
              // The CoreNode `scale` property is only used by Animations.
              // Unlike INode, `null` should never be possibility for Animations.
              this.scaleX = value;
              this.scaleY = value;
            }
          }, {
            key: "scaleX",
            get: function get() {
              return this.props.scaleX;
            },
            set: function set(value) {
              if (this.props.scaleX !== value) {
                this.props.scaleX = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "scaleY",
            get: function get() {
              return this.props.scaleY;
            },
            set: function set(value) {
              if (this.props.scaleY !== value) {
                this.props.scaleY = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "mount",
            get: function get() {
              return this.props.mount;
            },
            set: function set(value) {
              if (this.props.mountX !== value || this.props.mountY !== value) {
                this.props.mountX = value;
                this.props.mountY = value;
                this.props.mount = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "mountX",
            get: function get() {
              return this.props.mountX;
            },
            set: function set(value) {
              if (this.props.mountX !== value) {
                this.props.mountX = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "mountY",
            get: function get() {
              return this.props.mountY;
            },
            set: function set(value) {
              if (this.props.mountY !== value) {
                this.props.mountY = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivot",
            get: function get() {
              return this.props.pivot;
            },
            set: function set(value) {
              if (this.props.pivotX !== value || this.props.pivotY !== value) {
                this.props.pivotX = value;
                this.props.pivotY = value;
                this.props.pivot = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivotX",
            get: function get() {
              return this.props.pivotX;
            },
            set: function set(value) {
              if (this.props.pivotX !== value) {
                this.props.pivotX = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "pivotY",
            get: function get() {
              return this.props.pivotY;
            },
            set: function set(value) {
              if (this.props.pivotY !== value) {
                this.props.pivotY = value;
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "rotation",
            get: function get() {
              return this.props.rotation;
            },
            set: function set(value) {
              if (this.props.rotation !== value) {
                this.props.rotation = value;
                this.setUpdateType(UpdateType.ScaleRotate);
              }
            }
          }, {
            key: "alpha",
            get: function get() {
              return this.props.alpha;
            },
            set: function set(value) {
              this.props.alpha = value;
              this.setUpdateType(UpdateType.PremultipliedColors | UpdateType.WorldAlpha | UpdateType.Children | UpdateType.IsRenderable);
              this.childUpdateType |= UpdateType.WorldAlpha;
            }
          }, {
            key: "autosize",
            get: function get() {
              return this.props.autosize;
            },
            set: function set(value) {
              this.props.autosize = value;
            }
          }, {
            key: "boundsMargin",
            get: function get() {
              var _ref2, _this$props$boundsMar, _this$parent;
              return (_ref2 = (_this$props$boundsMar = this.props.boundsMargin) !== null && _this$props$boundsMar !== void 0 ? _this$props$boundsMar : (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.boundsMargin) !== null && _ref2 !== void 0 ? _ref2 : this.stage.boundsMargin;
            },
            set: function set(value) {
              if (value === this.props.boundsMargin) {
                return;
              }
              if (value === null) {
                this.props.boundsMargin = value;
              } else {
                var bm = Array.isArray(value) ? value : [value, value, value, value];
                this.props.boundsMargin = bm;
              }
              this.setUpdateType(UpdateType.RenderBounds);
            }
          }, {
            key: "clipping",
            get: function get() {
              return this.props.clipping;
            },
            set: function set(value) {
              this.props.clipping = value;
              this.setUpdateType(UpdateType.Clipping | UpdateType.RenderBounds | UpdateType.Children);
              this.childUpdateType |= UpdateType.Global | UpdateType.Clipping;
            }
          }, {
            key: "color",
            get: function get() {
              return this.props.color;
            },
            set: function set(value) {
              this.colorTop = value;
              this.colorBottom = value;
              this.colorLeft = value;
              this.colorRight = value;
              this.props.color = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTop",
            get: function get() {
              return this.props.colorTop;
            },
            set: function set(value) {
              if (this.props.colorTl !== value || this.props.colorTr !== value) {
                this.colorTl = value;
                this.colorTr = value;
              }
              this.props.colorTop = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBottom",
            get: function get() {
              return this.props.colorBottom;
            },
            set: function set(value) {
              if (this.props.colorBl !== value || this.props.colorBr !== value) {
                this.colorBl = value;
                this.colorBr = value;
              }
              this.props.colorBottom = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorLeft",
            get: function get() {
              return this.props.colorLeft;
            },
            set: function set(value) {
              if (this.props.colorTl !== value || this.props.colorBl !== value) {
                this.colorTl = value;
                this.colorBl = value;
              }
              this.props.colorLeft = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorRight",
            get: function get() {
              return this.props.colorRight;
            },
            set: function set(value) {
              if (this.props.colorTr !== value || this.props.colorBr !== value) {
                this.colorTr = value;
                this.colorBr = value;
              }
              this.props.colorRight = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTl",
            get: function get() {
              return this.props.colorTl;
            },
            set: function set(value) {
              this.props.colorTl = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorTr",
            get: function get() {
              return this.props.colorTr;
            },
            set: function set(value) {
              this.props.colorTr = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBl",
            get: function get() {
              return this.props.colorBl;
            },
            set: function set(value) {
              this.props.colorBl = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
          }, {
            key: "colorBr",
            get: function get() {
              return this.props.colorBr;
            },
            set: function set(value) {
              this.props.colorBr = value;
              this.setUpdateType(UpdateType.PremultipliedColors);
            }
            // we're only interested in parent zIndex to test
            // if we should use node zIndex is higher then parent zIndex
          }, {
            key: "zIndexLocked",
            get: function get() {
              return this.props.zIndexLocked || 0;
            },
            set: function set(value) {
              this.props.zIndexLocked = value;
              this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
              for (var i = 0, length = this.children.length; i < length; i++) {
                this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
              }
            }
          }, {
            key: "zIndex",
            get: function get() {
              return this.props.zIndex;
            },
            set: function set(value) {
              this.props.zIndex = value;
              this.setUpdateType(UpdateType.CalculatedZIndex | UpdateType.Children);
              for (var i = 0, length = this.children.length; i < length; i++) {
                this.children[i].setUpdateType(UpdateType.CalculatedZIndex);
              }
            }
          }, {
            key: "parent",
            get: function get() {
              return this.props.parent;
            },
            set: function set(newParent) {
              var oldParent = this.props.parent;
              if (oldParent === newParent) {
                return;
              }
              this.props.parent = newParent;
              if (oldParent) {
                var index = oldParent.children.indexOf(this);
                oldParent.children.splice(index, 1);
                oldParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
              }
              if (newParent) {
                newParent.children.push(this);
                // Since this node has a new parent, to be safe, have it do a full update.
                this.setUpdateType(UpdateType.All);
                // Tell parent that it's children need to be updated and sorted.
                newParent.setUpdateType(UpdateType.Children | UpdateType.ZIndexSortedChildren);
                // If the new parent has an RTT enabled, apply RTT inheritance
                if (newParent.rtt || newParent.parentHasRenderTexture) {
                  this.applyRTTInheritance(newParent);
                }
              }
              this.updateScaleRotateTransform();
              // fetch render bounds from parent
              this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
            }
          }, {
            key: "preventCleanup",
            get: function get() {
              return this.props.textureOptions.preventCleanup || false;
            },
            set: function set(value) {
              this.props.textureOptions.preventCleanup = value;
            }
          }, {
            key: "rtt",
            get: function get() {
              return this.props.rtt;
            },
            set: function set(value) {
              if (this.props.rtt === value) {
                return;
              }
              this.props.rtt = value;
              if (value === true) {
                this.initRenderTexture();
                this.markChildrenWithRTT();
              } else {
                this.cleanupRenderTexture();
              }
              this.setUpdateType(UpdateType.RenderTexture);
              if (this.parentHasRenderTexture === true) {
                this.notifyParentRTTOfUpdate();
              }
            }
          }, {
            key: "initRenderTexture",
            value: function initRenderTexture() {
              this.texture = this.stage.txManager.createTexture('RenderTexture', {
                width: this.width,
                height: this.height
              });
              this.stage.renderer.renderToTexture(this);
            }
          }, {
            key: "cleanupRenderTexture",
            value: function cleanupRenderTexture() {
              this.unloadTexture();
              this.clearRTTInheritance();
              this.hasRTTupdates = false;
              this.texture = null;
            }
          }, {
            key: "markChildrenWithRTT",
            value: function markChildrenWithRTT() {
              var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              var parent = node || this;
              var _iterator6 = _createForOfIteratorHelper(parent.children),
                _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  var child = _step6.value;
                  child.setUpdateType(UpdateType.All);
                  child.parentHasRenderTexture = true;
                  child.markChildrenWithRTT();
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            }
            // Apply RTT inheritance when a node has an RTT-enabled parent
          }, {
            key: "applyRTTInheritance",
            value: function applyRTTInheritance(parent) {
              if (parent.rtt) {
                // Only the RTT node should be added to `renderToTexture`
                parent.setUpdateType(UpdateType.RenderTexture);
              }
              // Propagate `parentHasRenderTexture` downwards
              this.markChildrenWithRTT(parent);
            }
            // Clear RTT inheritance when detaching from an RTT chain
          }, {
            key: "clearRTTInheritance",
            value: function clearRTTInheritance() {
              // if this node is RTT itself stop the propagation important for nested RTT nodes
              // for the initial RTT node this is already handled in `set rtt`
              if (this.rtt) {
                return;
              }
              var _iterator7 = _createForOfIteratorHelper(this.children),
                _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var child = _step7.value;
                  // force child to update everything as the RTT inheritance has changed
                  child.parentHasRenderTexture = false;
                  child.rttParent = null;
                  child.setUpdateType(UpdateType.All);
                  child.clearRTTInheritance();
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          }, {
            key: "shader",
            get: function get() {
              return this.props.shader;
            },
            set: function set(value) {
              if (this.props.shader === value) {
                return;
              }
              this.props.shader = value;
              this.setUpdateType(UpdateType.IsRenderable);
            }
          }, {
            key: "src",
            get: function get() {
              return this.props.src;
            },
            set: function set(imageUrl) {
              if (this.props.src === imageUrl) {
                return;
              }
              this.props.src = imageUrl;
              if (!imageUrl) {
                this.texture = null;
                return;
              }
              this.texture = this.stage.txManager.createTexture('ImageTexture', {
                src: imageUrl,
                width: this.props.width,
                height: this.props.height,
                type: this.props.imageType,
                sx: this.props.srcX,
                sy: this.props.srcY,
                sw: this.props.srcWidth,
                sh: this.props.srcHeight,
                maxRetryCount: this.props.textureOptions.maxRetryCount
              });
            }
          }, {
            key: "imageType",
            get: function get() {
              return this.props.imageType || null;
            },
            set: function set(type) {
              if (this.props.imageType === type) {
                return;
              }
              this.props.imageType = type;
            }
          }, {
            key: "srcHeight",
            get: function get() {
              return this.props.srcHeight;
            },
            set: function set(value) {
              this.props.srcHeight = value;
            }
          }, {
            key: "srcWidth",
            get: function get() {
              return this.props.srcWidth;
            },
            set: function set(value) {
              this.props.srcWidth = value;
            }
          }, {
            key: "srcX",
            get: function get() {
              return this.props.srcX;
            },
            set: function set(value) {
              this.props.srcX = value;
            }
          }, {
            key: "srcY",
            get: function get() {
              return this.props.srcY;
            },
            set: function set(value) {
              this.props.srcY = value;
            }
            /**
             * Returns the framebuffer dimensions of the node.
             * If the node has a render texture, the dimensions are the same as the node's dimensions.
             * If the node does not have a render texture, the dimensions are inherited from the parent.
             * If the node parent has a render texture and the node is a render texture, the nodes dimensions are used.
             */
          }, {
            key: "framebufferDimensions",
            get: function get() {
              if (this.parentHasRenderTexture && !this.rtt && this.parent) {
                return this.parent.framebufferDimensions;
              }
              return {
                width: this.width,
                height: this.height
              };
            }
            /**
             * Returns the parent render texture node if it exists.
             */
          }, {
            key: "parentRenderTexture",
            get: function get() {
              var parent = this.parent;
              while (parent) {
                if (parent.rtt) {
                  return parent;
                }
                parent = parent.parent;
              }
              return null;
            }
          }, {
            key: "texture",
            get: function get() {
              return this.props.texture;
            },
            set: function set(value) {
              if (this.props.texture === value) {
                return;
              }
              var oldTexture = this.props.texture;
              if (oldTexture) {
                this.unloadTexture();
              }
              this.props.texture = value;
              if (value !== null) {
                value.setRenderableOwner(this._id, this.isRenderable);
                this.loadTexture();
              }
              this.setUpdateType(UpdateType.IsRenderable);
            }
          }, {
            key: "textureOptions",
            get: function get() {
              return this.props.textureOptions;
            },
            set: function set(value) {
              this.props.textureOptions = value;
            }
          }, {
            key: "strictBounds",
            get: function get() {
              return this.props.strictBounds;
            },
            set: function set(v) {
              if (v === this.props.strictBounds) {
                return;
              }
              this.props.strictBounds = v;
              this.setUpdateType(UpdateType.RenderBounds | UpdateType.Children);
              this.childUpdateType |= UpdateType.RenderBounds | UpdateType.Children;
            }
          }, {
            key: "interactive",
            get: function get() {
              return this.props.interactive;
            },
            set: function set(value) {
              this.props.interactive = value;
              // Update Stage's interactive Set
              if (value === true) {
                this.stage.interactiveNodes.add(this);
              }
            }
          }, {
            key: "animate",
            value: function animate(props, settings) {
              var animation = new CoreAnimation(this, props, settings);
              var controller = new CoreAnimationController(this.stage.animationManager, animation);
              return controller;
            }
          }, {
            key: "flush",
            value: function flush() {
              // no-op
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Platform render loop initiator
         */
        var startLoop = function startLoop(stage) {
          var isIdle = false;
          var lastFrameTime = 0;
          var _runLoop = function runLoop() {
            var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var targetFrameTime = stage.targetFrameTime;
            // Check if we should throttle this frame
            if (targetFrameTime > 0 && currentTime - lastFrameTime < targetFrameTime) {
              // Too early for next frame, schedule with setTimeout for precise timing
              var _delay = targetFrameTime - (currentTime - lastFrameTime);
              setTimeout(function () {
                return requestAnimationFrame(_runLoop);
              }, _delay);
              return;
            }
            lastFrameTime = currentTime;
            stage.updateFrameTime();
            stage.updateAnimations();
            if (!stage.hasSceneUpdates()) {
              // We still need to calculate the fps else it looks like the app is frozen
              stage.calculateFps();
              if (targetFrameTime > 0) {
                // Use setTimeout for throttled idle frames
                setTimeout(function () {
                  return requestAnimationFrame(_runLoop);
                }, Math.max(targetFrameTime, 16.666666666666668));
              } else {
                // Use standard idle timeout when not throttling
                setTimeout(function () {
                  return requestAnimationFrame(_runLoop);
                }, 16.666666666666668);
              }
              if (!isIdle) {
                stage.eventBus.emit('idle');
                isIdle = true;
              }
              if (stage.txMemManager.checkCleanup() === true) {
                stage.txMemManager.cleanup();
              }
              stage.flushFrameEvents();
              return;
            }
            isIdle = false;
            stage.drawFrame();
            stage.flushFrameEvents();
            // Schedule next frame
            if (targetFrameTime > 0) {
              // Use setTimeout + rAF combination for precise FPS control
              var nextFrameDelay = Math.max(0, targetFrameTime - (performance.now() - currentTime));
              setTimeout(function () {
                return requestAnimationFrame(_runLoop);
              }, nextFrameDelay);
            } else {
              // Use standard rAF when not throttling
              requestAnimationFrame(_runLoop);
            }
          };
          requestAnimationFrame(_runLoop);
        };
        /**
         * Return unix timestamp
         * @return {number}
         */
        var getTimeStamp = function getTimeStamp() {
          return performance ? performance.now() : Date.now();
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var AnimationManager = /*#__PURE__*/function () {
          function AnimationManager() {
            _classCallCheck(this, AnimationManager);
            _defineProperty(this, "activeAnimations", new Set());
          }
          return _createClass(AnimationManager, [{
            key: "registerAnimation",
            value: function registerAnimation(animation) {
              this.activeAnimations.add(animation);
            }
          }, {
            key: "unregisterAnimation",
            value: function unregisterAnimation(animation) {
              this.activeAnimations.delete(animation);
            }
          }, {
            key: "update",
            value: function update(dt) {
              this.activeAnimations.forEach(function (animation) {
                animation.update(dt);
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Note that, within the createImageWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
         *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
         *
         * The createImageWorker function is a web worker that fetches an image from a URL and returns an ImageBitmap object.
         * The eslint @typescript rule is disabled for the entire function because the function is converted to a blob and used as the
         * js of the web worker thread, so the typescript syntax is not valid in this context.
         */
        /* eslint-disable */
        function createImageWorker() {
          function hasAlphaChannel(mimeType) {
            return mimeType.indexOf('image/png') !== -1;
          }
          function getImage(src, premultiplyAlpha, x, y, width, height, options) {
            return new Promise(function (resolve, reject) {
              var xhr = new XMLHttpRequest();
              xhr.open('GET', src, true);
              xhr.responseType = 'blob';
              xhr.onload = function () {
                // On most devices like WebOS and Tizen, the file protocol returns 0 while http(s) protocol returns 200
                if (xhr.status !== 200 && xhr.status !== 0) {
                  return reject(new Error('Failed to load image: ' + xhr.statusText));
                }
                var blob = xhr.response;
                premultiplyAlpha !== undefined ? premultiplyAlpha : hasAlphaChannel(blob.type);
                // createImageBitmap with crop and options
                {
                  // Fallback for browsers that do not support createImageBitmap with options
                  // this is supported for Chrome v50 to v52/54 that doesn't support options
                  createImageBitmap(blob).then(function (data) {
                    resolve({
                      data: data,
                      premultiplyAlpha: premultiplyAlpha
                    });
                  }).catch(function (error) {
                    reject(error);
                  });
                }
              };
              xhr.onerror = function () {
                reject(new Error('Network error occurred while trying to fetch the image.'));
              };
              xhr.send();
            });
          }
          self.onmessage = function (event) {
            var src = event.data.src;
            var id = event.data.id;
            var premultiplyAlpha = event.data.premultiplyAlpha;
            event.data.sx;
            event.data.sy;
            event.data.sw;
            event.data.sh;
            getImage(src, premultiplyAlpha).then(function (data) {
              // @ts-ignore ts has wrong postMessage signature
              self.postMessage({
                id: id,
                src: src,
                data: data
              }, [data.data]);
            }).catch(function (error) {
              self.postMessage({
                id: id,
                src: src,
                error: error.message
              });
            });
          };
        }
        /* eslint-enable */
        var ImageWorkerManager = /*#__PURE__*/function () {
          function ImageWorkerManager(numImageWorkers, createImageBitmapSupport) {
            var _this1 = this;
            _classCallCheck(this, ImageWorkerManager);
            _defineProperty(this, "imageWorkersEnabled", true);
            _defineProperty(this, "messageManager", {});
            _defineProperty(this, "workers", []);
            _defineProperty(this, "workerIndex", 0);
            _defineProperty(this, "nextId", 0);
            this.workers = this.createWorkers(numImageWorkers, createImageBitmapSupport);
            this.workers.forEach(function (worker) {
              worker.onmessage = _this1.handleMessage.bind(_this1);
            });
          }
          return _createClass(ImageWorkerManager, [{
            key: "handleMessage",
            value: function handleMessage(event) {
              var _event$data = event.data,
                id = _event$data.id,
                data = _event$data.data,
                error = _event$data.error;
              var msg = this.messageManager[id];
              if (msg) {
                var _msg = _slicedToArray(msg, 2),
                  resolve = _msg[0],
                  reject = _msg[1];
                delete this.messageManager[id];
                if (error) {
                  reject(new Error(error));
                } else {
                  resolve(data);
                }
              }
            }
          }, {
            key: "createWorkers",
            value: function createWorkers() {
              var numWorkers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
              var createImageBitmapSupport = arguments.length > 1 ? arguments[1] : undefined;
              var workerCode = "(".concat(createImageWorker.toString(), ")()");
              // Replace placeholders with actual initialization values
              if (createImageBitmapSupport.options === true) {
                workerCode = workerCode.replace('var supportsOptionsCreateImageBitmap = false;', 'var supportsOptionsCreateImageBitmap = true;');
              }
              if (createImageBitmapSupport.full === true) {
                workerCode = workerCode.replace('var supportsOptionsCreateImageBitmap = false;', 'var supportsOptionsCreateImageBitmap = true;');
                workerCode = workerCode.replace('var supportsFullCreateImageBitmap = false;', 'var supportsFullCreateImageBitmap = true;');
              }
              workerCode = workerCode.replace('"use strict";', '');
              var blob = new Blob([workerCode], {
                type: 'application/javascript'
              });
              var blobURL = (self.URL ? URL : webkitURL).createObjectURL(blob);
              var workers = [];
              for (var i = 0; i < numWorkers; i++) {
                workers.push(new Worker(blobURL));
              }
              return workers;
            }
          }, {
            key: "getNextWorker",
            value: function getNextWorker() {
              var worker = this.workers[this.workerIndex];
              this.workerIndex = (this.workerIndex + 1) % this.workers.length;
              return worker;
            }
          }, {
            key: "getImage",
            value: function getImage(src, premultiplyAlpha, sx, sy, sw, sh) {
              var _this10 = this;
              return new Promise(function (resolve, reject) {
                try {
                  if (_this10.workers) {
                    var id = _this10.nextId++;
                    _this10.messageManager[id] = [resolve, reject];
                    var nextWorker = _this10.getNextWorker();
                    if (nextWorker) {
                      nextWorker.postMessage({
                        id: id,
                        src: src,
                        premultiplyAlpha: premultiplyAlpha,
                        sx: sx,
                        sy: sy,
                        sw: sw,
                        sh: sh
                      });
                    }
                  }
                } catch (error) {
                  reject(error);
                }
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of only a 1x1 color pixel
         *
         * @remarks
         * The pixel color is set with the {@link ColorTextureProps.color} prop.
         *
         * This is the default texture used for a Node if it's
         * {@link INodeProps.texture} prop is set to `null` (the default)
         *
         * Generally the 1x1 color pixel is stretched to whatever the set dimensions of
         * a Node are.
         */
        var ColorTexture = /*#__PURE__*/function (_Texture2) {
          function ColorTexture(txManager, props) {
            var _this11;
            _classCallCheck(this, ColorTexture);
            _this11 = _callSuper(this, ColorTexture, [txManager]);
            _defineProperty(_this11, "type", TextureType.color);
            _defineProperty(_this11, "props", void 0);
            _this11.props = ColorTexture.resolveDefaults(props);
            return _this11;
          }
          _inherits(ColorTexture, _Texture2);
          return _createClass(ColorTexture, [{
            key: "color",
            get: function get() {
              return this.props.color;
            },
            set: function set(color) {
              this.props.color = color;
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
                var pixelData;
                return _regenerator().w(function (_context2) {
                  while (1) switch (_context2.n) {
                    case 0:
                      pixelData = new Uint8Array(4);
                      if (this.color === 0xffffffff) {
                        pixelData[0] = 255;
                        pixelData[1] = 255;
                        pixelData[2] = 255;
                        pixelData[3] = 255;
                      } else {
                        pixelData[0] = this.color >> 16 & 0xff; // Red
                        pixelData[1] = this.color >> 8 & 0xff; // Green
                        pixelData[2] = this.color & 0xff; // Blue
                        pixelData[3] = this.color >>> 24 & 0xff; // Alpha
                      }
                      return _context2.a(2, {
                        data: pixelData,
                        premultiplyAlpha: true
                      });
                  }
                }, _callee2, this);
              }));
              function getTextureSource() {
                return _getTextureSource.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              var resolvedProps = ColorTexture.resolveDefaults(props);
              return "ColorTexture,".concat(resolvedProps.color);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                color: props.color || 0xffffffff
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Tests if the given location is a compressed texture container
         * @param url
         * @remarks
         * This function is used to determine if the given image url is a compressed
         * and only supports the following extensions: .ktx and .pvr
         * @returns
         */
        _defineProperty(ColorTexture, "z$__type__Props", void 0);
        function isCompressedTextureContainer(url) {
          return /\.(ktx|pvr)$/.test(url);
        }
        /**
         * Loads a compressed texture container
         * @param url
         * @returns
         */
        var loadCompressedTexture = /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(url) {
            var response, arrayBuffer, _t;
            return _regenerator().w(function (_context3) {
              while (1) switch (_context3.p = _context3.n) {
                case 0:
                  _context3.p = 0;
                  _context3.n = 1;
                  return fetch(url);
                case 1:
                  response = _context3.v;
                  if (response.ok) {
                    _context3.n = 2;
                    break;
                  }
                  throw new Error("Failed to fetch compressed texture: ".concat(response.status, " ").concat(response.statusText));
                case 2:
                  _context3.n = 3;
                  return response.arrayBuffer();
                case 3:
                  arrayBuffer = _context3.v;
                  if (!(url.indexOf('.ktx') !== -1)) {
                    _context3.n = 4;
                    break;
                  }
                  return _context3.a(2, loadKTXData(arrayBuffer));
                case 4:
                  return _context3.a(2, loadPVRData(arrayBuffer));
                case 5:
                  _context3.p = 5;
                  _t = _context3.v;
                  throw new Error("Failed to load compressed texture from ".concat(url, ": ").concat(_t));
                case 6:
                  return _context3.a(2);
              }
            }, _callee3, null, [[0, 5]]);
          }));
          return function loadCompressedTexture(_x2) {
            return _ref3.apply(this, arguments);
          };
        }();
        /**
         * Loads a KTX texture container and returns the texture data
         * @param buffer
         * @returns
         */
        var loadKTXData = /*#__PURE__*/function () {
          var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(buffer) {
            var view, littleEndian, mipmaps, data, offset, i, imageSize;
            return _regenerator().w(function (_context4) {
              while (1) switch (_context4.n) {
                case 0:
                  view = new DataView(buffer);
                  littleEndian = view.getUint32(12) === 16909060 ? true : false;
                  mipmaps = [];
                  data = {
                    glInternalFormat: view.getUint32(28, littleEndian),
                    pixelWidth: view.getUint32(36, littleEndian),
                    pixelHeight: view.getUint32(40, littleEndian),
                    numberOfMipmapLevels: view.getUint32(56, littleEndian),
                    bytesOfKeyValueData: view.getUint32(60, littleEndian)
                  };
                  offset = 64; // Key Value Pairs of data start at byte offset 64
                  // But the only known kvp is the API version, so skipping parsing.
                  offset += data.bytesOfKeyValueData;
                  for (i = 0; i < data.numberOfMipmapLevels; i++) {
                    imageSize = view.getUint32(offset);
                    offset += 4;
                    mipmaps.push(view.buffer.slice(offset, imageSize));
                    offset += imageSize;
                  }
                  return _context4.a(2, {
                    data: {
                      glInternalFormat: data.glInternalFormat,
                      mipmaps: mipmaps,
                      width: data.pixelWidth || 0,
                      height: data.pixelHeight || 0,
                      type: 'ktx'
                    },
                    premultiplyAlpha: false
                  });
              }
            }, _callee4);
          }));
          return function loadKTXData(_x3) {
            return _ref4.apply(this, arguments);
          };
        }();
        /**
         * Loads a PVR texture container and returns the texture data
         * @param buffer
         * @returns
         */
        var loadPVRData = /*#__PURE__*/function () {
          var _ref5 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(buffer) {
            var pvrHeaderLength, pvrFormatEtc1, pvrWidth, pvrHeight, pvrMipmapCount, pvrMetadata, arrayBuffer, header, dataOffset, pvrtcData, mipmaps, data, offset, width, height, i, level, view;
            return _regenerator().w(function (_context5) {
              while (1) switch (_context5.n) {
                case 0:
                  // pvr header length in 32 bits
                  pvrHeaderLength = 13; // for now only we only support: COMPRESSED_RGB_ETC1_WEBGL
                  pvrFormatEtc1 = 0x8d64;
                  pvrWidth = 7;
                  pvrHeight = 6;
                  pvrMipmapCount = 11;
                  pvrMetadata = 12;
                  arrayBuffer = buffer;
                  header = new Int32Array(arrayBuffer, 0, pvrHeaderLength); // @ts-expect-error Object possibly undefined
                  dataOffset = header[pvrMetadata] + 52;
                  pvrtcData = new Uint8Array(arrayBuffer, dataOffset);
                  mipmaps = [];
                  data = {
                    pixelWidth: header[pvrWidth],
                    pixelHeight: header[pvrHeight],
                    numberOfMipmapLevels: header[pvrMipmapCount] || 0
                  };
                  offset = 0;
                  width = data.pixelWidth || 0;
                  height = data.pixelHeight || 0;
                  for (i = 0; i < data.numberOfMipmapLevels; i++) {
                    level = (width + 3 >> 2) * (height + 3 >> 2) * 8;
                    view = new Uint8Array(arrayBuffer, pvrtcData.byteOffset + offset, level);
                    mipmaps.push(view);
                    offset += level;
                    width = width >> 1;
                    height = height >> 1;
                  }
                  return _context5.a(2, {
                    data: {
                      glInternalFormat: pvrFormatEtc1,
                      mipmaps: mipmaps,
                      width: data.pixelWidth || 0,
                      height: data.pixelHeight || 0,
                      type: 'pvr'
                    },
                    premultiplyAlpha: false
                  });
              }
            }, _callee5);
          }));
          return function loadPVRData(_x4) {
            return _ref5.apply(this, arguments);
          };
        }();

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Tests if the given location is a SVG
         * @param url
         * @remarks
         * This function is used to determine if the given image url is a SVG
         * image
         * @returns
         */
        function isSvgImage(url) {
          return /\.(svg)(\?.*)?$/.test(url);
        }
        /**
         * Loads a SVG image
         * @param url
         * @returns
         */
        var loadSvg = function loadSvg(url, width, height, sx, sy, sw, sh) {
          return new Promise(function (resolve, reject) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            var img = new Image();
            img.onload = function () {
              var x = sx !== null && sx !== void 0 ? sx : 0;
              var y = sy !== null && sy !== void 0 ? sy : 0;
              var w = width || img.width;
              var h = height || img.height;
              canvas.width = w;
              canvas.height = h;
              ctx.drawImage(img, 0, 0, w, h);
              resolve({
                data: ctx.getImageData(x, y, sw !== null && sw !== void 0 ? sw : w, sh !== null && sh !== void 0 ? sh : h),
                premultiplyAlpha: false
              });
            };
            img.onerror = function (err) {
              reject(err);
            };
            img.src = url;
          });
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2020 Metrological
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function fetchJson(url) {
          var responseType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = responseType;
            xhr.onreadystatechange = function () {
              if (xhr.readyState == XMLHttpRequest.DONE) {
                // On most devices like WebOS and Tizen, the file protocol returns 0 while http(s) protocol returns 200
                if (xhr.status === 0 || xhr.status === 200) {
                  resolve(xhr.response);
                } else {
                  reject(xhr.statusText);
                }
              }
            };
            xhr.open('GET', url, true);
            xhr.send(null);
          });
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of an image loaded from a URL
         *
         * @remarks
         * The ImageTexture's {@link ImageTextureProps.src} prop defines the image URL
         * to be downloaded.
         *
         * By default, the texture's alpha values will be premultiplied into its color
         * values which is generally the desired setting before they are sent to the
         * texture's associated {@link Shader}. However, in special cases you may want
         * the Shader to receive straight (non-premultiplied) values. In that case you
         * can disable the default behavior by setting the
         * {@link ImageTextureProps.premultiplyAlpha} prop to `false`.
         */
        var ImageTexture = /*#__PURE__*/function (_Texture3) {
          function ImageTexture(txManager, props) {
            var _resolvedProps$maxRet;
            var _this12;
            _classCallCheck(this, ImageTexture);
            var resolvedProps = ImageTexture.resolveDefaults(props);
            _this12 = _callSuper(this, ImageTexture, [txManager]);
            _defineProperty(_this12, "type", TextureType.image);
            _defineProperty(_this12, "props", void 0);
            _this12.props = resolvedProps;
            _this12.maxRetryCount = (_resolvedProps$maxRet = resolvedProps.maxRetryCount) !== null && _resolvedProps$maxRet !== void 0 ? _resolvedProps$maxRet : _this12.txManager.maxRetryCount;
            return _this12;
          }
          _inherits(ImageTexture, _Texture3);
          return _createClass(ImageTexture, [{
            key: "hasAlphaChannel",
            value: function hasAlphaChannel(mimeType) {
              return mimeType.indexOf('image/png') !== -1;
            }
          }, {
            key: "loadImageFallback",
            value: function () {
              var _loadImageFallback = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(src, hasAlpha) {
                var img;
                return _regenerator().w(function (_context6) {
                  while (1) switch (_context6.n) {
                    case 0:
                      img = new Image();
                      if (typeof src === 'string' && isBase64Image(src) === false) {
                        img.crossOrigin = 'anonymous';
                      }
                      return _context6.a(2, new Promise(function (resolve, reject) {
                        img.onload = function () {
                          resolve({
                            data: img,
                            premultiplyAlpha: hasAlpha
                          });
                        };
                        img.onerror = function (err) {
                          var errorMessage = err instanceof Error ? err.message : err instanceof Event ? "Image loading failed for ".concat(img.src) : 'Unknown image loading error';
                          reject(new Error("Image loading failed: ".concat(errorMessage)));
                        };
                        if (src instanceof Blob) {
                          img.src = URL.createObjectURL(src);
                        } else {
                          img.src = src;
                        }
                      }));
                  }
                }, _callee6);
              }));
              function loadImageFallback(_x1, _x10) {
                return _loadImageFallback.apply(this, arguments);
              }
              return loadImageFallback;
            }()
          }, {
            key: "createImageBitmap",
            value: function (_createImageBitmap) {
              function createImageBitmap(_x5, _x6, _x7, _x8, _x9, _x0) {
                return _createImageBitmap.apply(this, arguments);
              }
              createImageBitmap.toString = function () {
                return _createImageBitmap.toString();
              };
              return createImageBitmap;
            }(/*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(blob, premultiplyAlpha, sx, sy, sw, sh) {
                var hasAlphaChannel, imageBitmapSupported, bitmap, _bitmap, _t2, _t3, _t4, _t5, _t6;
                return _regenerator().w(function (_context7) {
                  while (1) switch (_context7.p = _context7.n) {
                    case 0:
                      hasAlphaChannel = premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : blob.type.includes('image/png');
                      imageBitmapSupported = this.txManager.imageBitmapSupported;
                      if (!(imageBitmapSupported.full === true && sw !== null && sh !== null)) {
                        _context7.n = 4;
                        break;
                      }
                      _context7.p = 1;
                      _context7.n = 2;
                      return createImageBitmap(blob, sx || 0, sy || 0, sw, sh, {
                        premultiplyAlpha: hasAlphaChannel ? 'premultiply' : 'none',
                        colorSpaceConversion: 'none',
                        imageOrientation: 'none'
                      });
                    case 2:
                      bitmap = _context7.v;
                      return _context7.a(2, {
                        data: bitmap,
                        premultiplyAlpha: hasAlphaChannel
                      });
                    case 3:
                      _context7.p = 3;
                      _t2 = _context7.v;
                      throw new Error("Failed to create image bitmap with crop: ".concat(_t2));
                    case 4:
                      if (!(imageBitmapSupported.basic === true)) {
                        _context7.n = 8;
                        break;
                      }
                      _context7.p = 5;
                      _context7.n = 6;
                      return createImageBitmap(blob);
                    case 6:
                      _t3 = _context7.v;
                      _t4 = hasAlphaChannel;
                      return _context7.a(2, {
                        data: _t3,
                        premultiplyAlpha: _t4
                      });
                    case 7:
                      _context7.p = 7;
                      _t5 = _context7.v;
                      throw new Error("Failed to create basic image bitmap: ".concat(_t5));
                    case 8:
                      _context7.p = 8;
                      _context7.n = 9;
                      return createImageBitmap(blob, {
                        premultiplyAlpha: hasAlphaChannel ? 'premultiply' : 'none',
                        colorSpaceConversion: 'none',
                        imageOrientation: 'none'
                      });
                    case 9:
                      _bitmap = _context7.v;
                      return _context7.a(2, {
                        data: _bitmap,
                        premultiplyAlpha: hasAlphaChannel
                      });
                    case 10:
                      _context7.p = 10;
                      _t6 = _context7.v;
                      throw new Error("Failed to create image bitmap with options: ".concat(_t6));
                    case 11:
                      return _context7.a(2);
                  }
                }, _callee7, this, [[8, 10], [5, 7], [1, 3]]);
              }));
              return function (_x11, _x12, _x13, _x14, _x15, _x16) {
                return _ref6.apply(this, arguments);
              };
            }())
          }, {
            key: "loadImage",
            value: function () {
              var _loadImage = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(src) {
                var _this$props4, premultiplyAlpha, sx, sy, sw, sh, blob, _t7, _t8;
                return _regenerator().w(function (_context8) {
                  while (1) switch (_context8.p = _context8.n) {
                    case 0:
                      _this$props4 = this.props, premultiplyAlpha = _this$props4.premultiplyAlpha, sx = _this$props4.sx, sy = _this$props4.sy, sw = _this$props4.sw, sh = _this$props4.sh;
                      if (!(this.txManager.hasCreateImageBitmap === true)) {
                        _context8.n = 8;
                        break;
                      }
                      if (!(isBase64Image(src) === false && this.txManager.hasWorker === true && this.txManager.imageWorkerManager !== null)) {
                        _context8.n = 3;
                        break;
                      }
                      _context8.p = 1;
                      return _context8.a(2, this.txManager.imageWorkerManager.getImage(src, premultiplyAlpha, sx, sy, sw, sh));
                    case 2:
                      _context8.p = 2;
                      _t7 = _context8.v;
                      throw new Error("Failed to load image via worker: ".concat(_t7));
                    case 3:
                      if (!(isBase64Image(src) === true)) {
                        _context8.n = 4;
                        break;
                      }
                      blob = dataURIToBlob(src);
                      _context8.n = 7;
                      break;
                    case 4:
                      _context8.p = 4;
                      _context8.n = 5;
                      return fetchJson(src, 'blob');
                    case 5:
                      blob = _context8.v;
                      _context8.n = 7;
                      break;
                    case 6:
                      _context8.p = 6;
                      _t8 = _context8.v;
                      throw new Error("Failed to fetch image blob from ".concat(src, ": ").concat(_t8));
                    case 7:
                      return _context8.a(2, this.createImageBitmap(blob, premultiplyAlpha, sx, sy, sw, sh));
                    case 8:
                      return _context8.a(2, this.loadImageFallback(src, premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : true));
                  }
                }, _callee8, this, [[4, 6], [1, 2]]);
              }));
              function loadImage(_x17) {
                return _loadImage.apply(this, arguments);
              }
              return loadImage;
            }()
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9() {
                var _this$props$premultip;
                var resp, _t9;
                return _regenerator().w(function (_context9) {
                  while (1) switch (_context9.p = _context9.n) {
                    case 0:
                      _context9.p = 0;
                      _context9.n = 1;
                      return this.determineImageTypeAndLoadImage();
                    case 1:
                      resp = _context9.v;
                      _context9.n = 3;
                      break;
                    case 2:
                      _context9.p = 2;
                      _t9 = _context9.v;
                      this.setState('failed', _t9);
                      return _context9.a(2, {
                        data: null
                      });
                    case 3:
                      if (!(resp.data === null)) {
                        _context9.n = 4;
                        break;
                      }
                      this.setState('failed', Error('ImageTexture: No image data'));
                      return _context9.a(2, {
                        data: null
                      });
                    case 4:
                      return _context9.a(2, {
                        data: resp.data,
                        premultiplyAlpha: (_this$props$premultip = this.props.premultiplyAlpha) !== null && _this$props$premultip !== void 0 ? _this$props$premultip : true
                      });
                  }
                }, _callee9, this, [[0, 2]]);
              }));
              function getTextureSource() {
                return _getTextureSource2.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }, {
            key: "determineImageTypeAndLoadImage",
            value: function determineImageTypeAndLoadImage() {
              var _this$props5 = this.props,
                src = _this$props5.src,
                premultiplyAlpha = _this$props5.premultiplyAlpha,
                type = _this$props5.type;
              if (src === null) {
                return {
                  data: null
                };
              }
              if (typeof src !== 'string') {
                if (src instanceof Blob) {
                  if (this.txManager.hasCreateImageBitmap === true) {
                    var _this$props6 = this.props,
                      sx = _this$props6.sx,
                      sy = _this$props6.sy,
                      sw = _this$props6.sw,
                      sh = _this$props6.sh;
                    return this.createImageBitmap(src, premultiplyAlpha, sx, sy, sw, sh);
                  } else {
                    return this.loadImageFallback(src, premultiplyAlpha !== null && premultiplyAlpha !== void 0 ? premultiplyAlpha : true);
                  }
                }
                if (src instanceof ImageData) {
                  return {
                    data: src,
                    premultiplyAlpha: premultiplyAlpha
                  };
                }
                return {
                  data: src(),
                  premultiplyAlpha: premultiplyAlpha
                };
              }
              var absoluteSrc = convertUrlToAbsolute(src);
              if (type === 'regular') {
                return this.loadImage(absoluteSrc);
              }
              if (type === 'svg') {
                return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
              }
              if (isSvgImage(src) === true) {
                return loadSvg(absoluteSrc, this.props.width, this.props.height, this.props.sx, this.props.sy, this.props.sw, this.props.sh);
              }
              if (type === 'compressed') {
                return loadCompressedTexture(absoluteSrc);
              }
              if (isCompressedTextureContainer(src) === true) {
                return loadCompressedTexture(absoluteSrc);
              }
              // default
              return this.loadImage(absoluteSrc);
            }
            /**
             * Generates a cache key for the ImageTexture based on the provided props.
             * @param props - The props used to generate the cache key.
             * @returns The cache key as a string, or `false` if the key cannot be generated.
             */
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              var _resolvedProps$premul;
              var resolvedProps = ImageTexture.resolveDefaults(props);
              // Only cache key-able textures; prioritise key
              var key = resolvedProps.key || resolvedProps.src;
              if (typeof key !== 'string') {
                return false;
              }
              // if we have source dimensions, cache the texture separately
              var dimensionProps = '';
              if (resolvedProps.sh !== null && resolvedProps.sw !== null) {
                var _resolvedProps$sx, _resolvedProps$sy;
                dimensionProps += ',';
                dimensionProps += (_resolvedProps$sx = resolvedProps.sx) !== null && _resolvedProps$sx !== void 0 ? _resolvedProps$sx : '';
                dimensionProps += (_resolvedProps$sy = resolvedProps.sy) !== null && _resolvedProps$sy !== void 0 ? _resolvedProps$sy : '';
                dimensionProps += resolvedProps.sw || '';
                dimensionProps += resolvedProps.sh || '';
              }
              return "ImageTexture,".concat(key, ",").concat((_resolvedProps$premul = resolvedProps.premultiplyAlpha) !== null && _resolvedProps$premul !== void 0 ? _resolvedProps$premul : 'true').concat(dimensionProps);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$src, _props$premultiplyAlp, _props$key, _props$type, _props$width, _props$height, _props$sx, _props$sy, _props$sw, _props$sh, _props$maxRetryCount;
              return {
                src: (_props$src = props.src) !== null && _props$src !== void 0 ? _props$src : '',
                premultiplyAlpha: (_props$premultiplyAlp = props.premultiplyAlpha) !== null && _props$premultiplyAlp !== void 0 ? _props$premultiplyAlp : true,
                // null,
                key: (_props$key = props.key) !== null && _props$key !== void 0 ? _props$key : null,
                type: (_props$type = props.type) !== null && _props$type !== void 0 ? _props$type : null,
                width: (_props$width = props.width) !== null && _props$width !== void 0 ? _props$width : null,
                height: (_props$height = props.height) !== null && _props$height !== void 0 ? _props$height : null,
                sx: (_props$sx = props.sx) !== null && _props$sx !== void 0 ? _props$sx : null,
                sy: (_props$sy = props.sy) !== null && _props$sy !== void 0 ? _props$sy : null,
                sw: (_props$sw = props.sw) !== null && _props$sw !== void 0 ? _props$sw : null,
                sh: (_props$sh = props.sh) !== null && _props$sh !== void 0 ? _props$sh : null,
                maxRetryCount: (_props$maxRetryCount = props.maxRetryCount) !== null && _props$maxRetryCount !== void 0 ? _props$maxRetryCount : null
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Texture consisting of a random grid of greyscale pixels
         *
         * @remarks
         * The width and height of the NoiseTexture are defined by it's
         * {@link NoiseTextureProps.width} and {@link NoiseTextureProps.height}
         * properties. The {@link NoiseTextureProps.cacheId} prop can be varied in order
         * to bypass cache and get newly randomized texture data.
         */
        _defineProperty(ImageTexture, "z$__type__Props", void 0);
        var NoiseTexture = /*#__PURE__*/function (_Texture4) {
          function NoiseTexture(txManager, props) {
            var _this13;
            _classCallCheck(this, NoiseTexture);
            _this13 = _callSuper(this, NoiseTexture, [txManager]);
            _defineProperty(_this13, "props", void 0);
            _defineProperty(_this13, "type", TextureType.noise);
            _this13.props = NoiseTexture.resolveDefaults(props);
            return _this13;
          }
          _inherits(NoiseTexture, _Texture4);
          return _createClass(NoiseTexture, [{
            key: "getTextureSource",
            value: function () {
              var _getTextureSource3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0() {
                var _this$props7, width, height, size, pixelData8, i, v;
                return _regenerator().w(function (_context0) {
                  while (1) switch (_context0.n) {
                    case 0:
                      _this$props7 = this.props, width = _this$props7.width, height = _this$props7.height;
                      size = width * height * 4;
                      pixelData8 = new Uint8ClampedArray(size);
                      for (i = 0; i < size; i += 4) {
                        v = Math.floor(Math.random() * 256);
                        pixelData8[i] = v;
                        pixelData8[i + 1] = v;
                        pixelData8[i + 2] = v;
                        pixelData8[i + 3] = 255;
                      }
                      // Noise texture data ready - dimensions will be set during upload
                      return _context0.a(2, {
                        data: new ImageData(pixelData8, width, height)
                      });
                  }
                }, _callee0, this);
              }));
              function getTextureSource() {
                return _getTextureSource3.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              if (props.cacheId === undefined) {
                return false;
              }
              var resolvedProps = NoiseTexture.resolveDefaults(props);
              return "NoiseTexture,".concat(resolvedProps.width, ",").concat(resolvedProps.height, ",").concat(resolvedProps.cacheId);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width2, _props$height2, _props$cacheId;
              return {
                width: (_props$width2 = props.width) !== null && _props$width2 !== void 0 ? _props$width2 : 128,
                height: (_props$height2 = props.height) !== null && _props$height2 !== void 0 ? _props$height2 : 128,
                cacheId: (_props$cacheId = props.cacheId) !== null && _props$cacheId !== void 0 ? _props$cacheId : 0
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(NoiseTexture, "z$__type__Props", void 0);
        var subTextureId = 0;
        /**
         * A Texture that is a sub-region of another Texture.
         *
         * @remarks
         * The parent texture can be a Sprite Sheet/Texture Atlas and set using the
         * {@link SubTextureProps.texture} prop. The sub-region relative to the parent
         * texture is defined with the {@link SubTextureProps.x},
         * {@link SubTextureProps.y}, {@link SubTextureProps.width}, and
         * {@link SubTextureProps.height} pixel values.
         */
        var SubTexture = /*#__PURE__*/function (_Texture5) {
          function SubTexture(txManager, props) {
            var _this14;
            _classCallCheck(this, SubTexture);
            _this14 = _callSuper(this, SubTexture, [txManager]);
            _defineProperty(_this14, "props", void 0);
            _defineProperty(_this14, "parentTexture", void 0);
            _defineProperty(_this14, "type", TextureType.subTexture);
            _defineProperty(_this14, "subtextureId", "subtexture-".concat(subTextureId++));
            _defineProperty(_this14, "onParentTxLoaded", function () {
              // We ignore the parent's passed dimensions, and simply use the SubTexture's
              // configured dimensions (because that's all that matters here)
              _this14.forwardParentTxState('loaded', {
                width: _this14.props.width,
                height: _this14.props.height
              });
            });
            _defineProperty(_this14, "onParentTxFailed", function (target, error) {
              //decrement with 1 because in the failed state it will do +1 again.
              _this14.retryCount = _this14.parentTexture.retryCount - 1;
              _this14.forwardParentTxState('failed', error);
            });
            _defineProperty(_this14, "onParentTxLoading", function () {
              _this14.forwardParentTxState('loading');
            });
            _defineProperty(_this14, "onParentTxFreed", function () {
              _this14.forwardParentTxState('freed');
            });
            _this14.props = SubTexture.resolveDefaults(props || {});
            assertTruthy(_this14.props.texture);
            assertTruthy(_this14.props.texture instanceof ImageTexture);
            // Resolve parent texture from cache or fallback to provided texture
            _this14.parentTexture = txManager.resolveParentTexture(_this14.props.texture);
            if (_this14.renderableOwners.length > 0) {
              _this14.parentTexture.setRenderableOwner(_this14.subtextureId, true);
            }
            // If parent texture is already loaded / failed, trigger loaded event manually
            // so that users get a consistent event experience.
            // We do this in a microtask to allow listeners to be attached in the same
            // synchronous task after calling loadTexture()
            queueMicrotask(function () {
              var parentTx = _this14.parentTexture;
              if (parentTx.state === 'loaded' && parentTx.dimensions) {
                _this14.onParentTxLoaded(parentTx, parentTx.dimensions);
              } else if (parentTx.state === 'loading') {
                _this14.onParentTxLoading();
              } else if (parentTx.state === 'failed' && parentTx.error) {
                _this14.onParentTxFailed(parentTx, parentTx.error);
              } else if (parentTx.state === 'freed') {
                _this14.onParentTxFreed();
              }
              parentTx.on('loading', _this14.onParentTxLoading);
              parentTx.on('loaded', _this14.onParentTxLoaded);
              parentTx.on('failed', _this14.onParentTxFailed);
              parentTx.on('freed', _this14.onParentTxFreed);
            });
            return _this14;
          }
          _inherits(SubTexture, _Texture5);
          return _createClass(SubTexture, [{
            key: "forwardParentTxState",
            value: function forwardParentTxState(state, errorOrDimensions) {
              this.setState(state, errorOrDimensions);
            }
          }, {
            key: "onChangeIsRenderable",
            value: function onChangeIsRenderable(isRenderable) {
              // Propagate the renderable owner change to the parent texture
              this.parentTexture.setRenderableOwner(this.subtextureId, isRenderable);
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1() {
                return _regenerator().w(function (_context1) {
                  while (1) switch (_context1.n) {
                    case 0:
                      return _context1.a(2, {
                        data: this.props
                      });
                  }
                }, _callee1, this);
              }));
              function getTextureSource() {
                return _getTextureSource4.apply(this, arguments);
              }
              return getTextureSource;
            }() // eslint-disable-next-line @typescript-eslint/no-unused-vars
          }], [{
            key: "makeCacheKey",
            value: function makeCacheKey(props) {
              return false;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                texture: props.texture,
                x: props.x || 0,
                y: props.y || 0,
                width: props.width || 0,
                height: props.height || 0
              };
            }
          }]);
        }(Texture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(SubTexture, "z$__type__Props", void 0);
        var RenderTexture = /*#__PURE__*/function (_Texture6) {
          function RenderTexture(txManager, props) {
            var _this15;
            _classCallCheck(this, RenderTexture);
            _this15 = _callSuper(this, RenderTexture, [txManager]);
            _defineProperty(_this15, "props", void 0);
            _defineProperty(_this15, "type", TextureType.renderToTexture);
            _this15.props = RenderTexture.resolveDefaults(props || {});
            return _this15;
          }
          _inherits(RenderTexture, _Texture6);
          return _createClass(RenderTexture, [{
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              this.props.width = value;
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              this.props.height = value;
            }
          }, {
            key: "getTextureSource",
            value: function () {
              var _getTextureSource5 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10() {
                return _regenerator().w(function (_context10) {
                  while (1) switch (_context10.n) {
                    case 0:
                      return _context10.a(2, {
                        data: null,
                        premultiplyAlpha: null
                      });
                  }
                }, _callee10);
              }));
              function getTextureSource() {
                return _getTextureSource5.apply(this, arguments);
              }
              return getTextureSource;
            }()
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                width: props.width || 256,
                height: props.height || 256
              };
            }
          }]);
        }(Texture);
        _defineProperty(RenderTexture, "z$__type__Props", void 0);
        function validateCreateImageBitmap() {
          return _validateCreateImageBitmap.apply(this, arguments);
        }
        function _validateCreateImageBitmap() {
          _validateCreateImageBitmap = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23() {
            var _bitmap$close;
            var pngBinaryData, support, blob, bitmap, _bitmapWithOptions$cl, options, bitmapWithOptions, _bitmapWithFullOption, bitmapWithFullOptions, _t14, _t15;
            return _regenerator().w(function (_context24) {
              while (1) switch (_context24.p = _context24.n) {
                case 0:
                  // Test if createImageBitmap is supported using a simple 1x1 PNG image
                  // prettier-ignore
                  pngBinaryData = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
                  // PNG signature
                  0x00, 0x00, 0x00, 0x0d,
                  // IHDR chunk length
                  0x49, 0x48, 0x44, 0x52,
                  // "IHDR" chunk type
                  0x00, 0x00, 0x00, 0x01,
                  // Width: 1
                  0x00, 0x00, 0x00, 0x01,
                  // Height: 1
                  0x01,
                  // Bit depth: 1
                  0x03,
                  // Color type: Indexed
                  0x00,
                  // Compression method: Deflate
                  0x00,
                  // Filter method: None
                  0x00,
                  // Interlace method: None
                  0x25, 0xdb, 0x56, 0xca,
                  // CRC for IHDR
                  0x00, 0x00, 0x00, 0x03,
                  // PLTE chunk length
                  0x50, 0x4c, 0x54, 0x45,
                  // "PLTE" chunk type
                  0x00, 0x00, 0x00,
                  // Palette entry: Black
                  0xa7, 0x7a, 0x3d, 0xda,
                  // CRC for PLTE
                  0x00, 0x00, 0x00, 0x01,
                  // tRNS chunk length
                  0x74, 0x52, 0x4e, 0x53,
                  // "tRNS" chunk type
                  0x00,
                  // Transparency for black: Fully transparent
                  0x40, 0xe6, 0xd8, 0x66,
                  // CRC for tRNS
                  0x00, 0x00, 0x00, 0x0a,
                  // IDAT chunk length
                  0x49, 0x44, 0x41, 0x54,
                  // "IDAT" chunk type
                  0x08, 0xd7,
                  // Deflate header
                  0x63, 0x60, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,
                  // Zlib-compressed data
                  0xe2, 0x21, 0xbc, 0x33,
                  // CRC for IDAT
                  0x00, 0x00, 0x00, 0x00,
                  // IEND chunk length
                  0x49, 0x45, 0x4e, 0x44,
                  // "IEND" chunk type
                  0xae, 0x42, 0x60, 0x82 // CRC for IEND
                  ]);
                  support = {
                    basic: false,
                    options: false,
                    full: false
                  }; // Test basic createImageBitmap support
                  blob = new Blob([pngBinaryData], {
                    type: 'image/png'
                  });
                  _context24.n = 1;
                  return createImageBitmap(blob);
                case 1:
                  bitmap = _context24.v;
                  (_bitmap$close = bitmap.close) === null || _bitmap$close === void 0 || _bitmap$close.call(bitmap);
                  support.basic = true;
                  // Test createImageBitmap with options support
                  _context24.p = 2;
                  options = {
                    premultiplyAlpha: 'none'
                  };
                  _context24.n = 3;
                  return createImageBitmap(blob, options);
                case 3:
                  bitmapWithOptions = _context24.v;
                  (_bitmapWithOptions$cl = bitmapWithOptions.close) === null || _bitmapWithOptions$cl === void 0 || _bitmapWithOptions$cl.call(bitmapWithOptions);
                  support.options = true;
                  _context24.n = 5;
                  break;
                case 4:
                  _context24.p = 4;
                  _t14 = _context24.v;
                case 5:
                  _context24.p = 5;
                  _context24.n = 6;
                  return createImageBitmap(blob, 0, 0, 1, 1, {
                    premultiplyAlpha: 'none'
                  });
                case 6:
                  bitmapWithFullOptions = _context24.v;
                  (_bitmapWithFullOption = bitmapWithFullOptions.close) === null || _bitmapWithFullOption === void 0 || _bitmapWithFullOption.call(bitmapWithFullOptions);
                  support.full = true;
                  _context24.n = 8;
                  break;
                case 7:
                  _context24.p = 7;
                  _t15 = _context24.v;
                case 8:
                  return _context24.a(2, support);
              }
            }, _callee23, null, [[5, 7], [2, 4]]);
          }));
          return _validateCreateImageBitmap.apply(this, arguments);
        }
        var TextureErrorCode;
        (function (TextureErrorCode) {
          TextureErrorCode["MEMORY_THRESHOLD_EXCEEDED"] = "MEMORY_THRESHOLD_EXCEEDED";
          TextureErrorCode["TEXTURE_DATA_NULL"] = "TEXTURE_DATA_NULL";
          TextureErrorCode["TEXTURE_TYPE_NOT_REGISTERED"] = "TEXTURE_TYPE_NOT_REGISTERED";
        })(TextureErrorCode || (TextureErrorCode = {}));
        var defaultMessages = _defineProperty(_defineProperty(_defineProperty({}, TextureErrorCode.MEMORY_THRESHOLD_EXCEEDED, 'Memory threshold exceeded'), TextureErrorCode.TEXTURE_DATA_NULL, 'Texture data is null'), TextureErrorCode.TEXTURE_TYPE_NOT_REGISTERED, 'Texture type is not registered');
        var TextureError = /*#__PURE__*/function (_Error) {
          function TextureError(codeOrMessage, maybeMessage) {
            var _this16;
            _classCallCheck(this, TextureError);
            var isCode = Object.values(TextureErrorCode).includes(codeOrMessage);
            var code = isCode ? codeOrMessage : undefined;
            var message;
            if (isCode && code) {
              message = maybeMessage !== null && maybeMessage !== void 0 ? maybeMessage : defaultMessages[code];
            } else {
              message = String(codeOrMessage);
            }
            _this16 = _callSuper(this, TextureError, [message]);
            _defineProperty(_this16, "code", void 0);
            _this16.name = (this instanceof TextureError ? this.constructor : void 0).name;
            if (code) _this16.code = code;
            return _this16;
          }
          _inherits(TextureError, _Error);
          return _createClass(TextureError);
        }(/*#__PURE__*/_wrapNativeSuper(Error));
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreTextureManager = /*#__PURE__*/function (_EventEmitter6) {
          function CoreTextureManager(stage, settings) {
            var _this17;
            _classCallCheck(this, CoreTextureManager);
            _this17 = _callSuper(this, CoreTextureManager);
            /**
             * Map of textures by cache key
             */
            _defineProperty(_this17, "keyCache", new Map());
            /**
             * Map of cache keys by texture
             */
            _defineProperty(_this17, "inverseKeyCache", new WeakMap());
            /**
             * Map of texture constructors by their type name
             */
            _defineProperty(_this17, "txConstructors", {});
            _defineProperty(_this17, "maxRetryCount", void 0);
            _defineProperty(_this17, "priorityQueue", []);
            _defineProperty(_this17, "uploadTextureQueue", []);
            _defineProperty(_this17, "initialized", false);
            _defineProperty(_this17, "stage", void 0);
            _defineProperty(_this17, "numImageWorkers", void 0);
            _defineProperty(_this17, "imageWorkerManager", null);
            _defineProperty(_this17, "hasCreateImageBitmap", !!self.createImageBitmap);
            _defineProperty(_this17, "imageBitmapSupported", {
              basic: false,
              options: false,
              full: false
            });
            _defineProperty(_this17, "hasWorker", !!self.Worker);
            /**
             * Renderer that this texture manager is associated with
             *
             * @remarks
             * This MUST be set before the texture manager is used. Otherwise errors
             * will occur when using the texture manager.
             */
            _defineProperty(_this17, "renderer", void 0);
            /**
             * The current frame time in milliseconds
             *
             * @remarks
             * This is used to populate the `lastRenderableChangeTime` property of
             * {@link Texture} instances when their renderable state changes.
             *
             * Set by stage via `updateFrameTime` method.
             */
            _defineProperty(_this17, "frameTime", 0);
            var numImageWorkers = settings.numImageWorkers,
              createImageBitmapSupport = settings.createImageBitmapSupport,
              maxRetryCount = settings.maxRetryCount;
            _this17.stage = stage;
            _this17.numImageWorkers = numImageWorkers;
            _this17.maxRetryCount = maxRetryCount;
            if (createImageBitmapSupport === 'auto') {
              validateCreateImageBitmap().then(function (result) {
                _this17.initialize(result);
              }).catch(function () {
                console.warn('[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.');
                // initialized without image worker manager and createImageBitmap
                _this17.initialized = true;
                _this17.emit('initialized');
              });
            } else {
              _this17.initialize({
                basic: createImageBitmapSupport === 'basic',
                options: createImageBitmapSupport === 'options',
                full: createImageBitmapSupport === 'full'
              });
            }
            _this17.registerTextureType('ImageTexture', ImageTexture);
            _this17.registerTextureType('ColorTexture', ColorTexture);
            _this17.registerTextureType('NoiseTexture', NoiseTexture);
            _this17.registerTextureType('SubTexture', SubTexture);
            _this17.registerTextureType('RenderTexture', RenderTexture);
            return _this17;
          }
          _inherits(CoreTextureManager, _EventEmitter6);
          return _createClass(CoreTextureManager, [{
            key: "registerTextureType",
            value: function registerTextureType(textureType, textureClass) {
              this.txConstructors[textureType] = textureClass;
            }
          }, {
            key: "initialize",
            value: function initialize(support) {
              this.hasCreateImageBitmap = support.basic || support.options || support.full;
              this.imageBitmapSupported = support;
              if (!this.hasCreateImageBitmap) {
                console.warn('[Lightning] createImageBitmap is not supported on this browser. ImageTexture will be slower.');
              }
              if (this.hasCreateImageBitmap && this.hasWorker && this.numImageWorkers > 0) {
                this.imageWorkerManager = new ImageWorkerManager(this.numImageWorkers, support);
              } else {
                console.warn('[Lightning] Imageworker is 0 or not supported on this browser. Image loading will be slower.');
              }
              this.initialized = true;
              this.emit('initialized');
            }
            /**
             * Enqueue a texture for uploading to the GPU.
             *
             * @param texture - The texture to upload
             */
          }, {
            key: "enqueueUploadTexture",
            value: function enqueueUploadTexture(texture) {
              if (this.uploadTextureQueue.includes(texture) === false) {
                this.uploadTextureQueue.push(texture);
              }
            }
            /**
             * Create a texture
             *
             * @param textureType - The type of texture to create
             * @param props - The properties to use for the texture
             */
          }, {
            key: "createTexture",
            value: function createTexture(textureType, props) {
              var texture;
              var TextureClass = this.txConstructors[textureType];
              if (!TextureClass) {
                throw new TextureError(TextureErrorCode.TEXTURE_TYPE_NOT_REGISTERED, "Texture type \"".concat(textureType, "\" is not registered"));
              }
              // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument
              var cacheKey = TextureClass.makeCacheKey(props);
              if (cacheKey && this.keyCache.has(cacheKey)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                texture = this.keyCache.get(cacheKey);
              } else {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any
                texture = new TextureClass(this, props);
                if (cacheKey) {
                  this.initTextureToCache(texture, cacheKey);
                }
              }
              return texture;
            }
            /**
             * Override loadTexture to use the batched approach.
             *
             * @param texture - The texture to load
             * @param immediate - Whether to prioritize the texture for immediate loading
             */
          }, {
            key: "loadTexture",
            value: (function () {
              var _loadTexture = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(texture, priority) {
                var textureDataResult, shouldUploadImmediately;
                return _regenerator().w(function (_context11) {
                  while (1) switch (_context11.n) {
                    case 0:
                      if (!(texture.type === TextureType.subTexture)) {
                        _context11.n = 1;
                        break;
                      }
                      return _context11.a(2);
                    case 1:
                      if (!(texture.state === 'loaded')) {
                        _context11.n = 2;
                        break;
                      }
                      return _context11.a(2);
                    case 2:
                      if (!(texture.state === 'loading')) {
                        _context11.n = 3;
                        break;
                      }
                      return _context11.a(2);
                    case 3:
                      if (!(this.initialized === false)) {
                        _context11.n = 4;
                        break;
                      }
                      this.priorityQueue.push(texture);
                      return _context11.a(2);
                    case 4:
                      texture.setState('loading');
                      // Get texture data - early return on failure
                      _context11.n = 5;
                      return texture.getTextureData().catch(function (err) {
                        console.error(err);
                        texture.setState('failed');
                        return null;
                      });
                    case 5:
                      textureDataResult = _context11.v;
                      if (!(textureDataResult === null || texture.state === 'failed')) {
                        _context11.n = 6;
                        break;
                      }
                      return _context11.a(2);
                    case 6:
                      // Handle non-image textures: upload immediately
                      shouldUploadImmediately = texture.type !== TextureType.image || priority === true;
                      if (!(shouldUploadImmediately === true)) {
                        _context11.n = 8;
                        break;
                      }
                      _context11.n = 7;
                      return this.uploadTexture(texture).catch(function (err) {
                        console.error("Failed to upload texture:", err);
                        texture.setState('failed');
                      });
                    case 7:
                      return _context11.a(2);
                    case 8:
                      // Queue image textures for throttled upload
                      this.enqueueUploadTexture(texture);
                    case 9:
                      return _context11.a(2);
                  }
                }, _callee11, this);
              }));
              function loadTexture(_x18, _x19) {
                return _loadTexture.apply(this, arguments);
              }
              return loadTexture;
            }()
            /**
             * Upload a texture to the GPU
             *
             * @param texture Texture to upload
             * @returns Promise that resolves when the texture is fully loaded
             */
            )
          }, {
            key: "uploadTexture",
            value: (function () {
              var _uploadTexture = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(texture) {
                var coreContext;
                return _regenerator().w(function (_context12) {
                  while (1) switch (_context12.n) {
                    case 0:
                      if (!(this.stage.txMemManager.doNotExceedCriticalThreshold === true && this.stage.txMemManager.criticalCleanupRequested === true)) {
                        _context12.n = 1;
                        break;
                      }
                      // we're at a critical memory threshold, don't upload textures
                      texture.setState('failed', new TextureError(TextureErrorCode.MEMORY_THRESHOLD_EXCEEDED));
                      return _context12.a(2);
                    case 1:
                      if (!(texture.state === 'failed' || texture.state === 'freed')) {
                        _context12.n = 2;
                        break;
                      }
                      return _context12.a(2);
                    case 2:
                      if (!(texture.state === 'loaded')) {
                        _context12.n = 3;
                        break;
                      }
                      return _context12.a(2);
                    case 3:
                      if (!(texture.textureData === null)) {
                        _context12.n = 4;
                        break;
                      }
                      texture.setState('failed', new TextureError(TextureErrorCode.TEXTURE_DATA_NULL, 'Texture data is null, cannot upload texture'));
                      return _context12.a(2);
                    case 4:
                      coreContext = texture.loadCtxTexture();
                      if (!(coreContext !== null && coreContext.state === 'loaded')) {
                        _context12.n = 5;
                        break;
                      }
                      texture.setState('loaded');
                      return _context12.a(2);
                    case 5:
                      _context12.n = 6;
                      return coreContext.load();
                    case 6:
                      return _context12.a(2);
                  }
                }, _callee12, this);
              }));
              function uploadTexture(_x20) {
                return _uploadTexture.apply(this, arguments);
              }
              return uploadTexture;
            }()
            /**
             * Check if a texture is being processed
             */
            )
          }, {
            key: "isProcessingTexture",
            value: function isProcessingTexture(texture) {
              return this.uploadTextureQueue.includes(texture) === true;
            }
            /**
             * Process a limited number of uploads.
             *
             * @param maxProcessingTime - The maximum processing time in milliseconds
             */
          }, {
            key: "processSome",
            value: (function () {
              var _processSome = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(maxProcessingTime) {
                var startTime, texture, _texture, _t0, _t1;
                return _regenerator().w(function (_context13) {
                  while (1) switch (_context13.p = _context13.n) {
                    case 0:
                      if (!(this.initialized === false)) {
                        _context13.n = 1;
                        break;
                      }
                      return _context13.a(2);
                    case 1:
                      startTime = getTimeStamp(); // Process priority queue
                    case 2:
                      if (!(this.priorityQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime)) {
                        _context13.n = 8;
                        break;
                      }
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      texture = this.priorityQueue.pop();
                      _context13.p = 3;
                      _context13.n = 4;
                      return texture.getTextureData();
                    case 4:
                      _context13.n = 5;
                      return this.uploadTexture(texture);
                    case 5:
                      _context13.n = 7;
                      break;
                    case 6:
                      _context13.p = 6;
                      _t0 = _context13.v;
                      console.error('Failed to process priority texture:', _t0);
                      // Continue with next texture instead of stopping entire queue
                    case 7:
                      _context13.n = 2;
                      break;
                    case 8:
                      if (!(this.uploadTextureQueue.length > 0 && getTimeStamp() - startTime < maxProcessingTime)) {
                        _context13.n = 13;
                        break;
                      }
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      _texture = this.uploadTextureQueue.shift();
                      _context13.p = 9;
                      _context13.n = 10;
                      return this.uploadTexture(_texture);
                    case 10:
                      _context13.n = 12;
                      break;
                    case 11:
                      _context13.p = 11;
                      _t1 = _context13.v;
                      console.error('Failed to upload texture:', _t1);
                      // Continue with next texture instead of stopping entire queue
                    case 12:
                      _context13.n = 8;
                      break;
                    case 13:
                      return _context13.a(2);
                  }
                }, _callee13, this, [[9, 11], [3, 6]]);
              }));
              function processSome(_x21) {
                return _processSome.apply(this, arguments);
              }
              return processSome;
            }())
          }, {
            key: "hasUpdates",
            value: function hasUpdates() {
              return this.uploadTextureQueue.length > 0;
            }
            /**
             * Initialize a texture to the cache
             *
             * @param texture Texture to cache
             * @param cacheKey Cache key for the texture
             */
          }, {
            key: "initTextureToCache",
            value: function initTextureToCache(texture, cacheKey) {
              var keyCache = this.keyCache,
                inverseKeyCache = this.inverseKeyCache;
              keyCache.set(cacheKey, texture);
              inverseKeyCache.set(texture, cacheKey);
            }
            /**
             * Get a texture from the cache
             *
             * @param cacheKey
             */
          }, {
            key: "getTextureFromCache",
            value: function getTextureFromCache(cacheKey) {
              return this.keyCache.get(cacheKey);
            }
            /**
             * Remove a texture from the cache
             *
             * @remarks
             * Called by Texture Cleanup when a texture is freed.
             *
             * @param texture
             */
          }, {
            key: "removeTextureFromCache",
            value: function removeTextureFromCache(texture) {
              var inverseKeyCache = this.inverseKeyCache,
                keyCache = this.keyCache;
              var cacheKey = inverseKeyCache.get(texture);
              if (cacheKey) {
                keyCache.delete(cacheKey);
              }
            }
            /**
             * Resolve a parent texture from the cache or fallback to the provided texture.
             *
             * @param texture - The provided texture to resolve.
             * @returns The cached or provided texture.
             */
          }, {
            key: "resolveParentTexture",
            value: function resolveParentTexture(texture) {
              if (!(texture !== null && texture !== void 0 && texture.props)) {
                return texture;
              }
              var cacheKey = ImageTexture.makeCacheKey(texture.props);
              var cachedTexture = cacheKey ? this.getTextureFromCache(cacheKey) : undefined;
              return cachedTexture !== null && cachedTexture !== void 0 ? cachedTexture : texture;
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var weightConversions = {
          normal: 400,
          bold: 700,
          bolder: 900,
          lighter: 100
        };
        var fontWeightToNumber = function fontWeightToNumber(weight) {
          if (typeof weight === 'number') {
            return weight;
          }
          return weightConversions[weight] || 400;
        };
        function resolveFontToUse(familyMapsByPriority, family, weightIn, style, stretch) {
          var weight = fontWeightToNumber(weightIn);
          var _iterator8 = _createForOfIteratorHelper(familyMapsByPriority),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var fontFamiles = _step8.value;
              var fontFaces = fontFamiles[family];
              if (!fontFaces) {
                continue;
              }
              if (fontFaces.size === 1) {
                // No Exact match found, find nearest weight match
                console.warn("TrFontManager: Only one font face found for family: '".concat(family, "' - will be used for all weights and styles"));
                return fontFaces.values().next().value;
              }
              var weightMap = new Map();
              var _iterator9 = _createForOfIteratorHelper(fontFaces),
                _step9;
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var fontFace = _step9.value;
                  var fontFamilyWeight = fontWeightToNumber(fontFace.descriptors.weight);
                  if (fontFamilyWeight === weight && fontFace.descriptors.style === style && fontFace.descriptors.stretch === stretch) {
                    return fontFace;
                  }
                  weightMap.set(fontFamilyWeight, fontFace);
                }
                // No Exact match found, find nearest weight match
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
              var msg = "TrFontManager: No exact match: '".concat(family, " Weight: ").concat(weight, " Style: ").concat(style, " Stretch: ").concat(stretch, "'");
              console.error(msg);
              // Follow the CSS font-weight algorithm to find the nearest weight match
              // https://www.w3.org/TR/2018/REC-css-fonts-3-20180920/#font-matching-algorithm
              if (weight === 400 && weightMap.has(500)) {
                return weightMap.get(500);
              }
              if (weight === 500 && weightMap.has(400)) {
                return weightMap.get(400);
              }
              if (weight < 400) {
                while (weight > 0) {
                  if (weightMap.has(weight)) {
                    return weightMap.get(weight);
                  }
                  weight -= 100;
                }
                // reset back for the next loop
                weight = 600;
              }
              while (weight < 1000) {
                if (weightMap.has(weight)) {
                  return weightMap.get(weight);
                }
                weight += 100;
              }
              // finally check lower again
              weight = 500;
              while (weight > 0) {
                if (weightMap.has(weight)) {
                  return weightMap.get(weight);
                }
                weight -= 100;
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
          return;
        }
        var TrFontManager = /*#__PURE__*/function () {
          function TrFontManager(textRenderers) {
            _classCallCheck(this, TrFontManager);
            _defineProperty(this, "textRenderers", void 0);
            _defineProperty(this, "fontCache", new Map());
            this.textRenderers = textRenderers;
            // Intentionally left blank
          }
          return _createClass(TrFontManager, [{
            key: "addFontFace",
            value: function addFontFace(font) {
              // All the font face to all of the text renderers that support it
              for (var trId in this.textRenderers) {
                var tr = this.textRenderers[trId];
                if (tr && tr.isFontFaceSupported(font)) {
                  tr.addFontFace(font);
                }
              }
            }
            /**
             * Utility method to resolve a single font face from a list of prioritized family maps based on
             * a set of font properties.
             *
             * @remarks
             * These are to be used by a text renderer to resolve a font face if needed.
             *
             * @param familyMapsByPriority
             * @param props
             * @returns
             */
          }, {
            key: "resolveFontFace",
            value: function resolveFontFace(familyMapsByPriority, props, rendererType) {
              var fontFamily = props.fontFamily,
                fontWeight = props.fontWeight,
                fontStyle = props.fontStyle,
                fontStretch = props.fontStretch;
              var fontCacheString = "".concat(rendererType, "_").concat(fontFamily, "_").concat(fontStyle, "_").concat(fontWeight, "_").concat(fontStretch);
              if (this.fontCache.has(fontCacheString) === true) {
                return this.fontCache.get(fontCacheString);
              }
              var resolvedFont = resolveFontToUse(familyMapsByPriority, fontFamily, fontWeight, fontStyle, fontStretch);
              if (resolvedFont !== undefined) {
                this.fontCache.set(fontCacheString, resolvedFont);
              }
              return resolvedFont;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreShader = /*#__PURE__*/function () {
          function CoreShader() {
            _classCallCheck(this, CoreShader);
          }
          return _createClass(CoreShader, null, [{
            key: "makeCacheKey",
            value:
            // abstract draw(): void;
            function makeCacheKey(props) {
              return false;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {};
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        //#endregion Types
        function createShader(glw, type, source) {
          var shader = glw.createShader(type);
          if (!shader) {
            var glError = glw.getError();
            throw new Error("Unable to create the shader: ".concat(type === glw.VERTEX_SHADER ? 'VERTEX_SHADER' : 'FRAGMENT_SHADER', ".").concat(glError ? " WebGlContext Error: ".concat(glError) : ''));
          }
          glw.shaderSource(shader, source);
          glw.compileShader(shader);
          var success = !!glw.getShaderParameter(shader, glw.COMPILE_STATUS);
          if (success) {
            return shader;
          }
          console.error(glw.getShaderInfoLog(shader));
          glw.deleteShader(shader);
        }
        function createProgram(glw, vertexShader, fragmentShader) {
          var program = glw.createProgram();
          if (!program) {
            throw new Error('Unable to create program');
          }
          glw.attachShader(program, vertexShader);
          glw.attachShader(program, fragmentShader);
          glw.linkProgram(program);
          var success = !!glw.getProgramParameter(program, glw.LINK_STATUS);
          if (success) {
            return program;
          }
          console.warn(glw.getProgramInfoLog(program));
          glw.deleteProgram(program);
          return undefined;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreShader = /*#__PURE__*/function (_CoreShader) {
          function WebGlCoreShader(options) {
            var _this18;
            _classCallCheck(this, WebGlCoreShader);
            _this18 = _callSuper(this, WebGlCoreShader);
            _defineProperty(_this18, "boundBufferCollection", null);
            _defineProperty(_this18, "buffersBound", false);
            _defineProperty(_this18, "program", void 0);
            /**
             * Vertex Array Object
             *
             * @remarks
             * Used by WebGL2 Only
             */
            _defineProperty(_this18, "vao", void 0);
            _defineProperty(_this18, "renderer", void 0);
            _defineProperty(_this18, "glw", void 0);
            _defineProperty(_this18, "attributeBuffers", void 0);
            _defineProperty(_this18, "attributeLocations", void 0);
            _defineProperty(_this18, "attributeNames", void 0);
            _defineProperty(_this18, "uniformLocations", void 0);
            _defineProperty(_this18, "uniformTypes", void 0);
            _defineProperty(_this18, "supportsIndexedTextures", void 0);
            var renderer = _this18.renderer = options.renderer;
            var glw = _this18.glw = _this18.renderer.glw;
            _this18.supportsIndexedTextures = options.supportsIndexedTextures || false;
            // Check that extensions are supported
            var webGl2 = glw.isWebGl2();
            var requiredExtensions = webGl2 && options.webgl2Extensions || !webGl2 && options.webgl1Extensions || [];
            var glVersion = webGl2 ? '2.0' : '1.0';
            requiredExtensions.forEach(function (extensionName) {
              if (!glw.getExtension(extensionName)) {
                throw new Error("Shader \"".concat(_this18.constructor.name, "\" requires extension \"").concat(extensionName, "\" for WebGL ").concat(glVersion, " but wasn't found"));
              }
            });
            // Gather shader sources
            // - If WebGL 2 and special WebGL 2 sources are provided, we copy those sources and delete
            // the extra copy of them to save memory.
            // TODO: This could be further made optimal by just caching the compiled shaders and completely deleting
            // the source code
            var shaderSources = options.shaderSources || _this18.constructor.shaderSources;
            if (!shaderSources) {
              throw new Error("Shader \"".concat(_this18.constructor.name, "\" is missing shaderSources."));
            } else if (webGl2 && shaderSources !== null && shaderSources !== void 0 && shaderSources.webGl2) {
              shaderSources.fragment = shaderSources.webGl2.fragment;
              shaderSources.vertex = shaderSources.webGl2.vertex;
              delete shaderSources.webGl2;
            }
            var textureUnits = renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            var vertexSource = shaderSources.vertex instanceof Function ? shaderSources.vertex(textureUnits) : shaderSources.vertex;
            var fragmentSource = shaderSources.fragment instanceof Function ? shaderSources.fragment(textureUnits) : shaderSources.fragment;
            var vertexShader = createShader(glw, glw.VERTEX_SHADER, vertexSource);
            var fragmentShader = createShader(glw, glw.FRAGMENT_SHADER, fragmentSource);
            if (!vertexShader || !fragmentShader) {
              throw new Error("Unable to create the following shader(s): ".concat([!vertexShader && 'VERTEX_SHADER', !fragmentShader && 'FRAGMENT_SHADER'].filter(Boolean).join(' and ')));
            }
            var program = createProgram(glw, vertexShader, fragmentShader);
            if (!program) {
              throw new Error('Unable to create program');
            }
            _this18.program = program;
            _this18.attributeLocations = {};
            _this18.attributeBuffers = {};
            _this18.attributeNames = [];
            _toConsumableArray(options.attributes).forEach(function (attributeName) {
              var location = glw.getAttribLocation(_this18.program, attributeName);
              if (location < 0) {
                throw new Error("".concat(_this18.constructor.name, ": Vertex shader must have an attribute \"").concat(attributeName, "\"!"));
              }
              var buffer = glw.createBuffer();
              if (!buffer) {
                throw new Error("".concat(_this18.constructor.name, ": Could not create buffer for attribute \"").concat(attributeName, "\""));
              }
              _this18.attributeLocations[attributeName] = location;
              _this18.attributeBuffers[attributeName] = buffer;
              _this18.attributeNames.push(attributeName);
            });
            _this18.uniformLocations = {};
            _this18.uniformTypes = {};
            options.uniforms.forEach(function (uniform) {
              var location = glw.getUniformLocation(_this18.program, uniform.name);
              _this18.uniformTypes[uniform.name] = uniform.uniform;
              if (!location) {
                console.warn("Shader \"".concat(_this18.constructor.name, "\" could not get uniform location for \"").concat(uniform.name, "\""));
                return;
              }
              _this18.uniformLocations[uniform.name] = location;
            });
            return _this18;
          }
          _inherits(WebGlCoreShader, _CoreShader);
          return _createClass(WebGlCoreShader, [{
            key: "bindBufferAttribute",
            value: function bindBufferAttribute(location, buffer, attribute) {
              var glw = this.glw;
              glw.enableVertexAttribArray(location);
              glw.vertexAttribPointer(buffer, location, attribute.size, attribute.type, attribute.normalized, attribute.stride, attribute.offset);
            }
          }, {
            key: "disableAttribute",
            value: function disableAttribute(location) {
              this.glw.disableVertexAttribArray(location);
            }
          }, {
            key: "disableAttributes",
            value: function disableAttributes() {
              for (var loc in this.attributeLocations) {
                this.disableAttribute(this.attributeLocations[loc]);
              }
              this.boundBufferCollection = null;
            }
            /**
             * Given two sets of Shader props destined for this Shader, determine if they can be batched together
             * to reduce the number of draw calls.
             *
             * @remarks
             * This is used by the {@link WebGlCoreRenderer} to determine if it can batch multiple consecutive draw
             * calls into a single draw call.
             *
             * By default, this returns false (meaning no batching is allowed), but can be
             * overridden by child classes to provide more efficient batching.
             *
             * @param propsA
             * @param propsB
             * @returns
             */
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              return false;
            }
          }, {
            key: "bindRenderOp",
            value: function bindRenderOp(renderOp, props) {
              var _renderOp$textures$;
              this.bindBufferCollection(renderOp.buffers);
              // Since we're not using batched rendering yet we can safely test
              // for first texture only
              if (renderOp.textures.length > 0 && (_renderOp$textures$ = renderOp.textures[0]) !== null && _renderOp$textures$ !== void 0 && _renderOp$textures$.ctxTexture) {
                this.bindTextures(renderOp.textures);
              }
              var glw = renderOp.glw,
                parentHasRenderTexture = renderOp.parentHasRenderTexture,
                renderToTexture = renderOp.renderToTexture;
              // Skip if the parent and current operation both have render textures
              if (renderToTexture && parentHasRenderTexture) {
                return;
              }
              // Bind render texture framebuffer dimensions as resolution
              // if the parent has a render texture
              if (parentHasRenderTexture) {
                var _ref7 = renderOp.framebufferDimensions || {},
                  width = _ref7.width,
                  height = _ref7.height;
                // Force pixel ratio to 1.0 for render textures since they are always 1:1
                // the final render texture will be rendered to the screen with the correct pixel ratio
                glw.uniform1f(this.getUniformLocation('u_pixelRatio'), 1.0);
                // Set resolution to the framebuffer dimensions
                glw.uniform2f(this.getUniformLocation('u_resolution'), width !== null && width !== void 0 ? width : 0, height !== null && height !== void 0 ? height : 0);
              } else {
                glw.uniform1f(this.getUniformLocation('u_pixelRatio'), renderOp.options.pixelRatio);
                glw.uniform2f(this.getUniformLocation('u_resolution'), glw.canvas.width, glw.canvas.height);
              }
              if (props) {
                // Bind optional automatic uniforms
                // These are only bound if their keys are present in the props.
                if (hasOwn(props, '$dimensions')) {
                  var dimensions = props.$dimensions;
                  if (!dimensions) {
                    dimensions = renderOp.dimensions;
                  }
                  glw.uniform2f(this.getUniformLocation('u_dimensions'), dimensions.width, dimensions.height);
                }
                if (hasOwn(props, '$alpha')) {
                  var alpha = props.$alpha;
                  if (!alpha) {
                    alpha = renderOp.alpha;
                  }
                  glw.uniform1f(this.getUniformLocation('u_alpha'), alpha);
                }
                this.bindProps(props);
              }
            }
          }, {
            key: "getUniformLocation",
            value: function getUniformLocation(name) {
              return this.uniformLocations[name] || null;
            }
          }, {
            key: "bindBufferCollection",
            value: function bindBufferCollection(buffer) {
              if (this.boundBufferCollection === buffer) {
                return;
              }
              for (var attributeName in this.attributeLocations) {
                var resolvedBuffer = buffer.getBuffer(attributeName);
                var resolvedInfo = buffer.getAttributeInfo(attributeName);
                this.bindBufferAttribute(this.attributeLocations[attributeName], resolvedBuffer, resolvedInfo);
              }
              this.boundBufferCollection = buffer;
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              // Implement in child class
            }
          }, {
            key: "bindTextures",
            value: function bindTextures(textures) {
              // no defaults
            }
          }, {
            key: "attach",
            value: function attach() {
              this.glw.useProgram(this.program);
              if (this.glw.isWebGl2() && this.vao) {
                this.glw.bindVertexArray(this.vao);
              }
            }
          }, {
            key: "detach",
            value: function detach() {
              this.disableAttributes();
            }
          }]);
        }(CoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(WebGlCoreShader, "shaderSources", void 0);
        var DefaultShader = /*#__PURE__*/function (_WebGlCoreShader2) {
          function DefaultShader(renderer) {
            _classCallCheck(this, DefaultShader);
            return _callSuper(this, DefaultShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2fv'
              }]
            }]);
          }
          _inherits(DefaultShader, _WebGlCoreShader2);
          return _createClass(DefaultShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // import type { Texture } from '../textures/Texture';
        _defineProperty(DefaultShader, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio;\n        vec2 screenSpace = vec2(2.0 / u_resolution.x, -2.0 / u_resolution.y);\n\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        gl_Position = vec4(normalized.x * screenSpace.x - 1.0, normalized.y * -abs(screenSpace.y) + 1.0, 0.0, 1.0);\n        gl_Position.y = -sign(screenSpace.y) * gl_Position.y;\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n          vec4 color = texture2D(u_texture, v_textureCoordinate);\n          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);\n      }\n    "
        });
        var DefaultShaderBatched = /*#__PURE__*/function (_WebGlCoreShader3) {
          function DefaultShaderBatched(renderer) {
            var _this19;
            _classCallCheck(this, DefaultShaderBatched);
            _this19 = _callSuper(this, DefaultShaderBatched, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color', 'a_textureIndex'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_textures[0]',
                uniform: 'uniform1iv'
              }]
            }]);
            _defineProperty(_this19, "supportsIndexedTextures", true);
            return _this19;
          }
          _inherits(DefaultShaderBatched, _WebGlCoreShader3);
          return _createClass(DefaultShaderBatched, [{
            key: "bindTextures",
            value: function bindTextures(texture) {
              var renderer = this.renderer,
                glw = this.glw;
              if (texture.length > renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS) {
                throw new Error("DefaultShaderBatched: Cannot bind more than ".concat(renderer.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS, " textures"));
              }
              texture.forEach(function (t, i) {
                glw.activeTexture(i);
                glw.bindTexture(t.ctxTexture);
              });
              var samplers = Array.from(Array(texture.length).keys());
              this.glw.uniform1iv(this.getUniformLocation('u_textures[0]'), samplers);
            }
          }]);
        }(WebGlCoreShader);
        _defineProperty(DefaultShaderBatched, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_textureCoordinate;\n      attribute vec2 a_position;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      void main(){\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n        v_textureIndex = a_textureIndex;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",
          fragment: function fragment(textureUnits) {
            return "\n      #define txUnits ".concat(textureUnits, "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textures[txUnits];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      vec4 sampleFromTexture(sampler2D textures[").concat(textureUnits, "], int idx, vec2 uv) {\n        ").concat(Array.from(Array(textureUnits).keys()).map(function (idx) {
              return "\n          ".concat(idx !== 0 ? 'else ' : '', "if (idx == ").concat(idx, ") {\n            return texture2D(textures[").concat(idx, "], uv);\n          }\n        ");
            }).join(''), "\n        return texture2D(textures[0], uv);\n      }\n\n      void main(){\n        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);\n      }\n    ");
          }
        });
        var ShaderEffect = /*#__PURE__*/function () {
          function ShaderEffect(options) {
            _classCallCheck(this, ShaderEffect);
            _defineProperty(this, "priority", 1);
            _defineProperty(this, "name", '');
            _defineProperty(this, "ref", void 0);
            _defineProperty(this, "target", void 0);
            _defineProperty(this, "passParameters", '');
            _defineProperty(this, "declaredUniforms", '');
            _defineProperty(this, "uniformInfo", {});
            var ref = options.ref,
              target = options.target,
              _options$props = options.props,
              props = _options$props === void 0 ? {} : _options$props;
            this.ref = ref;
            this.target = target;
            var uniformInfo = {};
            var passParameters = [];
            var declaredUniforms = '';
            var uniforms = this.constructor.uniforms || {};
            for (var u in uniforms) {
              var unif = uniforms[u];
              var uniType = unif.type;
              //make unique uniform name
              var uniformName = "".concat(ref, "_").concat(u);
              var define = '';
              if (unif.size) {
                define = "[".concat(unif.size(props), "]");
              }
              passParameters.push(uniformName);
              declaredUniforms += "uniform ".concat(uniType, " ").concat(uniformName).concat(define, ";");
              uniformInfo[u] = {
                name: uniformName,
                uniform: uniforms[u].method
              };
            }
            this.passParameters = passParameters.join(',');
            this.declaredUniforms = declaredUniforms;
            this.uniformInfo = uniformInfo;
          }
          return _createClass(ShaderEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              return '';
            }
          }, {
            key: "getMethodParameters",
            value: function getMethodParameters(uniforms, props) {
              var res = [];
              for (var u in uniforms) {
                var uni = uniforms[u];
                var define = '';
                if (uni.size) {
                  define = "[".concat(uni.size(props), "]");
                }
                res.push("".concat(uni.type, " ").concat(u).concat(define));
              }
              return res.join(',');
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {};
            }
          }, {
            key: "makeEffectKey",
            value: function makeEffectKey(props) {
              return false;
            }
          }]);
        }();
        _defineProperty(ShaderEffect, "uniforms", {});
        _defineProperty(ShaderEffect, "methods", void 0);
        _defineProperty(ShaderEffect, "onShaderMask", void 0);
        _defineProperty(ShaderEffect, "onColorize", void 0);
        _defineProperty(ShaderEffect, "onEffectMask", void 0);
        var effectCache = new Map();
        var getResolvedEffect = function getResolvedEffect(effects, effectContructors) {
          var key = JSON.stringify(effects);
          if (effectCache.has(key)) {
            return effectCache.get(key);
          }
          effects = effects !== null && effects !== void 0 ? effects : [];
          var resolvedEffects = [];
          var effectsLength = effects.length;
          var i = 0;
          for (; i < effectsLength; i++) {
            var _effects$i = effects[i],
              name = _effects$i.name,
              type = _effects$i.type,
              props = _effects$i.props;
            var resolvedEffect = {
              name: name,
              type: type,
              props: {}
            };
            var effectConstructor = effectContructors[type];
            var defaultPropValues = effectConstructor.resolveDefaults(props);
            var uniforms = effectConstructor.uniforms;
            var uniformKeys = Object.keys(uniforms);
            var uniformsLength = uniformKeys.length;
            var j = 0;
            for (; j < uniformsLength; j++) {
              var _key4 = uniformKeys[j];
              var uniform = uniforms[_key4];
              var result = {
                value: defaultPropValues[_key4],
                programValue: undefined,
                method: uniform.method,
                updateOnBind: uniform.updateOnBind || false,
                hasValidator: uniform.validator !== undefined,
                hasProgramValueUpdater: uniform.updateProgramValue !== undefined
              };
              var validatedValue = result.hasValidator && uniform.validator(defaultPropValues[_key4], defaultPropValues) || defaultPropValues[_key4];
              if (defaultPropValues[_key4] !== validatedValue) {
                result.validatedValue = validatedValue;
              }
              if (result.hasProgramValueUpdater) {
                uniform.updateProgramValue(result);
              }
              if (result.programValue === undefined) {
                result.programValue = result.value;
              }
              resolvedEffect.props[_key4] = result;
            }
            resolvedEffects.push(resolvedEffect);
          }
          effectCache.set(key, resolvedEffects);
          return resolvedEffects;
        };
        var DynamicShader = /*#__PURE__*/function (_WebGlCoreShader4) {
          function DynamicShader(renderer, props, effectContructors) {
            var _this20;
            _classCallCheck(this, DynamicShader);
            var shader = DynamicShader.createShader(props, effectContructors);
            _this20 = _callSuper(this, DynamicShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2fv'
              }, {
                name: 'u_dimensions',
                uniform: 'uniform2fv'
              }, {
                name: 'u_alpha',
                uniform: 'uniform1f'
              }].concat(_toConsumableArray(shader.uniforms)),
              shaderSources: {
                vertex: shader.vertex,
                fragment: shader.fragment
              }
            }]);
            _defineProperty(_this20, "effects", []);
            _this20.effects = shader.effects;
            return _this20;
          }
          _inherits(DynamicShader, _WebGlCoreShader4);
          return _createClass(DynamicShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindUniformMethods",
            value: function bindUniformMethods(props) {
              var _this21 = this;
              var glw = this.glw;
              var effects = props.effects;
              var effectsL = effects.length;
              for (var i = 0; i < effectsL; i++) {
                var uniformInfo = this.effects[i].uniformInfo;
                var _effect2 = effects[i];
                var propKeys = Object.keys(_effect2.props);
                var propsLength = propKeys.length;
                var _loop = function _loop() {
                    var key = propKeys[j];
                    var method = _effect2.props[key].method;
                    var location = _this21.getUniformLocation(uniformInfo[key].name);
                    if (method === 'uniform2fv' || method === 'uniform2iv' ||
                    //uniform === 'uniform3fv	' || <--- check why this isnt recognized
                    method === 'uniform3iv' || method === 'uniform4fv' || method === 'uniform4iv' || method === 'uniformMatrix2fv' || method === 'uniformMatrix3fv' || method === 'uniformMatrix4fv' || method === 'uniform1f' || method === 'uniform1fv' || method === 'uniform1i' || method === 'uniform1iv') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform2f' || method === 'uniform2i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1]);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform3f' || method === 'uniform3i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2]);
                      };
                      return 0; // continue
                    }
                    if (method === 'uniform4f' || method === 'uniform4i') {
                      _effect2.props[key].setUniformValue = function () {
                        glw[method](location, this.programValue[0], this.programValue[1], this.programValue[2], this.programValue[3]);
                      };
                      return 0; // continue
                    }
                  },
                  _ret;
                for (var j = 0; j < propsLength; j++) {
                  _ret = _loop();
                  if (_ret === 0) continue;
                }
              }
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var effects = props.effects;
              var effectsL = effects.length;
              var i = 0;
              for (; i < effectsL; i++) {
                var _effect3 = effects[i];
                var propKeys = Object.keys(_effect3.props);
                var propsLength = propKeys.length;
                var j = 0;
                for (; j < propsLength; j++) {
                  var key = propKeys[j];
                  var prop = _effect3.props[key];
                  if (prop.updateOnBind === true) {
                    var _this$renderer$shMana;
                    var uniform = (_this$renderer$shMana = this.renderer.shManager.getRegisteredEffects()[_effect3.type]) === null || _this$renderer$shMana === void 0 ? void 0 : _this$renderer$shMana.uniforms[key];
                    uniform === null || uniform === void 0 || uniform.updateProgramValue(_effect3.props[key], props);
                  }
                  prop.setUniformValue();
                }
              }
            }
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              if (propsA.$alpha !== propsB.$alpha || propsA.$dimensions.width !== propsB.$dimensions.width || propsA.$dimensions.height !== propsB.$dimensions.height || propsA.effects.length !== propsB.effects.length) {
                return false;
              }
              var propsEffectsLen = propsA.effects.length;
              var i = 0;
              for (; i < propsEffectsLen; i++) {
                var effectA = propsA.effects[i];
                var effectB = propsB.effects[i];
                if (effectA.type !== effectB.type) {
                  return false;
                }
                for (var key in effectA.props) {
                  if (effectB.props && !effectB.props[key] || effectA.props[key].value !== effectB.props[key].value) {
                    return false;
                  }
                }
              }
              return true;
            }
          }], [{
            key: "createShader",
            value: function createShader(props, effectContructors) {
              //counts duplicate effects
              var effectNameCount = {};
              var methods = {};
              var declareUniforms = '';
              var uniforms = [];
              var uFx = [];
              var effects = props.effects.map(function (effect) {
                var baseClass = effectContructors[effect.type];
                var key = baseClass.getEffectKey(effect.props || {});
                effectNameCount[key] = effectNameCount[key] ? ++effectNameCount[key] : 1;
                var nr = effectNameCount[key];
                if (nr === 1) {
                  uFx.push({
                    key: key,
                    type: effect.type,
                    props: effect.props
                  });
                }
                //initialize new effect class;
                var fxClass = new baseClass({
                  ref: "".concat(key).concat(nr === 1 ? '' : nr),
                  target: key,
                  props: effect.props
                });
                declareUniforms += fxClass.declaredUniforms;
                uniforms.push.apply(uniforms, _toConsumableArray(Object.values(fxClass.uniformInfo)));
                return fxClass;
              });
              //build source
              var effectMethods = '';
              uFx === null || uFx === void 0 || uFx.forEach(function (fx) {
                var _fx$props;
                var fxClass = effectContructors[fx.type];
                var fxProps = fxClass.resolveDefaults((_fx$props = fx.props) !== null && _fx$props !== void 0 ? _fx$props : {});
                var remap = [];
                for (var m in fxClass.methods) {
                  var cm = m;
                  var fxMethod = fxClass.methods[m];
                  if (methods[m] && methods[m] !== fxMethod) {
                    cm = DynamicShader.resolveMethodDuplicate(m, fxMethod, methods);
                  }
                  methods[cm] = fxMethod.replace('function', cm);
                  remap.push({
                    m: m,
                    cm: cm
                  });
                }
                var onShaderMask = fxClass.onShaderMask instanceof Function ? fxClass.onShaderMask(fxProps) : fxClass.onShaderMask;
                var onColorize = fxClass.onColorize instanceof Function ? fxClass.onColorize(fxProps) : fxClass.onColorize;
                var onEffectMask = fxClass.onEffectMask instanceof Function ? fxClass.onEffectMask(fxProps) : fxClass.onEffectMask;
                remap.forEach(function (r) {
                  var m = r.m,
                    cm = r.cm;
                  var reg = new RegExp("\\$".concat(m), 'g');
                  if (onShaderMask) {
                    onShaderMask = onShaderMask.replace(reg, cm);
                  }
                  if (onColorize) {
                    onColorize = onColorize.replace(reg, cm);
                  }
                  if (onEffectMask) {
                    onEffectMask = onEffectMask.replace(reg, cm);
                  }
                });
                var methodParameters = fxClass.getMethodParameters(fxClass.uniforms, fxProps);
                var pm = methodParameters.length > 0 ? ", ".concat(methodParameters) : '';
                if (onShaderMask) {
                  effectMethods += "\n        float fx_".concat(fx.key, "_onShaderMask(float shaderMask ").concat(pm, ") {\n          ").concat(onShaderMask, "\n        }\n        ");
                }
                if (onColorize) {
                  effectMethods += "\n          vec4 fx_".concat(fx.key, "_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(pm, ") {\n            ").concat(onColorize, "\n          }\n        ");
                }
                if (onEffectMask) {
                  effectMethods += "\n          vec4 fx_".concat(fx.key, "_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(pm, ") {\n            ").concat(onEffectMask, "\n          }\n        ");
                }
              });
              var sharedMethods = '';
              for (var m in methods) {
                sharedMethods += methods[m];
              }
              //fill main functions
              var currentMask = "mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))";
              var drawEffects = "\n\n    ";
              for (var i = 0; i < effects.length; i++) {
                var current = effects[i];
                var pm = current.passParameters.length > 0 ? ", ".concat(current.passParameters) : '';
                var currentClass = effectContructors[current.name];
                if (currentClass.onShaderMask) {
                  drawEffects += "\n        shaderMask = fx_".concat(current.target, "_onShaderMask(shaderMask ").concat(pm, ");\n        ");
                }
                if (currentClass.onColorize) {
                  drawEffects += "\n        maskColor = fx_".concat(current.target, "_onColorize(shaderMask, maskColor, shaderColor").concat(pm, ");\n        ");
                }
                if (currentClass.onEffectMask) {
                  currentMask = "fx_".concat(current.target, "_onEffectMask(shaderMask, maskColor, shaderColor").concat(pm, ")");
                }
                var next = effects[i + 1];
                if (next === undefined || effectContructors[next.name].onEffectMask) {
                  drawEffects += "\n          shaderColor = ".concat(currentMask, ";\n        ");
                }
              }
              return {
                effects: effects,
                uniforms: uniforms,
                fragment: DynamicShader.fragment(declareUniforms, sharedMethods, effectMethods, drawEffects),
                vertex: DynamicShader.vertex()
              };
            }
          }, {
            key: "resolveMethodDuplicate",
            value: function resolveMethodDuplicate(key, effectMethod, methodCollection) {
              var increment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var m = key + (increment > 0 ? increment : '');
              if (methodCollection[m] && methodCollection[m] !== effectMethod) {
                return this.resolveMethodDuplicate(key, effectMethod, methodCollection, ++increment);
              }
              return m;
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props, effectContructors) {
              var _props$effects;
              return {
                effects: getResolvedEffect((_props$effects = props.effects) !== null && _props$effects !== void 0 ? _props$effects : [], effectContructors),
                $dimensions: {
                  width: 0,
                  height: 0
                },
                $alpha: 0
              };
            }
          }, {
            key: "makeCacheKey",
            value: function makeCacheKey(props, effectContructors) {
              var _props$effects2;
              var fx = '';
              (_props$effects2 = props.effects) === null || _props$effects2 === void 0 || _props$effects2.forEach(function (effect) {
                var baseClass = effectContructors[effect.type];
                var key = baseClass.getEffectKey(effect.props || {});
                fx += ",".concat(key);
              });
              return "DynamicShader".concat(fx);
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Similar to the {@link DefaultShader} but cuts out 4 rounded rectangle corners
         * as defined by the specified corner {@link RoundedRectangleProps.radius}
         */
        _defineProperty(DynamicShader, "z$__type__Props", void 0);
        _defineProperty(DynamicShader, "vertex", function () {
          return "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_textureCoordinate;\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    attribute float a_textureIndex;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n    varying float v_textureIndex;\n\n    void main(){\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      // pass to fragment\n      v_color = a_color;\n      v_textureCoordinate = a_textureCoordinate;\n      v_textureIndex = a_textureIndex;\n\n      // flip y\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  ";
        });
        _defineProperty(DynamicShader, "fragment", function (uniforms, methods, effectMethods, drawEffects) {
          return "\n    # ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_radius;\n    uniform sampler2D u_texture;\n    uniform float u_pixelRatio;\n\n    ".concat(uniforms, "\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n\n    ").concat(methods, "\n\n    ").concat(effectMethods, "\n\n    void main() {\n      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;\n      vec2 d = abs(p) - (u_dimensions) * 0.5;\n      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n      vec4 shaderColor = vec4(0.0);\n      float shaderMask = lng_DefaultMask;\n\n      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;\n\n      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));\n\n      ").concat(drawEffects, "\n\n      gl_FragColor = shaderColor * u_alpha;\n    }\n  ");
        });
        var RoundedRectangle = /*#__PURE__*/function (_WebGlCoreShader5) {
          function RoundedRectangle(renderer) {
            _classCallCheck(this, RoundedRectangle);
            return _callSuper(this, RoundedRectangle, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate', 'a_color'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2f'
              }, {
                name: 'u_dimensions',
                uniform: 'uniform2fv'
              }, {
                name: 'u_radius',
                uniform: 'uniform1f'
              }]
            }]);
          }
          _inherits(RoundedRectangle, _WebGlCoreShader5);
          return _createClass(RoundedRectangle, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var radiusFactor = Math.min(props.$dimensions.width, props.$dimensions.height) / (2.0 * props.radius);
              this.glw.uniform1f(this.getUniformLocation('u_radius'), props.radius * Math.min(radiusFactor, 1));
            }
          }, {
            key: "canBatchShaderProps",
            value: function canBatchShaderProps(propsA, propsB) {
              return propsA.radius === propsB.radius && propsA.$dimensions.width === propsB.$dimensions.width && propsA.$dimensions.height === propsB.$dimensions.height;
            }
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              return {
                radius: props.radius || 10,
                $dimensions: {
                  width: 0,
                  height: 0
                }
              };
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(RoundedRectangle, "z$__type__Props", void 0);
        _defineProperty(RoundedRectangle, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform vec2 u_dimensions;\n      uniform float u_radius;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      float boxDist(vec2 p, vec2 size, float radius){\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n\n      float fillMask(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;\n        vec2 halfDimensions = u_dimensions * 0.5;\n\n        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);\n        gl_FragColor = mix(vec4(0.0), color, fillMask(d));\n      }\n    "
        });
        var IDENTITY_MATRIX_3x3 = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        /**
         * SdfShader supports multi-channel and single-channel signed distance field textures.
         *
         * @remarks
         * This Shader is used by the {@link SdfTextRenderer}. Do not use thie Shader
         * directly. Instead create a Text Node and assign a SDF font family to it.
         *
         * @internalRemarks
         * The only thing this shader does to support multi-channel SDFs is to
         * add a median function to the fragment shader. If this one function call
         * ends up being a performance bottleneck we can always look at ways to
         * remove it.
         */
        var SdfShader = /*#__PURE__*/function (_WebGlCoreShader6) {
          function SdfShader(renderer) {
            _classCallCheck(this, SdfShader);
            return _callSuper(this, SdfShader, [{
              renderer: renderer,
              attributes: ['a_position', 'a_textureCoordinate'],
              uniforms: [{
                name: 'u_resolution',
                uniform: 'uniform2fv'
              }, {
                name: 'u_transform',
                uniform: 'uniformMatrix3fv'
              }, {
                name: 'u_scrollY',
                uniform: 'uniform1f'
              }, {
                name: 'u_pixelRatio',
                uniform: 'uniform1f'
              }, {
                name: 'u_texture',
                uniform: 'uniform2f'
              }, {
                name: 'u_color',
                uniform: 'uniform4fv'
              }, {
                name: 'u_size',
                uniform: 'uniform1f'
              }, {
                name: 'u_distanceRange',
                uniform: 'uniform1f'
              }, {
                name: 'u_debug',
                uniform: 'uniform1i'
              }]
            }]);
          }
          _inherits(SdfShader, _WebGlCoreShader6);
          return _createClass(SdfShader, [{
            key: "bindTextures",
            value: function bindTextures(textures) {
              var glw = this.glw;
              glw.activeTexture(0);
              glw.bindTexture(textures[0].ctxTexture);
            }
          }, {
            key: "bindProps",
            value: function bindProps(props) {
              var resolvedProps = SdfShader.resolveDefaults(props);
              for (var key in resolvedProps) {
                if (key === 'transform') {
                  this.glw.uniformMatrix3fv(this.getUniformLocation('u_transform'), resolvedProps[key]);
                } else if (key === 'scrollY') {
                  this.glw.uniform1f(this.getUniformLocation('u_scrollY'), resolvedProps[key]);
                } else if (key === 'color') {
                  var components = getNormalizedRgbaComponents(resolvedProps.color);
                  this.glw.uniform4fv(this.getUniformLocation('u_color'), components);
                } else if (key === 'size') {
                  this.glw.uniform1f(this.getUniformLocation('u_size'), resolvedProps[key]);
                } else if (key === 'distanceRange') {
                  this.glw.uniform1f(this.getUniformLocation('u_distanceRange'), resolvedProps[key]);
                } else if (key === 'debug') {
                  this.glw.uniform1i(this.getUniformLocation('u_debug'), resolvedProps[key] ? 1 : 0);
                }
              }
            }
          }], [{
            key: "resolveDefaults",
            value: function resolveDefaults() {
              var _props$transform, _props$scrollY, _props$color, _props$size, _props$distanceRange, _props$debug;
              var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              return {
                transform: (_props$transform = props.transform) !== null && _props$transform !== void 0 ? _props$transform : IDENTITY_MATRIX_3x3,
                scrollY: (_props$scrollY = props.scrollY) !== null && _props$scrollY !== void 0 ? _props$scrollY : 0,
                color: (_props$color = props.color) !== null && _props$color !== void 0 ? _props$color : 0xffffffff,
                size: (_props$size = props.size) !== null && _props$size !== void 0 ? _props$size : 16,
                distanceRange: (_props$distanceRange = props.distanceRange) !== null && _props$distanceRange !== void 0 ? _props$distanceRange : 1.0,
                debug: (_props$debug = props.debug) !== null && _props$debug !== void 0 ? _props$debug : false
              };
            }
          }]);
        }(WebGlCoreShader);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(SdfShader, "z$__type__Props", void 0);
        _defineProperty(SdfShader, "shaderSources", {
          vertex: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n\n      uniform vec2 u_resolution;\n      uniform mat3 u_transform;\n      uniform float u_scrollY;\n      uniform float u_pixelRatio;\n      uniform float u_size;\n\n      varying vec2 v_texcoord;\n\n      void main() {\n        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);\n        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;\n\n        // Calculate screen space with pixel ratio\n        vec2 screenSpace = (transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1);\n\n        gl_Position = vec4(screenSpace, 0.0, 1.0);\n        v_texcoord = a_textureCoordinate;\n\n      }\n    ",
          fragment: "\n      # ifdef GL_FRAGMENT_PRECISION_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n      uniform vec4 u_color;\n      uniform sampler2D u_texture;\n      uniform float u_distanceRange;\n      uniform float u_pixelRatio;\n      uniform int u_debug;\n\n      varying vec2 v_texcoord;\n\n      float median(float r, float g, float b) {\n          return max(min(r, g), min(max(r, g), b));\n      }\n\n      void main() {\n          vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n          if (u_debug == 1) {\n            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);\n            return;\n          }\n          float scaledDistRange = u_distanceRange * u_pixelRatio;\n          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n          // Build the final color.\n          // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n      }\n    "
        });
        var updateShaderEffectColor = function updateShaderEffectColor(values) {
          if (values.programValue === undefined) {
            values.programValue = new Float32Array(4);
          }
          var rgba = values.value;
          var floatArray = values.programValue;
          floatArray[0] = (rgba >>> 24) / 255;
          floatArray[1] = (rgba >>> 16 & 0xff) / 255;
          floatArray[2] = (rgba >>> 8 & 0xff) / 255;
          floatArray[3] = (rgba & 0xff) / 255;
        };
        var updateFloat32ArrayLength2 = function updateFloat32ArrayLength2(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var floatArray = values.programValue;
            floatArray[0] = validatedValue[0];
            floatArray[1] = validatedValue[1];
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var updateFloat32ArrayLength4 = function updateFloat32ArrayLength4(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var floatArray = values.programValue;
            floatArray[0] = validatedValue[0];
            floatArray[1] = validatedValue[1];
            floatArray[2] = validatedValue[2];
            floatArray[3] = validatedValue[3];
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var updateFloat32ArrayLengthN = function updateFloat32ArrayLengthN(values) {
          var validatedValue = values.validatedValue || values.value;
          if (values.programValue instanceof Float32Array) {
            var len = validatedValue.length;
            var programValue = values.programValue;
            for (var i = 0; i < len; i++) {
              programValue[i] = validatedValue[i];
            }
          } else {
            values.programValue = new Float32Array(validatedValue);
          }
        };
        var validateArrayLength4 = function validateArrayLength4(value) {
          var isArray = Array.isArray(value);
          if (!isArray) {
            return [value, value, value, value];
          } else if (isArray && value.length === 4) {
            return value;
          } else if (isArray && value.length === 2) {
            return [value[0], value[1], value[0], value[1]];
          } else if (isArray && value.length === 3) {
            return [value[0], value[1], value[2], value[0]];
          }
          return [value[0], value[0], value[0], value[0]];
        };
        var updateWebSafeRadius = function updateWebSafeRadius(values, shaderProps) {
          if (values.programValue === undefined) {
            values.programValue = new Float32Array(4);
          }
          var programValue = values.programValue;
          var validatedValue = values.validatedValue || values.value;
          if (shaderProps === undefined && values.$dimensions === undefined) {
            programValue[0] = validatedValue[0];
            programValue[1] = validatedValue[1];
            programValue[2] = validatedValue[2];
            programValue[3] = validatedValue[3];
            return;
          }
          var storedDimensions = values.$dimensions;
          if (shaderProps !== undefined) {
            var $dimensions = shaderProps.$dimensions;
            if (storedDimensions !== undefined && (storedDimensions.width === $dimensions.width || storedDimensions.height === $dimensions.height)) {
              return;
            }
            if (storedDimensions === undefined) {
              storedDimensions = {
                width: $dimensions === null || $dimensions === void 0 ? void 0 : $dimensions.width,
                height: $dimensions === null || $dimensions === void 0 ? void 0 : $dimensions.height
              };
              values.$dimensions = storedDimensions;
            }
          }
          var _storedDimensions = storedDimensions,
            width = _storedDimensions.width,
            height = _storedDimensions.height;
          var _validatedValue = _slicedToArray(validatedValue, 4),
            r0 = _validatedValue[0],
            r1 = _validatedValue[1],
            r2 = _validatedValue[2],
            r3 = _validatedValue[3];
          var factor = Math.min(Math.min(Math.min(width / Math.max(width, r0 + r1), width / Math.max(width, r2 + r3)), Math.min(height / Math.max(height, r0 + r2), height / Math.max(height, r1 + r3))), 1);
          programValue[0] = r0 * factor;
          programValue[1] = r1 * factor;
          programValue[2] = r2 * factor;
          programValue[3] = r3 * factor;
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Masks the current maskcolor with rounded corners similar to {@link RoundedRectangle}
         */
        var RadiusEffect = /*#__PURE__*/function (_ShaderEffect2) {
          function RadiusEffect() {
            var _this22;
            _classCallCheck(this, RadiusEffect);
            for (var _len = arguments.length, args = new Array(_len), _key5 = 0; _key5 < _len; _key5++) {
              args[_key5] = arguments[_key5];
            }
            _this22 = _callSuper(this, RadiusEffect, [].concat(args));
            _defineProperty(_this22, "name", 'radius');
            return _this22;
          }
          _inherits(RadiusEffect, _ShaderEffect2);
          return _createClass(RadiusEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "radius";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$radius;
              return {
                radius: (_props$radius = props.radius) !== null && _props$radius !== void 0 ? _props$radius : 10
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderEffect renders a border along all edges of an element
         */
        _defineProperty(RadiusEffect, "z$__type__Props", void 0);
        _defineProperty(RadiusEffect, "uniforms", {
          radius: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            updateOnBind: true,
            validator: validateArrayLength4,
            updateProgramValue: updateWebSafeRadius
          }
        });
        _defineProperty(RadiusEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          boxDist: "\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "
        });
        _defineProperty(RadiusEffect, "onShaderMask", "\n  vec2 halfDimensions = u_dimensions * 0.5;\n  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);\n  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);\n  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);\n  ");
        _defineProperty(RadiusEffect, "onEffectMask", "\n  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));\n  ");
        var BorderEffect = /*#__PURE__*/function (_ShaderEffect3) {
          function BorderEffect() {
            var _this23;
            _classCallCheck(this, BorderEffect);
            for (var _len2 = arguments.length, args = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {
              args[_key6] = arguments[_key6];
            }
            _this23 = _callSuper(this, BorderEffect, [].concat(args));
            _defineProperty(_this23, "name", 'border');
            return _this23;
          }
          _inherits(BorderEffect, _ShaderEffect3);
          return _createClass(BorderEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "border";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width3, _props$color2;
              return {
                width: (_props$width3 = props.width) !== null && _props$width3 !== void 0 ? _props$width3 : 10,
                color: (_props$color2 = props.color) !== null && _props$color2 !== void 0 ? _props$color2 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Linear Gradient effect over a effect mask
         */
        _defineProperty(BorderEffect, "z$__type__Props", void 0);
        _defineProperty(BorderEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderEffect, "onEffectMask", "\n  float intR = shaderMask + 1.0;\n  float mask = clamp(intR + width, 0.0, 1.0) - clamp(intR, 0.0, 1.0);\n  return mix(shaderColor, mix(shaderColor, maskColor, maskColor.a), mask);\n  ");
        _defineProperty(BorderEffect, "onColorize", "\n    return color;\n  ");
        var LinearGradientEffect = /*#__PURE__*/function (_ShaderEffect4) {
          function LinearGradientEffect() {
            var _this24;
            _classCallCheck(this, LinearGradientEffect);
            for (var _len3 = arguments.length, args = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {
              args[_key7] = arguments[_key7];
            }
            _this24 = _callSuper(this, LinearGradientEffect, [].concat(args));
            _defineProperty(_this24, "name", 'linearGradient');
            return _this24;
          }
          _inherits(LinearGradientEffect, _ShaderEffect4);
          return _createClass(LinearGradientEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              if (props.colors.value) {
                return "linearGradient".concat(props.colors.value.length);
              }
              return "linearGradient".concat(props.colors.length);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$colors, _props$angle;
              var colors = (_props$colors = props.colors) !== null && _props$colors !== void 0 ? _props$colors : [0xff000000, 0xffffffff];
              var stops = props.stops || [];
              if (stops.length === 0 || stops.length !== colors.length) {
                var colorsL = colors.length;
                var i = 0;
                var tmp = stops;
                for (; i < colorsL; i++) {
                  if (stops[i]) {
                    tmp[i] = stops[i];
                    if (stops[i - 1] === undefined && tmp[i - 2] !== undefined) {
                      tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
                    }
                  } else {
                    tmp[i] = i * (1 / (colors.length - 1));
                  }
                }
                stops = tmp;
              }
              return {
                colors: colors,
                stops: stops,
                angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Grayscale effect grayscales the color values of the current mask color
         */
        _defineProperty(LinearGradientEffect, "z$__type__Props", void 0);
        _defineProperty(LinearGradientEffect, "uniforms", {
          angle: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          colors: {
            value: 0xffffffff,
            validator: function validator(rgbas) {
              return rgbas.reduce(function (acc, val) {
                return acc.concat(getNormalizedRgbaComponents(val));
              }, []);
            },
            updateProgramValue: updateFloat32ArrayLengthN,
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform4fv',
            type: 'vec4'
          },
          stops: {
            value: [],
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform1fv',
            type: 'float'
          }
        });
        _defineProperty(LinearGradientEffect, "methods", {
          calcPoint: "\n      vec2 function(float d, float angle) {\n        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n      }\n    "
        });
        _defineProperty(LinearGradientEffect, "ColorLoop", function (amount) {
          var loop = '';
          for (var i = 2; i < amount; i++) {
            loop += "colorOut = mix(colorOut, colors[".concat(i, "], clamp((dist - stops[").concat(i - 1, "]) / (stops[").concat(i, "] - stops[").concat(i - 1, "]), 0.0, 1.0));");
          }
          return loop;
        });
        _defineProperty(LinearGradientEffect, "onColorize", function (props) {
          var colors = props.colors.length || 1;
          return "\n      float a = angle - (PI / 180.0 * 90.0);\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = $calcPoint(lineDist * 0.5, a);\n      vec2 t = $calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n\n      //return early if dist is lower or equal to first stop\n      if(dist <= stops[0]) {\n        return mix(maskColor, colors[0], clamp(colors[0].a, 0.0, 1.0));\n      }\n      const int amount = ".concat(colors, ";\n      const int last = amount - 1;\n\n      if(dist >= stops[last]) {\n        return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));\n      }\n\n      for(int i = 0; i < last; i++) {\n        float left = stops[i];\n        float right = stops[i + 1];\n        if(dist >= left && dist <= right) {\n          float localDist = smoothstep(left, right, dist);\n          vec4 colorOut = mix(colors[i], colors[i + 1], localDist);\n          return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n        }\n      }\n\n      //final fallback\n      return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));\n    ");
        });
        var GrayscaleEffect = /*#__PURE__*/function (_ShaderEffect5) {
          function GrayscaleEffect() {
            var _this25;
            _classCallCheck(this, GrayscaleEffect);
            for (var _len4 = arguments.length, args = new Array(_len4), _key8 = 0; _key8 < _len4; _key8++) {
              args[_key8] = arguments[_key8];
            }
            _this25 = _callSuper(this, GrayscaleEffect, [].concat(args));
            _defineProperty(_this25, "name", 'grayscale');
            return _this25;
          }
          _inherits(GrayscaleEffect, _ShaderEffect5);
          return _createClass(GrayscaleEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "grayscale";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$amount;
              return {
                amount: (_props$amount = props.amount) !== null && _props$amount !== void 0 ? _props$amount : 1
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the right side of an element
         */
        _defineProperty(GrayscaleEffect, "uniforms", {
          amount: {
            value: 1,
            method: 'uniform1f',
            type: 'float'
          }
        });
        _defineProperty(GrayscaleEffect, "onColorize", "\n    float grayness = 0.2 * maskColor.r + 0.6 * maskColor.g + 0.2 * maskColor.b;\n    return vec4(amount * vec3(grayness) + (1.0 - amount) * maskColor.rgb, maskColor.a);\n  ");
        var BorderRightEffect = /*#__PURE__*/function (_ShaderEffect6) {
          function BorderRightEffect() {
            var _this26;
            _classCallCheck(this, BorderRightEffect);
            for (var _len5 = arguments.length, args = new Array(_len5), _key9 = 0; _key9 < _len5; _key9++) {
              args[_key9] = arguments[_key9];
            }
            _this26 = _callSuper(this, BorderRightEffect, [].concat(args));
            _defineProperty(_this26, "name", 'borderRight');
            return _this26;
          }
          _inherits(BorderRightEffect, _ShaderEffect6);
          return _createClass(BorderRightEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderRight";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width4, _props$color3;
              return {
                width: (_props$width4 = props.width) !== null && _props$width4 !== void 0 ? _props$width4 : 10,
                color: (_props$color3 = props.color) !== null && _props$color3 !== void 0 ? _props$color3 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the top side of an element
         */
        _defineProperty(BorderRightEffect, "z$__type__Props", void 0);
        _defineProperty(BorderRightEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderRightEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderRightEffect, "onEffectMask", "\n  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderRightEffect, "onColorize", "\n    return color;\n  ");
        var BorderTopEffect = /*#__PURE__*/function (_ShaderEffect7) {
          function BorderTopEffect() {
            var _this27;
            _classCallCheck(this, BorderTopEffect);
            for (var _len6 = arguments.length, args = new Array(_len6), _key0 = 0; _key0 < _len6; _key0++) {
              args[_key0] = arguments[_key0];
            }
            _this27 = _callSuper(this, BorderTopEffect, [].concat(args));
            _defineProperty(_this27, "name", 'borderTop');
            return _this27;
          }
          _inherits(BorderTopEffect, _ShaderEffect7);
          return _createClass(BorderTopEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderTop";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width5, _props$color4;
              return {
                width: (_props$width5 = props.width) !== null && _props$width5 !== void 0 ? _props$width5 : 10,
                color: (_props$color4 = props.color) !== null && _props$color4 !== void 0 ? _props$color4 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the bottom side of an element
         */
        _defineProperty(BorderTopEffect, "z$__type__Props", void 0);
        _defineProperty(BorderTopEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderTopEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderTopEffect, "onEffectMask", "\n  vec2 pos = vec2(0.0, width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderTopEffect, "onColorize", "\n    return color;\n  ");
        var BorderBottomEffect = /*#__PURE__*/function (_ShaderEffect8) {
          function BorderBottomEffect() {
            var _this28;
            _classCallCheck(this, BorderBottomEffect);
            for (var _len7 = arguments.length, args = new Array(_len7), _key1 = 0; _key1 < _len7; _key1++) {
              args[_key1] = arguments[_key1];
            }
            _this28 = _callSuper(this, BorderBottomEffect, [].concat(args));
            _defineProperty(_this28, "name", 'borderBottom');
            return _this28;
          }
          _inherits(BorderBottomEffect, _ShaderEffect8);
          return _createClass(BorderBottomEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderBottom";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width6, _props$color5;
              return {
                width: (_props$width6 = props.width) !== null && _props$width6 !== void 0 ? _props$width6 : 10,
                color: (_props$color5 = props.color) !== null && _props$color5 !== void 0 ? _props$color5 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The BorderBottomEffect renders a border on the left of an element
         */
        _defineProperty(BorderBottomEffect, "z$__type__Props", void 0);
        _defineProperty(BorderBottomEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderBottomEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderBottomEffect, "onEffectMask", "\n  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderBottomEffect, "onColorize", "\n    return color;\n  ");
        var BorderLeftEffect = /*#__PURE__*/function (_ShaderEffect9) {
          function BorderLeftEffect() {
            var _this29;
            _classCallCheck(this, BorderLeftEffect);
            for (var _len8 = arguments.length, args = new Array(_len8), _key10 = 0; _key10 < _len8; _key10++) {
              args[_key10] = arguments[_key10];
            }
            _this29 = _callSuper(this, BorderLeftEffect, [].concat(args));
            _defineProperty(_this29, "name", 'borderLeft');
            return _this29;
          }
          _inherits(BorderLeftEffect, _ShaderEffect9);
          return _createClass(BorderLeftEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "borderLeft";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width7, _props$color6;
              return {
                width: (_props$width7 = props.width) !== null && _props$width7 !== void 0 ? _props$width7 : 10,
                color: (_props$color6 = props.color) !== null && _props$color6 !== void 0 ? _props$color6 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /**
         * Renders a Glitch effect using the incoming texture
         */
        _defineProperty(BorderLeftEffect, "z$__type__Props", void 0);
        _defineProperty(BorderLeftEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(BorderLeftEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          rectDist: "\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "
        });
        _defineProperty(BorderLeftEffect, "onEffectMask", "\n  vec2 pos = vec2(width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ");
        _defineProperty(BorderLeftEffect, "onColorize", "\n    return color;\n  ");
        var GlitchEffect = /*#__PURE__*/function (_ShaderEffect0) {
          function GlitchEffect() {
            var _this30;
            _classCallCheck(this, GlitchEffect);
            for (var _len9 = arguments.length, args = new Array(_len9), _key11 = 0; _key11 < _len9; _key11++) {
              args[_key11] = arguments[_key11];
            }
            _this30 = _callSuper(this, GlitchEffect, [].concat(args));
            _defineProperty(_this30, "name", 'glitch');
            return _this30;
          }
          _inherits(GlitchEffect, _ShaderEffect0);
          return _createClass(GlitchEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              return "glitch";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$amplitude, _props$narrowness, _props$blockiness, _props$minimizer, _props$time;
              return {
                amplitude: (_props$amplitude = props.amplitude) !== null && _props$amplitude !== void 0 ? _props$amplitude : 0.2,
                narrowness: (_props$narrowness = props.narrowness) !== null && _props$narrowness !== void 0 ? _props$narrowness : 4.0,
                blockiness: (_props$blockiness = props.blockiness) !== null && _props$blockiness !== void 0 ? _props$blockiness : 2.0,
                minimizer: (_props$minimizer = props.minimizer) !== null && _props$minimizer !== void 0 ? _props$minimizer : 8.0,
                time: (_props$time = props.time) !== null && _props$time !== void 0 ? _props$time : Date.now()
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(GlitchEffect, "z$__type__Props", void 0);
        _defineProperty(GlitchEffect, "uniforms", {
          amplitude: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          narrowness: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          blockiness: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          minimizer: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          time: {
            value: 0,
            method: 'uniform1f',
            updateOnBind: true,
            updateProgramValue: function updateProgramValue(values) {
              var value = values.value = (Date.now() - values.value) % 1000;
              values.programValue = value;
            },
            type: 'float'
          }
        });
        _defineProperty(GlitchEffect, "methods", {
          rand: "\n      float function(vec2 p, float time) {\n        float t = floor(time * 20.) / 10.;\n        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n      }\n    ",
          noise: "\n      float function(vec2 uv, float blockiness, float time) {\n        vec2 lv = fract(uv);\n        vec2 id = floor(uv);\n\n        float n1 = rand(id, time);\n        float n2 = rand(id+vec2(1,0), time);\n        float n3 = rand(id+vec2(0,1), time);\n        float n4 = rand(id+vec2(1,1), time);\n        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n      }\n    ",
          fbm: "\n      float function(vec2 uv, int count, float blockiness, float complexity, float time) {\n        float val = 0.0;\n        float amp = 0.5;\n        const int MAX_ITERATIONS = 10;\n\n        for(int i = 0; i < MAX_ITERATIONS; i++) {\n          if(i >= count) {break;}\n          val += amp * noise(uv, blockiness, time);\n          amp *= 0.5;\n          uv *= complexity;\n        }\n        return val;\n      }\n    "
        });
        _defineProperty(GlitchEffect, "onColorize", "\n    vec2 uv = v_textureCoordinate.xy;\n    float aspect = u_dimensions.x / u_dimensions.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));\n\n    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);\n    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);\n    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);\n    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n\n    vec3 f = vec3(colR, colG, colB);\n    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);\n  ");
        var FadeOutEffect = /*#__PURE__*/function (_ShaderEffect1) {
          function FadeOutEffect() {
            var _this31;
            _classCallCheck(this, FadeOutEffect);
            for (var _len0 = arguments.length, args = new Array(_len0), _key12 = 0; _key12 < _len0; _key12++) {
              args[_key12] = arguments[_key12];
            }
            _this31 = _callSuper(this, FadeOutEffect, [].concat(args));
            _defineProperty(_this31, "name", 'fadeOut');
            return _this31;
          }
          _inherits(FadeOutEffect, _ShaderEffect1);
          return _createClass(FadeOutEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "fadeOut";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$fade;
              return {
                fade: (_props$fade = props.fade) !== null && _props$fade !== void 0 ? _props$fade : 10
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(FadeOutEffect, "z$__type__Props", void 0);
        _defineProperty(FadeOutEffect, "uniforms", {
          fade: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            validator: validateArrayLength4,
            updateProgramValue: updateFloat32ArrayLength4
          }
        });
        _defineProperty(FadeOutEffect, "onColorize", "\n  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;\n  vec2 pos1;\n  vec2 pos2;\n  vec2 d;\n  float c;\n  vec4 result = maskColor;\n\n\n  if(fade[0] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x, point.y + fade[0]);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[1] > 0.0) {\n    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);\n    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[2] > 0.0) {\n    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);\n    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[3] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x + fade[3], point.y);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  return result;\n  ");
        var RadialGradientEffect = /*#__PURE__*/function (_ShaderEffect10) {
          function RadialGradientEffect() {
            var _this32;
            _classCallCheck(this, RadialGradientEffect);
            for (var _len1 = arguments.length, args = new Array(_len1), _key13 = 0; _key13 < _len1; _key13++) {
              args[_key13] = arguments[_key13];
            }
            _this32 = _callSuper(this, RadialGradientEffect, [].concat(args));
            _defineProperty(_this32, "name", 'radialGradient');
            return _this32;
          }
          _inherits(RadialGradientEffect, _ShaderEffect10);
          return _createClass(RadialGradientEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey(props) {
              if (props.colors.value) {
                return "radialGradient".concat(props.colors.value.length);
              }
              return "radialGradient".concat(props.colors.length);
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$colors2, _props$width8, _ref8, _props$height3, _props$pivot;
              var colors = (_props$colors2 = props.colors) !== null && _props$colors2 !== void 0 ? _props$colors2 : [0xff000000, 0xffffffff];
              var stops = props.stops || [];
              if (stops.length === 0 || stops.length !== colors.length) {
                var colorsL = colors.length;
                var i = 0;
                var tmp = stops;
                for (; i < colorsL; i++) {
                  if (stops[i]) {
                    tmp[i] = stops[i];
                    if (stops[i - 1] === undefined && tmp[i - 2] !== undefined) {
                      tmp[i - 1] = tmp[i - 2] + (stops[i] - tmp[i - 2]) / 2;
                    }
                  } else {
                    tmp[i] = i * (1 / (colors.length - 1));
                  }
                }
                stops = tmp;
              }
              return {
                colors: colors,
                stops: stops,
                width: (_props$width8 = props.width) !== null && _props$width8 !== void 0 ? _props$width8 : 0,
                height: (_ref8 = (_props$height3 = props.height) !== null && _props$height3 !== void 0 ? _props$height3 : props.width) !== null && _ref8 !== void 0 ? _ref8 : 0,
                pivot: (_props$pivot = props.pivot) !== null && _props$pivot !== void 0 ? _props$pivot : [0.5, 0.5]
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The RadialProgressEffect renders a border along all edges of an element
         */
        _defineProperty(RadialGradientEffect, "z$__type__Props", void 0);
        _defineProperty(RadialGradientEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          height: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          pivot: {
            value: [0.5, 0.5],
            updateProgramValue: updateFloat32ArrayLength2,
            method: 'uniform2fv',
            type: 'vec2'
          },
          colors: {
            value: 0xffffffff,
            validator: function validator(rgbas) {
              return rgbas.reduce(function (acc, val) {
                return acc.concat(getNormalizedRgbaComponents(val));
              }, []);
            },
            updateProgramValue: updateFloat32ArrayLengthN,
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform4fv',
            type: 'vec4'
          },
          stops: {
            value: [],
            size: function size(props) {
              return props.colors.length;
            },
            method: 'uniform1fv',
            type: 'float'
          }
        });
        _defineProperty(RadialGradientEffect, "methods", {
          getGradientColor: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    "
        });
        _defineProperty(RadialGradientEffect, "ColorLoop", function (amount) {
          var loop = '';
          for (var i = 2; i < amount; i++) {
            loop += "colorOut = mix(colorOut, colors[".concat(i, "], clamp((dist - stops[").concat(i - 1, "]) / (stops[").concat(i, "] - stops[").concat(i - 1, "]), 0.0, 1.0));");
          }
          return loop;
        });
        _defineProperty(RadialGradientEffect, "onColorize", function (props) {
          var colors = props.colors.length || 1;
          return "\n      vec2 point = v_textureCoordinate.xy * u_dimensions;\n      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);\n\n      float dist = length((point - projection) / vec2(width, height));\n\n      dist = clamp(dist, 0.0, 1.0);\n      //return early if dist is lower or equal to first stop\n      if(dist <= stops[0]) {\n        return mix(maskColor, colors[0], clamp(colors[0].a, 0.0, 1.0));\n      }\n      const int amount = ".concat(colors, ";\n      const int last = amount - 1;\n\n      if(dist >= stops[last]) {\n        return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));\n      }\n\n      for(int i = 0; i < last; i++) {\n        float left = stops[i];\n        float right = stops[i + 1];\n        if(dist >= left && dist <= right) {\n          float localDist = smoothstep(left, right, dist);\n          vec4 colorOut = mix(colors[i], colors[i + 1], localDist);\n          return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n        }\n      }\n\n      //final fallback\n      return mix(maskColor, colors[last], clamp(colors[last].a, 0.0, 1.0));\n    ");
        });
        var RadialProgressEffect = /*#__PURE__*/function (_ShaderEffect11) {
          function RadialProgressEffect() {
            var _this33;
            _classCallCheck(this, RadialProgressEffect);
            for (var _len10 = arguments.length, args = new Array(_len10), _key14 = 0; _key14 < _len10; _key14++) {
              args[_key14] = arguments[_key14];
            }
            _this33 = _callSuper(this, RadialProgressEffect, [].concat(args));
            _defineProperty(_this33, "name", 'radialProgress');
            return _this33;
          }
          _inherits(RadialProgressEffect, _ShaderEffect11);
          return _createClass(RadialProgressEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "radialProgress";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$width9, _props$progress, _props$offset, _props$range, _props$rounded, _props$radius2, _props$color7;
              return {
                width: (_props$width9 = props.width) !== null && _props$width9 !== void 0 ? _props$width9 : 10,
                progress: (_props$progress = props.progress) !== null && _props$progress !== void 0 ? _props$progress : 0.5,
                offset: (_props$offset = props.offset) !== null && _props$offset !== void 0 ? _props$offset : 0,
                range: (_props$range = props.range) !== null && _props$range !== void 0 ? _props$range : Math.PI * 2,
                rounded: (_props$rounded = props.rounded) !== null && _props$rounded !== void 0 ? _props$rounded : false,
                radius: (_props$radius2 = props.radius) !== null && _props$radius2 !== void 0 ? _props$radius2 : 1,
                color: (_props$color7 = props.color) !== null && _props$color7 !== void 0 ? _props$color7 : 0xffffffff
              };
            }
          }]);
        }(ShaderEffect);
        /**
         * Masks the current maskcolor a holepunch effect with rounded corners similar to {@link RoundedRectangle}
         */
        _defineProperty(RadialProgressEffect, "z$__type__Props", void 0);
        _defineProperty(RadialProgressEffect, "uniforms", {
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          progress: {
            value: 0.5,
            method: 'uniform1f',
            type: 'float'
          },
          offset: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          range: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          rounded: {
            value: 0,
            method: 'uniform1f',
            type: 'float',
            validator: function validator(value) {
              return value ? 1 : 0;
            }
          },
          radius: {
            value: 1,
            method: 'uniform1f',
            type: 'float'
          },
          color: {
            value: 0xffffffff,
            updateProgramValue: updateShaderEffectColor,
            method: 'uniform4fv',
            type: 'vec4'
          }
        });
        _defineProperty(RadialProgressEffect, "methods", {
          rotateUV: "\n    vec2 function(vec2 uv, float d) {\n      float s = sin(d);\n      float c = cos(d);\n      mat2 rotMatrix = mat2(c, -s, s, c);\n      return uv * rotMatrix;\n    }\n    ",
          drawDot: "\n    float function(vec2 uv, vec2 p, float r) {\n      uv += p;\n      float circle = length(uv) - r;\n      return clamp(-circle, 0.0, 1.0);\n    }\n    "
        });
        _defineProperty(RadialProgressEffect, "onEffectMask", "\n    float outerRadius = radius * u_dimensions.y * 0.5;\n\n    float endAngle = range * progress - 0.0005;\n\n    vec2 uv = v_textureCoordinate.xy * u_dimensions.xy - u_dimensions * 0.5;\n\n    uv = $rotateUV(uv, -(offset));\n    float linewidth = width * u_pixelRatio;\n    float circle = length(uv) - (outerRadius - linewidth) ;\n    circle = abs(circle) - linewidth;\n    circle = clamp(-circle, 0.0, 1.0);\n\n    float angle = (atan(uv.x, -uv.y) / 3.14159265359 * 0.5);\n    float p = endAngle / (PI * 2.);\n\n    circle *= step(fract(angle), fract(p));\n\n    circle = rounded < 1. ? circle : max(circle, $drawDot(uv, vec2(0, outerRadius - linewidth), linewidth));\n    circle = rounded < 1. ? circle : max(circle, $drawDot($rotateUV(uv, -(endAngle)), vec2(0, outerRadius - linewidth), linewidth));\n\n    return mix(shaderColor, maskColor, circle);\n  ");
        _defineProperty(RadialProgressEffect, "onColorize", "\n    return color;\n  ");
        var HolePunchEffect = /*#__PURE__*/function (_ShaderEffect12) {
          function HolePunchEffect() {
            var _this34;
            _classCallCheck(this, HolePunchEffect);
            for (var _len11 = arguments.length, args = new Array(_len11), _key15 = 0; _key15 < _len11; _key15++) {
              args[_key15] = arguments[_key15];
            }
            _this34 = _callSuper(this, HolePunchEffect, [].concat(args));
            _defineProperty(_this34, "name", 'holePunch');
            return _this34;
          }
          _inherits(HolePunchEffect, _ShaderEffect12);
          return _createClass(HolePunchEffect, null, [{
            key: "getEffectKey",
            value: function getEffectKey() {
              return "holePunch";
            }
          }, {
            key: "resolveDefaults",
            value: function resolveDefaults(props) {
              var _props$radius3;
              return {
                x: props.x || 0,
                y: props.y || 0,
                width: props.width || 50,
                height: props.height || 50,
                radius: (_props$radius3 = props.radius) !== null && _props$radius3 !== void 0 ? _props$radius3 : 0
              };
            }
          }]);
        }(ShaderEffect);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        _defineProperty(HolePunchEffect, "z$__type__Props", void 0);
        _defineProperty(HolePunchEffect, "uniforms", {
          x: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          y: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          width: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          height: {
            value: 0,
            method: 'uniform1f',
            type: 'float'
          },
          radius: {
            value: 0,
            method: 'uniform4fv',
            type: 'vec4',
            updateOnBind: true,
            validator: validateArrayLength4,
            updateProgramValue: updateWebSafeRadius
          }
        });
        _defineProperty(HolePunchEffect, "methods", {
          fillMask: "\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",
          boxDist: "\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "
        });
        _defineProperty(HolePunchEffect, "onShaderMask", "\n  vec2 halfDimensions = u_dimensions * 0.5;\n  vec2 size = vec2(width, height) * 0.5;\n  vec2 basePos = v_textureCoordinate.xy * u_dimensions.xy - vec2(x, y);\n  vec2 pos = basePos - size;\n  float r = radius[0] * step(pos.x, 0.5) * step(pos.y, 0.5);\n  r = r + radius[1] * step(0.5, pos.x) * step(pos.y, 0.5);\n  r = r + radius[2] * step(0.5, pos.x) * step(0.5, pos.y);\n  r = r + radius[3] * step(pos.x, 0.5) * step(0.5, pos.y);\n  return $boxDist(pos, size, r);\n  ");
        _defineProperty(HolePunchEffect, "onEffectMask", "\n  return mix(maskColor, vec4(0.0), $fillMask(shaderMask));\n  ");
        var ROUNDED_RECTANGLE_SHADER_TYPE = 'RoundedRectangle';
        var UnsupportedShader = /*#__PURE__*/function (_CoreShader2) {
          function UnsupportedShader(shType) {
            var _this35;
            _classCallCheck(this, UnsupportedShader);
            _this35 = _callSuper(this, UnsupportedShader);
            _defineProperty(_this35, "shType", void 0);
            _this35.shType = shType;
            // if (shType !== ROUNDED_RECTANGLE_SHADER_TYPE) {
            //   console.warn('Unsupported shader:', shType);
            // }
            return _this35;
          }
          _inherits(UnsupportedShader, _CoreShader2);
          return _createClass(UnsupportedShader, [{
            key: "bindRenderOp",
            value: function bindRenderOp() {
              // noop
            }
          }, {
            key: "bindProps",
            value: function bindProps() {
              // noop
            }
          }, {
            key: "attach",
            value: function attach() {
              // noop
            }
          }, {
            key: "detach",
            value: function detach() {
              // noop
            }
          }]);
        }(CoreShader);
        /**
         * Shader Controller Class
         *
         * @remarks
         * This class is used to control shader props.
         */
        var ShaderController = /*#__PURE__*/function () {
          function ShaderController(type, shader, props, stage) {
            var _this36 = this;
            _classCallCheck(this, ShaderController);
            _defineProperty(this, "type", void 0);
            _defineProperty(this, "shader", void 0);
            _defineProperty(this, "resolvedProps", void 0);
            _defineProperty(this, "props", void 0);
            this.type = type;
            this.shader = shader;
            this.resolvedProps = props;
            var keys = Object.keys(props);
            var l = keys.length;
            var definedProps = {};
            var _loop2 = function _loop2() {
              var name = keys[i];
              Object.defineProperty(definedProps, name, {
                get: function get() {
                  return _this36.resolvedProps[name];
                },
                set: function set(value) {
                  _this36.resolvedProps[name] = value;
                  stage.requestRender();
                }
              });
            };
            for (var i = 0; i < l; i++) {
              _loop2();
            }
            this.props = definedProps;
          }
          return _createClass(ShaderController, [{
            key: "getResolvedProps",
            value: function getResolvedProps() {
              return this.resolvedProps;
            }
          }]);
        }();
        var DynamicShaderController = /*#__PURE__*/function () {
          function DynamicShaderController(shader, props, shManager) {
            var _this37 = this;
            _classCallCheck(this, DynamicShaderController);
            _defineProperty(this, "shader", void 0);
            _defineProperty(this, "resolvedProps", void 0);
            _defineProperty(this, "props", void 0);
            _defineProperty(this, "type", void 0);
            this.shader = shader;
            this.type = 'DynamicShader';
            this.resolvedProps = props;
            var effectConstructors = shManager.getRegisteredEffects();
            var definedProps = {};
            var effects = props.effects;
            var effectsLength = effects.length;
            var _loop3 = function _loop3(i) {
              var _effects$i2 = effects[i],
                effectName = _effects$i2.name,
                effectProps = _effects$i2.props,
                effectType = _effects$i2.type;
              if (effectName === undefined) {
                return 1; // continue
              }
              var definedEffectProps = {};
              var propEntries = Object.keys(effectProps);
              var propEntriesLength = propEntries.length;
              var _loop4 = function _loop4() {
                var propName = propEntries[j];
                Object.defineProperty(definedEffectProps, propName, {
                  get: function get() {
                    return _this37.resolvedProps.effects[i].props[propName].value;
                  },
                  set: function set(value) {
                    var target = _this37.resolvedProps.effects[i].props[propName];
                    target.value = value;
                    if (target.hasValidator) {
                      var _effectConstructors$e;
                      value = target.validatedValue = (_effectConstructors$e = effectConstructors[effectType].uniforms[propName]) === null || _effectConstructors$e === void 0 ? void 0 : _effectConstructors$e.validator(value, effectProps);
                    }
                    if (target.hasProgramValueUpdater) {
                      var _effectConstructors$e2;
                      (_effectConstructors$e2 = effectConstructors[effectType].uniforms[propName]) === null || _effectConstructors$e2 === void 0 || _effectConstructors$e2.updateProgramValue(target);
                    } else {
                      target.programValue = value;
                    }
                    shManager.renderer.stage.requestRender();
                  }
                });
              };
              for (var j = 0; j < propEntriesLength; j++) {
                _loop4();
              }
              Object.defineProperty(definedProps, effectName, {
                get: function get() {
                  return definedEffectProps;
                }
              });
            };
            for (var i = 0; i < effectsLength; i++) {
              if (_loop3(i)) continue;
            }
            this.props = definedProps;
          }
          return _createClass(DynamicShaderController, [{
            key: "getResolvedProps",
            value: function getResolvedProps() {
              return this.resolvedProps;
            }
          }]);
        }();
        var CoreShaderManager = /*#__PURE__*/function () {
          function CoreShaderManager() {
            _classCallCheck(this, CoreShaderManager);
            _defineProperty(this, "shCache", new Map());
            _defineProperty(this, "shConstructors", {});
            _defineProperty(this, "attachedShader", null);
            _defineProperty(this, "effectConstructors", {});
            _defineProperty(this, "renderer", void 0);
            this.registerShaderType('DefaultShader', DefaultShader);
            this.registerShaderType('DefaultShaderBatched', DefaultShaderBatched);
            this.registerShaderType('RoundedRectangle', RoundedRectangle);
            this.registerShaderType('DynamicShader', DynamicShader);
            this.registerShaderType('SdfShader', SdfShader);
            this.registerEffectType('border', BorderEffect);
            this.registerEffectType('borderBottom', BorderBottomEffect);
            this.registerEffectType('borderLeft', BorderLeftEffect);
            this.registerEffectType('borderRight', BorderRightEffect);
            this.registerEffectType('borderTop', BorderTopEffect);
            this.registerEffectType('fadeOut', FadeOutEffect);
            this.registerEffectType('linearGradient', LinearGradientEffect);
            this.registerEffectType('radialGradient', RadialGradientEffect);
            this.registerEffectType('grayscale', GrayscaleEffect);
            this.registerEffectType('glitch', GlitchEffect);
            this.registerEffectType('radius', RadiusEffect);
            this.registerEffectType('radialProgress', RadialProgressEffect);
            this.registerEffectType('holePunch', HolePunchEffect);
          }
          return _createClass(CoreShaderManager, [{
            key: "registerShaderType",
            value: function registerShaderType(shType, shClass) {
              this.shConstructors[shType] = shClass;
            }
          }, {
            key: "registerEffectType",
            value: function registerEffectType(effectType, effectClass) {
              this.effectConstructors[effectType] = effectClass;
            }
          }, {
            key: "getRegisteredEffects",
            value: function getRegisteredEffects() {
              return this.effectConstructors;
            }
          }, {
            key: "getRegisteredShaders",
            value: function getRegisteredShaders() {
              return this.shConstructors;
            }
            /**
             * Loads a shader (if not already loaded) and returns a controller for it.
             *
             * @param shType
             * @param props
             * @returns
             */
          }, {
            key: "loadShader",
            value: function loadShader(shType, props) {
              if (!this.renderer) {
                throw new Error("Renderer is not been defined");
              }
              var ShaderClass = this.shConstructors[shType];
              if (!ShaderClass) {
                throw new Error("Shader type \"".concat(shType, "\" is not registered"));
              }
              if (this.renderer.mode === 'canvas' && ShaderClass.prototype instanceof WebGlCoreShader) {
                return this._createShaderCtr(shType, new UnsupportedShader(shType), props);
              }
              if (shType === 'DynamicShader') {
                return this.loadDynamicShader(props);
              }
              var resolvedProps = ShaderClass.resolveDefaults(props);
              var cacheKey = ShaderClass.makeCacheKey(resolvedProps) || ShaderClass.name;
              if (cacheKey && this.shCache.has(cacheKey)) {
                return this._createShaderCtr(shType, this.shCache.get(cacheKey), resolvedProps);
              }
              // @ts-expect-error ShaderClass WILL accept a Renderer
              var shader = new ShaderClass(this.renderer, props);
              if (cacheKey) {
                this.shCache.set(cacheKey, shader);
              }
              return this._createShaderCtr(shType, shader, resolvedProps);
            }
          }, {
            key: "loadDynamicShader",
            value: function loadDynamicShader(props) {
              if (!this.renderer) {
                throw new Error("Renderer is not been defined");
              }
              var resolvedProps = DynamicShader.resolveDefaults(props, this.effectConstructors);
              var cacheKey = DynamicShader.makeCacheKey(resolvedProps, this.effectConstructors);
              if (cacheKey && this.shCache.has(cacheKey)) {
                return this._createDynShaderCtr(this.shCache.get(cacheKey), resolvedProps);
              }
              var shader = new DynamicShader(this.renderer, props, this.effectConstructors);
              if (cacheKey) {
                this.shCache.set(cacheKey, shader);
              }
              return this._createDynShaderCtr(shader, resolvedProps);
            }
          }, {
            key: "_createShaderCtr",
            value: function _createShaderCtr(type, shader, props) {
              return new ShaderController(type, shader, props, this.renderer.stage);
            }
          }, {
            key: "_createDynShaderCtr",
            value: function _createDynShaderCtr(shader, props) {
              shader.bindUniformMethods(props);
              return new DynamicShaderController(shader, props, this);
            }
          }, {
            key: "useShader",
            value: function useShader(shader) {
              if (this.attachedShader === shader) {
                return;
              }
              if (this.attachedShader) {
                this.attachedShader.detach();
              }
              shader.attach();
              this.attachedShader = shader;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var trPropSetterDefaults = {
          x: function x(state, value) {
            state.props.x = value;
          },
          y: function y(state, value) {
            state.props.y = value;
          },
          width: function width(state, value) {
            state.props.width = value;
          },
          height: function height(state, value) {
            state.props.height = value;
          },
          color: function color(state, value) {
            state.props.color = value;
          },
          zIndex: function zIndex(state, value) {
            state.props.zIndex = value;
          },
          fontFamily: function fontFamily(state, value) {
            state.props.fontFamily = value;
          },
          fontWeight: function fontWeight(state, value) {
            state.props.fontWeight = value;
          },
          fontStyle: function fontStyle(state, value) {
            state.props.fontStyle = value;
          },
          fontStretch: function fontStretch(state, value) {
            state.props.fontStretch = value;
          },
          fontSize: function fontSize(state, value) {
            state.props.fontSize = value;
          },
          text: function text(state, value) {
            state.props.text = value;
          },
          textAlign: function textAlign(state, value) {
            state.props.textAlign = value;
          },
          contain: function contain(state, value) {
            state.props.contain = value;
          },
          offsetY: function offsetY(state, value) {
            state.props.offsetY = value;
          },
          scrollable: function scrollable(state, value) {
            state.props.scrollable = value;
          },
          scrollY: function scrollY(state, value) {
            state.props.scrollY = value;
          },
          letterSpacing: function letterSpacing(state, value) {
            state.props.letterSpacing = value;
          },
          lineHeight: function lineHeight(state, value) {
            state.props.lineHeight = value;
          },
          maxLines: function maxLines(state, value) {
            state.props.maxLines = value;
          },
          textBaseline: function textBaseline(state, value) {
            state.props.textBaseline = value;
          },
          verticalAlign: function verticalAlign(state, value) {
            state.props.verticalAlign = value;
          },
          overflowSuffix: function overflowSuffix(state, value) {
            state.props.overflowSuffix = value;
          },
          debug: function debug(state, value) {
            state.props.debug = value;
          }
        };
        var TextRenderer = /*#__PURE__*/function () {
          function TextRenderer(stage) {
            var _this38 = this;
            _classCallCheck(this, TextRenderer);
            _defineProperty(this, "stage", void 0);
            _defineProperty(this, "set", void 0);
            this.stage = stage;
            var propSetters = _objectSpread(_objectSpread({}, trPropSetterDefaults), this.getPropertySetters());
            // For each prop setter add a wrapper method that checks if the prop is
            // different before calling the setter
            var propSet = {};
            Object.keys(propSetters).forEach(function (key) {
              Object.defineProperty(propSet, key, {
                value: function value(state, _value) {
                  // Check if the current prop value is different before calling the setter
                  if (state.props[key] !== _value) {
                    propSetters[key](state, _value);
                    // Assume any prop change will require a render
                    // This ensures that renders are triggered appropriately even with RAF paused
                    _this38.stage.requestRender();
                  }
                },
                writable: false,
                // Prevents property from being changed
                configurable: false // Prevents property from being deleted
              });
            });
            this.set = propSet;
          }
          return _createClass(TextRenderer, [{
            key: "setStatus",
            value: function setStatus(state, status, error) {
              // Don't emit the same status twice
              if (state.status === status) {
                return;
              }
              state.status = status;
              state.emitter.emit(status, error);
            }
            /**
             * Allows the CoreTextNode to communicate changes to the isRenderable state of
             * the itself.
             *
             * @param state
             * @param renderable
             */
          }, {
            key: "setIsRenderable",
            value: function setIsRenderable(state, renderable) {
              state.isRenderable = renderable;
            }
            /**
             * Destroy/Clean up the state object
             *
             * @remarks
             * Opposite of createState(). Frees any event listeners / resources held by
             * the state that may not reliably get garbage collected.
             *
             * @param state
             */
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              this.setStatus(state, 'destroyed');
              state.emitter.removeAllListeners();
            }
            /**
             * Schedule a state update via queueMicrotask
             *
             * @remarks
             * This method is used to schedule a state update via queueMicrotask. This
             * method should be called whenever a state update is needed, and it will
             * ensure that the state is only updated once per microtask.
             * @param state
             * @returns
             */
          }, {
            key: "scheduleUpdateState",
            value: function scheduleUpdateState(state) {
              var _this39 = this;
              if (state.updateScheduled) {
                return;
              }
              state.updateScheduled = true;
              queueMicrotask(function () {
                // If the state has been destroyed, don't update it
                if (state.status === 'destroyed') {
                  return;
                }
                state.updateScheduled = false;
                _this39.updateState(state);
              });
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Class that keeps track of the invocations of Context methods when
         * the `enableContextSpy` renderer option is enabled.
         */
        var ContextSpy = /*#__PURE__*/function () {
          function ContextSpy() {
            _classCallCheck(this, ContextSpy);
            _defineProperty(this, "data", {});
          }
          return _createClass(ContextSpy, [{
            key: "reset",
            value: function reset() {
              this.data = {};
            }
          }, {
            key: "increment",
            value: function increment(name) {
              if (!this.data[name]) {
                this.data[name] = 0;
              }
              this.data[name]++;
            }
          }, {
            key: "getData",
            value: function getData() {
              return _objectSpread({}, this.data);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2024 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * LRU (Least Recently Used) style memory manager for textures
         *
         * @remarks
         * This class is responsible for managing the memory usage of textures
         * in the Renderer. It keeps track of the memory used by each texture
         * and triggers a cleanup when the memory usage exceeds a critical
         * threshold (`criticalThreshold`).
         *
         * The cleanup process will free up non-renderable textures until the
         * memory usage is below a target threshold (`targetThresholdLevel`).
         *
         * The memory manager's clean up process will also be triggered when the
         * scene is idle for a certain amount of time (`cleanupInterval`).
         */
        var TextureMemoryManager = /*#__PURE__*/function () {
          function TextureMemoryManager(stage, settings) {
            var _this40 = this;
            _classCallCheck(this, TextureMemoryManager);
            _defineProperty(this, "stage", void 0);
            _defineProperty(this, "memUsed", 0);
            _defineProperty(this, "loadedTextures", []);
            _defineProperty(this, "criticalThreshold", void 0);
            _defineProperty(this, "targetThreshold", void 0);
            _defineProperty(this, "cleanupInterval", void 0);
            _defineProperty(this, "debugLogging", void 0);
            _defineProperty(this, "lastCleanupTime", 0);
            _defineProperty(this, "baselineMemoryAllocation", void 0);
            _defineProperty(this, "hasWarnedAboveCritical", false);
            _defineProperty(this, "criticalCleanupRequested", false);
            _defineProperty(this, "doNotExceedCriticalThreshold", void 0);
            /**
             * The current frame time in milliseconds
             *
             * @remarks
             * This is used to determine when to perform Idle Texture Cleanups.
             *
             * Set by stage via `updateFrameTime` method.
             */
            _defineProperty(this, "frameTime", 0);
            this.stage = stage;
            var criticalThreshold = settings.criticalThreshold,
              doNotExceedCriticalThreshold = settings.doNotExceedCriticalThreshold;
            this.doNotExceedCriticalThreshold = doNotExceedCriticalThreshold || false;
            this.criticalThreshold = Math.round(criticalThreshold);
            var targetFraction = Math.max(0, Math.min(1, settings.targetThresholdLevel));
            this.cleanupInterval = settings.cleanupInterval;
            this.debugLogging = settings.debugLogging;
            this.baselineMemoryAllocation = Math.round(settings.baselineMemoryAllocation);
            this.targetThreshold = Math.max(Math.round(criticalThreshold * targetFraction), this.baselineMemoryAllocation);
            this.memUsed = Math.round(settings.baselineMemoryAllocation);
            if (settings.debugLogging) {
              var lastMemUse = 0;
              setInterval(function () {
                if (lastMemUse !== _this40.memUsed) {
                  lastMemUse = _this40.memUsed;
                  console.log("[TextureMemoryManager] Memory used: ".concat(bytesToMb$1(_this40.memUsed), " mb / ").concat(bytesToMb$1(_this40.criticalThreshold), " mb (").concat((_this40.memUsed / _this40.criticalThreshold * 100).toFixed(1), "%)"));
                }
              }, 1000);
            }
            // If the threshold is 0, we disable the memory manager by replacing the
            // setTextureMemUse method with a no-op function.
            if (criticalThreshold === 0) {
              this.setTextureMemUse = function () {};
            }
          }
          /**
           * Set the memory usage of a texture
           *
           * @param texture - The texture to set memory usage for
           * @param byteSize - The size of the texture in bytes
           */
          return _createClass(TextureMemoryManager, [{
            key: "setTextureMemUse",
            value: function setTextureMemUse(texture, byteSize) {
              // Update global memory counter by subtracting old value
              this.memUsed -= texture.memUsed;
              if (byteSize === 0) {
                // PERFORMANCE: Mark for deletion, slot will be reused later
                var index = this.loadedTextures.indexOf(texture);
                if (index !== -1) {
                  this.loadedTextures[index] = null;
                }
                texture.memUsed = 0;
                return;
              } else {
                // Update texture memory and add to tracking if not already present
                texture.memUsed = byteSize;
                this.memUsed += byteSize;
                if (this.loadedTextures.indexOf(texture) === -1) {
                  // PERFORMANCE: Reuse empty slots before appending
                  var emptyIndex = this.loadedTextures.indexOf(null);
                  if (emptyIndex !== -1) {
                    this.loadedTextures[emptyIndex] = texture;
                  } else {
                    this.loadedTextures.push(texture);
                  }
                }
              }
              if (this.memUsed > this.criticalThreshold) {
                this.criticalCleanupRequested = true;
              }
            }
          }, {
            key: "checkCleanup",
            value: function checkCleanup() {
              return this.criticalCleanupRequested || this.memUsed > this.targetThreshold && this.frameTime - this.lastCleanupTime >= this.cleanupInterval;
            }
          }, {
            key: "checkCriticalCleanup",
            value: function checkCriticalCleanup() {
              return this.memUsed > this.criticalThreshold;
            }
            /**
             * Destroy a texture and null out its array position
             *
             * @param texture - The texture to destroy
             */
          }, {
            key: "destroyTexture",
            value: function destroyTexture(texture) {
              if (this.debugLogging === true) {
                console.log("[TextureMemoryManager] Destroying texture. State: ".concat(texture.state));
              }
              // PERFORMANCE: Null out array position, slot will be reused later
              var index = this.loadedTextures.indexOf(texture);
              if (index !== -1) {
                this.loadedTextures[index] = null;
              }
              // Destroy texture and update memory counters
              var txManager = this.stage.txManager;
              txManager.removeTextureFromCache(texture);
              texture.destroy();
              // Update memory counters
              this.memUsed -= texture.memUsed;
              texture.memUsed = 0;
            }
          }, {
            key: "cleanup",
            value: function cleanup() {
              var critical = this.criticalCleanupRequested;
              this.lastCleanupTime = this.frameTime;
              if (critical === true) {
                this.stage.queueFrameEvent('criticalCleanup', {
                  memUsed: this.memUsed,
                  criticalThreshold: this.criticalThreshold
                });
              }
              if (this.debugLogging === true) {
                console.log("[TextureMemoryManager] Cleaning up textures. Critical: ".concat(critical, "."));
              }
              // Free non-renderable textures until we reach the target threshold
              var memTarget = critical ? this.criticalThreshold : this.targetThreshold;
              // PERFORMANCE: Zero-overhead cleanup with null marking
              // Skip null entries, mark cleaned textures as null for later defrag
              var currentMemUsed = this.memUsed;
              for (var i = 0; i < this.loadedTextures.length; i++) {
                // Early exit: target memory reached
                if (currentMemUsed < memTarget) {
                  break;
                }
                var texture = this.loadedTextures[i];
                if (!texture) continue; // Skip null entries from previous deletions
                // Fast type check for cleanable textures
                var isCleanableType = texture.type === TextureType.image || texture.type === TextureType.noise || texture.type === TextureType.renderToTexture;
                // Immediate cleanup if eligible
                if (isCleanableType && texture.canBeCleanedUp() === true) {
                  // Get memory before destroying
                  var textureMemory = texture.memUsed;
                  // Destroy texture (which will null out the array position)
                  this.destroyTexture(texture);
                  currentMemUsed -= textureMemory;
                }
              }
              if (this.memUsed >= this.criticalThreshold) {
                this.stage.queueFrameEvent('criticalCleanupFailed', {
                  memUsed: this.memUsed,
                  criticalThreshold: this.criticalThreshold
                });
                // Only emit the warning once per over-threshold period
                if (!this.hasWarnedAboveCritical && (this.debugLogging === true || isProductionEnvironment === false)) {
                  console.warn("[TextureMemoryManager] Memory usage above critical threshold after cleanup: ".concat(this.memUsed));
                  this.hasWarnedAboveCritical = true;
                }
              } else {
                this.criticalCleanupRequested = false;
                this.hasWarnedAboveCritical = false;
              }
            }
            /**
             * Get the current texture memory usage information
             *
             * @remarks
             * This method is for debugging purposes and returns information about the
             * current memory usage of the textures in the Renderer.
             */
          }, {
            key: "getMemoryInfo",
            value: function getMemoryInfo() {
              var renderableTexturesLoaded = 0;
              var renderableMemUsed = this.baselineMemoryAllocation;
              var _iterator0 = _createForOfIteratorHelper(this.loadedTextures),
                _step0;
              try {
                for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
                  var texture = _step0.value;
                  if (texture && texture.renderable) {
                    renderableTexturesLoaded += 1;
                    renderableMemUsed += texture.memUsed;
                  }
                }
                // Count non-null entries for accurate loaded texture count
              } catch (err) {
                _iterator0.e(err);
              } finally {
                _iterator0.f();
              }
              var actualLoadedTextures = this.loadedTextures.filter(function (t) {
                return t !== null;
              }).length;
              return {
                criticalThreshold: this.criticalThreshold,
                targetThreshold: this.targetThreshold,
                renderableMemUsed: renderableMemUsed,
                memUsed: this.memUsed,
                renderableTexturesLoaded: renderableTexturesLoaded,
                loadedTextures: actualLoadedTextures,
                baselineMemoryAllocation: this.baselineMemoryAllocation
              };
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreContextTexture = /*#__PURE__*/function () {
          function CoreContextTexture(memManager, textureSource) {
            _classCallCheck(this, CoreContextTexture);
            _defineProperty(this, "textureSource", void 0);
            _defineProperty(this, "memManager", void 0);
            _defineProperty(this, "state", 'freed');
            this.memManager = memManager;
            this.textureSource = textureSource;
          }
          return _createClass(CoreContextTexture, [{
            key: "setTextureMemUse",
            value: function setTextureMemUse(byteSize) {
              this.memManager.setTextureMemUse(this.textureSource, byteSize);
            }
          }, {
            key: "renderable",
            get: function get() {
              return this.textureSource.renderable;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreRenderer = /*#__PURE__*/_createClass(function CoreRenderer(options) {
          _classCallCheck(this, CoreRenderer);
          _defineProperty(this, "options", void 0);
          _defineProperty(this, "mode", void 0);
          _defineProperty(this, "stage", void 0);
          //// Core Managers
          _defineProperty(this, "txManager", void 0);
          _defineProperty(this, "txMemManager", void 0);
          _defineProperty(this, "shManager", void 0);
          _defineProperty(this, "rttNodes", []);
          this.options = options;
          this.stage = options.stage;
          this.txManager = options.txManager;
          this.txMemManager = options.txMemManager;
          this.shManager = options.shManager;
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * An CoreNode in the Renderer scene graph that renders text.
         *
         * @remarks
         * A Text Node is the second graphical building block of the Renderer scene
         * graph. It renders text using a specific text renderer that is automatically
         * chosen based on the font requested and what type of fonts are installed
         * into an app.
         *
         * The text renderer can be overridden by setting the `textRendererOverride`
         *
         * The `texture` and `shader` properties are managed by loaded text renderer and
         * should not be set directly.
         *
         * For non-text rendering, see {@link CoreNode}.
         */
        var CoreTextNode = /*#__PURE__*/function (_CoreNode2) {
          function CoreTextNode(stage, props, textRenderer) {
            var _this41;
            _classCallCheck(this, CoreTextNode);
            _this41 = _callSuper(this, CoreTextNode, [stage, props]);
            _defineProperty(_this41, "textRenderer", void 0);
            _defineProperty(_this41, "trState", void 0);
            _defineProperty(_this41, "_textRendererOverride", null);
            _defineProperty(_this41, "onTextLoaded", function () {
              var _this42 = _this41,
                contain = _this42.contain;
              var setWidth = _this41.trState.props.width;
              var setHeight = _this41.trState.props.height;
              var calcWidth = _this41.trState.textW || 0;
              var calcHeight = _this41.trState.textH || 0;
              if (contain === 'both') {
                _this41.props.width = setWidth;
                _this41.props.height = setHeight;
              } else if (contain === 'width') {
                _this41.props.width = setWidth;
                _this41.props.height = calcHeight;
              } else if (contain === 'none') {
                _this41.props.width = calcWidth;
                _this41.props.height = calcHeight;
              }
              _this41.updateLocalTransform();
              // Incase the RAF loop has been stopped already before text was loaded,
              // we request a render so it can be drawn.
              _this41.stage.requestRender();
              _this41.emit('loaded', {
                type: 'text',
                dimensions: {
                  width: _this41.trState.textW || 0,
                  height: _this41.trState.textH || 0
                }
              });
            });
            _defineProperty(_this41, "onTextFailed", function (target, error) {
              _this41.emit('failed', {
                type: 'text',
                error: error
              });
            });
            _this41._textRendererOverride = props.textRendererOverride;
            _this41.textRenderer = textRenderer;
            var textRendererState = _this41.createState({
              x: 0,
              y: 0,
              width: props.width,
              height: props.height,
              textAlign: props.textAlign,
              color: props.color,
              zIndex: props.zIndex,
              contain: props.contain,
              scrollable: props.scrollable,
              scrollY: props.scrollY,
              offsetY: props.offsetY,
              letterSpacing: props.letterSpacing,
              debug: props.debug,
              fontFamily: props.fontFamily,
              fontSize: props.fontSize,
              fontStretch: props.fontStretch,
              fontStyle: props.fontStyle,
              fontWeight: props.fontWeight,
              text: props.text,
              lineHeight: props.lineHeight,
              maxLines: props.maxLines,
              textBaseline: props.textBaseline,
              verticalAlign: props.verticalAlign,
              overflowSuffix: props.overflowSuffix
            });
            _this41.trState = textRendererState;
            return _this41;
          }
          _inherits(CoreTextNode, _CoreNode2);
          return _createClass(CoreTextNode, [{
            key: "width",
            get: function get() {
              return this.props.width;
            },
            set: function set(value) {
              this.props.width = value;
              this.textRenderer.set.width(this.trState, value);
              // If not containing, we must update the local transform to account for the
              // new width
              if (this.contain === 'none') {
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "height",
            get: function get() {
              return this.props.height;
            },
            set: function set(value) {
              this.props.height = value;
              this.textRenderer.set.height(this.trState, value);
              // If not containing in the horizontal direction, we must update the local
              // transform to account for the new height
              if (this.contain !== 'both') {
                this.setUpdateType(UpdateType.Local);
              }
            }
          }, {
            key: "color",
            get: function get() {
              return this.trState.props.color;
            },
            set: function set(value) {
              this.textRenderer.set.color(this.trState, value);
            }
          }, {
            key: "text",
            get: function get() {
              return this.trState.props.text;
            },
            set: function set(value) {
              this.textRenderer.set.text(this.trState, value);
            }
          }, {
            key: "textRendererOverride",
            get: function get() {
              return this._textRendererOverride;
            },
            set: function set(value) {
              this._textRendererOverride = value;
              this.textRenderer.destroyState(this.trState);
              var textRenderer = this.stage.resolveTextRenderer(this.trState.props, this._textRendererOverride);
              if (!textRenderer) {
                console.warn('Text Renderer not found for font', this.trState.props.fontFamily);
                return;
              }
              this.textRenderer = textRenderer;
              this.trState = this.createState(this.trState.props);
            }
          }, {
            key: "fontSize",
            get: function get() {
              return this.trState.props.fontSize;
            },
            set: function set(value) {
              this.textRenderer.set.fontSize(this.trState, value);
            }
          }, {
            key: "fontFamily",
            get: function get() {
              return this.trState.props.fontFamily;
            },
            set: function set(value) {
              this.textRenderer.set.fontFamily(this.trState, value);
            }
          }, {
            key: "fontStretch",
            get: function get() {
              return this.trState.props.fontStretch;
            },
            set: function set(value) {
              this.textRenderer.set.fontStretch(this.trState, value);
            }
          }, {
            key: "fontStyle",
            get: function get() {
              return this.trState.props.fontStyle;
            },
            set: function set(value) {
              this.textRenderer.set.fontStyle(this.trState, value);
            }
          }, {
            key: "fontWeight",
            get: function get() {
              return this.trState.props.fontWeight;
            },
            set: function set(value) {
              this.textRenderer.set.fontWeight(this.trState, value);
            }
          }, {
            key: "textAlign",
            get: function get() {
              return this.trState.props.textAlign;
            },
            set: function set(value) {
              this.textRenderer.set.textAlign(this.trState, value);
            }
          }, {
            key: "contain",
            get: function get() {
              return this.trState.props.contain;
            },
            set: function set(value) {
              this.textRenderer.set.contain(this.trState, value);
            }
          }, {
            key: "scrollable",
            get: function get() {
              return this.trState.props.scrollable;
            },
            set: function set(value) {
              this.textRenderer.set.scrollable(this.trState, value);
            }
          }, {
            key: "scrollY",
            get: function get() {
              return this.trState.props.scrollY;
            },
            set: function set(value) {
              this.textRenderer.set.scrollY(this.trState, value);
            }
          }, {
            key: "offsetY",
            get: function get() {
              return this.trState.props.offsetY;
            },
            set: function set(value) {
              this.textRenderer.set.offsetY(this.trState, value);
            }
          }, {
            key: "letterSpacing",
            get: function get() {
              return this.trState.props.letterSpacing;
            },
            set: function set(value) {
              this.textRenderer.set.letterSpacing(this.trState, value);
            }
          }, {
            key: "lineHeight",
            get: function get() {
              return this.trState.props.lineHeight;
            },
            set: function set(value) {
              this.textRenderer.set.lineHeight(this.trState, value);
            }
          }, {
            key: "maxLines",
            get: function get() {
              return this.trState.props.maxLines;
            },
            set: function set(value) {
              this.textRenderer.set.maxLines(this.trState, value);
            }
          }, {
            key: "textBaseline",
            get: function get() {
              return this.trState.props.textBaseline;
            },
            set: function set(value) {
              this.textRenderer.set.textBaseline(this.trState, value);
            }
          }, {
            key: "verticalAlign",
            get: function get() {
              return this.trState.props.verticalAlign;
            },
            set: function set(value) {
              this.textRenderer.set.verticalAlign(this.trState, value);
            }
          }, {
            key: "overflowSuffix",
            get: function get() {
              return this.trState.props.overflowSuffix;
            },
            set: function set(value) {
              this.textRenderer.set.overflowSuffix(this.trState, value);
            }
          }, {
            key: "debug",
            get: function get() {
              return this.trState.props.debug;
            },
            set: function set(value) {
              this.textRenderer.set.debug(this.trState, value);
            }
          }, {
            key: "update",
            value: function update(delta, parentClippingRect) {
              _superPropGet(CoreTextNode, "update", this, 3)([delta, parentClippingRect]);
              assertTruthy(this.globalTransform);
              // globalTransform is updated in super.update(delta)
              this.textRenderer.set.x(this.trState, this.globalTransform.tx);
              this.textRenderer.set.y(this.trState, this.globalTransform.ty);
            }
          }, {
            key: "checkBasicRenderability",
            value: function checkBasicRenderability() {
              if (this.worldAlpha === 0 || this.isOutOfBounds() === true) {
                return false;
              }
              if (this.trState && this.trState.props.text !== '') {
                return true;
              }
              return false;
            }
          }, {
            key: "setRenderable",
            value: function setRenderable(isRenderable) {
              _superPropGet(CoreTextNode, "setRenderable", this, 3)([isRenderable]);
              this.textRenderer.setIsRenderable(this.trState, isRenderable);
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(renderer) {
              var _this$props$parent4;
              assertTruthy(this.globalTransform);
              // If the text renderer does not support rendering quads, fallback to the
              // default renderQuads method
              if (!this.textRenderer.renderQuads) {
                _superPropGet(CoreTextNode, "renderQuads", this, 3)([renderer]);
                return;
              }
              // If the text renderer does support rendering quads, use it...
              // Prevent quad rendering if parent has a render texture
              // and this node is not the render texture
              if (this.parentHasRenderTexture) {
                if (!renderer.renderToTextureActive) {
                  return;
                }
                // Prevent quad rendering if parent render texture is not the active render texture
                if (this.parentRenderTexture !== renderer.activeRttNode) {
                  return;
                }
              }
              if (this.parentHasRenderTexture && (_this$props$parent4 = this.props.parent) !== null && _this$props$parent4 !== void 0 && _this$props$parent4.rtt) {
                this.globalTransform = Matrix3d.identity();
                if (this.localTransform) {
                  this.globalTransform.multiply(this.localTransform);
                }
              }
              assertTruthy(this.globalTransform);
              this.textRenderer.renderQuads(this.trState, this.globalTransform, this.clippingRect, this.worldAlpha, this.parentHasRenderTexture, this.framebufferDimensions);
            }
            /**
             * Destroy the node and cleanup all resources
             */
          }, {
            key: "destroy",
            value: function destroy() {
              _superPropGet(CoreTextNode, "destroy", this, 3)([]);
              this.textRenderer.destroyState(this.trState);
            }
            /**
             * Resolve a text renderer and a new state based on the current text renderer props provided
             * @param props
             * @returns
             */
          }, {
            key: "createState",
            value: function createState(props) {
              var textRendererState = this.textRenderer.createState(props, this);
              textRendererState.emitter.on('loaded', this.onTextLoaded);
              textRendererState.emitter.on('failed', this.onTextFailed);
              this.textRenderer.scheduleUpdateState(textRendererState);
              return textRendererState;
            }
          }]);
        }(CoreNode);
        function santizeCustomDataMap(d) {
          var validTypes = {
            boolean: true,
            string: true,
            number: true,
            undefined: true
          };
          var keys = Object.keys(d);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!key) {
              continue;
            }
            var value = d[key];
            var valueType = _typeof(value);
            // Typescript doesn't understand the above const valueType ¯\_(ツ)_/¯
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore-next-line
            if (valueType === 'string' && value.length > 2048) {
              console.warn("Custom Data value for ".concat(key, " is too long, it will be truncated to 2048 characters"));
              // same here, see above comment, this can only be a string at this point
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-ignore-next-line
              // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call
              d[key] = value.substring(0, 2048);
            }
            if (!validTypes[valueType]) {
              console.warn("Custom Data value for ".concat(key, " is not a boolean, string, or number, it will be ignored"));
              delete d[key];
            }
          }
          return d;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var bufferMemory = 2e6;
        var Stage = /*#__PURE__*/function () {
          /**
           * Stage constructor
           */
          function Stage(options) {
            var _this43 = this;
            _classCallCheck(this, Stage);
            _defineProperty(this, "options", void 0);
            /// Module Instances
            _defineProperty(this, "animationManager", void 0);
            _defineProperty(this, "txManager", void 0);
            _defineProperty(this, "txMemManager", void 0);
            _defineProperty(this, "fontManager", void 0);
            _defineProperty(this, "textRenderers", void 0);
            _defineProperty(this, "shManager", void 0);
            _defineProperty(this, "renderer", void 0);
            _defineProperty(this, "root", void 0);
            _defineProperty(this, "interactiveNodes", new Set());
            _defineProperty(this, "boundsMargin", void 0);
            _defineProperty(this, "defShaderCtr", void 0);
            _defineProperty(this, "strictBound", void 0);
            _defineProperty(this, "preloadBound", void 0);
            _defineProperty(this, "strictBounds", void 0);
            _defineProperty(this, "defaultTexture", null);
            /**
             * Target frame time in milliseconds (calculated from targetFPS)
             *
             * @remarks
             * This is pre-calculated to avoid recalculating on every frame.
             * - 0 means no throttling (use display refresh rate)
             * - >0 means throttle to this frame time (1000 / targetFPS)
             */
            _defineProperty(this, "targetFrameTime", 0);
            /**
             * Renderer Event Bus for the Stage to emit events onto
             *
             * @remarks
             * In reality this is just the RendererMain instance, which is an EventEmitter.
             * this allows us to directly emit events from the Stage to RendererMain
             * without having to set up forwarding handlers.
             */
            _defineProperty(this, "eventBus", void 0);
            /// State
            _defineProperty(this, "deltaTime", 0);
            _defineProperty(this, "lastFrameTime", 0);
            _defineProperty(this, "currentFrameTime", 0);
            _defineProperty(this, "fpsNumFrames", 0);
            _defineProperty(this, "fpsElapsedTime", 0);
            _defineProperty(this, "numQuadsRendered", 0);
            _defineProperty(this, "renderRequested", false);
            _defineProperty(this, "frameEventQueue", []);
            _defineProperty(this, "fontResolveMap", {});
            /// Debug data
            _defineProperty(this, "contextSpy", null);
            this.options = options;
            var canvas = options.canvas,
              clearColor = options.clearColor,
              appWidth = options.appWidth,
              appHeight = options.appHeight,
              boundsMargin = options.boundsMargin,
              enableContextSpy = options.enableContextSpy,
              forceWebGL2 = options.forceWebGL2,
              numImageWorkers = options.numImageWorkers,
              textureMemory = options.textureMemory,
              renderEngine = options.renderEngine,
              fontEngines = options.fontEngines,
              createImageBitmapSupport = options.createImageBitmapSupport,
              maxRetryCount = options.maxRetryCount;
            this.eventBus = options.eventBus;
            // Calculate target frame time from targetFPS option
            this.targetFrameTime = options.targetFPS > 0 ? 1000 / options.targetFPS : 0;
            this.txManager = new CoreTextureManager(this, {
              numImageWorkers: numImageWorkers,
              createImageBitmapSupport: createImageBitmapSupport,
              maxRetryCount: maxRetryCount
            });
            // Wait for the Texture Manager to initialize
            // once it does, request a render
            this.txManager.on('initialized', function () {
              _this43.requestRender();
            });
            this.txMemManager = new TextureMemoryManager(this, textureMemory);
            this.shManager = new CoreShaderManager();
            this.animationManager = new AnimationManager();
            this.contextSpy = enableContextSpy ? new ContextSpy() : null;
            this.strictBounds = options.strictBounds;
            var bm = [0, 0, 0, 0];
            if (boundsMargin) {
              bm = Array.isArray(boundsMargin) ? boundsMargin : [boundsMargin, boundsMargin, boundsMargin, boundsMargin];
            }
            this.boundsMargin = bm;
            // precalculate our viewport bounds
            this.strictBound = createBound(0, 0, appWidth, appHeight);
            this.preloadBound = createPreloadBounds(this.strictBound, bm);
            var rendererOptions = {
              stage: this,
              canvas: canvas,
              pixelRatio: options.devicePhysicalPixelRatio * options.deviceLogicalPixelRatio,
              clearColor: clearColor !== null && clearColor !== void 0 ? clearColor : 0xff000000,
              bufferMemory: bufferMemory,
              txManager: this.txManager,
              txMemManager: this.txMemManager,
              shManager: this.shManager,
              contextSpy: this.contextSpy,
              forceWebGL2: forceWebGL2
            };
            this.renderer = new renderEngine(rendererOptions);
            var renderMode = this.renderer.mode || 'webgl';
            this.createDefaultTexture();
            this.defShaderCtr = this.renderer.getDefShaderCtr();
            setPremultiplyMode(renderMode);
            // Must do this after renderer is created
            this.txManager.renderer = this.renderer;
            // Create text renderers
            this.textRenderers = {};
            fontEngines.forEach(function (fontEngineConstructor) {
              var fontEngineInstance = new fontEngineConstructor(_this43);
              var className = fontEngineInstance.type;
              if (className === 'sdf' && renderMode === 'canvas') {
                console.warn('SdfTextRenderer is not compatible with Canvas renderer. Skipping...');
                return;
              }
              if (fontEngineInstance instanceof TextRenderer) {
                if (className === 'canvas') {
                  _this43.textRenderers['canvas'] = fontEngineInstance;
                } else if (className === 'sdf') {
                  _this43.textRenderers['sdf'] = fontEngineInstance;
                }
              }
            });
            if (Object.keys(this.textRenderers).length === 0) {
              console.warn('No text renderers available. Your text will not render.');
            }
            this.fontManager = new TrFontManager(this.textRenderers);
            // create root node
            var rootNode = new CoreNode(this, {
              x: 0,
              y: 0,
              width: appWidth,
              height: appHeight,
              alpha: 1,
              autosize: false,
              boundsMargin: null,
              clipping: false,
              color: 0x00000000,
              colorTop: 0x00000000,
              colorBottom: 0x00000000,
              colorLeft: 0x00000000,
              colorRight: 0x00000000,
              colorTl: 0x00000000,
              colorTr: 0x00000000,
              colorBl: 0x00000000,
              colorBr: 0x00000000,
              zIndex: 0,
              zIndexLocked: 0,
              scaleX: 1,
              scaleY: 1,
              mountX: 0,
              mountY: 0,
              mount: 0,
              pivot: 0.5,
              pivotX: 0.5,
              pivotY: 0.5,
              rotation: 0,
              parent: null,
              texture: null,
              textureOptions: {},
              shader: this.defShaderCtr,
              rtt: false,
              src: null,
              scale: 1,
              preventCleanup: false,
              strictBounds: this.strictBounds
            });
            this.root = rootNode;
            // execute platform start loop
            {
              startLoop(this);
            }
          }
          return _createClass(Stage, [{
            key: "setClearColor",
            value: function setClearColor(color) {
              this.renderer.updateClearColor(color);
              this.renderRequested = true;
            }
            /**
             * Update the target frame time based on the current targetFPS setting
             *
             * @remarks
             * This should be called whenever the targetFPS option is changed
             * to ensure targetFrameTime stays in sync.
             * targetFPS of 0 means no throttling (targetFrameTime = 0)
             * targetFPS > 0 means throttle to 1000/targetFPS milliseconds
             */
          }, {
            key: "updateTargetFrameTime",
            value: function updateTargetFrameTime() {
              this.targetFrameTime = this.options.targetFPS > 0 ? 1000 / this.options.targetFPS : 0;
            }
          }, {
            key: "updateFrameTime",
            value: function updateFrameTime() {
              var newFrameTime = getTimeStamp();
              this.lastFrameTime = this.currentFrameTime;
              this.currentFrameTime = newFrameTime;
              this.deltaTime = !this.lastFrameTime ? 100 / 6 : newFrameTime - this.lastFrameTime;
              this.txManager.frameTime = newFrameTime;
              this.txMemManager.frameTime = newFrameTime;
              // This event is emitted at the beginning of the frame (before any updates
              // or rendering), so no need to to use `stage.queueFrameEvent` here.
              this.eventBus.emit('frameTick', {
                time: this.currentFrameTime,
                delta: this.deltaTime
              });
            }
            /**
             * Create default PixelTexture
             */
          }, {
            key: "createDefaultTexture",
            value: function createDefaultTexture() {
              var _this44 = this;
              this.defaultTexture = this.txManager.createTexture('ColorTexture', {
                color: 0xffffffff
              });
              assertTruthy(this.defaultTexture instanceof ColorTexture);
              this.txManager.loadTexture(this.defaultTexture, true);
              // Mark the default texture as ALWAYS renderable
              // This prevents it from ever being cleaned up.
              // Fixes https://github.com/lightning-js/renderer/issues/262
              this.defaultTexture.setRenderableOwner('stage', true);
              // When the default texture is loaded, request a render in case the
              // RAF is paused. Fixes: https://github.com/lightning-js/renderer/issues/123
              this.defaultTexture.once('loaded', function () {
                _this44.requestRender();
              });
            }
            /**
             * Update animations
             */
          }, {
            key: "updateAnimations",
            value: function updateAnimations() {
              var animationManager = this.animationManager;
              if (!this.root) {
                return;
              }
              // step animation
              animationManager.update(this.deltaTime);
            }
            /**
             * Check if the scene has updates
             */
          }, {
            key: "hasSceneUpdates",
            value: function hasSceneUpdates() {
              return !!this.root.updateType || this.renderRequested || this.txManager.hasUpdates();
            }
            /**
             * Start a new frame draw
             */
          }, {
            key: "drawFrame",
            value: function drawFrame() {
              var renderer = this.renderer,
                renderRequested = this.renderRequested;
              // Update tree if needed
              if (this.root.updateType !== 0) {
                this.root.update(this.deltaTime, this.root.clippingRect);
              }
              // Process some textures asynchronously but don't block the frame
              // Use a background task to prevent frame drops
              this.txManager.processSome(this.options.textureProcessingTimeLimit).catch(function (err) {
                console.error('Error processing textures:', err);
              });
              // Reset render operations and clear the canvas
              renderer.reset();
              // If we have RTT nodes draw them first
              // So we can use them as textures in the main scene
              if (renderer.rttNodes.length > 0) {
                renderer.renderRTTNodes();
              }
              // Fill quads buffer
              this.addQuads(this.root);
              // Perform render pass
              renderer === null || renderer === void 0 || renderer.render();
              this.calculateFps();
              this.calculateQuads();
              // Reset renderRequested flag if it was set
              if (renderRequested) {
                this.renderRequested = false;
              }
              // Check if we need to cleanup textures
              if (this.txMemManager.criticalCleanupRequested === true) {
                this.txMemManager.cleanup();
              }
            }
            /**
             * Queue an event to be emitted after the current/next frame is rendered
             *
             * @remarks
             * When we are operating in the context of the render loop, we may want to
             * emit events that are related to the current frame. However, we generally do
             * NOT want to emit events directly in the middle of the render loop, since
             * this could enable event handlers to modify the scene graph and cause
             * unexpected behavior. Instead, we queue up events to be emitted and then
             * flush the queue after the frame has been rendered.
             *
             * @param name
             * @param data
             */
          }, {
            key: "queueFrameEvent",
            value: function queueFrameEvent(name, data) {
              this.frameEventQueue.push([name, data]);
            }
            /**
             * Emit all queued frame events
             *
             * @remarks
             * This method should be called after the frame has been rendered to emit
             * all events that were queued during the frame.
             *
             * See {@link queueFrameEvent} for more information.
             */
          }, {
            key: "flushFrameEvents",
            value: function flushFrameEvents() {
              var _iterator1 = _createForOfIteratorHelper(this.frameEventQueue),
                _step1;
              try {
                for (_iterator1.s(); !(_step1 = _iterator1.n()).done;) {
                  var _step1$value = _slicedToArray(_step1.value, 2),
                    name = _step1$value[0],
                    data = _step1$value[1];
                  this.eventBus.emit(name, data);
                }
              } catch (err) {
                _iterator1.e(err);
              } finally {
                _iterator1.f();
              }
              this.frameEventQueue = [];
            }
          }, {
            key: "calculateFps",
            value: function calculateFps() {
              // If there's an FPS update interval, emit the FPS update event
              // when the specified interval has elapsed.
              var fpsUpdateInterval = this.options.fpsUpdateInterval;
              if (fpsUpdateInterval) {
                this.fpsNumFrames++;
                this.fpsElapsedTime += this.deltaTime;
                if (this.fpsElapsedTime >= fpsUpdateInterval) {
                  var _this$contextSpy$getD, _this$contextSpy, _this$contextSpy2;
                  var _fps = Math.round(this.fpsNumFrames * 1000 / this.fpsElapsedTime);
                  this.fpsNumFrames = 0;
                  this.fpsElapsedTime = 0;
                  this.queueFrameEvent('fpsUpdate', {
                    fps: _fps,
                    contextSpyData: (_this$contextSpy$getD = (_this$contextSpy = this.contextSpy) === null || _this$contextSpy === void 0 ? void 0 : _this$contextSpy.getData()) !== null && _this$contextSpy$getD !== void 0 ? _this$contextSpy$getD : null
                  });
                  (_this$contextSpy2 = this.contextSpy) === null || _this$contextSpy2 === void 0 || _this$contextSpy2.reset();
                }
              }
            }
          }, {
            key: "calculateQuads",
            value: function calculateQuads() {
              var quads = this.renderer.getQuadCount();
              if (quads && quads !== this.numQuadsRendered) {
                this.numQuadsRendered = quads;
                this.queueFrameEvent('quadsUpdate', {
                  quads: quads
                });
              }
            }
          }, {
            key: "addQuads",
            value: function addQuads(node) {
              assertTruthy(this.renderer);
              // If the node is renderable and has a loaded texture, render it
              if (node.isRenderable === true) {
                node.renderQuads(this.renderer);
              }
              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                if (child === undefined) {
                  continue;
                }
                if (child.worldAlpha === 0 || child.strictBounds === true && child.renderState === CoreNodeRenderState.OutOfBounds) {
                  continue;
                }
                this.addQuads(child);
              }
            }
            /**
             * Request a render pass without forcing an update
             */
          }, {
            key: "requestRender",
            value: function requestRender() {
              this.renderRequested = true;
            }
            /**
             * Find all nodes at a given point
             * @param data
             */
          }, {
            key: "findNodesAtPoint",
            value: function findNodesAtPoint(data) {
              var x = data.x / this.options.deviceLogicalPixelRatio;
              var y = data.y / this.options.deviceLogicalPixelRatio;
              var nodes = [];
              var _iterator10 = _createForOfIteratorHelper(this.interactiveNodes),
                _step10;
              try {
                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                  var node = _step10.value;
                  if (node.isRenderable === false) {
                    continue;
                  }
                  if (pointInBound(x, y, node.renderBound) === true) {
                    nodes.push(node);
                  }
                }
              } catch (err) {
                _iterator10.e(err);
              } finally {
                _iterator10.f();
              }
              return nodes;
            }
            /**
             * Find the top node at a given point
             * @param data
             * @returns
             */
          }, {
            key: "getNodeFromPosition",
            value: function getNodeFromPosition(data) {
              var nodes = this.findNodesAtPoint(data);
              if (nodes.length === 0) {
                return null;
              }
              var topNode = nodes[0];
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].zIndex > topNode.zIndex) {
                  topNode = nodes[i];
                }
              }
              return topNode || null;
            }
            /**
             * Given a font name, and possible renderer override, return the best compatible text renderer.
             *
             * @remarks
             * Will try to return a canvas renderer if no other suitable renderer can be resolved.
             *
             * @param fontFamily
             * @param textRendererOverride
             * @returns
             */
          }, {
            key: "resolveTextRenderer",
            value: function resolveTextRenderer(trProps) {
              var textRendererOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var fontCacheString = "".concat(trProps.fontFamily).concat(trProps.fontStyle).concat(trProps.fontWeight).concat(trProps.fontStretch).concat(textRendererOverride ? textRendererOverride : '');
              // check our resolve cache first
              if (this.fontResolveMap[fontCacheString] !== undefined) {
                return this.fontResolveMap[fontCacheString];
              }
              // Resolve the text renderer
              var rendererId = textRendererOverride;
              var overrideFallback = false;
              // Check if the override is valid (if one is provided)
              if (rendererId) {
                var possibleRenderer = this.textRenderers[rendererId];
                if (!possibleRenderer) {
                  console.warn("Text renderer override '".concat(rendererId, "' not found."));
                  rendererId = null;
                  overrideFallback = true;
                } else if (!possibleRenderer.canRenderFont(trProps)) {
                  console.warn("Cannot use override text renderer '".concat(rendererId, "' for font"), trProps);
                  rendererId = null;
                  overrideFallback = true;
                }
              }
              if (!rendererId) {
                // Iterate through the text renderers and find the first one that can render the font
                for (var _i = 0, _Object$entries = Object.entries(this.textRenderers); _i < _Object$entries.length; _i++) {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                    trId = _Object$entries$_i[0],
                    tr = _Object$entries$_i[1];
                  if (tr.canRenderFont(trProps)) {
                    rendererId = trId;
                    break;
                  }
                }
                if (!rendererId && this.textRenderers.canvas !== undefined) {
                  // If no renderer can be found, use the canvas renderer
                  rendererId = 'canvas';
                }
              }
              if (overrideFallback) {
                console.warn("Falling back to text renderer ".concat(String(rendererId)));
              }
              if (!rendererId) {
                // silently fail if no renderer can be found, the error is already created
                // at the constructor level
                return null;
              }
              // By now we are guaranteed to have a valid rendererId (at least Canvas);
              var resolvedTextRenderer = this.textRenderers[rendererId];
              // cache the resolved renderer for future use with these trProps
              this.fontResolveMap[fontCacheString] = resolvedTextRenderer;
              // Need to explicitly cast to TextRenderer because TS doesn't like
              // the covariant state argument in the setter method map
              return resolvedTextRenderer;
            }
            /**
             * Create a shader controller instance
             *
             * @param type
             * @param props
             * @returns
             */
          }, {
            key: "createShaderCtr",
            value: function createShaderCtr(type, props) {
              return this.shManager.loadShader(type, props);
            }
          }, {
            key: "createNode",
            value: function createNode(props) {
              var resolvedProps = this.resolveNodeDefaults(props);
              return new CoreNode(this, resolvedProps);
            }
          }, {
            key: "createTextNode",
            value: function createTextNode(props) {
              var _props$fontSize, _props$text, _props$textRendererOv, _props$fontFamily, _props$fontStyle, _props$fontWeight, _props$fontStretch, _props$textAlign, _props$contain, _props$scrollable, _props$scrollY2, _props$offsetY, _props$letterSpacing, _props$maxLines, _props$textBaseline, _props$verticalAlign, _props$overflowSuffix, _props$debug2;
              var fontSize = (_props$fontSize = props.fontSize) !== null && _props$fontSize !== void 0 ? _props$fontSize : 16;
              var resolvedProps = _objectSpread(_objectSpread({}, this.resolveNodeDefaults(props)), {}, {
                text: (_props$text = props.text) !== null && _props$text !== void 0 ? _props$text : '',
                textRendererOverride: (_props$textRendererOv = props.textRendererOverride) !== null && _props$textRendererOv !== void 0 ? _props$textRendererOv : null,
                fontSize: fontSize,
                fontFamily: (_props$fontFamily = props.fontFamily) !== null && _props$fontFamily !== void 0 ? _props$fontFamily : 'sans-serif',
                fontStyle: (_props$fontStyle = props.fontStyle) !== null && _props$fontStyle !== void 0 ? _props$fontStyle : 'normal',
                fontWeight: (_props$fontWeight = props.fontWeight) !== null && _props$fontWeight !== void 0 ? _props$fontWeight : 'normal',
                fontStretch: (_props$fontStretch = props.fontStretch) !== null && _props$fontStretch !== void 0 ? _props$fontStretch : 'normal',
                textAlign: (_props$textAlign = props.textAlign) !== null && _props$textAlign !== void 0 ? _props$textAlign : 'left',
                contain: (_props$contain = props.contain) !== null && _props$contain !== void 0 ? _props$contain : 'none',
                scrollable: (_props$scrollable = props.scrollable) !== null && _props$scrollable !== void 0 ? _props$scrollable : false,
                scrollY: (_props$scrollY2 = props.scrollY) !== null && _props$scrollY2 !== void 0 ? _props$scrollY2 : 0,
                offsetY: (_props$offsetY = props.offsetY) !== null && _props$offsetY !== void 0 ? _props$offsetY : 0,
                letterSpacing: (_props$letterSpacing = props.letterSpacing) !== null && _props$letterSpacing !== void 0 ? _props$letterSpacing : 0,
                lineHeight: props.lineHeight,
                // `undefined` is a valid value
                maxLines: (_props$maxLines = props.maxLines) !== null && _props$maxLines !== void 0 ? _props$maxLines : 0,
                textBaseline: (_props$textBaseline = props.textBaseline) !== null && _props$textBaseline !== void 0 ? _props$textBaseline : 'alphabetic',
                verticalAlign: (_props$verticalAlign = props.verticalAlign) !== null && _props$verticalAlign !== void 0 ? _props$verticalAlign : 'middle',
                overflowSuffix: (_props$overflowSuffix = props.overflowSuffix) !== null && _props$overflowSuffix !== void 0 ? _props$overflowSuffix : '...',
                debug: (_props$debug2 = props.debug) !== null && _props$debug2 !== void 0 ? _props$debug2 : {},
                shaderProps: null
              });
              var resolvedTextRenderer = this.resolveTextRenderer(resolvedProps, props.textRendererOverride);
              if (!resolvedTextRenderer) {
                throw new Error("No compatible text renderer found for ".concat(resolvedProps.fontFamily));
              }
              return new CoreTextNode(this, resolvedProps, resolvedTextRenderer);
            }
          }, {
            key: "setBoundsMargin",
            value: function setBoundsMargin(value) {
              this.boundsMargin = Array.isArray(value) ? value : [value, value, value, value];
              this.root.setUpdateType(UpdateType.RenderBounds);
            }
            /**
             * Resolves the default property values for a Node
             *
             * @remarks
             * This method is used internally by the RendererMain to resolve the default
             * property values for a Node. It is exposed publicly so that it can be used
             * by Core Driver implementations.
             *
             * @param props
             * @returns
             */
          }, {
            key: "resolveNodeDefaults",
            value: function resolveNodeDefaults(props) {
              var _props$color8, _ref9, _ref0, _props$colorTl, _ref1, _ref10, _props$colorTr, _ref11, _ref12, _props$colorBl, _ref13, _ref14, _props$colorBr, _props$x, _props$y, _props$width0, _props$height4, _props$alpha, _props$autosize, _props$boundsMargin, _props$clipping, _props$colorTop, _props$colorBottom, _props$colorLeft, _props$colorRight, _props$zIndex, _props$zIndexLocked, _props$parent3, _props$texture, _props$textureOptions, _props$shader, _props$src2, _props$scale, _ref15, _props$scaleX, _ref16, _props$scaleY, _props$mount, _ref17, _props$mountX, _ref18, _props$mountY, _props$pivot2, _ref19, _props$pivotX, _ref20, _props$pivotY, _props$rotation, _props$rtt, _props$preventCleanup, _props$interactive, _props$strictBounds;
              var color = (_props$color8 = props.color) !== null && _props$color8 !== void 0 ? _props$color8 : 0xffffffff;
              var colorTl = (_ref9 = (_ref0 = (_props$colorTl = props.colorTl) !== null && _props$colorTl !== void 0 ? _props$colorTl : props.colorTop) !== null && _ref0 !== void 0 ? _ref0 : props.colorLeft) !== null && _ref9 !== void 0 ? _ref9 : color;
              var colorTr = (_ref1 = (_ref10 = (_props$colorTr = props.colorTr) !== null && _props$colorTr !== void 0 ? _props$colorTr : props.colorTop) !== null && _ref10 !== void 0 ? _ref10 : props.colorRight) !== null && _ref1 !== void 0 ? _ref1 : color;
              var colorBl = (_ref11 = (_ref12 = (_props$colorBl = props.colorBl) !== null && _props$colorBl !== void 0 ? _props$colorBl : props.colorBottom) !== null && _ref12 !== void 0 ? _ref12 : props.colorLeft) !== null && _ref11 !== void 0 ? _ref11 : color;
              var colorBr = (_ref13 = (_ref14 = (_props$colorBr = props.colorBr) !== null && _props$colorBr !== void 0 ? _props$colorBr : props.colorBottom) !== null && _ref14 !== void 0 ? _ref14 : props.colorRight) !== null && _ref13 !== void 0 ? _ref13 : color;
              var data = {};
              if (this.options.inspector === true) {
                var _props$data;
                data = santizeCustomDataMap((_props$data = props.data) !== null && _props$data !== void 0 ? _props$data : {});
              }
              return {
                x: (_props$x = props.x) !== null && _props$x !== void 0 ? _props$x : 0,
                y: (_props$y = props.y) !== null && _props$y !== void 0 ? _props$y : 0,
                width: (_props$width0 = props.width) !== null && _props$width0 !== void 0 ? _props$width0 : 0,
                height: (_props$height4 = props.height) !== null && _props$height4 !== void 0 ? _props$height4 : 0,
                alpha: (_props$alpha = props.alpha) !== null && _props$alpha !== void 0 ? _props$alpha : 1,
                autosize: (_props$autosize = props.autosize) !== null && _props$autosize !== void 0 ? _props$autosize : false,
                boundsMargin: (_props$boundsMargin = props.boundsMargin) !== null && _props$boundsMargin !== void 0 ? _props$boundsMargin : null,
                clipping: (_props$clipping = props.clipping) !== null && _props$clipping !== void 0 ? _props$clipping : false,
                color: color,
                colorTop: (_props$colorTop = props.colorTop) !== null && _props$colorTop !== void 0 ? _props$colorTop : color,
                colorBottom: (_props$colorBottom = props.colorBottom) !== null && _props$colorBottom !== void 0 ? _props$colorBottom : color,
                colorLeft: (_props$colorLeft = props.colorLeft) !== null && _props$colorLeft !== void 0 ? _props$colorLeft : color,
                colorRight: (_props$colorRight = props.colorRight) !== null && _props$colorRight !== void 0 ? _props$colorRight : color,
                colorBl: colorBl,
                colorBr: colorBr,
                colorTl: colorTl,
                colorTr: colorTr,
                zIndex: (_props$zIndex = props.zIndex) !== null && _props$zIndex !== void 0 ? _props$zIndex : 0,
                zIndexLocked: (_props$zIndexLocked = props.zIndexLocked) !== null && _props$zIndexLocked !== void 0 ? _props$zIndexLocked : 0,
                parent: (_props$parent3 = props.parent) !== null && _props$parent3 !== void 0 ? _props$parent3 : null,
                texture: (_props$texture = props.texture) !== null && _props$texture !== void 0 ? _props$texture : null,
                textureOptions: (_props$textureOptions = props.textureOptions) !== null && _props$textureOptions !== void 0 ? _props$textureOptions : {},
                shader: (_props$shader = props.shader) !== null && _props$shader !== void 0 ? _props$shader : this.defShaderCtr,
                // Since setting the `src` will trigger a texture load, we need to set it after
                // we set the texture. Otherwise, problems happen.
                src: (_props$src2 = props.src) !== null && _props$src2 !== void 0 ? _props$src2 : null,
                srcHeight: props.srcHeight,
                srcWidth: props.srcWidth,
                srcX: props.srcX,
                srcY: props.srcY,
                scale: (_props$scale = props.scale) !== null && _props$scale !== void 0 ? _props$scale : null,
                scaleX: (_ref15 = (_props$scaleX = props.scaleX) !== null && _props$scaleX !== void 0 ? _props$scaleX : props.scale) !== null && _ref15 !== void 0 ? _ref15 : 1,
                scaleY: (_ref16 = (_props$scaleY = props.scaleY) !== null && _props$scaleY !== void 0 ? _props$scaleY : props.scale) !== null && _ref16 !== void 0 ? _ref16 : 1,
                mount: (_props$mount = props.mount) !== null && _props$mount !== void 0 ? _props$mount : 0,
                mountX: (_ref17 = (_props$mountX = props.mountX) !== null && _props$mountX !== void 0 ? _props$mountX : props.mount) !== null && _ref17 !== void 0 ? _ref17 : 0,
                mountY: (_ref18 = (_props$mountY = props.mountY) !== null && _props$mountY !== void 0 ? _props$mountY : props.mount) !== null && _ref18 !== void 0 ? _ref18 : 0,
                pivot: (_props$pivot2 = props.pivot) !== null && _props$pivot2 !== void 0 ? _props$pivot2 : 0.5,
                pivotX: (_ref19 = (_props$pivotX = props.pivotX) !== null && _props$pivotX !== void 0 ? _props$pivotX : props.pivot) !== null && _ref19 !== void 0 ? _ref19 : 0.5,
                pivotY: (_ref20 = (_props$pivotY = props.pivotY) !== null && _props$pivotY !== void 0 ? _props$pivotY : props.pivot) !== null && _ref20 !== void 0 ? _ref20 : 0.5,
                rotation: (_props$rotation = props.rotation) !== null && _props$rotation !== void 0 ? _props$rotation : 0,
                rtt: (_props$rtt = props.rtt) !== null && _props$rtt !== void 0 ? _props$rtt : false,
                data: data,
                preventCleanup: (_props$preventCleanup = props.preventCleanup) !== null && _props$preventCleanup !== void 0 ? _props$preventCleanup : false,
                imageType: props.imageType,
                interactive: (_props$interactive = props.interactive) !== null && _props$interactive !== void 0 ? _props$interactive : false,
                strictBounds: (_props$strictBounds = props.strictBounds) !== null && _props$strictBounds !== void 0 ? _props$strictBounds : this.strictBounds
              };
            }
            /**
             * Cleanup Unused Textures
             *
             * @remarks
             * This method is used to cleanup unused textures that are no longer in use.
             */
          }, {
            key: "cleanup",
            value: function cleanup() {
              this.txMemManager.cleanup();
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * The Renderer Main API
         *
         * @remarks
         * This is the primary class used to configure and operate the Renderer.
         *
         * It is used to create and destroy Nodes, as well as Texture and Shader
         * references.
         *
         * Example:
         * ```ts
         * import { RendererMain, MainCoreDriver } from '@lightningjs/renderer';
         *
         * // Initialize the Renderer
         * const renderer = new RendererMain(
         *   {
         *     appWidth: 1920,
         *     appHeight: 1080
         *   },
         *   'app',
         *   new MainCoreDriver(),
         * );
         * ```
         *
         * ## Events
         * - `fpsUpdate`
         *   - Emitted every `fpsUpdateInterval` milliseconds with the current FPS
         * - `frameTick`
         *   - Emitted every frame tick
         * - `quadsUpdate`
         *  - Emitted when number of quads rendered is updated
         * - `idle`
         *   - Emitted when the renderer is idle (no changes to the scene
         *     graph/animations running)
         * - `criticalCleanup`
         *  - Emitted when the Texture Memory Manager Cleanup process is triggered
         *  - Payload: { memUsed: number, criticalThreshold: number }
         *    - `memUsed` - The amount of memory (in bytes) used by textures before the
         *       cleanup process
         *    - `criticalThreshold` - The critical threshold (in bytes)
         * - `criticalCleanupFailed`
         *   - Emitted when the Texture Memory Manager Cleanup process is unable to free
         *     up enough texture memory to reach below the critical threshold.
         *     This can happen when there is not enough non-renderable textures to
         *     free up.
         *   - Payload (object with keys):
         *     - `memUsed` - The amount of memory (in bytes) used by textures after
         *       the cleanup process
         *     - `criticalThreshold` - The critical threshold (in bytes)
         */
        var RendererMain = /*#__PURE__*/function (_EventEmitter7) {
          /**
           * Constructs a new Renderer instance
           *
           * @param settings Renderer settings
           * @param target Element ID or HTMLElement to insert the canvas into
           * @param driver Core Driver to use
           */
          function RendererMain(settings, target) {
            var _settings$textureMemo, _settings$textureMemo2, _settings$textureMemo3, _settings$textureMemo4, _settings$textureMemo5, _settings$textureMemo6, _settings$clearColor, _settings$enableConte, _settings$forceWebGL, _settings$inspector, _settings$quadBufferS, _settings$strictBound, _settings$maxRetryCou;
            var _this45;
            _classCallCheck(this, RendererMain);
            _this45 = _callSuper(this, RendererMain);
            _defineProperty(_this45, "root", void 0);
            _defineProperty(_this45, "canvas", void 0);
            _defineProperty(_this45, "settings", void 0);
            _defineProperty(_this45, "stage", void 0);
            _defineProperty(_this45, "inspector", null);
            var resolvedTxSettings = {
              criticalThreshold: ((_settings$textureMemo = settings.textureMemory) === null || _settings$textureMemo === void 0 ? void 0 : _settings$textureMemo.criticalThreshold) || 124e6,
              targetThresholdLevel: ((_settings$textureMemo2 = settings.textureMemory) === null || _settings$textureMemo2 === void 0 ? void 0 : _settings$textureMemo2.targetThresholdLevel) || 0.5,
              cleanupInterval: ((_settings$textureMemo3 = settings.textureMemory) === null || _settings$textureMemo3 === void 0 ? void 0 : _settings$textureMemo3.cleanupInterval) || 5000,
              debugLogging: ((_settings$textureMemo4 = settings.textureMemory) === null || _settings$textureMemo4 === void 0 ? void 0 : _settings$textureMemo4.debugLogging) || false,
              baselineMemoryAllocation: ((_settings$textureMemo5 = settings.textureMemory) === null || _settings$textureMemo5 === void 0 ? void 0 : _settings$textureMemo5.baselineMemoryAllocation) || 26e6,
              doNotExceedCriticalThreshold: ((_settings$textureMemo6 = settings.textureMemory) === null || _settings$textureMemo6 === void 0 ? void 0 : _settings$textureMemo6.doNotExceedCriticalThreshold) || false
            };
            var resolvedSettings = {
              appWidth: settings.appWidth || 1920,
              appHeight: settings.appHeight || 1080,
              textureMemory: resolvedTxSettings,
              boundsMargin: settings.boundsMargin || 0,
              deviceLogicalPixelRatio: settings.deviceLogicalPixelRatio || 1,
              devicePhysicalPixelRatio: settings.devicePhysicalPixelRatio || window.devicePixelRatio,
              clearColor: (_settings$clearColor = settings.clearColor) !== null && _settings$clearColor !== void 0 ? _settings$clearColor : 0x00000000,
              fpsUpdateInterval: settings.fpsUpdateInterval || 0,
              targetFPS: settings.targetFPS || 0,
              numImageWorkers: settings.numImageWorkers !== undefined ? settings.numImageWorkers : 2,
              enableContextSpy: (_settings$enableConte = settings.enableContextSpy) !== null && _settings$enableConte !== void 0 ? _settings$enableConte : false,
              forceWebGL2: (_settings$forceWebGL = settings.forceWebGL2) !== null && _settings$forceWebGL !== void 0 ? _settings$forceWebGL : false,
              inspector: (_settings$inspector = settings.inspector) !== null && _settings$inspector !== void 0 ? _settings$inspector : false,
              renderEngine: settings.renderEngine,
              quadBufferSize: (_settings$quadBufferS = settings.quadBufferSize) !== null && _settings$quadBufferS !== void 0 ? _settings$quadBufferS : 4 * 1024 * 1024,
              fontEngines: settings.fontEngines,
              strictBounds: (_settings$strictBound = settings.strictBounds) !== null && _settings$strictBound !== void 0 ? _settings$strictBound : true,
              textureProcessingTimeLimit: settings.textureProcessingTimeLimit || 42,
              canvas: settings.canvas || document.createElement('canvas'),
              createImageBitmapSupport: settings.createImageBitmapSupport || 'full',
              maxRetryCount: (_settings$maxRetryCou = settings.maxRetryCount) !== null && _settings$maxRetryCou !== void 0 ? _settings$maxRetryCou : 5
            };
            _this45.settings = resolvedSettings;
            var appWidth = resolvedSettings.appWidth,
              appHeight = resolvedSettings.appHeight,
              deviceLogicalPixelRatio = resolvedSettings.deviceLogicalPixelRatio,
              devicePhysicalPixelRatio = resolvedSettings.devicePhysicalPixelRatio,
              inspector = resolvedSettings.inspector,
              canvas = resolvedSettings.canvas;
            var deviceLogicalWidth = appWidth * deviceLogicalPixelRatio;
            var deviceLogicalHeight = appHeight * deviceLogicalPixelRatio;
            _this45.canvas = canvas;
            canvas.width = deviceLogicalWidth * devicePhysicalPixelRatio;
            canvas.height = deviceLogicalHeight * devicePhysicalPixelRatio;
            canvas.style.width = "".concat(deviceLogicalWidth, "px");
            canvas.style.height = "".concat(deviceLogicalHeight, "px");
            // Initialize the stage
            _this45.stage = new Stage({
              appWidth: _this45.settings.appWidth,
              appHeight: _this45.settings.appHeight,
              boundsMargin: _this45.settings.boundsMargin,
              clearColor: _this45.settings.clearColor,
              canvas: _this45.canvas,
              deviceLogicalPixelRatio: _this45.settings.deviceLogicalPixelRatio,
              devicePhysicalPixelRatio: _this45.settings.devicePhysicalPixelRatio,
              enableContextSpy: _this45.settings.enableContextSpy,
              forceWebGL2: _this45.settings.forceWebGL2,
              fpsUpdateInterval: _this45.settings.fpsUpdateInterval,
              targetFPS: _this45.settings.targetFPS,
              numImageWorkers: _this45.settings.numImageWorkers,
              renderEngine: _this45.settings.renderEngine,
              textureMemory: resolvedTxSettings,
              eventBus: _this45,
              quadBufferSize: _this45.settings.quadBufferSize,
              fontEngines: _this45.settings.fontEngines,
              inspector: _this45.settings.inspector !== null,
              strictBounds: _this45.settings.strictBounds,
              textureProcessingTimeLimit: _this45.settings.textureProcessingTimeLimit,
              createImageBitmapSupport: _this45.settings.createImageBitmapSupport,
              maxRetryCount: _this45.settings.maxRetryCount
            });
            // Extract the root node
            _this45.root = _this45.stage.root;
            // Get the target element and attach the canvas to it
            var targetEl;
            if (typeof target === 'string') {
              targetEl = document.getElementById(target);
            } else {
              targetEl = target;
            }
            if (!targetEl) {
              throw new Error('Could not find target element');
            }
            targetEl.appendChild(canvas);
            return _this45;
          }
          /**
           * Create a new scene graph node
           *
           * @remarks
           * A node is the main graphical building block of the Renderer scene graph. It
           * can be a container for other nodes, or it can be a leaf node that renders a
           * solid color, gradient, image, or specific texture, using a specific shader.
           *
           * To create a text node, see {@link createTextNode}.
           *
           * See {@link CoreNode} for more details.
           *
           * @param props
           * @returns
           */
          _inherits(RendererMain, _EventEmitter7);
          return _createClass(RendererMain, [{
            key: "createNode",
            value: function createNode(props) {
              var node = this.stage.createNode(props);
              if (this.inspector) {
                return this.inspector.createNode(node);
              }
              // FIXME onDestroy event? node.once('beforeDestroy'
              // FIXME onCreate event?
              return node;
            }
            /**
             * Create a new scene graph text node
             *
             * @remarks
             * A text node is the second graphical building block of the Renderer scene
             * graph. It renders text using a specific text renderer that is automatically
             * chosen based on the font requested and what type of fonts are installed
             * into an app.
             *
             * See {@link ITextNode} for more details.
             *
             * @param props
             * @returns
             */
          }, {
            key: "createTextNode",
            value: function createTextNode(props) {
              var textNode = this.stage.createTextNode(props);
              if (this.inspector) {
                return this.inspector.createTextNode(textNode);
              }
              return textNode;
            }
            /**
             * Destroy a node
             *
             * @remarks
             * This method destroys a node
             *
             * @param node
             * @returns
             */
          }, {
            key: "destroyNode",
            value: function destroyNode(node) {
              if (this.inspector) {
                this.inspector.destroyNode(node.id);
              }
              return node.destroy();
            }
            /**
             * Create a new texture reference
             *
             * @remarks
             * This method creates a new reference to a texture. The texture is not
             * loaded until it is used on a node.
             *
             * It can be assigned to a node's `texture` property, or it can be used
             * when creating a SubTexture.
             *
             * @param textureType
             * @param props
             * @param options
             * @returns
             */
          }, {
            key: "createTexture",
            value: function createTexture(textureType, props) {
              return this.stage.txManager.createTexture(textureType, props);
            }
            /**
             * Create a new shader controller for a shader type
             *
             * @remarks
             * This method creates a new Shader Controller for a specific shader type.
             *
             * If the shader has not been loaded yet, it will be loaded. Otherwise, the
             * existing shader will be reused.
             *
             * It can be assigned to a Node's `shader` property.
             *
             * @param shaderType
             * @param props
             * @returns
             */
          }, {
            key: "createShader",
            value: function createShader(shaderType, props) {
              return this.stage.shManager.loadShader(shaderType, props);
            }
            /**
             * Create a new Dynamic Shader controller
             *
             * @remarks
             * A Dynamic Shader is a shader that can be composed of an array of mulitple
             * effects. Each effect can be animated or changed after creation (provided
             * the effect is given a name).
             *
             * Example:
             * ```ts
             * renderer.createNode({
             *   shader: renderer.createDynamicShader([
             *     renderer.createEffect('radius', {
             *       radius: 0
             *     }, 'effect1'),
             *     renderer.createEffect('border', {
             *       color: 0xff00ffff,
             *       width: 10,
             *     }, 'effect2'),
             *   ]),
             * });
             * ```
             *
             * @param effects
             * @returns
             */
          }, {
            key: "createDynamicShader",
            value: function createDynamicShader(effects) {
              return this.stage.shManager.loadDynamicShader({
                effects: effects
              });
            }
            /**
             * Create an effect to be used in a Dynamic Shader
             *
             * @remark
             * The {name} parameter is optional but required if you want to animate the effect
             * or change the effect's properties after creation.
             *
             * See {@link createDynamicShader} for an example.
             *
             * @param type
             * @param props
             * @param name
             * @returns
             */
          }, {
            key: "createEffect",
            value: function createEffect(type, props, name) {
              return {
                name: name,
                type: type,
                props: props
              };
            }
            /**
             * Get a Node by its ID
             *
             * @param id
             * @returns
             */
          }, {
            key: "getNodeById",
            value: function getNodeById(id) {
              var _this$stage;
              var root = (_this$stage = this.stage) === null || _this$stage === void 0 ? void 0 : _this$stage.root;
              if (!root) {
                return null;
              }
              var _findNode = function findNode(node) {
                if (node.id === id) {
                  return node;
                }
                var _iterator11 = _createForOfIteratorHelper(node.children),
                  _step11;
                try {
                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                    var child = _step11.value;
                    var found = _findNode(child);
                    if (found) {
                      return found;
                    }
                  }
                } catch (err) {
                  _iterator11.e(err);
                } finally {
                  _iterator11.f();
                }
                return null;
              };
              return _findNode(root);
            }
          }, {
            key: "toggleFreeze",
            value: function toggleFreeze() {
              throw new Error('Not implemented');
            }
          }, {
            key: "advanceFrame",
            value: function advanceFrame() {
              throw new Error('Not implemented');
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              return this.stage.renderer.getBufferInfo();
            }
            /**
             * Re-render the current frame without advancing any running animations.
             *
             * @remarks
             * Any state changes will be reflected in the re-rendered frame. Useful for
             * debugging.
             *
             * May not do anything if the render loop is running on a separate worker.
             */
          }, {
            key: "rerender",
            value: function rerender() {
              this.stage.requestRender();
            }
            /**
             * Cleanup textures that are not being used
             *
             * @remarks
             * This can be used to free up GFX memory used by textures that are no longer
             * being displayed.
             *
             * This routine is also called automatically when the memory used by textures
             * exceeds the critical threshold on frame generation **OR** when the renderer
             * is idle and the memory used by textures exceeds the target threshold.
             *
             * **NOTE**: This is a heavy operation and should be used sparingly.
             * **NOTE2**: This will not cleanup textures that are currently being displayed.
             * **NOTE3**: This will not cleanup textures that are marked as `preventCleanup`.
             * **NOTE4**: This has nothing to do with the garbage collection of JavaScript.
             */
          }, {
            key: "cleanup",
            value: function cleanup() {
              this.stage.cleanup();
            }
            /**
             * Sets the clear color for the stage.
             *
             * @param color - The color to set as the clear color.
             */
          }, {
            key: "setClearColor",
            value: function setClearColor(color) {
              this.stage.setClearColor(color);
            }
            /**
             * Gets the target FPS for the global render loop
             *
             * @returns The current target FPS (0 means no throttling)
             *
             * @remarks
             * This controls the maximum frame rate of the entire rendering system.
             * When 0, the system runs at display refresh rate.
             */
          }, {
            key: "targetFPS",
            get: function get() {
              return this.stage.options.targetFPS;
            }
            /**
             * Sets the target FPS for the global render loop
             *
             * @param fps - The target FPS to set for the global render loop.
             *              Set to 0 or a negative value to disable throttling.
             *
             * @remarks
             * This setting affects the entire rendering system immediately.
             * All animations, rendering, and frame updates will be throttled
             * to this target FPS. Provides global performance control.
             *
             * @example
             * ```typescript
             * // Set global target to 30fps for better performance
             * renderer.targetFPS = 30;
             *
             * // Disable global throttling (use display refresh rate)
             * renderer.targetFPS = 0;
             * ```
             */,
            set: function set(fps) {
              this.stage.options.targetFPS = fps > 0 ? fps : 0;
              this.stage.updateTargetFrameTime();
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TrFontFace = /*#__PURE__*/function (_EventEmitter8) {
          function TrFontFace(options) {
            var _this46;
            _classCallCheck(this, TrFontFace);
            _this46 = _callSuper(this, TrFontFace);
            _defineProperty(_this46, "fontFamily", void 0);
            _defineProperty(_this46, "descriptors", void 0);
            _defineProperty(_this46, "loaded", false);
            _defineProperty(_this46, "metrics", null);
            var fontFamily = options.fontFamily,
              descriptors = options.descriptors,
              metrics = options.metrics;
            if (metrics) {
              // Normalize metrics to be in the range of 0 to 1
              _this46.metrics = {
                ascender: metrics.ascender / metrics.unitsPerEm,
                descender: metrics.descender / metrics.unitsPerEm,
                lineGap: metrics.lineGap / metrics.unitsPerEm
              };
            }
            _this46.fontFamily = fontFamily;
            _this46.descriptors = _objectSpread({
              style: 'normal',
              weight: 'normal',
              stretch: 'normal'
            }, descriptors);
            return _this46;
          }
          /**
           * Convert a TrFontFaceDescriptors to a FontFaceDescriptors which differ slightly
           *
           * @param descriptors
           * @returns
           */
          _inherits(TrFontFace, _EventEmitter8);
          return _createClass(TrFontFace, null, [{
            key: "convertToCssFontFaceDescriptors",
            value: function convertToCssFontFaceDescriptors(descriptors) {
              return {
                style: descriptors.style,
                weight: typeof descriptors.weight === 'number' ? "".concat(descriptors.weight) : descriptors.weight,
                stretch: descriptors.stretch,
                unicodeRange: descriptors.unicodeRange,
                featureSettings: descriptors.featureSettings,
                display: descriptors.display
              };
            }
          }]);
        }(EventEmitter);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebTrFontFace = /*#__PURE__*/function (_TrFontFace2) {
          function WebTrFontFace(options) {
            var _this47;
            _classCallCheck(this, WebTrFontFace);
            _this47 = _callSuper(this, WebTrFontFace, [options]);
            _defineProperty(_this47, "fontFace", void 0);
            _defineProperty(_this47, "fontUrl", void 0);
            var fontFamily = options.fontFamily,
              fontUrl = options.fontUrl;
            // Filter out parentheses from fontUrl
            var fontUrlWithoutParentheses = fontUrl.replace(/\(|\)/g, '');
            // Defaults for descriptors resolved in the super constructor
            var determinedDescriptors = _this47.descriptors;
            // Convert TrFontFaceDescriptors to CSS FontFaceDescriptors
            var cssDescriptors = {
              style: determinedDescriptors.style,
              weight: typeof determinedDescriptors.weight === 'number' ? "".concat(determinedDescriptors.weight) : determinedDescriptors.weight,
              stretch: determinedDescriptors.stretch,
              unicodeRange: determinedDescriptors.unicodeRange,
              featureSettings: determinedDescriptors.featureSettings,
              display: determinedDescriptors.display
            };
            for (var k in cssDescriptors) {
              var key = k;
              if (cssDescriptors[key] === undefined) {
                delete cssDescriptors[key];
              }
            }
            var fontFace = new FontFace(fontFamily, "url(".concat(fontUrlWithoutParentheses, ")"), cssDescriptors);
            if (fontUrlWithoutParentheses.length > 0) {
              fontFace.load().then(function () {
                _this47.loaded = true;
                _this47.emit('loaded');
              }).catch(console.error);
            } else {
              // Default font
              _this47.loaded = true;
              _this47.emit('loaded');
            }
            _this47.fontFace = fontFace;
            _this47.fontUrl = fontUrl;
            return _this47;
          }
          _inherits(WebTrFontFace, _TrFontFace2);
          return _createClass(WebTrFontFace);
        }(TrFontFace);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CoreRenderOp = /*#__PURE__*/_createClass(function CoreRenderOp() {
          _classCallCheck(this, CoreRenderOp);
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Can render multiple quads with multiple textures (up to vertex shader texture limit)
         *
         */
        var WebGlCoreRenderOp = /*#__PURE__*/function (_CoreRenderOp) {
          function WebGlCoreRenderOp(glw, options, buffers, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, zIndex, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
            var _this48;
            _classCallCheck(this, WebGlCoreRenderOp);
            _this48 = _callSuper(this, WebGlCoreRenderOp);
            _defineProperty(_this48, "glw", void 0);
            _defineProperty(_this48, "options", void 0);
            _defineProperty(_this48, "buffers", void 0);
            _defineProperty(_this48, "shader", void 0);
            _defineProperty(_this48, "shaderProps", void 0);
            _defineProperty(_this48, "alpha", void 0);
            _defineProperty(_this48, "clippingRect", void 0);
            _defineProperty(_this48, "dimensions", void 0);
            _defineProperty(_this48, "bufferIdx", void 0);
            _defineProperty(_this48, "zIndex", void 0);
            _defineProperty(_this48, "renderToTexture", void 0);
            _defineProperty(_this48, "parentHasRenderTexture", void 0);
            _defineProperty(_this48, "framebufferDimensions", void 0);
            _defineProperty(_this48, "length", 0);
            _defineProperty(_this48, "numQuads", 0);
            _defineProperty(_this48, "textures", []);
            _defineProperty(_this48, "maxTextures", void 0);
            _this48.glw = glw;
            _this48.options = options;
            _this48.buffers = buffers;
            _this48.shader = shader;
            _this48.shaderProps = shaderProps;
            _this48.alpha = alpha;
            _this48.clippingRect = clippingRect;
            _this48.dimensions = dimensions;
            _this48.bufferIdx = bufferIdx;
            _this48.zIndex = zIndex;
            _this48.renderToTexture = renderToTexture;
            _this48.parentHasRenderTexture = parentHasRenderTexture;
            _this48.framebufferDimensions = framebufferDimensions;
            _this48.maxTextures = shader.supportsIndexedTextures ? glw.getParameter(glw.MAX_VERTEX_TEXTURE_IMAGE_UNITS) : 1;
            return _this48;
          }
          _inherits(WebGlCoreRenderOp, _CoreRenderOp);
          return _createClass(WebGlCoreRenderOp, [{
            key: "addTexture",
            value: function addTexture(texture) {
              var textures = this.textures,
                maxTextures = this.maxTextures;
              var existingIdx = -1;
              var texturesLength = textures.length;
              for (var i = 0; i < texturesLength; i++) {
                var t = textures[i];
                if (t === texture) {
                  existingIdx = i;
                  break;
                }
              }
              if (existingIdx !== -1) {
                return existingIdx;
              }
              if (texturesLength >= maxTextures) {
                return 0xffffffff;
              }
              this.textures.push(texture);
              return texturesLength;
            }
          }, {
            key: "draw",
            value: function draw() {
              var glw = this.glw,
                shader = this.shader,
                shaderProps = this.shaderProps,
                options = this.options;
              var shManager = options.shManager;
              shManager.useShader(shader);
              shader.bindRenderOp(this, shaderProps);
              // TODO: Reduce calculations required
              var quadIdx = this.bufferIdx / 24 * 6 * 2;
              // Clipping
              if (this.clippingRect.valid) {
                var _this$clippingRect = this.clippingRect,
                  x = _this$clippingRect.x,
                  y = _this$clippingRect.y,
                  width = _this$clippingRect.width,
                  height = _this$clippingRect.height;
                var pixelRatio = this.parentHasRenderTexture ? 1 : options.pixelRatio;
                var canvasHeight = options.canvas.height;
                var clipX = Math.round(x * pixelRatio);
                var clipWidth = Math.round(width * pixelRatio);
                var clipHeight = Math.round(height * pixelRatio);
                var clipY = Math.round(canvasHeight - clipHeight - y * pixelRatio);
                // if parent has render texture, we need to adjust the scissor rect
                // to be relative to the parent's framebuffer
                if (this.parentHasRenderTexture) {
                  clipY = this.framebufferDimensions ? this.framebufferDimensions.height - this.dimensions.height : 0;
                }
                glw.setScissorTest(true);
                glw.scissor(clipX, clipY, clipWidth, clipHeight);
              } else {
                glw.setScissorTest(false);
              }
              glw.drawElements(glw.TRIANGLES, 6 * this.numQuads, glw.UNSIGNED_SHORT, quadIdx);
            }
          }]);
        }(CoreRenderOp);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Get device specific webgl parameters
         * @param glw
         */
        function getWebGlParameters(glw) {
          var params = {
            MAX_RENDERBUFFER_SIZE: 0,
            MAX_TEXTURE_SIZE: 0,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any
            MAX_VIEWPORT_DIMS: 0,
            // Code below will replace this with an Int32Array
            MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0,
            MAX_TEXTURE_IMAGE_UNITS: 0,
            MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0,
            MAX_VERTEX_ATTRIBS: 0,
            MAX_VARYING_VECTORS: 0,
            MAX_VERTEX_UNIFORM_VECTORS: 0,
            MAX_FRAGMENT_UNIFORM_VECTORS: 0
          };
          // Map over all parameters and get them
          var keys = Object.keys(params);
          keys.forEach(function (key) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            params[key] = glw.getParameter(glw[key]);
          });
          return params;
        }
        /**
         * Get device webgl extensions
         * @param glw
         */
        function getWebGlExtensions(glw) {
          var extensions = {
            ANGLE_instanced_arrays: null,
            WEBGL_compressed_texture_s3tc: null,
            WEBGL_compressed_texture_astc: null,
            WEBGL_compressed_texture_etc: null,
            WEBGL_compressed_texture_etc1: null,
            WEBGL_compressed_texture_pvrtc: null,
            WEBKIT_WEBGL_compressed_texture_pvrtc: null,
            WEBGL_compressed_texture_s3tc_srgb: null,
            OES_vertex_array_object: null
          };
          // Map over all extensions and get them
          var keys = Object.keys(extensions);
          keys.forEach(function (key) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            extensions[key] = glw.getExtension(key);
          });
          return extensions;
        }
        /**
         * Allocate big memory chunk that we
         * can re-use to draw quads
         *
         * @param glw
         * @param size
         */
        function createIndexBuffer(glw, size) {
          var maxQuads = ~~(size / 80);
          var indices = new Uint16Array(maxQuads * 6);
          for (var i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
            indices[i] = j;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 2;
            indices[i + 4] = j + 1;
            indices[i + 5] = j + 3;
          }
          var buffer = glw.createBuffer();
          glw.elementArrayBufferData(buffer, indices, glw.STATIC_DRAW);
        }
        /**
         * Checks if an object is of type HTMLImageElement.
         * This is used because we cant check for HTMLImageElement directly when the
         * renderer is running in a seperate web worker context.
         *
         * @param obj
         * @returns
         */
        function isHTMLImageElement(obj) {
          return obj !== null && (_typeof(obj) === 'object' && obj.constructor && obj.constructor.name === 'HTMLImageElement' || typeof HTMLImageElement !== 'undefined' && obj instanceof HTMLImageElement);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var TRANSPARENT_TEXTURE_DATA = new Uint8Array([0, 0, 0, 0]);
        /**
         * A wrapper around a WebGLTexture that handles loading the texture data
         * from a Texture source and uploading it to the GPU as well as freeing
         * the uploaded texture.
         *
         * @remarks
         * When accessing the ctxTexture property, the texture will be loaded if
         * it hasn't been already. ctxTexture will always return a valid WebGLTexture
         * and trigger the loading/uploading of the texture's data if it hasn't been
         * loaded yet.
         */
        var WebGlCoreCtxTexture = /*#__PURE__*/function (_CoreContextTexture2) {
          function WebGlCoreCtxTexture(glw, memManager, textureSource) {
            var _this49;
            _classCallCheck(this, WebGlCoreCtxTexture);
            _this49 = _callSuper(this, WebGlCoreCtxTexture, [memManager, textureSource]);
            _defineProperty(_this49, "glw", void 0);
            _defineProperty(_this49, "_nativeCtxTexture", null);
            _defineProperty(_this49, "_w", 0);
            _defineProperty(_this49, "_h", 0);
            _this49.glw = glw;
            return _this49;
          }
          /**
           * GL error check with direct state marking
           * Uses cached error result to minimize function calls
           */
          _inherits(WebGlCoreCtxTexture, _CoreContextTexture2);
          return _createClass(WebGlCoreCtxTexture, [{
            key: "checkGLError",
            value: function checkGLError() {
              // Skip if already failed to prevent double-processing
              if (this.state === 'failed') {
                return true;
              }
              var error = this.glw.getError();
              if (error !== 0) {
                this.state = 'failed';
                this.textureSource.setState('failed', new Error("WebGL Error: ".concat(error)));
                return true;
              }
              return false;
            }
          }, {
            key: "ctxTexture",
            get: function get() {
              if (this.state === 'freed') {
                this.load();
                return null;
              }
              assertTruthy(this._nativeCtxTexture);
              return this._nativeCtxTexture;
            }
          }, {
            key: "w",
            get: function get() {
              return this._w;
            }
          }, {
            key: "h",
            get: function get() {
              return this._h;
            }
            /**
             * Load the texture data from the Texture source and upload it to the GPU
             *
             * @remarks
             * This method is called automatically when accessing the ctxTexture property
             * if the texture hasn't been loaded yet. But it can also be called manually
             * to force the texture to be pre-loaded prior to accessing the ctxTexture
             * property.
             */
          }, {
            key: "load",
            value: (function () {
              var _load = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14() {
                var _yield$this$onLoadReq, width, height, _t10;
                return _regenerator().w(function (_context14) {
                  while (1) switch (_context14.p = _context14.n) {
                    case 0:
                      if (!(this.state === 'loading' || this.state === 'loaded')) {
                        _context14.n = 1;
                        break;
                      }
                      return _context14.a(2, Promise.resolve());
                    case 1:
                      this.state = 'loading';
                      this.textureSource.setState('loading');
                      // Await the native texture creation to ensure GPU buffer is fully allocated
                      this._nativeCtxTexture = this.createNativeCtxTexture();
                      if (!(this._nativeCtxTexture === null)) {
                        _context14.n = 2;
                        break;
                      }
                      this.state = 'failed';
                      this.textureSource.setState('failed', new Error('WebGL Texture creation failed'));
                      return _context14.a(2);
                    case 2:
                      _context14.p = 2;
                      _context14.n = 3;
                      return this.onLoadRequest();
                    case 3:
                      _yield$this$onLoadReq = _context14.v;
                      width = _yield$this$onLoadReq.width;
                      height = _yield$this$onLoadReq.height;
                      if (!(this.state === 'freed')) {
                        _context14.n = 4;
                        break;
                      }
                      return _context14.a(2);
                    case 4:
                      this.state = 'loaded';
                      this._w = width;
                      this._h = height;
                      // Update the texture source's width and height so that it can be used
                      // for rendering.
                      this.textureSource.setState('loaded', {
                        width: width,
                        height: height
                      });
                      this.textureSource.freeTextureData();
                      _context14.n = 7;
                      break;
                    case 5:
                      _context14.p = 5;
                      _t10 = _context14.v;
                      if (!(this.state === 'freed')) {
                        _context14.n = 6;
                        break;
                      }
                      return _context14.a(2);
                    case 6:
                      // Ensure texture is marked as failed
                      this.state = 'failed';
                      this.textureSource.setState('failed');
                    case 7:
                      return _context14.a(2);
                  }
                }, _callee14, this, [[2, 5]]);
              }));
              function load() {
                return _load.apply(this, arguments);
              }
              return load;
            }()
            /**
             * Called when the texture data needs to be loaded and uploaded to a texture
             */
            )
          }, {
            key: "onLoadRequest",
            value: (function () {
              var _onLoadRequest = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
                var glw, textureData, width, height, tdata, format, formatBytes, memoryPadding, _mipmaps$, mipmaps, _tdata$width, _width, _tdata$height, _height, type, glInternalFormat, view;
                return _regenerator().w(function (_context15) {
                  while (1) switch (_context15.n) {
                    case 0:
                      glw = this.glw;
                      textureData = this.textureSource.textureData; // Early return if texture is already failed
                      if (!(this.state === 'failed')) {
                        _context15.n = 1;
                        break;
                      }
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 1:
                      if (!(textureData === null || this._nativeCtxTexture === null)) {
                        _context15.n = 2;
                        break;
                      }
                      this.state = 'failed';
                      this.textureSource.setState('failed', new Error('No texture data available'));
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 2:
                      // Set to a 1x1 transparent texture
                      glw.texImage2D(0, glw.RGBA, 1, 1, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                      this.setTextureMemUse(TRANSPARENT_TEXTURE_DATA.byteLength);
                      width = 0;
                      height = 0;
                      glw.activeTexture(0);
                      // High-performance error check - single call, direct state marking
                      if (!(this.checkGLError() === true)) {
                        _context15.n = 3;
                        break;
                      }
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 3:
                      tdata = textureData.data;
                      format = glw.RGBA;
                      formatBytes = 4;
                      memoryPadding = 1.1; // Add padding to account for GPU Padding
                      // If textureData is null, the texture is empty (0, 0) and we don't need to
                      // upload any data to the GPU.
                      if (!(typeof ImageBitmap !== 'undefined' && tdata instanceof ImageBitmap || tdata instanceof ImageData ||
                      // not using typeof HTMLImageElement due to web worker
                      isHTMLImageElement(tdata))) {
                        _context15.n = 5;
                        break;
                      }
                      width = tdata.width;
                      height = tdata.height;
                      glw.bindTexture(this._nativeCtxTexture);
                      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
                      glw.texImage2D(0, format, format, glw.UNSIGNED_BYTE, tdata);
                      // Check for errors after image upload operations
                      if (!(this.checkGLError() === true)) {
                        _context15.n = 4;
                        break;
                      }
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 4:
                      this.setTextureMemUse(height * width * formatBytes * memoryPadding);
                      _context15.n = 10;
                      break;
                    case 5:
                      if (!(tdata && 'mipmaps' in tdata && tdata.mipmaps)) {
                        _context15.n = 7;
                        break;
                      }
                      mipmaps = tdata.mipmaps, _tdata$width = tdata.width, _width = _tdata$width === void 0 ? 0 : _tdata$width, _tdata$height = tdata.height, _height = _tdata$height === void 0 ? 0 : _tdata$height, type = tdata.type, glInternalFormat = tdata.glInternalFormat;
                      view = type === 'ktx' ? new DataView((_mipmaps$ = mipmaps[0]) !== null && _mipmaps$ !== void 0 ? _mipmaps$ : new ArrayBuffer(0)) : mipmaps[0];
                      glw.bindTexture(this._nativeCtxTexture);
                      glw.compressedTexImage2D(0, glInternalFormat, _width, _height, 0, view);
                      glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
                      glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
                      glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
                      glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
                      // Check for errors after compressed texture operations
                      if (!(this.checkGLError() === true)) {
                        _context15.n = 6;
                        break;
                      }
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 6:
                      this.setTextureMemUse(view.byteLength);
                      _context15.n = 10;
                      break;
                    case 7:
                      if (!(tdata && tdata instanceof Uint8Array)) {
                        _context15.n = 9;
                        break;
                      }
                      // Color Texture
                      width = 1;
                      height = 1;
                      glw.bindTexture(this._nativeCtxTexture);
                      glw.pixelStorei(glw.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !!textureData.premultiplyAlpha);
                      glw.texImage2D(0, format, width, height, 0, format, glw.UNSIGNED_BYTE, tdata);
                      // Check for errors after color texture operations
                      if (!(this.checkGLError() === true)) {
                        _context15.n = 8;
                        break;
                      }
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 8:
                      this.setTextureMemUse(width * height * formatBytes);
                      _context15.n = 10;
                      break;
                    case 9:
                      console.error("WebGlCoreCtxTexture.onLoadRequest: Unexpected textureData returned", textureData);
                      this.state = 'failed';
                      this.textureSource.setState('failed', new Error('Unexpected texture data'));
                      return _context15.a(2, {
                        width: 0,
                        height: 0
                      });
                    case 10:
                      return _context15.a(2, {
                        width: width,
                        height: height
                      });
                  }
                }, _callee15, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest.apply(this, arguments);
              }
              return onLoadRequest;
            }()
            /**
             * Free the WebGLTexture from the GPU
             *
             * @returns
             */
            )
          }, {
            key: "free",
            value: function free() {
              if (this.state === 'freed') {
                return;
              }
              this.state = 'freed';
              this.textureSource.setState('freed');
              this.release();
            }
            /**
             * Release the WebGLTexture from the GPU without changing state
             */
          }, {
            key: "release",
            value: function release() {
              this._w = 0;
              this._h = 0;
              if (this._nativeCtxTexture !== null) {
                this.glw.deleteTexture(this._nativeCtxTexture);
                this.setTextureMemUse(0);
                this._nativeCtxTexture = null;
              }
              // if the texture still has source data, free it
              this.textureSource.freeTextureData();
            }
            /**
             * Create native context texture asynchronously
             *
             * @remarks
             * When this method resolves, the returned texture will be bound to the GL context state
             * and fully ready for use. This ensures proper GPU resource allocation timing.
             *
             * @returns Promise that resolves to the native WebGL texture or null on failure
             */
          }, {
            key: "createNativeCtxTexture",
            value: function createNativeCtxTexture() {
              var glw = this.glw;
              var nativeTexture = glw.createTexture();
              if (!nativeTexture) {
                return null;
              }
              // On initial load request, create a 1x1 transparent texture to use until
              // the texture data is finally loaded.
              glw.activeTexture(0);
              glw.bindTexture(nativeTexture);
              // linear texture filtering
              glw.texParameteri(glw.TEXTURE_MAG_FILTER, glw.LINEAR);
              glw.texParameteri(glw.TEXTURE_MIN_FILTER, glw.LINEAR);
              // texture wrapping method
              glw.texParameteri(glw.TEXTURE_WRAP_S, glw.CLAMP_TO_EDGE);
              glw.texParameteri(glw.TEXTURE_WRAP_T, glw.CLAMP_TO_EDGE);
              var error = glw.getError();
              if (error !== 0) {
                return null;
              }
              return nativeTexture;
            }
          }]);
        }(CoreContextTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreCtxSubTexture = /*#__PURE__*/function (_WebGlCoreCtxTexture2) {
          function WebGlCoreCtxSubTexture(glw, memManager, textureSource) {
            _classCallCheck(this, WebGlCoreCtxSubTexture);
            return _callSuper(this, WebGlCoreCtxSubTexture, [glw, memManager, textureSource]);
          }
          _inherits(WebGlCoreCtxSubTexture, _WebGlCoreCtxTexture2);
          return _createClass(WebGlCoreCtxSubTexture, [{
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16() {
                var _props$data2, _props$data3;
                var props;
                return _regenerator().w(function (_context16) {
                  while (1) switch (_context16.n) {
                    case 0:
                      props = this.textureSource.textureData;
                      if (!(props.data instanceof Uint8Array)) {
                        _context16.n = 1;
                        break;
                      }
                      return _context16.a(2, {
                        width: 1,
                        height: 1
                      });
                    case 1:
                      return _context16.a(2, {
                        width: ((_props$data2 = props.data) === null || _props$data2 === void 0 ? void 0 : _props$data2.width) || 0,
                        height: ((_props$data3 = props.data) === null || _props$data3 === void 0 ? void 0 : _props$data3.height) || 0
                      });
                  }
                }, _callee16, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest2.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }]);
        }(WebGlCoreCtxTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Represents a collection of WebGL Buffers along with their associated
         * vertex attribute formats.
         */
        var BufferCollection = /*#__PURE__*/function () {
          function BufferCollection(config) {
            _classCallCheck(this, BufferCollection);
            _defineProperty(this, "config", void 0);
            this.config = config;
          }
          /**
           * Get the WebGLBuffer associated with the given attribute name if it exists.
           *
           * @param attributeName
           * @returns
           */
          return _createClass(BufferCollection, [{
            key: "getBuffer",
            value: function getBuffer(attributeName) {
              var _this$config$find;
              return (_this$config$find = this.config.find(function (item) {
                return item.attributes[attributeName];
              })) === null || _this$config$find === void 0 ? void 0 : _this$config$find.buffer;
            }
            /**
             * Get the AttributeInfo associated with the given attribute name if it exists.
             *
             * @param attributeName
             * @returns
             */
          }, {
            key: "getAttributeInfo",
            value: function getAttributeInfo(attributeName) {
              var _this$config$find2;
              return (_this$config$find2 = this.config.find(function (item) {
                return item.attributes[attributeName];
              })) === null || _this$config$find2 === void 0 ? void 0 : _this$config$find2.attributes[attributeName];
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Generic WebGL Utility Functions
         *
         * @remarks
         * Nothing here should be coupled to Renderer logic / types.
         *
         * @param gl
         * @returns
         */
        function _isWebGl(gl) {
          return self.WebGL2RenderingContext && gl instanceof self.WebGL2RenderingContext;
        }

        /* eslint-disable @typescript-eslint/no-unsafe-return */
        /* eslint-disable @typescript-eslint/no-explicit-any */
        /* eslint-disable @typescript-eslint/no-unsafe-argument */
        /**
         * Optimized WebGL Context Wrapper
         *
         * @remarks
         * This class contains the subset of the WebGLRenderingContext & WebGL2RenderingContext
         * API that is used by the renderer. Select high volume WebGL methods include
         * caching optimizations to avoid making WebGL calls if the state is already set
         * to the desired value.
         *
         * While most methods contained are direct passthroughs to the WebGL context,
         * some methods combine multiple WebGL calls into one for convenience, modify
         * arguments to be more convenient, or are replaced by more specific methods.
         *
         * Not all methods are optimized. Only methods that are called frequently
         * and/or have a high cost are optimized.
         *
         * A subset of GLenum constants are also exposed as properties on this class
         * for convenience.
         */
        var WebGlContextWrapper = /*#__PURE__*/function () {
          //#endregion WebGL Enums
          function WebGlContextWrapper(gl) {
            var _this50 = this;
            _classCallCheck(this, WebGlContextWrapper);
            _defineProperty(this, "gl", void 0);
            //#region Cached WebGL State
            _defineProperty(this, "activeTextureUnit", 0);
            _defineProperty(this, "texture2dUnits", void 0);
            _defineProperty(this, "texture2dParams", new WeakMap());
            _defineProperty(this, "scissorEnabled", void 0);
            _defineProperty(this, "scissorX", void 0);
            _defineProperty(this, "scissorY", void 0);
            _defineProperty(this, "scissorWidth", void 0);
            _defineProperty(this, "scissorHeight", void 0);
            _defineProperty(this, "blendEnabled", void 0);
            _defineProperty(this, "blendSrcRgb", void 0);
            _defineProperty(this, "blendDstRgb", void 0);
            _defineProperty(this, "blendSrcAlpha", void 0);
            _defineProperty(this, "blendDstAlpha", void 0);
            _defineProperty(this, "boundArrayBuffer", void 0);
            _defineProperty(this, "boundElementArrayBuffer", void 0);
            _defineProperty(this, "curProgram", void 0);
            //#endregion Cached WebGL State
            //#region Canvas
            _defineProperty(this, "canvas", void 0);
            //#endregion Canvas
            //#region WebGL Enums
            _defineProperty(this, "MAX_RENDERBUFFER_SIZE", void 0);
            _defineProperty(this, "MAX_TEXTURE_SIZE", void 0);
            _defineProperty(this, "MAX_VIEWPORT_DIMS", void 0);
            _defineProperty(this, "MAX_VERTEX_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_COMBINED_TEXTURE_IMAGE_UNITS", void 0);
            _defineProperty(this, "MAX_VERTEX_ATTRIBS", void 0);
            _defineProperty(this, "MAX_VARYING_VECTORS", void 0);
            _defineProperty(this, "MAX_VERTEX_UNIFORM_VECTORS", void 0);
            _defineProperty(this, "MAX_FRAGMENT_UNIFORM_VECTORS", void 0);
            _defineProperty(this, "TEXTURE_MAG_FILTER", void 0);
            _defineProperty(this, "TEXTURE_MIN_FILTER", void 0);
            _defineProperty(this, "TEXTURE_WRAP_S", void 0);
            _defineProperty(this, "TEXTURE_WRAP_T", void 0);
            _defineProperty(this, "LINEAR", void 0);
            _defineProperty(this, "CLAMP_TO_EDGE", void 0);
            _defineProperty(this, "RGB", void 0);
            _defineProperty(this, "RGBA", void 0);
            _defineProperty(this, "UNSIGNED_BYTE", void 0);
            _defineProperty(this, "UNPACK_PREMULTIPLY_ALPHA_WEBGL", void 0);
            _defineProperty(this, "UNPACK_FLIP_Y_WEBGL", void 0);
            _defineProperty(this, "FLOAT", void 0);
            _defineProperty(this, "TRIANGLES", void 0);
            _defineProperty(this, "UNSIGNED_SHORT", void 0);
            _defineProperty(this, "ONE", void 0);
            _defineProperty(this, "ONE_MINUS_SRC_ALPHA", void 0);
            _defineProperty(this, "VERTEX_SHADER", void 0);
            _defineProperty(this, "FRAGMENT_SHADER", void 0);
            _defineProperty(this, "STATIC_DRAW", void 0);
            _defineProperty(this, "COMPILE_STATUS", void 0);
            _defineProperty(this, "LINK_STATUS", void 0);
            _defineProperty(this, "DYNAMIC_DRAW", void 0);
            _defineProperty(this, "COLOR_ATTACHMENT0", void 0);
            _defineProperty(this, "INVALID_ENUM", void 0);
            _defineProperty(this, "INVALID_OPERATION", void 0);
            this.gl = gl;
            // The following code extracts the current state of the WebGL context
            // to our local JavaScript cached version of it. This is so we can
            // avoid making WebGL calls if we don't need to.
            // We could assume that the WebGL context is in a default state, but
            // in the future we may want to support restoring a broken WebGL context
            // and this will help with that.
            this.activeTextureUnit = gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0;
            var maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            // save current texture units
            this.texture2dUnits = new Array(maxTextureUnits).fill(undefined).map(function (_, i) {
              _this50.activeTexture(i);
              return gl.getParameter(gl.TEXTURE_BINDING_2D);
            });
            // restore active texture unit
            this.activeTexture(this.activeTextureUnit);
            this.scissorEnabled = gl.isEnabled(gl.SCISSOR_TEST);
            var scissorBox = gl.getParameter(gl.SCISSOR_BOX);
            this.scissorX = scissorBox[0];
            this.scissorY = scissorBox[1];
            this.scissorWidth = scissorBox[2];
            this.scissorHeight = scissorBox[3];
            this.blendEnabled = gl.isEnabled(gl.BLEND);
            this.blendSrcRgb = gl.getParameter(gl.BLEND_SRC_RGB);
            this.blendDstRgb = gl.getParameter(gl.BLEND_DST_RGB);
            this.blendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
            this.blendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
            this.boundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
            this.boundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);
            this.curProgram = gl.getParameter(gl.CURRENT_PROGRAM);
            this.canvas = gl.canvas;
            // Extract GLenums
            this.MAX_RENDERBUFFER_SIZE = gl.MAX_RENDERBUFFER_SIZE;
            this.MAX_TEXTURE_SIZE = gl.MAX_TEXTURE_SIZE;
            this.MAX_VIEWPORT_DIMS = gl.MAX_VIEWPORT_DIMS;
            this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            this.MAX_TEXTURE_IMAGE_UNITS = gl.MAX_TEXTURE_IMAGE_UNITS;
            this.MAX_COMBINED_TEXTURE_IMAGE_UNITS = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS;
            this.MAX_VERTEX_ATTRIBS = gl.MAX_VERTEX_ATTRIBS;
            this.MAX_VARYING_VECTORS = gl.MAX_VARYING_VECTORS;
            this.MAX_VERTEX_UNIFORM_VECTORS = gl.MAX_VERTEX_UNIFORM_VECTORS;
            this.MAX_FRAGMENT_UNIFORM_VECTORS = gl.MAX_FRAGMENT_UNIFORM_VECTORS;
            this.TEXTURE_MAG_FILTER = gl.TEXTURE_MAG_FILTER;
            this.TEXTURE_MIN_FILTER = gl.TEXTURE_MIN_FILTER;
            this.TEXTURE_WRAP_S = gl.TEXTURE_WRAP_S;
            this.TEXTURE_WRAP_T = gl.TEXTURE_WRAP_T;
            this.LINEAR = gl.LINEAR;
            this.CLAMP_TO_EDGE = gl.CLAMP_TO_EDGE;
            this.RGB = gl.RGB;
            this.RGBA = gl.RGBA;
            this.UNSIGNED_BYTE = gl.UNSIGNED_BYTE;
            this.UNPACK_PREMULTIPLY_ALPHA_WEBGL = gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL;
            this.UNPACK_FLIP_Y_WEBGL = gl.UNPACK_FLIP_Y_WEBGL;
            this.FLOAT = gl.FLOAT;
            this.TRIANGLES = gl.TRIANGLES;
            this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
            this.ONE = gl.ONE;
            this.ONE_MINUS_SRC_ALPHA = gl.ONE_MINUS_SRC_ALPHA;
            this.MAX_VERTEX_TEXTURE_IMAGE_UNITS = gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS;
            this.TRIANGLES = gl.TRIANGLES;
            this.UNSIGNED_SHORT = gl.UNSIGNED_SHORT;
            this.VERTEX_SHADER = gl.VERTEX_SHADER;
            this.FRAGMENT_SHADER = gl.FRAGMENT_SHADER;
            this.STATIC_DRAW = gl.STATIC_DRAW;
            this.COMPILE_STATUS = gl.COMPILE_STATUS;
            this.LINK_STATUS = gl.LINK_STATUS;
            this.DYNAMIC_DRAW = gl.DYNAMIC_DRAW;
            this.COLOR_ATTACHMENT0 = gl.COLOR_ATTACHMENT0;
            this.INVALID_ENUM = gl.INVALID_ENUM;
            this.INVALID_OPERATION = gl.INVALID_OPERATION;
          }
          /**
           * Returns true if the WebGL context is WebGL2
           *
           * @returns
           */
          return _createClass(WebGlContextWrapper, [{
            key: "isWebGl2",
            value: function isWebGl2() {
              return _isWebGl(this.gl);
            }
            /**
             * ```
             * gl.activeTexture(textureUnit + gl.TEXTURE0);
             * ```
             *
             * @remarks
             * **WebGL Difference**: `textureUnit` is based from 0, not `gl.TEXTURE0`.
             *
             * @param textureUnit
             */
          }, {
            key: "activeTexture",
            value: function activeTexture(textureUnit) {
              var gl = this.gl;
              if (this.activeTextureUnit !== textureUnit) {
                gl.activeTexture(textureUnit + gl.TEXTURE0);
                this.activeTextureUnit = textureUnit;
              }
            }
            /**
             * ```
             * gl.bindTexture(gl.TEXTURE_2D, texture);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             *
             * @param texture
             */
          }, {
            key: "bindTexture",
            value: function bindTexture(texture) {
              var gl = this.gl,
                activeTextureUnit = this.activeTextureUnit,
                texture2dUnits = this.texture2dUnits;
              if (texture2dUnits[activeTextureUnit] === texture) {
                return;
              }
              texture2dUnits[activeTextureUnit] = texture;
              gl.bindTexture(this.gl.TEXTURE_2D, texture);
            }
          }, {
            key: "_getActiveTexture",
            value: function _getActiveTexture() {
              var activeTextureUnit = this.activeTextureUnit,
                texture2dUnits = this.texture2dUnits;
              return texture2dUnits[activeTextureUnit];
            }
            /**
             * ```
             * gl.texParameteri(gl.TEXTURE_2D, pname, param);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             *
             * @param pname
             * @param param
             * @returns
             */
          }, {
            key: "texParameteri",
            value: function texParameteri(pname, param) {
              var gl = this.gl,
                texture2dParams = this.texture2dParams;
              var activeTexture = this._getActiveTexture();
              if (!activeTexture) {
                throw new Error('No active texture');
              }
              var textureParams = texture2dParams.get(activeTexture);
              if (!textureParams) {
                textureParams = {};
                texture2dParams.set(activeTexture, textureParams);
              }
              if (textureParams[pname] === param) {
                return;
              }
              textureParams[pname] = param;
              gl.texParameteri(gl.TEXTURE_2D, pname, param);
            }
          }, {
            key: "texImage2D",
            value: function texImage2D(level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels) {
              var gl = this.gl;
              if (format) {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource, format, type, pixels);
              } else {
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, widthOrFormat, heightOrType, borderOrSource);
              }
            }
            /**
             * ```
             * gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, data);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             */
          }, {
            key: "compressedTexImage2D",
            value: function compressedTexImage2D(level, internalformat, width, height, border, data) {
              var gl = this.gl;
              gl.compressedTexImage2D(gl.TEXTURE_2D, level, internalformat, width, height, border, data);
            }
            /**
             * ```
             * gl.pixelStorei(pname, param);
             * ```
             *
             * @param pname
             * @param param
             */
          }, {
            key: "pixelStorei",
            value: function pixelStorei(pname, param) {
              var gl = this.gl;
              gl.pixelStorei(pname, param);
            }
            /**
             * ```
             * gl.generateMipmap(gl.TEXTURE_2D);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.TEXTURE_2D`
             */
          }, {
            key: "generateMipmap",
            value: function generateMipmap() {
              var gl = this.gl;
              gl.generateMipmap(gl.TEXTURE_2D);
            }
            /**
             * ```
             * gl.createTexture();
             * ```
             *
             * @returns
             */
          }, {
            key: "createTexture",
            value: function createTexture() {
              var gl = this.gl;
              return gl.createTexture();
            }
            /**
             * ```
             * gl.deleteTexture(texture);
             * ```
             *
             * @param texture
             */
          }, {
            key: "deleteTexture",
            value: function deleteTexture(texture) {
              var gl = this.gl;
              if (texture) {
                this.texture2dParams.delete(texture);
              }
              gl.deleteTexture(texture);
            }
            /**
             * ```
             * gl.deleteFramebuffer(framebuffer);
             *
             * @param framebuffer
             */
          }, {
            key: "deleteFramebuffer",
            value: function deleteFramebuffer(framebuffer) {
              this.gl.deleteFramebuffer(framebuffer);
            }
            /**
             * ```
             * gl.viewport(x, y, width, height);
             * ```
             */
          }, {
            key: "viewport",
            value: function viewport(x, y, width, height) {
              var gl = this.gl;
              gl.viewport(x, y, width, height);
            }
            /**
             * ```
             * gl.clearColor(red, green, blue, alpha);
             * ```
             *
             * @param red
             * @param green
             * @param blue
             * @param alpha
             */
          }, {
            key: "clearColor",
            value: function clearColor(red, green, blue, alpha) {
              var gl = this.gl;
              gl.clearColor(red, green, blue, alpha);
            }
            /**
             * ```
             * gl["enable"|"disable"](gl.SCISSOR_TEST);
             * ```
             * @param enable
             */
          }, {
            key: "setScissorTest",
            value: function setScissorTest(enable) {
              var gl = this.gl,
                scissorEnabled = this.scissorEnabled;
              if (enable === scissorEnabled) {
                return;
              }
              if (enable) {
                gl.enable(gl.SCISSOR_TEST);
              } else {
                gl.disable(gl.SCISSOR_TEST);
              }
              this.scissorEnabled = enable;
            }
            /**
             * ```
             * gl.scissor(x, y, width, height);
             * ```
             *
             * @param x
             * @param y
             * @param width
             * @param height
             */
          }, {
            key: "scissor",
            value: function scissor(x, y, width, height) {
              var gl = this.gl,
                scissorX = this.scissorX,
                scissorY = this.scissorY,
                scissorWidth = this.scissorWidth,
                scissorHeight = this.scissorHeight;
              if (x !== scissorX || y !== scissorY || width !== scissorWidth || height !== scissorHeight) {
                gl.scissor(x, y, width, height);
                this.scissorX = x;
                this.scissorY = y;
                this.scissorWidth = width;
                this.scissorHeight = height;
              }
            }
            /**
             * ```
             * gl["enable"|"disable"](gl.BLEND);
             * ```
             *
             * @param blend
             * @returns
             */
          }, {
            key: "setBlend",
            value: function setBlend(blend) {
              var gl = this.gl,
                blendEnabled = this.blendEnabled;
              if (blend === blendEnabled) {
                return;
              }
              if (blend) {
                gl.enable(gl.BLEND);
              } else {
                gl.disable(gl.BLEND);
              }
              this.blendEnabled = blend;
            }
            /**
             * ```
             * gl.blendFunc(src, dst);
             * ```
             *
             * @param src
             * @param dst
             */
          }, {
            key: "blendFunc",
            value: function blendFunc(src, dst) {
              var gl = this.gl,
                blendSrcRgb = this.blendSrcRgb,
                blendDstRgb = this.blendDstRgb,
                blendSrcAlpha = this.blendSrcAlpha,
                blendDstAlpha = this.blendDstAlpha;
              if (src !== blendSrcRgb || dst !== blendDstRgb || src !== blendSrcAlpha || dst !== blendDstAlpha) {
                gl.blendFunc(src, dst);
                this.blendSrcRgb = src;
                this.blendDstRgb = dst;
                this.blendSrcAlpha = src;
                this.blendDstAlpha = dst;
              }
            }
            /**
             * ```
             * gl.createBuffer();
             * ```
             *
             * @returns
             */
          }, {
            key: "createBuffer",
            value: function createBuffer() {
              var gl = this.gl;
              return gl.createBuffer();
            }
            /**
             * ```
             * gl.createFramebuffer();
             * ```
             * @returns
             */
          }, {
            key: "createFramebuffer",
            value: function createFramebuffer() {
              var gl = this.gl;
              return gl.createFramebuffer();
            }
            /**
             * ```
             * gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
             * ```
             *
             * @param framebuffer
             */
          }, {
            key: "bindFramebuffer",
            value: function bindFramebuffer(framebuffer) {
              var gl = this.gl;
              gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            }
            /**
             * ```
             * gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
             * ```
             * @remarks
             * **WebGL Difference**: Bind target is always `gl.FRAMEBUFFER` and textarget is always `gl.TEXTURE_2D`
             */
          }, {
            key: "framebufferTexture2D",
            value: function framebufferTexture2D(attachment, texture, level) {
              var gl = this.gl;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, level);
            }
            /**
             * ```
             * gl.clear(gl.COLOR_BUFFER_BIT);
             * ```
             *
             * @remarks
             * **WebGL Difference**: Clear mask is always `gl.COLOR_BUFFER_BIT`
             */
          }, {
            key: "clear",
            value: function clear() {
              var gl = this.gl;
              gl.clear(gl.COLOR_BUFFER_BIT);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
             * gl.bufferData(gl.ARRAY_BUFFER, data, usage);
             * ```
             *
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
             *
             * @param buffer
             * @param data
             * @param usage
             */
          }, {
            key: "arrayBufferData",
            value: function arrayBufferData(buffer, data, usage) {
              var gl = this.gl,
                boundArrayBuffer = this.boundArrayBuffer;
              if (boundArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                this.boundArrayBuffer = buffer;
              }
              gl.bufferData(gl.ARRAY_BUFFER, data, usage);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
             * gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
             * ```
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.bufferData` are combined into one function.
             *
             * @param buffer
             * @param data
             * @param usage
             */
          }, {
            key: "elementArrayBufferData",
            value: function elementArrayBufferData(buffer, data, usage) {
              var gl = this.gl,
                boundElementArrayBuffer = this.boundElementArrayBuffer;
              if (boundElementArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                this.boundElementArrayBuffer = buffer;
              }
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, usage);
            }
            /**
             * ```
             * gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
             * gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
             * ```
             *
             * @remarks
             * **WebGL Combo**: `gl.bindBuffer` and `gl.vertexAttribPointer` are combined into one function.
             *
             * @param buffer
             * @param index
             * @param size
             * @param type
             * @param normalized
             * @param stride
             * @param offset
             */
          }, {
            key: "vertexAttribPointer",
            value: function vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
              var gl = this.gl,
                boundArrayBuffer = this.boundArrayBuffer;
              if (boundArrayBuffer !== buffer) {
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                this.boundArrayBuffer = buffer;
              }
              gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
            }
            /**
             * ```
             * gl.useProgram(program);
             * ```
             *
             * @param program
             * @returns
             */
          }, {
            key: "useProgram",
            value: function useProgram(program) {
              var gl = this.gl,
                curProgram = this.curProgram;
              if (curProgram === program) {
                return;
              }
              gl.useProgram(program);
              this.curProgram = program;
            }
            /**
             * Sets the value of a single float uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The value to set.
             */
          }, {
            key: "uniform1f",
            value: function uniform1f(location, v0) {
              var gl = this.gl;
              gl.uniform1f(location, v0);
            }
            /**
             * Sets the value of a float array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of values to set.
             */
          }, {
            key: "uniform1fv",
            value: function uniform1fv(location, value) {
              var gl = this.gl;
              gl.uniform1fv(location, value);
            }
            /**
             * Sets the value of a single integer uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The value to set.
             */
          }, {
            key: "uniform1i",
            value: function uniform1i(location, v0) {
              var gl = this.gl;
              gl.uniform1i(location, v0);
            }
            /**
             * Sets the value of an integer array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of values to set.
             */
          }, {
            key: "uniform1iv",
            value: function uniform1iv(location, value) {
              var gl = this.gl;
              gl.uniform1iv(location, value);
            }
            /**
             * Sets the value of a vec2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             */
          }, {
            key: "uniform2f",
            value: function uniform2f(location, v0, v1) {
              var gl = this.gl;
              gl.uniform2f(location, v0, v1);
            }
            /**
             * Sets the value of a vec2 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec2 values to set.
             */
          }, {
            key: "uniform2fv",
            value: function uniform2fv(location, value) {
              var gl = this.gl;
              gl.uniform2fv(location, value);
            }
            /**
             * Sets the value of a ivec2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             */
          }, {
            key: "uniform2i",
            value: function uniform2i(location, v0, v1) {
              var gl = this.gl;
              gl.uniform2i(location, v0, v1);
            }
            /**
             * Sets the value of an ivec2 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec2 values to set.
             */
          }, {
            key: "uniform2iv",
            value: function uniform2iv(location, value) {
              var gl = this.gl;
              gl.uniform2iv(location, value);
            }
            /**
             * Sets the value of a vec3 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             */
          }, {
            key: "uniform3f",
            value: function uniform3f(location, v0, v1, v2) {
              var gl = this.gl;
              gl.uniform3f(location, v0, v1, v2);
            }
            /**
             * Sets the value of a vec3 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec3 values to set.
             */
          }, {
            key: "uniform3fv",
            value: function uniform3fv(location, value) {
              var gl = this.gl;
              gl.uniform3fv(location, value);
            }
            /**
             * Sets the value of a ivec3 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             */
          }, {
            key: "uniform3i",
            value: function uniform3i(location, v0, v1, v2) {
              var gl = this.gl;
              gl.uniform3i(location, v0, v1, v2);
            }
            /**
             * Sets the value of an ivec3 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec3 values to set.
             */
          }, {
            key: "uniform3iv",
            value: function uniform3iv(location, value) {
              var gl = this.gl;
              gl.uniform3iv(location, value);
            }
            /**
             * Sets the value of a vec4 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             * @param v3 - The fourth component of the vector.
             */
          }, {
            key: "uniform4f",
            value: function uniform4f(location, v0, v1, v2, v3) {
              var gl = this.gl;
              gl.uniform4f(location, v0, v1, v2, v3);
            }
            /**
             * Sets the value of a vec4 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of vec4 values to set.
             */
          }, {
            key: "uniform4fv",
            value: function uniform4fv(location, value) {
              var gl = this.gl;
              gl.uniform4fv(location, value);
            }
            /**
             * Sets the value of a ivec4 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param v0 - The first component of the vector.
             * @param v1 - The second component of the vector.
             * @param v2 - The third component of the vector.
             * @param v3 - The fourth component of the vector.
             */
          }, {
            key: "uniform4i",
            value: function uniform4i(location, v0, v1, v2, v3) {
              var gl = this.gl;
              gl.uniform4i(location, v0, v1, v2, v3);
            }
            /**
             * Sets the value of an ivec4 array uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param value - The array of ivec4 values to set.
             */
          }, {
            key: "uniform4iv",
            value: function uniform4iv(location, value) {
              var gl = this.gl;
              gl.uniform4iv(location, value);
            }
            /**
             * Sets the value of a mat2 uniform variable.
             *
             * @param location - The location of the uniform variable.
             * @param transpose - Whether to transpose the matrix.
             * @param value - The array of mat2 values to set.
             */
          }, {
            key: "uniformMatrix2fv",
            value: function uniformMatrix2fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix2fv(location, false, value);
            }
            /**
             * Sets the value of a mat2 uniform variable.
             * @param location - The location of the uniform variable.
             * @param value - The array of mat2 values to set.
             */
          }, {
            key: "uniformMatrix3fv",
            value: function uniformMatrix3fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix3fv(location, false, value);
            }
            /**
             * Sets the value of a mat4 uniform variable.
             * @param location - The location of the uniform variable.
             * @param value - The array of mat4 values to set.
             */
          }, {
            key: "uniformMatrix4fv",
            value: function uniformMatrix4fv(location, value) {
              var gl = this.gl;
              gl.uniformMatrix4fv(location, false, value);
            }
            /**
             * ```
             * gl.getParameter(pname);
             * ```
             *
             * @param pname
             * @returns
             */
          }, {
            key: "getParameter",
            value: function getParameter(pname) {
              var gl = this.gl;
              return gl.getParameter(pname);
            }
            /**
             * ```
             * gl.drawElements(mode, count, type, offset);
             * ```
             *
             * @param mode
             * @param count
             * @param type
             * @param offset
             */
          }, {
            key: "drawElements",
            value: function drawElements(mode, count, type, offset) {
              var gl = this.gl;
              gl.drawElements(mode, count, type, offset);
            }
            /**
             * ```
             * gl.drawArrays(mode, first, count);
             * ```
             *
             * @param name
             * @returns
             */
          }, {
            key: "getExtension",
            value: function getExtension(name) {
              var gl = this.gl;
              return gl.getExtension(name);
            }
            /**
             * ```
             * gl.getError(type);
             * ```
             *
             * @returns
             */
          }, {
            key: "getError",
            value: function getError() {
              var gl = this.gl;
              return gl.getError();
            }
            /**
             * ```
             * gl.createVertexArray();
             * ```
             *
             * @returns
             */
          }, {
            key: "createVertexArray",
            value: function createVertexArray() {
              var gl = this.gl;
              return gl.createVertexArray();
            }
            /**
             * ```
             * gl.bindVertexArray(vertexArray);
             * ```
             *
             * @param vertexArray
             */
          }, {
            key: "bindVertexArray",
            value: function bindVertexArray(vertexArray) {
              var gl = this.gl;
              gl.bindVertexArray(vertexArray);
            }
            /**
             * ```
             * gl.getAttribLocation(program, name);
             * ```
             *
             * @param program
             * @param name
             * @returns
             */
          }, {
            key: "getAttribLocation",
            value: function getAttribLocation(program, name) {
              var gl = this.gl;
              return gl.getAttribLocation(program, name);
            }
            /**
             * ```
             * gl.getUniformLocation(program, name);
             * ```
             *
             * @param program
             * @param name
             * @returns
             */
          }, {
            key: "getUniformLocation",
            value: function getUniformLocation(program, name) {
              var gl = this.gl;
              return gl.getUniformLocation(program, name);
            }
            /**
             * ```
             * gl.enableVertexAttribArray(index);
             * ```
             *
             * @param index
             */
          }, {
            key: "enableVertexAttribArray",
            value: function enableVertexAttribArray(index) {
              var gl = this.gl;
              gl.enableVertexAttribArray(index);
            }
            /**
             * ```
             * gl.disableVertexAttribArray(index);
             * ```
             *
             * @param index
             */
          }, {
            key: "disableVertexAttribArray",
            value: function disableVertexAttribArray(index) {
              var gl = this.gl;
              gl.disableVertexAttribArray(index);
            }
            /**
             * ```
             * gl.createShader(type);
             * ```
             *
             * @param type
             * @returns
             */
          }, {
            key: "createShader",
            value: function createShader(type) {
              var gl = this.gl;
              return gl.createShader(type);
            }
            /**
             * ```
             * gl.compileShader(shader);
             * ```
             *
             * @param shader
             * @returns
             */
          }, {
            key: "compileShader",
            value: function compileShader(shader) {
              var gl = this.gl;
              gl.compileShader(shader);
            }
            /**
             * ```
             * gl.attachShader(program, shader);
             * ```
             *
             * @param program
             * @param shader
             */
          }, {
            key: "attachShader",
            value: function attachShader(program, shader) {
              var gl = this.gl;
              gl.attachShader(program, shader);
            }
            /**
             * ```
             * gl.linkProgram(program);
             * ```
             *
             * @param program
             */
          }, {
            key: "linkProgram",
            value: function linkProgram(program) {
              var gl = this.gl;
              gl.linkProgram(program);
            }
            /**
             * ```
             * gl.deleteProgram(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "deleteProgram",
            value: function deleteProgram(shader) {
              var gl = this.gl;
              gl.deleteProgram(shader);
            }
            /**
             * ```
             * gl.getShaderParameter(shader, pname);
             * ```
             *
             * @param shader
             * @param pname
             */
          }, {
            key: "getShaderParameter",
            value: function getShaderParameter(shader, pname) {
              var gl = this.gl;
              return gl.getShaderParameter(shader, pname);
            }
            /**
             * ```
             * gl.getShaderInfoLog(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "getShaderInfoLog",
            value: function getShaderInfoLog(shader) {
              var gl = this.gl;
              return gl.getShaderInfoLog(shader);
            }
            /**
             * ```
             * gl.createProgram();
             * ```
             *
             * @returns
             */
          }, {
            key: "createProgram",
            value: function createProgram() {
              var gl = this.gl;
              return gl.createProgram();
            }
            /**
             * ```
             * gl.getProgramParameter(program, pname);
             * ```
             *
             * @param program
             * @param pname
             * @returns
             */
          }, {
            key: "getProgramParameter",
            value: function getProgramParameter(program, pname) {
              var gl = this.gl;
              return gl.getProgramParameter(program, pname);
            }
            /**
             * ```
             * gl.getProgramInfoLog(program);
             * ```
             *
             * @param program
             * @returns
             */
          }, {
            key: "getProgramInfoLog",
            value: function getProgramInfoLog(program) {
              var gl = this.gl;
              return gl.getProgramInfoLog(program);
            }
            /**
             * ```
             * gl.shaderSource(shader, source);
             * ```
             *
             * @param shader
             * @param source
             */
          }, {
            key: "shaderSource",
            value: function shaderSource(shader, source) {
              var gl = this.gl;
              gl.shaderSource(shader, source);
            }
            /**
             * ```
             * gl.deleteShader(shader);
             * ```
             *
             * @param shader
             */
          }, {
            key: "deleteShader",
            value: function deleteShader(shader) {
              var gl = this.gl;
              gl.deleteShader(shader);
            }
            /**
             * Check for WebGL errors and return error information
             * @param operation Description of the operation for error reporting
             * @returns Object with error information or null if no error
             */
          }, {
            key: "checkError",
            value: function checkError(operation) {
              var error = this.getError();
              if (error !== 0) {
                // 0 is GL_NO_ERROR
                var errorName = 'UNKNOWN_ERROR';
                switch (error) {
                  case this.INVALID_ENUM:
                    errorName = 'INVALID_ENUM';
                    break;
                  case 0x0501:
                    // GL_INVALID_VALUE
                    errorName = 'INVALID_VALUE';
                    break;
                  case this.INVALID_OPERATION:
                    errorName = 'INVALID_OPERATION';
                    break;
                  case 0x0505:
                    // GL_OUT_OF_MEMORY
                    errorName = 'OUT_OF_MEMORY';
                    break;
                  case 0x9242:
                    // GL_CONTEXT_LOST_WEBGL
                    errorName = 'CONTEXT_LOST_WEBGL';
                    break;
                }
                var message = "WebGL ".concat(errorName, " (0x").concat(error.toString(16), ") during ").concat(operation);
                return {
                  error: error,
                  errorName: errorName,
                  message: message
                };
              }
              return null;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2024 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WebGlCoreCtxRenderTexture = /*#__PURE__*/function (_WebGlCoreCtxTexture3) {
          function WebGlCoreCtxRenderTexture(glw, memManager, textureSource) {
            var _this51;
            _classCallCheck(this, WebGlCoreCtxRenderTexture);
            _this51 = _callSuper(this, WebGlCoreCtxRenderTexture, [glw, memManager, textureSource]);
            _defineProperty(_this51, "framebuffer", null);
            return _this51;
          }
          _inherits(WebGlCoreCtxRenderTexture, _WebGlCoreCtxTexture3);
          return _createClass(WebGlCoreCtxRenderTexture, [{
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17() {
                var glw, nativeTexture, _this$textureSource, width, height;
                return _regenerator().w(function (_context17) {
                  while (1) switch (_context17.n) {
                    case 0:
                      glw = this.glw;
                      nativeTexture = this._nativeCtxTexture = this.createNativeCtxTexture();
                      if (nativeTexture) {
                        _context17.n = 1;
                        break;
                      }
                      throw new Error('Failed to create native texture for RenderTexture');
                    case 1:
                      _this$textureSource = this.textureSource, width = _this$textureSource.width, height = _this$textureSource.height; // Create Framebuffer object
                      this.framebuffer = glw.createFramebuffer();
                      // Set the dimensions of the render texture
                      glw.texImage2D(0, glw.RGBA, width, height, 0, glw.RGBA, glw.UNSIGNED_BYTE, null);
                      // Update the texture memory manager
                      this.setTextureMemUse(width * height * 4);
                      // Bind the framebuffer
                      glw.bindFramebuffer(this.framebuffer);
                      // Attach the texture to the framebuffer
                      glw.framebufferTexture2D(glw.COLOR_ATTACHMENT0, nativeTexture, 0);
                      // Unbind the framebuffer
                      glw.bindFramebuffer(null);
                      return _context17.a(2, {
                        width: width,
                        height: height
                      });
                  }
                }, _callee17, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest3.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }, {
            key: "free",
            value: function free() {
              _superPropGet(WebGlCoreCtxRenderTexture, "free", this, 3)([]);
              // Delete the framebuffer
              this.glw.deleteFramebuffer(this.framebuffer);
              this.framebuffer = null;
            }
          }]);
        }(WebGlCoreCtxTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WORDS_PER_QUAD = 24;
        var WebGlCoreRenderer = /*#__PURE__*/function (_CoreRenderer2) {
          function WebGlCoreRenderer(options) {
            var _this52;
            _classCallCheck(this, WebGlCoreRenderer);
            _this52 = _callSuper(this, WebGlCoreRenderer, [options]);
            //// WebGL Native Context and Data
            _defineProperty(_this52, "glw", void 0);
            _defineProperty(_this52, "system", void 0);
            //// Persistent data
            _defineProperty(_this52, "quadBuffer", void 0);
            _defineProperty(_this52, "fQuadBuffer", void 0);
            _defineProperty(_this52, "uiQuadBuffer", void 0);
            _defineProperty(_this52, "renderOps", []);
            //// Render Op / Buffer Filling State
            _defineProperty(_this52, "curBufferIdx", 0);
            _defineProperty(_this52, "curRenderOp", null);
            _defineProperty(_this52, "rttNodes", []);
            _defineProperty(_this52, "activeRttNode", null);
            //// Default Shader
            _defineProperty(_this52, "defShaderCtrl", void 0);
            _defineProperty(_this52, "defaultShader", void 0);
            _defineProperty(_this52, "quadBufferCollection", void 0);
            _defineProperty(_this52, "clearColor", {
              raw: 0x00000000,
              normalized: [0, 0, 0, 0]
            });
            /**
             * White pixel texture used by default when no texture is specified.
             */
            _defineProperty(_this52, "quadBufferUsage", 0);
            _defineProperty(_this52, "numQuadsRendered", 0);
            /**
             * Whether the renderer is currently rendering to a texture.
             */
            _defineProperty(_this52, "renderToTextureActive", false);
            _this52.quadBuffer = new ArrayBuffer(_this52.stage.options.quadBufferSize);
            _this52.fQuadBuffer = new Float32Array(_this52.quadBuffer);
            _this52.uiQuadBuffer = new Uint32Array(_this52.quadBuffer);
            _this52.mode = 'webgl';
            var canvas = options.canvas,
              clearColor = options.clearColor,
              bufferMemory = options.bufferMemory;
            var gl = createWebGLContext(canvas, options.forceWebGL2, options.contextSpy);
            var glw = _this52.glw = new WebGlContextWrapper(gl);
            glw.viewport(0, 0, canvas.width, canvas.height);
            _this52.updateClearColor(clearColor);
            glw.setBlend(true);
            glw.blendFunc(glw.ONE, glw.ONE_MINUS_SRC_ALPHA);
            createIndexBuffer(glw, bufferMemory);
            _this52.system = {
              parameters: getWebGlParameters(_this52.glw),
              extensions: getWebGlExtensions(_this52.glw)
            };
            _this52.shManager.renderer = _this52;
            _this52.defShaderCtrl = _this52.shManager.loadShader('DefaultShader');
            _this52.defaultShader = _this52.defShaderCtrl.shader;
            var quadBuffer = glw.createBuffer();
            var stride = 6 * Float32Array.BYTES_PER_ELEMENT;
            _this52.quadBufferCollection = new BufferCollection([{
              buffer: quadBuffer,
              attributes: {
                a_position: {
                  name: 'a_position',
                  size: 2,
                  // 2 components per iteration
                  type: glw.FLOAT,
                  // the data is 32bit floats
                  normalized: false,
                  // don't normalize the data
                  stride: stride,
                  // 0 = move forward size * sizeof(type) each iteration to get the next position
                  offset: 0 // start at the beginning of the buffer
                },
                a_textureCoordinate: {
                  name: 'a_textureCoordinate',
                  size: 2,
                  type: glw.FLOAT,
                  normalized: false,
                  stride: stride,
                  offset: 2 * Float32Array.BYTES_PER_ELEMENT
                },
                a_color: {
                  name: 'a_color',
                  size: 4,
                  type: glw.UNSIGNED_BYTE,
                  normalized: true,
                  stride: stride,
                  offset: 4 * Float32Array.BYTES_PER_ELEMENT
                },
                a_textureIndex: {
                  name: 'a_textureIndex',
                  size: 1,
                  type: glw.FLOAT,
                  normalized: false,
                  stride: stride,
                  offset: 5 * Float32Array.BYTES_PER_ELEMENT
                }
              }
            }]);
            return _this52;
          }
          _inherits(WebGlCoreRenderer, _CoreRenderer2);
          return _createClass(WebGlCoreRenderer, [{
            key: "reset",
            value: function reset() {
              var glw = this.glw;
              this.curBufferIdx = 0;
              this.curRenderOp = null;
              this.renderOps.length = 0;
              glw.setScissorTest(false);
              glw.clear();
            }
          }, {
            key: "getShaderManager",
            value: function getShaderManager() {
              return this.shManager;
            }
          }, {
            key: "createCtxTexture",
            value: function createCtxTexture(textureSource) {
              if (textureSource instanceof SubTexture) {
                return new WebGlCoreCtxSubTexture(this.glw, this.txMemManager, textureSource);
              } else if (textureSource instanceof RenderTexture) {
                return new WebGlCoreCtxRenderTexture(this.glw, this.txMemManager, textureSource);
              }
              return new WebGlCoreCtxTexture(this.glw, this.txMemManager, textureSource);
            }
            /**
             * This function adds a quad (a rectangle composed of two triangles) to the WebGL rendering pipeline.
             *
             * It takes a set of options that define the quad's properties, such as its dimensions, colors, texture, shader, and transformation matrix.
             * The function first updates the shader properties with the current dimensions if necessary, then sets the default texture if none is provided.
             * It then checks if a new render operation is needed, based on the current shader and clipping rectangle.
             * If a new render operation is needed, it creates one and updates the current render operation.
             * The function then adjusts the texture coordinates based on the texture options and adds the texture to the texture manager.
             *
             * Finally, it calculates the vertices for the quad, taking into account any transformations, and adds them to the quad buffer.
             * The function updates the length and number of quads in the current render operation, and updates the current buffer index.
             */
          }, {
            key: "addQuad",
            value: function addQuad(params) {
              var fQuadBuffer = this.fQuadBuffer,
                uiQuadBuffer = this.uiQuadBuffer;
              var texture = params.texture;
              /**
               * If the shader props contain any automatic properties, update it with the
               * current dimensions and or alpha that will be used to render the quad.
               */
              if (params.shader !== this.defaultShader) {
                if (hasOwn(params.shaderProps, '$dimensions') == true) {
                  var dimensions = params.shaderProps.$dimensions;
                  dimensions.width = params.width;
                  dimensions.height = params.height;
                }
                if (hasOwn(params.shaderProps, '$alpha') === true) {
                  params.shaderProps.$alpha = params.alpha;
                }
              }
              var bufferIdx = this.curBufferIdx,
                curRenderOp = this.curRenderOp;
              var targetDims = {
                width: params.width,
                height: params.height
              };
              if (this.reuseRenderOp(params) === false) {
                this.newRenderOp(params.shader, params.shaderProps, params.alpha, targetDims, params.clippingRect, bufferIdx, params.rtt, params.parentHasRenderTexture, params.framebufferDimensions);
                curRenderOp = this.curRenderOp;
              }
              var texCoordX1 = 0;
              var texCoordY1 = 0;
              var texCoordX2 = 1;
              var texCoordY2 = 1;
              if (texture.type === TextureType.subTexture) {
                var _texture$props = texture.props,
                  tx = _texture$props.x,
                  ty = _texture$props.y,
                  tw = _texture$props.width,
                  th = _texture$props.height;
                var _ref21 = texture.parentTexture.dimensions || {
                    width: 0,
                    height: 0
                  },
                  _ref21$width = _ref21.width,
                  parentW = _ref21$width === void 0 ? 0 : _ref21$width,
                  _ref21$height = _ref21.height,
                  parentH = _ref21$height === void 0 ? 0 : _ref21$height;
                texCoordX1 = tx / parentW;
                texCoordX2 = texCoordX1 + tw / parentW;
                texCoordY1 = ty / parentH;
                texCoordY2 = texCoordY1 + th / parentH;
                texture = texture.parentTexture;
              }
              if (texture.type === TextureType.image && params.textureOptions !== null && params.textureOptions.resizeMode !== undefined && texture.dimensions !== null) {
                var resizeMode = params.textureOptions.resizeMode;
                var _texture$dimensions2 = texture.dimensions,
                  _tw = _texture$dimensions2.width,
                  _th = _texture$dimensions2.height;
                if (resizeMode.type === 'cover') {
                  var scaleX = params.width / _tw;
                  var scaleY = params.height / _th;
                  var scale = Math.max(scaleX, scaleY);
                  var precision = 1 / scale;
                  // Determine based on width
                  if (scale && scaleX && scaleX < scale) {
                    var _resizeMode$clipX;
                    var desiredSize = precision * params.width;
                    texCoordX1 = (1 - desiredSize / _tw) * ((_resizeMode$clipX = resizeMode.clipX) !== null && _resizeMode$clipX !== void 0 ? _resizeMode$clipX : 0.5);
                    texCoordX2 = texCoordX1 + desiredSize / _tw;
                  }
                  // Determine based on height
                  if (scale && scaleY && scaleY < scale) {
                    var _resizeMode$clipY;
                    var _desiredSize = precision * params.height;
                    texCoordY1 = (1 - _desiredSize / _th) * ((_resizeMode$clipY = resizeMode.clipY) !== null && _resizeMode$clipY !== void 0 ? _resizeMode$clipY : 0.5);
                    texCoordY2 = texCoordY1 + _desiredSize / _th;
                  }
                }
              }
              // Flip texture coordinates if dictated by texture options
              var flipY = 0;
              if (params.textureOptions !== null) {
                if (params.textureOptions.flipX === true) {
                  var _ref22 = [texCoordX2, texCoordX1];
                  texCoordX1 = _ref22[0];
                  texCoordX2 = _ref22[1];
                }
                // convert to integer for bitwise operation below
                flipY = +(params.textureOptions.flipY || false);
              }
              // Eitherone should be true
              if (flipY ^ +(texture.type === TextureType.renderToTexture)) {
                var _ref23 = [texCoordY2, texCoordY1];
                texCoordY1 = _ref23[0];
                texCoordY2 = _ref23[1];
              }
              var ctxTexture = texture.ctxTexture;
              if (ctxTexture === undefined) {
                var _this$stage$defaultTe;
                ctxTexture = (_this$stage$defaultTe = this.stage.defaultTexture) === null || _this$stage$defaultTe === void 0 ? void 0 : _this$stage$defaultTe.ctxTexture;
                console.warn('WebGL Renderer: Texture does not have a ctxTexture, using default texture instead');
              }
              var textureIdx = this.addTexture(ctxTexture, bufferIdx);
              assertTruthy(this.curRenderOp !== null);
              if (params.renderCoords) {
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.renderCoords.x1; // vertexX
                fQuadBuffer[bufferIdx++] = params.renderCoords.y1; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = params.renderCoords.x2;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y2;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.renderCoords.x4;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y4;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = params.renderCoords.x3;
                fQuadBuffer[bufferIdx++] = params.renderCoords.y3;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              } else if (params.tb !== 0 || params.tc !== 0) {
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.tx; // vertexX
                fQuadBuffer[bufferIdx++] = params.ty; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta;
                fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.tx + params.height * params.tb;
                fQuadBuffer[bufferIdx++] = params.ty + params.height * params.td;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = params.tx + params.width * params.ta + params.height * params.tb;
                fQuadBuffer[bufferIdx++] = params.ty + params.width * params.tc + params.height * params.td;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              } else {
                // Calculate the right corner of the quad
                // multiplied by the scale
                var rightCornerX = params.tx + params.width * params.ta;
                var rightCornerY = params.ty + params.height * params.td;
                // Upper-Left
                fQuadBuffer[bufferIdx++] = params.tx; // vertexX
                fQuadBuffer[bufferIdx++] = params.ty; // vertexY
                fQuadBuffer[bufferIdx++] = texCoordX1; // texCoordX
                fQuadBuffer[bufferIdx++] = texCoordY1; // texCoordY
                uiQuadBuffer[bufferIdx++] = params.colorTl; // color
                fQuadBuffer[bufferIdx++] = textureIdx; // texIndex
                // Upper-Right
                fQuadBuffer[bufferIdx++] = rightCornerX;
                fQuadBuffer[bufferIdx++] = params.ty;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY1;
                uiQuadBuffer[bufferIdx++] = params.colorTr;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Left
                fQuadBuffer[bufferIdx++] = params.tx;
                fQuadBuffer[bufferIdx++] = rightCornerY;
                fQuadBuffer[bufferIdx++] = texCoordX1;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBl;
                fQuadBuffer[bufferIdx++] = textureIdx;
                // Lower-Right
                fQuadBuffer[bufferIdx++] = rightCornerX;
                fQuadBuffer[bufferIdx++] = rightCornerY;
                fQuadBuffer[bufferIdx++] = texCoordX2;
                fQuadBuffer[bufferIdx++] = texCoordY2;
                uiQuadBuffer[bufferIdx++] = params.colorBr;
                fQuadBuffer[bufferIdx++] = textureIdx;
              }
              // Update the length of the current render op
              this.curRenderOp.length += WORDS_PER_QUAD;
              this.curRenderOp.numQuads++;
              this.curBufferIdx = bufferIdx;
            }
            /**
             * Replace the existing RenderOp with a new one that uses the specified Shader
             * and starts at the specified buffer index.
             *
             * @param shader
             * @param bufferIdx
             */
          }, {
            key: "newRenderOp",
            value: function newRenderOp(shader, shaderProps, alpha, dimensions, clippingRect, bufferIdx, renderToTexture, parentHasRenderTexture, framebufferDimensions) {
              var curRenderOp = new WebGlCoreRenderOp(this.glw, this.options, this.quadBufferCollection, shader, shaderProps, alpha, clippingRect, dimensions, bufferIdx, 0,
              // Z-Index is only used for explictly added Render Ops
              renderToTexture, parentHasRenderTexture, framebufferDimensions);
              this.curRenderOp = curRenderOp;
              this.renderOps.push(curRenderOp);
            }
            /**
             * Add a texture to the current RenderOp. If the texture cannot be added to the
             * current RenderOp, a new RenderOp will be created and the texture will be added
             * to that one.
             *
             * If the texture cannot be added to the new RenderOp, an error will be thrown.
             *
             * @param texture
             * @param bufferIdx
             * @param recursive
             * @returns Assigned Texture Index of the texture in the render op
             */
          }, {
            key: "addTexture",
            value: function addTexture(texture, bufferIdx, recursive) {
              var curRenderOp = this.curRenderOp;
              var textureIdx = curRenderOp.addTexture(texture);
              // TODO: Refactor to be more DRY
              if (textureIdx === 0xffffffff) {
                if (recursive) {
                  throw new Error('Unable to add texture to render op');
                }
                this.newRenderOp(curRenderOp.shader, curRenderOp.shaderProps, curRenderOp.alpha, curRenderOp.dimensions, curRenderOp.clippingRect, bufferIdx);
                return this.addTexture(texture, bufferIdx, true);
              }
              return textureIdx;
            }
            /**
             * Test if the current Render operation can be reused for the specified parameters.
             * @param params
             * @returns
             */
          }, {
            key: "reuseRenderOp",
            value: function reuseRenderOp(params) {
              var _this$curRenderOp;
              var shader = params.shader,
                shaderProps = params.shaderProps,
                parentHasRenderTexture = params.parentHasRenderTexture,
                rtt = params.rtt,
                clippingRect = params.clippingRect;
              // Switching shader program will require a new render operation
              if (((_this$curRenderOp = this.curRenderOp) === null || _this$curRenderOp === void 0 ? void 0 : _this$curRenderOp.shader) !== shader) {
                return false;
              }
              // Switching clipping rect will require a new render operation
              if (compareRect(this.curRenderOp.clippingRect, clippingRect) === false) {
                return false;
              }
              // Force new render operation if rendering to texture
              // @todo: This needs to be improved, render operations could also be reused
              // for rendering to texture
              if (parentHasRenderTexture === true || rtt === true) {
                return false;
              }
              // Check if the shader can batch the shader properties
              if (this.curRenderOp.shader !== this.defaultShader && this.curRenderOp.shader.canBatchShaderProps(this.curRenderOp.shaderProps, shaderProps) === false) {
                return false;
              }
              // Render operation can be reused
              return true;
            }
            /**
             * add RenderOp to the render pipeline
             */
          }, {
            key: "addRenderOp",
            value: function addRenderOp(renderable) {
              this.renderOps.push(renderable);
              this.curRenderOp = null;
            }
            /**
             * Render the current set of RenderOps to render to the specified surface.
             *
             * TODO: 'screen' is the only supported surface at the moment.
             *
             * @param surface
             */
          }, {
            key: "render",
            value: function render() {
              var surface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'screen';
              var glw = this.glw,
                quadBuffer = this.quadBuffer;
              var arr = new Float32Array(quadBuffer, 0, this.curBufferIdx);
              var buffer = this.quadBufferCollection.getBuffer('a_position') || null;
              glw.arrayBufferData(buffer, arr, glw.STATIC_DRAW);
              for (var i = 0, length = this.renderOps.length; i < length; i++) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.renderOps[i].draw();
              }
              this.quadBufferUsage = this.curBufferIdx * arr.BYTES_PER_ELEMENT;
              // Calculate the size of each quad in bytes (4 vertices per quad) times the size of each vertex in bytes
              var QUAD_SIZE_IN_BYTES = 4 * (6 * arr.BYTES_PER_ELEMENT); // 6 attributes per vertex
              this.numQuadsRendered = this.quadBufferUsage / QUAD_SIZE_IN_BYTES;
            }
          }, {
            key: "getQuadCount",
            value: function getQuadCount() {
              return this.numQuadsRendered;
            }
          }, {
            key: "renderToTexture",
            value: function renderToTexture(node) {
              for (var i = 0; i < this.rttNodes.length; i++) {
                if (this.rttNodes[i] === node) {
                  return;
                }
              }
              this.insertRTTNodeInOrder(node);
            }
            /**
             * Inserts an RTT node into `this.rttNodes` while maintaining the correct rendering order based on hierarchy.
             *
             * Rendering order for RTT nodes is critical when nested RTT nodes exist in a parent-child relationship.
             * Specifically:
             *  - Child RTT nodes must be rendered before their RTT-enabled parents to ensure proper texture composition.
             *  - If an RTT node is added and it has existing RTT children, it should be rendered after those children.
             *
             * This function addresses both cases by:
             * 1. **Checking Upwards**: It traverses the node's hierarchy upwards to identify any RTT parent
             *    already in `rttNodes`. If an RTT parent is found, the new node is placed before this parent.
             * 2. **Checking Downwards**: It traverses the node’s children recursively to find any RTT-enabled
             *    children that are already in `rttNodes`. If such children are found, the new node is inserted
             *    after the last (highest index) RTT child node.
             *
             * The final calculated insertion index ensures the new node is positioned in `rttNodes` to respect
             * both parent-before-child and child-before-parent rendering rules, preserving the correct order
             * for the WebGL renderer.
             *
             * @param node - The RTT-enabled CoreNode to be added to `rttNodes` in the appropriate hierarchical position.
             */
          }, {
            key: "insertRTTNodeInOrder",
            value: function insertRTTNodeInOrder(node) {
              var insertIndex = this.rttNodes.length; // Default to the end of the array
              // 1. Traverse upwards to ensure the node is placed before its RTT parent (if any).
              var currentNode = node;
              while (currentNode) {
                if (!currentNode.parent) {
                  break;
                }
                var parentIndex = this.rttNodes.indexOf(currentNode.parent);
                if (parentIndex !== -1) {
                  // Found an RTT parent in the list; set insertIndex to place node before the parent
                  insertIndex = parentIndex;
                  break;
                }
                currentNode = currentNode.parent;
              }
              // 2. Traverse downwards to ensure the node is placed after any RTT children.
              // Look through each child recursively to see if any are already in rttNodes.
              var maxChildIndex = this.findMaxChildRTTIndex(node);
              if (maxChildIndex !== -1) {
                // Adjust insertIndex to be after the last child RTT node
                insertIndex = Math.max(insertIndex, maxChildIndex + 1);
              }
              // 3. Insert the node at the calculated position
              this.rttNodes.splice(insertIndex, 0, node);
            }
            // Helper function to find the highest index of any RTT children of a node within rttNodes
          }, {
            key: "findMaxChildRTTIndex",
            value: function findMaxChildRTTIndex(node) {
              var _this53 = this;
              var maxIndex = -1;
              var _traverseChildren = function traverseChildren(currentNode) {
                var currentIndex = _this53.rttNodes.indexOf(currentNode);
                if (currentIndex !== -1) {
                  maxIndex = Math.max(maxIndex, currentIndex);
                }
                // Recursively check all children of the current node
                var _iterator12 = _createForOfIteratorHelper(currentNode.children),
                  _step12;
                try {
                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                    var child = _step12.value;
                    _traverseChildren(child);
                  }
                } catch (err) {
                  _iterator12.e(err);
                } finally {
                  _iterator12.f();
                }
              };
              // Start traversal directly with the provided node
              _traverseChildren(node);
              return maxIndex;
            }
          }, {
            key: "renderRTTNodes",
            value: function renderRTTNodes() {
              var glw = this.glw;
              var txManager = this.stage.txManager;
              // Render all associated RTT nodes to their textures
              for (var i = 0; i < this.rttNodes.length; i++) {
                var node = this.rttNodes[i];
                // Skip nodes that don't have RTT updates
                if (node === undefined || node.hasRTTupdates === false) {
                  continue;
                }
                // Skip nodes that are not visible
                if (node.worldAlpha === 0 || node.strictBounds === true && node.renderState === CoreNodeRenderState.OutOfBounds) {
                  continue;
                }
                // Skip nodes that do not have a loaded texture
                if (node.texture === null || node.texture.state !== 'loaded') {
                  continue;
                }
                // Set the active RTT node to the current node
                // So we can prevent rendering children of nested RTT nodes
                this.activeRttNode = node;
                assertTruthy(node.texture);
                var ctxTexture = node.texture.ctxTexture;
                this.renderToTextureActive = true;
                // Bind the the texture's framebuffer
                glw.bindFramebuffer(ctxTexture.framebuffer);
                glw.viewport(0, 0, ctxTexture.w, ctxTexture.h);
                // Set the clear color to transparent
                glw.clearColor(0, 0, 0, 0);
                glw.clear();
                // Render all associated quads to the texture
                for (var _i2 = 0; _i2 < node.children.length; _i2++) {
                  var child = node.children[_i2];
                  if (child === undefined) {
                    continue;
                  }
                  this.stage.addQuads(child);
                  child.hasRTTupdates = false;
                }
                // Render all associated quads to the texture
                this.render();
                // Reset render operations
                this.renderOps.length = 0;
                node.hasRTTupdates = false;
              }
              var clearColor = this.clearColor.normalized;
              // Restore the default clear color
              glw.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
              // Bind the default framebuffer
              glw.bindFramebuffer(null);
              glw.viewport(0, 0, this.glw.canvas.width, this.glw.canvas.height);
              this.renderToTextureActive = false;
            }
          }, {
            key: "removeRTTNode",
            value: function removeRTTNode(node) {
              var index = this.rttNodes.indexOf(node);
              if (index === -1) {
                return;
              }
              this.rttNodes.splice(index, 1);
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              var bufferInfo = {
                totalAvailable: this.stage.options.quadBufferSize,
                totalUsed: this.quadBufferUsage
              };
              return bufferInfo;
            }
          }, {
            key: "getDefShaderCtr",
            value: function getDefShaderCtr() {
              return this.defShaderCtrl;
            }
            /**
             * Updates the WebGL context's clear color and clears the color buffer.
             *
             * @param color - The color to set as the clear color, represented as a 32-bit integer.
             */
          }, {
            key: "updateClearColor",
            value: function updateClearColor(color) {
              if (this.clearColor.raw === color) {
                return;
              }
              var glw = this.glw;
              var normalizedColor = getNormalizedRgbaComponents(color);
              glw.clearColor(normalizedColor[0], normalizedColor[1], normalizedColor[2], normalizedColor[3]);
              this.clearColor = {
                raw: color,
                normalized: normalizedColor
              };
              glw.clear();
            }
          }]);
        }(CoreRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var SpecialCodepoints = {
          LINE_FEED: 0x0a
        };

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var FontShaper = /*#__PURE__*/_createClass(function FontShaper() {
          _classCallCheck(this, FontShaper);
        });
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var SdfFontShaper = /*#__PURE__*/function (_FontShaper) {
          function SdfFontShaper(data, glyphMap) {
            var _this54;
            _classCallCheck(this, SdfFontShaper);
            _this54 = _callSuper(this, SdfFontShaper);
            _defineProperty(_this54, "data", void 0);
            _defineProperty(_this54, "glyphMap", void 0);
            _defineProperty(_this54, "kernings", void 0);
            _this54.data = data;
            _this54.glyphMap = glyphMap;
            var kernings = _this54.kernings = {};
            data.kernings.forEach(function (kerning) {
              var second = kerning.second;
              var firsts = kernings[second] = kernings[second] || {};
              firsts[kerning.first] = kerning.amount;
            });
            _this54.kernings = kernings;
            return _this54;
          }
          _inherits(SdfFontShaper, _FontShaper);
          return _createClass(SdfFontShaper, [{
            key: "shapeText",
            value: /*#__PURE__*/_regenerator().m(function shapeText(props, codepoints) {
              var codepointResult, lastGlyphId, codepoint, glyph, _this$kernings$glyph$, kerning;
              return _regenerator().w(function (_context18) {
                while (1) switch (_context18.n) {
                  case 0:
                    lastGlyphId = undefined;
                  case 1:
                    if (!((codepointResult = codepoints.peek()) && !codepointResult.done)) {
                      _context18.n = 5;
                      break;
                    }
                    codepoint = codepointResult.value;
                    glyph = this.glyphMap.get(codepoint);
                    codepoints.next();
                    if (!(glyph !== undefined)) {
                      _context18.n = 3;
                      break;
                    }
                    // We found a glyph for this codepoint
                    // Yield the mapped glyph info
                    /**
                     * Kerning includes any possible additional letter spacing
                     */
                    kerning = lastGlyphId !== undefined ? (((_this$kernings$glyph$ = this.kernings[glyph.id]) === null || _this$kernings$glyph$ === void 0 ? void 0 : _this$kernings$glyph$[lastGlyphId]) || 0) + props.letterSpacing : 0;
                    lastGlyphId = glyph.id;
                    _context18.n = 2;
                    return {
                      mapped: true,
                      glyphId: glyph.id,
                      codepoint: codepoint,
                      cluster: codepoints.lastIndex,
                      xAdvance: glyph.xadvance + kerning,
                      yAdvance: 0,
                      xOffset: glyph.xoffset + kerning,
                      yOffset: glyph.yoffset,
                      xBearing: 0,
                      yBearing: 0,
                      width: glyph.width,
                      height: glyph.height
                    };
                  case 2:
                    _context18.n = 4;
                    break;
                  case 3:
                    // We didn't find a glyph for this codepoint
                    // Yield the unmapped codepoint info
                    // If this codepoint is a linebreak, we should reset the last glyph id
                    // so that the next glyph will not be kerned with the last glyph of the
                    // previous line.
                    if (codepoint === SpecialCodepoints.LINE_FEED) {
                      lastGlyphId = undefined;
                    }
                    _context18.n = 4;
                    return {
                      mapped: false,
                      codepoint: codepoint,
                      cluster: codepoints.lastIndex
                    };
                  case 4:
                    _context18.n = 1;
                    break;
                  case 5:
                    return _context18.a(2);
                }
              }, shapeText, this);
            })
          }]);
        }(FontShaper);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // import type { Renderer } from '../../../Renderer';
        var SdfTrFontFace = /*#__PURE__*/function (_TrFontFace3) {
          function SdfTrFontFace(type, options) {
            var _this55;
            _classCallCheck(this, SdfTrFontFace);
            _this55 = _callSuper(this, SdfTrFontFace, [options]);
            _defineProperty(_this55, "type", void 0);
            _defineProperty(_this55, "texture", void 0);
            /**
             * Height of the tallest character in the font including the whitespace above it
             * in SDF/vertex units.
             */
            _defineProperty(_this55, "maxCharHeight", 0);
            _defineProperty(_this55, "shaper", void 0);
            _defineProperty(_this55, "glyphMap", new Map());
            _defineProperty(_this55, "data", void 0);
            var atlasUrl = options.atlasUrl,
              atlasDataUrl = options.atlasDataUrl,
              stage = options.stage;
            _this55.type = type;
            stage.renderer;
            // Load image
            _this55.texture = stage.txManager.createTexture('ImageTexture', {
              src: atlasUrl,
              // IMPORTANT: The SDF shader requires the alpha channel to NOT be
              // premultiplied on the atlas texture. If it is premultiplied, the
              // rendering of SDF glyphs (especially single-channel SDF fonts) will
              // be very jagged.
              premultiplyAlpha: false
            });
            // Load the texture
            stage.txManager.loadTexture(_this55.texture, true);
            // FIXME This is a stop-gap solution to avoid Font Face textures to be cleaned up
            // Ideally we do want to clean up the textures if they're not being used to save as much memory as possible
            // However, we need to make sure that the font face is reloaded if the texture is cleaned up and needed again
            // and make sure the SdfFontRenderer is properly guarded against textures being reloaded
            // for now this will do the trick and the increase on memory is not that big
            _this55.texture.preventCleanup = true;
            _this55.texture.on('loaded', function () {
              _this55.checkLoaded();
              // Make sure we mark the stage for a re-render (in case the font's texture was freed and reloaded)
              stage.requestRender();
            });
            // Set this.data to the fetched data from dataUrl
            fetchJson(atlasDataUrl).then(function (response) {
              _this55.data = JSON.parse(response);
              assertTruthy(_this55.data);
              // Add all the glyphs to the glyph map
              var maxCharHeight = 0;
              _this55.data.chars.forEach(function (glyph) {
                _this55.glyphMap.set(glyph.id, glyph);
                var charHeight = glyph.yoffset + glyph.height;
                if (charHeight > maxCharHeight) {
                  maxCharHeight = charHeight;
                }
              });
              _this55.maxCharHeight = maxCharHeight;
              // We know `data` is defined here, because we just set it
              _this55.shaper = new SdfFontShaper(_this55.data, _this55.glyphMap);
              // If the metrics aren't provided explicitly in the font face options,
              // Gather them from the metrics added by the msdf-generator tool ()
              // If they are missing then we throw an error.
              if (!_this55.metrics) {
                var _this55$data;
                if ((_this55$data = _this55.data) !== null && _this55$data !== void 0 && _this55$data.lightningMetrics) {
                  var _this55$data$lightnin = _this55.data.lightningMetrics,
                    ascender = _this55$data$lightnin.ascender,
                    descender = _this55$data$lightnin.descender,
                    lineGap = _this55$data$lightnin.lineGap,
                    unitsPerEm = _this55$data$lightnin.unitsPerEm;
                  _this55.metrics = {
                    ascender: ascender / unitsPerEm,
                    descender: descender / unitsPerEm,
                    lineGap: lineGap / unitsPerEm
                  };
                } else {
                  throw new Error("Font metrics not found in ".concat(_this55.type, " font ").concat(_this55.fontFamily, ". ") + 'Make sure you are using the latest version of the Lightning ' + '3 `msdf-generator` tool to generate your SDF fonts.');
                }
              }
              _this55.checkLoaded();
            }).catch(console.error);
            return _this55;
          }
          _inherits(SdfTrFontFace, _TrFontFace3);
          return _createClass(SdfTrFontFace, [{
            key: "getAtlasEntry",
            value: function getAtlasEntry(glyphId) {
              var glyph = this.glyphMap.get(glyphId);
              if (glyph === undefined) {
                throw new Error("Glyph ".concat(glyphId, " not found in font ").concat(this.fontFamily));
              }
              return {
                x: glyph.x,
                y: glyph.y,
                width: glyph.width,
                height: glyph.height
              };
            }
          }, {
            key: "checkLoaded",
            value: function checkLoaded() {
              if (this.loaded) return;
              if (this.texture.state === 'loaded' && this.data) {
                this.loaded = true;
                this.emit('loaded');
              }
            }
          }]);
        }(TrFontFace);
        var __vite_import_meta_env__ = {
          "LEGACY": true
        };
        var SHADERS_ENABLED = !!(__vite_import_meta_env__ && undefined !== "true");
        var Config = exports("a8", {
          debug: false,
          focusDebug: false,
          keyDebug: false,
          animationsEnabled: true,
          animationSettings: {
            duration: 250,
            easing: "ease-in-out"
          },
          fontSettings: {
            fontFamily: "Ubuntu",
            fontSize: 100
          },
          setActiveElement: function setActiveElement() {},
          focusStateKey: "$focus",
          lockStyles: true
        });
        var renderer$1;
        function startLightningRenderer(options) {
          var rootId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "app";
          renderer$1 = new RendererMain(options, rootId);
          return renderer$1;
        }
        function loadFonts(fonts) {
          var _iterator13 = _createForOfIteratorHelper(fonts),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var font = _step13.value;
              if (renderer$1.stage.renderer.mode === "webgl" && "type" in font && (font.type === "msdf" || font.type === "ssdf")) {
                renderer$1.stage.fontManager.addFontFace(new SdfTrFontFace(font.type, _objectSpread(_objectSpread({}, font), {}, {
                  stage: renderer$1.stage
                })));
              } else if ("fontUrl" in font) {
                renderer$1.stage.fontManager.addFontFace(new WebTrFontFace(font));
              }
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
        }
        var NodeType = {
          Element: "element",
          TextNode: "textNode",
          Text: "text"
        };
        function log(msg, node) {}
        var isFunc = function isFunc(obj) {
          return obj instanceof Function;
        };
        var isFunction = function isFunction(obj) {
          return typeof obj === "function";
        };
        function isArray(item) {
          return Array.isArray(item);
        }
        function isString(item) {
          return typeof item === "string";
        }
        function isNumber(item) {
          return typeof item === "number";
        }
        function isInteger(item) {
          return Number.isInteger(item);
        }
        function isINode(node) {
          return "destroy" in node && typeof node.destroy === "function";
        }
        function isElementNode(node) {
          return node instanceof ElementNode;
        }
        function isElementText(node) {
          return node._type === NodeType.TextNode;
        }
        function isTextNode(node) {
          return node._type === NodeType.Text;
        }
        function keyExists(obj, keys) {
          var _iterator14 = _createForOfIteratorHelper(keys),
            _step14;
          try {
            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
              var key = _step14.value;
              if (key in obj) {
                return true;
              }
            }
          } catch (err) {
            _iterator14.e(err);
          } finally {
            _iterator14.f();
          }
          return false;
        }
        function isFocused(el) {
          var _el$states;
          return el === null || el === void 0 || (_el$states = el.states) === null || _el$states === void 0 ? void 0 : _el$states.has(Config.focusStateKey);
        }
        var States = /*#__PURE__*/function (_Array) {
          function States(callback) {
            var _this56;
            var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            _classCallCheck(this, States);
            if (isArray(initialState)) {
              _this56 = _callSuper(this, States, _toConsumableArray(initialState));
            } else if (isString(initialState)) {
              _this56 = _callSuper(this, States, [initialState]);
            } else {
              _this56 = _callSuper(this, States, _toConsumableArray(Object.entries(initialState).filter(function (_ref24) {
                var _ref25 = _slicedToArray(_ref24, 2),
                  _key = _ref25[0],
                  value = _ref25[1];
                return value;
              }).map(function (_ref26) {
                var _ref27 = _slicedToArray(_ref26, 1),
                  key = _ref27[0];
                return key;
              })));
            }
            _this56.onChange = callback;
            return _possibleConstructorReturn(_this56, _assertThisInitialized(_this56));
          }
          _inherits(States, _Array);
          return _createClass(States, [{
            key: "has",
            value: function has(state) {
              return this.indexOf(state) >= 0 || this.indexOf("$".concat(state)) >= 0;
            }
          }, {
            key: "is",
            value: function is(state) {
              return this.indexOf(state) >= 0;
            }
          }, {
            key: "add",
            value: function add(state) {
              if (this.has(state)) {
                return;
              }
              this.push(state);
              this.onChange();
            }
          }, {
            key: "toggle",
            value: function toggle(state, force) {
              if (force === true) {
                this.add(state);
              } else if (force === false) {
                this.remove(state);
              } else {
                if (this.has(state)) {
                  this.remove(state);
                } else {
                  this.add(state);
                }
              }
            }
          }, {
            key: "merge",
            value: function merge(newStates) {
              if (isArray(newStates)) {
                this.length = 0;
                this.push.apply(this, _toConsumableArray(newStates));
              } else if (isString(newStates)) {
                this.length = 0;
                this.push(newStates);
              } else {
                for (var state in newStates) {
                  var value = newStates[state];
                  if (value) {
                    if (!this.has(state)) {
                      this.push(state);
                    }
                  } else {
                    var stateIndexToRemove = this.indexOf(state);
                    if (stateIndexToRemove >= 0) {
                      this.splice(stateIndexToRemove, 1);
                    }
                  }
                }
              }
              return this;
            }
          }, {
            key: "remove",
            value: function remove(state) {
              var stateIndexToRemove = this.indexOf(state);
              if (stateIndexToRemove >= 0) {
                this.splice(stateIndexToRemove, 1);
                this.onChange();
              }
            }
          }]);
        }(/*#__PURE__*/_wrapNativeSuper(Array));
        function calculateFlex(node) {
          var direction = node.flexDirection || "row";
          var isRow = direction === "row";
          var dimension = isRow ? "width" : "height";
          var crossDimension = isRow ? "height" : "width";
          var marginOne = isRow ? "marginLeft" : "marginTop";
          var crossMarginOne = isRow ? "marginTop" : "marginLeft";
          var marginTwo = isRow ? "marginRight" : "marginBottom";
          var crossMarginTwo = isRow ? "marginBottom" : "marginRight";
          var processedChildren = [];
          var hasOrder = false;
          var totalFlexGrow = 0;
          for (var i = 0; i < node.children.length; i++) {
            var c = node.children[i];
            if (isElementText(c) && c.text && !(c.width || c.height)) {
              return false;
            }
            if (isTextNode(c) || c.flexItem === false) {
              continue;
            }
            var flexOrder = c.flexOrder;
            if (flexOrder !== void 0) {
              hasOrder = true;
            }
            var flexGrow = c.flexGrow;
            var isGrowItem = flexGrow !== void 0 && flexGrow >= 0;
            if (isGrowItem) {
              totalFlexGrow += flexGrow;
            }
            var mainSize = c[dimension] || 0;
            var currentMarginStart = c[marginOne] || 0;
            var currentMarginEnd = c[marginTwo] || 0;
            processedChildren.push({
              node: c,
              mainSize: mainSize,
              marginStart: currentMarginStart,
              marginEnd: currentMarginEnd,
              totalMainSizeOnAxis: mainSize + currentMarginStart + currentMarginEnd,
              isGrowItem: isGrowItem,
              flexGrowValue: isGrowItem ? flexGrow : 0,
              flexOrder: flexOrder || 0,
              crossSize: c[crossDimension] || 0,
              crossMarginStart: c[crossMarginOne] || 0,
              crossMarginEnd: c[crossMarginTwo] || 0
            });
          }
          if (hasOrder) {
            processedChildren.sort(function (a, b) {
              return a.flexOrder - b.flexOrder;
            });
          } else if (node.direction === "rtl") {
            processedChildren.reverse();
          }
          var numProcessedChildren = processedChildren.length;
          if (numProcessedChildren === 0) {
            return false;
          }
          var prop = isRow ? "x" : "y";
          var crossProp = isRow ? "y" : "x";
          var containerSize = node[dimension] || 0;
          var containerCrossSize = node[crossDimension] || 0;
          var gap = node.gap || 0;
          var justify = node.justifyContent || "flexStart";
          var containerUpdated = false;
          if (totalFlexGrow > 0 && numProcessedChildren > 1) {
            node.flexBoundary = node.flexBoundary || "fixed";
            var sumOfFlexBaseSizesWithMargins = 0;
            var _iterator15 = _createForOfIteratorHelper(processedChildren),
              _step15;
            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var _pc2 = _step15.value;
                sumOfFlexBaseSizesWithMargins += _pc2.mainSize + _pc2.marginStart + _pc2.marginEnd;
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }
            var totalGapSpace = numProcessedChildren > 0 ? gap * (numProcessedChildren - 1) : 0;
            var availableSpace = containerSize - sumOfFlexBaseSizesWithMargins - totalGapSpace;
            if (availableSpace > 0) {
              var _iterator16 = _createForOfIteratorHelper(processedChildren),
                _step16;
              try {
                for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                  var pc = _step16.value;
                  if (pc.isGrowItem && pc.flexGrowValue > 0) {
                    var shareOfSpace = pc.flexGrowValue / totalFlexGrow * availableSpace;
                    var newMainSize = pc.mainSize + shareOfSpace;
                    pc.node[dimension] = newMainSize;
                    pc.mainSize = newMainSize;
                    pc.totalMainSizeOnAxis = newMainSize + pc.marginStart + pc.marginEnd;
                  }
                }
              } catch (err) {
                _iterator16.e(err);
              } finally {
                _iterator16.f();
              }
              node._containsFlexGrow = node._containsFlexGrow ? null : true;
            } else if (node._containsFlexGrow) {
              node._containsFlexGrow = null;
            } else {
              console.warn("No available space for flex-grow items to expand, or items overflow.");
            }
          }
          var totalItemSize = 0;
          if (justify === "center" || justify === "spaceBetween" || justify === "spaceEvenly" || justify === "spaceAround") {
            var _iterator17 = _createForOfIteratorHelper(processedChildren),
              _step17;
            try {
              for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                var _pc3 = _step17.value;
                totalItemSize += _pc3.totalMainSizeOnAxis;
              }
            } catch (err) {
              _iterator17.e(err);
            } finally {
              _iterator17.f();
            }
          }
          var align = node.alignItems || (node.flexWrap ? "flexStart" : void 0);
          var doCrossAlign = containerCrossSize ? function (pc) {
            var crossCurrentPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            var alignSelf = pc.node.alignSelf || align;
            if (!alignSelf) {
              return;
            }
            if (alignSelf === "flexStart") {
              pc.node[crossProp] = crossCurrentPos + pc.crossMarginStart;
            } else if (alignSelf === "center") {
              pc.node[crossProp] = crossCurrentPos + (containerCrossSize - pc.crossSize) / 2 + pc.crossMarginStart;
            } else if (alignSelf === "flexEnd") {
              pc.node[crossProp] = crossCurrentPos + containerCrossSize - pc.crossSize - pc.crossMarginEnd;
            }
          } : function (_pc) {
            var _crossCurrentPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          };
          if (isRow && node._calcHeight && !node.flexCrossBoundary) {
            var maxHeight = processedChildren.reduce(function (max, pc) {
              return Math.max(max, pc.crossSize);
            }, 0);
            var newHeight = maxHeight || node.height;
            if (newHeight !== node.height) {
              containerUpdated = true;
              node.height = containerCrossSize = newHeight;
            }
          }
          var currentPos = node.padding || 0;
          if (justify === "flexStart") {
            if (node.flexWrap === "wrap") {
              var _processedChildren$, _node$columnGap, _node$rowGap;
              var crossCurrentPos = 0;
              var childCrossSize = ((_processedChildren$ = processedChildren[0]) === null || _processedChildren$ === void 0 ? void 0 : _processedChildren$.crossSize) || containerCrossSize;
              var crossGap = isRow ? (_node$columnGap = node.columnGap) !== null && _node$columnGap !== void 0 ? _node$columnGap : gap : (_node$rowGap = node.rowGap) !== null && _node$rowGap !== void 0 ? _node$rowGap : gap;
              var _iterator18 = _createForOfIteratorHelper(processedChildren),
                _step18;
              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var _pc4 = _step18.value;
                  if (currentPos + _pc4.totalMainSizeOnAxis > containerSize && currentPos > (node.padding || 0)) {
                    currentPos = node.padding || 0;
                    crossCurrentPos += childCrossSize + crossGap;
                  }
                  _pc4.node[prop] = currentPos + _pc4.marginStart;
                  currentPos += _pc4.totalMainSizeOnAxis + gap;
                  doCrossAlign(_pc4, crossCurrentPos);
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
              var finalCrossSize = crossCurrentPos + childCrossSize;
              if (node[crossDimension] !== finalCrossSize) {
                node["preFlex".concat(crossDimension)] = node[crossDimension];
                node[crossDimension] = finalCrossSize;
                containerUpdated = true;
              }
            } else {
              var _iterator19 = _createForOfIteratorHelper(processedChildren),
                _step19;
              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  var _pc5 = _step19.value;
                  _pc5.node[prop] = currentPos + _pc5.marginStart;
                  currentPos += _pc5.totalMainSizeOnAxis + gap;
                  doCrossAlign(_pc5);
                }
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }
            }
            if (node.flexBoundary !== "fixed" && node.flexWrap !== "wrap") {
              var calculatedSize = currentPos - gap + (node.padding || 0);
              if (calculatedSize !== containerSize) {
                node["preFlex".concat(dimension)] = containerSize;
                node[dimension] = calculatedSize;
                return true;
              }
            }
          } else if (justify === "flexEnd") {
            currentPos = containerSize - (node.padding || 0);
            for (var _i3 = numProcessedChildren - 1; _i3 >= 0; _i3--) {
              var _pc6 = processedChildren[_i3];
              _pc6.node[prop] = currentPos - _pc6.mainSize - _pc6.marginEnd;
              currentPos -= _pc6.totalMainSizeOnAxis + gap;
              doCrossAlign(_pc6);
            }
          } else if (justify === "center") {
            currentPos = (containerSize - (totalItemSize + gap * (numProcessedChildren - 1))) / 2 + (node.padding || 0);
            var _iterator20 = _createForOfIteratorHelper(processedChildren),
              _step20;
            try {
              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                var _pc7 = _step20.value;
                _pc7.node[prop] = currentPos + _pc7.marginStart;
                currentPos += _pc7.totalMainSizeOnAxis + gap;
                doCrossAlign(_pc7);
              }
            } catch (err) {
              _iterator20.e(err);
            } finally {
              _iterator20.f();
            }
          } else if (justify === "spaceBetween") {
            var spaceBetween = numProcessedChildren > 1 ? (containerSize - totalItemSize - (node.padding || 0) * 2) / (numProcessedChildren - 1) : 0;
            currentPos = node.padding || 0;
            var _iterator21 = _createForOfIteratorHelper(processedChildren),
              _step21;
            try {
              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                var _pc8 = _step21.value;
                _pc8.node[prop] = currentPos + _pc8.marginStart;
                currentPos += _pc8.totalMainSizeOnAxis + spaceBetween;
                doCrossAlign(_pc8);
              }
            } catch (err) {
              _iterator21.e(err);
            } finally {
              _iterator21.f();
            }
          } else if (justify === "spaceAround") {
            var spaceAround = numProcessedChildren > 0 ? (containerSize - totalItemSize - (node.padding || 0) * 2) / numProcessedChildren : 0;
            currentPos = (node.padding || 0) + spaceAround / 2;
            var _iterator22 = _createForOfIteratorHelper(processedChildren),
              _step22;
            try {
              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                var _pc9 = _step22.value;
                _pc9.node[prop] = currentPos + _pc9.marginStart;
                currentPos += _pc9.totalMainSizeOnAxis + spaceAround;
                doCrossAlign(_pc9);
              }
            } catch (err) {
              _iterator22.e(err);
            } finally {
              _iterator22.f();
            }
          } else if (justify === "spaceEvenly") {
            var spaceEvenly = (containerSize - totalItemSize - (node.padding || 0) * 2) / (numProcessedChildren + 1);
            currentPos = spaceEvenly + (node.padding || 0);
            var _iterator23 = _createForOfIteratorHelper(processedChildren),
              _step23;
            try {
              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                var _pc0 = _step23.value;
                _pc0.node[prop] = currentPos + _pc0.marginStart;
                currentPos += _pc0.totalMainSizeOnAxis + spaceEvenly;
                doCrossAlign(_pc0);
              }
            } catch (err) {
              _iterator23.e(err);
            } finally {
              _iterator23.f();
            }
          }
          return containerUpdated;
        }
        var keyMapEntries = {
          ArrowLeft: "Left",
          ArrowRight: "Right",
          ArrowUp: "Up",
          ArrowDown: "Down",
          Enter: "Enter",
          l: "Last",
          " ": "Space",
          Backspace: "Back",
          Escape: "Escape"
        };
        var keyHoldMapEntries = {
          // Enter: 'EnterHold',
        };
        var flattenKeyMap = function flattenKeyMap(keyMap, targetMap) {
          var _loop5 = function _loop5() {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
              key = _Object$entries2$_i[0],
              value = _Object$entries2$_i[1];
            if (Array.isArray(value)) {
              value.forEach(function (v) {
                targetMap[v] = key;
              });
            } else if (value === null) {
              delete targetMap[key];
            } else {
              targetMap[value] = key;
            }
          };
          for (var _i4 = 0, _Object$entries2 = Object.entries(keyMap); _i4 < _Object$entries2.length; _i4++) {
            _loop5();
          }
        };
        var needFocusDebugStyles = true;
        var addFocusDebug = function addFocusDebug(prevFocusPath, newFocusPath) {
          if (needFocusDebugStyles) {
            var style = document.createElement("style");
            style.type = "text/css";
            style.innerHTML = "\n      [data-focus=\"3\"] {\n        border: 2px solid rgba(255, 33, 33, 0.2);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus=\"2\"] {\n        border: 2px solid rgba(255, 33, 33, 0.4);\n        border-radius: 5px;\n        transition: border-color 0.3s ease;\n      }\n\n      [data-focus=\"1\"] {\n        border: 4px solid rgba(255, 33, 33, 0.9);\n        border-radius: 5px;\n        transition: border-color 0.5s ease;\n      }\n    ";
            document.head.appendChild(style);
            needFocusDebugStyles = false;
          }
          prevFocusPath.forEach(function (elm) {
            elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
              focus: void 0
            });
          });
          newFocusPath.forEach(function (elm, i) {
            elm.data = _objectSpread(_objectSpread({}, elm.data), {}, {
              focus: i + 1
            });
          });
        };
        var activeElement$1;
        var setActiveElement$1 = function setActiveElement$1(elm) {
          updateFocusPath(elm, activeElement$1);
          activeElement$1 = elm;
          Config.setActiveElement(elm);
        };
        var focusPath$1 = [];
        var updateFocusPath = function updateFocusPath(currentFocusedElm, prevFocusedElm) {
          var current = currentFocusedElm;
          var fp = [];
          while (current) {
            if (!current.states.has(Config.focusStateKey) || current === currentFocusedElm) {
              var _current$onFocus, _current$onFocusChang;
              current.states.add(Config.focusStateKey);
              (_current$onFocus = current.onFocus) === null || _current$onFocus === void 0 || _current$onFocus.call(current, currentFocusedElm, prevFocusedElm);
              (_current$onFocusChang = current.onFocusChanged) === null || _current$onFocusChang === void 0 || _current$onFocusChang.call(current, true, currentFocusedElm, prevFocusedElm);
            }
            fp.push(current);
            current = current.parent;
          }
          focusPath$1.forEach(function (elm) {
            if (!fp.includes(elm)) {
              var _elm$onBlur, _elm$onFocusChanged;
              elm.states.remove(Config.focusStateKey);
              (_elm$onBlur = elm.onBlur) === null || _elm$onBlur === void 0 || _elm$onBlur.call(elm, currentFocusedElm, prevFocusedElm);
              (_elm$onFocusChanged = elm.onFocusChanged) === null || _elm$onFocusChanged === void 0 || _elm$onFocusChanged.call(elm, false, currentFocusedElm, prevFocusedElm);
            }
          });
          if (Config.focusDebug) {
            addFocusDebug(focusPath$1, fp);
          }
          focusPath$1 = fp;
          return fp;
        };
        var lastGlobalKeyPressTime = 0;
        var lastInputKey;
        var propagateKeyPress = function propagateKeyPress(e, mappedEvent) {
          var isHold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var isUp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var currentTime = performance.now();
          var key = e.key || e.keyCode;
          var sameKey = lastInputKey === key;
          lastInputKey = key;
          if (!isUp && Config.throttleInput) {
            if (sameKey && currentTime - lastGlobalKeyPressTime < Config.throttleInput) {
              return false;
            }
            lastGlobalKeyPressTime = currentTime;
          }
          var finalFocusElm;
          var numItems = focusPath$1.length;
          var captureEvent = "onCapture".concat(mappedEvent || e.key) + isUp ? "Release" : "";
          var captureKey = isUp ? "onCaptureKeyRelease" : "onCaptureKey";
          for (var i = numItems - 1; i >= 0; i--) {
            var elm = focusPath$1[i];
            if (elm.throttleInput) {
              if (sameKey && elm._lastAnyKeyPressTime !== void 0 && currentTime - elm._lastAnyKeyPressTime < elm.throttleInput) {
                return true;
              }
            }
            var captureHandler = elm[captureEvent] || elm[captureKey];
            if (isFunction(captureHandler) && captureHandler.call(elm, e, elm, finalFocusElm, mappedEvent) === true) {
              elm._lastAnyKeyPressTime = currentTime;
              return true;
            }
          }
          var eventHandlerKey;
          var releaseEventHandlerKey;
          var fallbackHandlerKey;
          if (mappedEvent) {
            eventHandlerKey = "on".concat(mappedEvent);
            releaseEventHandlerKey = "on".concat(mappedEvent, "Release");
          }
          if (!isUp) {
            fallbackHandlerKey = isHold ? "onKeyHold" : "onKeyPress";
          }
          for (var _i5 = 0; _i5 < numItems; _i5++) {
            var _elm = focusPath$1[_i5];
            if (!finalFocusElm) {
              finalFocusElm = _elm;
            }
            if (_elm.throttleInput) {
              if (sameKey && _elm._lastAnyKeyPressTime !== void 0 && currentTime - _elm._lastAnyKeyPressTime < _elm.throttleInput) {
                return true;
              }
            }
            var handled = false;
            if (isUp && releaseEventHandlerKey) {
              var eventHandler = _elm[releaseEventHandlerKey];
              if (isFunction(eventHandler)) {
                if (eventHandler.call(_elm, e, _elm, finalFocusElm) === true) handled = true;
              }
            } else if (!isUp && eventHandlerKey) {
              var _eventHandler = _elm[eventHandlerKey];
              if (isFunction(_eventHandler)) {
                if (_eventHandler.call(_elm, e, _elm, finalFocusElm) === true) handled = true;
              }
            }
            if (!handled && fallbackHandlerKey) {
              var fallbackHandler = _elm[fallbackHandlerKey];
              if (isFunction(fallbackHandler)) {
                if (fallbackHandler.call(_elm, e, mappedEvent, _elm, finalFocusElm) === true) handled = true;
              }
            }
            if (handled) {
              _elm._lastAnyKeyPressTime = currentTime;
              return true;
            }
          }
          return false;
        };
        var DEFAULT_KEY_HOLD_THRESHOLD = 500;
        var keyHoldTimeouts = {};
        var handleKeyEvents = function handleKeyEvents(delay, keydown, keyup) {
          if (keydown) {
            var key = keydown.key || keydown.keyCode;
            var mappedKeyHoldEvent = keyHoldMapEntries[keydown.key] || keyHoldMapEntries[keydown.keyCode];
            var mappedKeyEvent = keyMapEntries[keydown.key] || keyMapEntries[keydown.keyCode];
            if (mappedKeyHoldEvent) {
              if (!keyHoldTimeouts[key]) {
                keyHoldTimeouts[key] = window.setTimeout(function () {
                  keyHoldTimeouts[key] = true;
                  propagateKeyPress(keydown, mappedKeyHoldEvent, true);
                }, delay);
              }
              return;
            }
            propagateKeyPress(keydown, mappedKeyEvent, false);
          } else if (keyup) {
            var _key16 = keyup.key || keyup.keyCode;
            var _mappedKeyEvent = keyMapEntries[keyup.key] || keyMapEntries[keyup.keyCode];
            if (keyHoldTimeouts[_key16] === true) {
              delete keyHoldTimeouts[_key16];
            } else if (keyHoldTimeouts[_key16]) {
              clearTimeout(keyHoldTimeouts[_key16]);
              delete keyHoldTimeouts[_key16];
              propagateKeyPress(keyup, _mappedKeyEvent, false);
            }
            propagateKeyPress(keyup, _mappedKeyEvent, false, true);
          }
        };
        var useFocusManager$1 = function useFocusManager$1() {
          var _ref28 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            userKeyMap = _ref28.userKeyMap,
            keyHoldOptions = _ref28.keyHoldOptions,
            _ref28$ownerContext = _ref28.ownerContext,
            ownerContext = _ref28$ownerContext === void 0 ? function (cb) {
              cb();
            } : _ref28$ownerContext;
          if (userKeyMap) {
            flattenKeyMap(userKeyMap, keyMapEntries);
          }
          if (keyHoldOptions !== null && keyHoldOptions !== void 0 && keyHoldOptions.userKeyHoldMap) {
            flattenKeyMap(keyHoldOptions.userKeyHoldMap, keyHoldMapEntries);
          }
          var delay = (keyHoldOptions === null || keyHoldOptions === void 0 ? void 0 : keyHoldOptions.holdThreshold) || DEFAULT_KEY_HOLD_THRESHOLD;
          var runKeyEvent = handleKeyEvents.bind(null, delay);
          var keyPressHandler = function keyPressHandler(event) {
            return ownerContext(function () {
              runKeyEvent(event, void 0);
            });
          };
          var keyUpHandler = function keyUpHandler(event) {
            return ownerContext(function () {
              runKeyEvent(void 0, event);
            });
          };
          document.addEventListener("keyup", keyUpHandler);
          document.addEventListener("keydown", keyPressHandler);
          return {
            cleanup: function cleanup() {
              document.removeEventListener("keydown", keyPressHandler);
              document.removeEventListener("keyup", keyUpHandler);
              for (var _i6 = 0, _Object$entries3 = Object.entries(keyHoldTimeouts); _i6 < _Object$entries3.length; _i6++) {
                var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i6], 2),
                  _ = _Object$entries3$_i[0],
                  timeout = _Object$entries3$_i[1];
                if (timeout && timeout !== true) clearTimeout(timeout);
              }
            },
            focusPath: function focusPath() {
              return focusPath$1;
            }
          };
        };
        var SimpleAnimation = /*#__PURE__*/function () {
          function SimpleAnimation() {
            _classCallCheck(this, SimpleAnimation);
            this.nodeConfigs = [];
            this.isRegistered = false;
          }
          return _createClass(SimpleAnimation, [{
            key: "register",
            value: function register(stage) {
              if (this.isRegistered) {
                return;
              }
              this.isRegistered = true;
              this.stage = stage;
              stage.animationManager.registerAnimation(this);
            }
            /**
             * Adds a node and its animation properties to this animation instance.
             * The animation's start values for the specified properties are captured
             * from the node's current state when this method is called.
             *
             * @param node - The CoreNode to animate.
             * @param props - The properties to animate and their target values. Only number properties are supported.
             * @param settings - Animation settings for this specific node animation.
             */
          }, {
            key: "add",
            value: function add(node, key, value, settings) {
              var _settings$duration2, _settings$delay2;
              var existingConfig = this.nodeConfigs.find(function (config) {
                return config.node === node && config.propName === key;
              });
              var duration = (_settings$duration2 = settings.duration) !== null && _settings$duration2 !== void 0 ? _settings$duration2 : 0;
              var delay = (_settings$delay2 = settings.delay) !== null && _settings$delay2 !== void 0 ? _settings$delay2 : 0;
              var easing = settings.easing || "linear";
              var timingFunction = getTimingFunction(easing);
              var targetValue = value;
              var startValue = node[key];
              if (existingConfig) {
                existingConfig.duration = duration;
                existingConfig.delay = delay;
                existingConfig.easing = easing;
                existingConfig.timingFunction = timingFunction;
                existingConfig.targetValue = targetValue;
                existingConfig.startValue = startValue;
                existingConfig.progress = 0;
                existingConfig.delayFor = delay;
              } else {
                this.nodeConfigs.push({
                  node: node,
                  duration: duration,
                  delay: delay,
                  easing: easing,
                  progress: 0,
                  delayFor: delay,
                  timingFunction: timingFunction,
                  propName: key,
                  startValue: startValue,
                  targetValue: targetValue
                });
              }
            }
          }, {
            key: "update",
            value: function update(dt) {
              for (var i = this.nodeConfigs.length - 1; i >= 0; i--) {
                var nodeConfig = this.nodeConfigs[i];
                var node = nodeConfig.node,
                  duration = nodeConfig.duration,
                  timingFunction = nodeConfig.timingFunction,
                  propName = nodeConfig.propName,
                  startValue = nodeConfig.startValue,
                  targetValue = nodeConfig.targetValue;
                var remainingDt = dt;
                if (nodeConfig.delayFor > 0) {
                  nodeConfig.delayFor -= remainingDt;
                  if (nodeConfig.delayFor >= 0) {
                    continue;
                  } else {
                    remainingDt = -nodeConfig.delayFor;
                    nodeConfig.delayFor = 0;
                  }
                }
                if (duration > 0) {
                  nodeConfig.progress += remainingDt / duration;
                  nodeConfig.progress = Math.max(0, Math.min(1, nodeConfig.progress));
                } else if (duration === 0 && nodeConfig.delayFor <= 0) {
                  nodeConfig.progress = 1;
                }
                var easedProgress = timingFunction(nodeConfig.progress) || nodeConfig.progress;
                var interpolatedValue = void 0;
                if (nodeConfig.progress === 1) {
                  interpolatedValue = targetValue;
                } else {
                  if (propName.includes("color")) {
                    interpolatedValue = mergeColorProgress(startValue, targetValue, easedProgress);
                  } else {
                    interpolatedValue = startValue + (targetValue - startValue) * easedProgress;
                  }
                }
                node.lng[propName] = interpolatedValue;
                if (nodeConfig.progress === 1) {
                  this.nodeConfigs.splice(i, 1);
                }
                if (this.nodeConfigs.length === 0) {
                  var _this$stage2;
                  (_this$stage2 = this.stage) === null || _this$stage2 === void 0 || _this$stage2.animationManager.unregisterAnimation(this);
                  this.isRegistered = false;
                }
              }
            }
          }]);
        }();
        var simpleAnimation = new SimpleAnimation();
        var layoutRunQueued = false;
        var layoutQueue = /* @__PURE__ */new Set();
        function runLayout() {
          layoutRunQueued = false;
          var queue = _toConsumableArray(layoutQueue);
          layoutQueue.clear();
          for (var i = queue.length - 1; i >= 0; i--) {
            var node = queue[i];
            node.updateLayout();
          }
        }
        function addToLayoutQueue(node) {
          layoutQueue.add(node);
          if (!layoutRunQueued) {
            layoutRunQueued = true;
            queueMicrotask(runLayout);
          }
        }
        function convertEffectsToShader(node, styleEffects) {
          var effects = [];
          for (var type in styleEffects) {
            var props = styleEffects[type];
            if (type === "rounded") {
              type = "radius";
            }
            if (_typeof(props) === "object") {
              effects.push(renderer$1.createEffect(type, props, type));
            }
          }
          return renderer$1.createShader("DynamicShader", {
            effects: effects
          });
        }
        function borderAccessor() {
          var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          return {
            set: function set(value) {
              if (isNumber(value)) {
                value = {
                  width: value,
                  color: 255
                };
              }
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects || {}), _defineProperty({}, "border".concat(direction), value)) : _defineProperty({}, "border".concat(direction), value);
            },
            get: function get() {
              var _this$effects;
              return (_this$effects = this.effects) === null || _this$effects === void 0 ? void 0 : _this$effects["border".concat(direction)];
            }
          };
        }
        var LightningRendererNumberProps = ["alpha", "color", "colorTop", "colorRight", "colorLeft", "colorBottom", "colorTl", "colorTr", "colorBl", "colorBr", "height", "fontSize", "lineHeight", "mount", "mountX", "mountY", "pivot", "pivotX", "pivotY", "rotation", "scale", "scaleX", "scaleY", "width", "worldX", "worldY", "x", "y", "zIndex", "zIndexLocked"];
        var LightningRendererNonAnimatingProps = ["absX", "absY", "autosize", "clipping", "contain", "data", "destroyed", "fontFamily", "fontStretch", "fontStyle", "fontWeight", "imageType", "letterSpacing", "maxLines", "offsetY", "overflowSuffix", "preventCleanup", "rtt", "scrollable", "scrollY", "srcHeight", "srcWidth", "srcX", "srcY", "strictBounds", "text", "textAlign", "textBaseline", "textOverflow", "texture", "textureOptions", "verticalAlign", "wordWrap"];
        var ElementNode = /*#__PURE__*/function (_Object) {
          function ElementNode(name) {
            var _this57;
            _classCallCheck(this, ElementNode);
            _this57 = _callSuper(this, ElementNode);
            _this57._type = name === "text" ? NodeType.TextNode : NodeType.Element;
            _this57.rendered = false;
            _this57.lng = {};
            _this57.children = [];
            return _this57;
          }
          _inherits(ElementNode, _Object);
          return _createClass(ElementNode, [{
            key: "effects",
            get: function get() {
              return this._effects;
            },
            set: function set(v) {
              this._effects = v;
              if (SHADERS_ENABLED && this.rendered) {
                this.lng.shader = convertEffectsToShader(this, v);
              }
            }
          }, {
            key: "id",
            get: function get() {
              return this._id;
            },
            set: function set(id) {
              var _Config$rendererOptio;
              this._id = id;
              if ((_Config$rendererOptio = Config.rendererOptions) !== null && _Config$rendererOptio !== void 0 && _Config$rendererOptio.inspector) {
                this.data = _objectSpread(_objectSpread({}, this.data), {}, {
                  testId: id
                });
              }
            }
          }, {
            key: "parent",
            get: function get() {
              return this._parent;
            },
            set: function set(p) {
              this._parent = p;
              if (this.rendered && p !== null && p !== void 0 && p.rendered) {
                var _p$lng;
                this.lng.parent = (_p$lng = p.lng) !== null && _p$lng !== void 0 ? _p$lng : null;
              }
            }
          }, {
            key: "insertChild",
            value: function insertChild(node, beforeNode) {
              if (node.parent) {
                node.parent.removeChild(node);
                if (!this.rendered) {
                  this._hasRenderedChildren = true;
                }
              }
              node.parent = this;
              if (beforeNode) {
                this.removeChild(node);
                var index = this.children.indexOf(beforeNode);
                if (index >= 0) {
                  this.children.splice(index, 0, node);
                  return;
                }
              }
              this.children.push(node);
            }
          }, {
            key: "removeChild",
            value: function removeChild(node) {
              var nodeIndexToRemove = this.children.indexOf(node);
              if (nodeIndexToRemove >= 0) {
                var _node$onRemove;
                this.children.splice(nodeIndexToRemove, 1);
                (_node$onRemove = node.onRemove) === null || _node$onRemove === void 0 || _node$onRemove.call(node, node);
              }
            }
          }, {
            key: "selectedNode",
            get: function get() {
              var selectedIndex = this.selected || 0;
              for (var i = selectedIndex; i < this.children.length; i++) {
                var element = this.children[i];
                if (isElementNode(element)) {
                  this.selected = i;
                  return element;
                }
              }
              return void 0;
            }
          }, {
            key: "shader",
            set: function set(shaderProps) {
              var _renderer$;
              this.lng.shader = isArray(shaderProps) ? (_renderer$ = renderer$1).createShader.apply(_renderer$, _toConsumableArray(shaderProps)) : shaderProps;
            }
          }, {
            key: "_sendToLightningAnimatable",
            value: function _sendToLightningAnimatable(name, value) {
              var _this58 = this;
              if (this.transition && this.rendered && Config.animationsEnabled && (this.transition === true || this.transition[name])) {
                var animationSettings = this.transition === true || this.transition[name] === true ? void 0 : this.transition[name];
                if (Config.simpleAnimationsEnabled) {
                  simpleAnimation.add(this, name, value, animationSettings || this.animationSettings);
                  simpleAnimation.register(renderer$1.stage);
                  return;
                } else {
                  var animationController = this.animate(_defineProperty({}, name, value), animationSettings);
                  if (this.onAnimation) {
                    var animationEvents = Object.keys(this.onAnimation);
                    var _loop6 = function _loop6() {
                      var event = _animationEvents[_i7];
                      var handler = _this58.onAnimation[event];
                      animationController.on(event, function (controller, props) {
                        handler.call(_this58, controller, name, value, props);
                      });
                    };
                    for (var _i7 = 0, _animationEvents = animationEvents; _i7 < _animationEvents.length; _i7++) {
                      _loop6();
                    }
                  }
                  return animationController.start();
                }
              }
              this.lng[name] = value;
            }
          }, {
            key: "animate",
            value: function animate(props, animationSettings) {
              return this.lng.animate(props, animationSettings || this.animationSettings || {});
            }
          }, {
            key: "chain",
            value: function chain(props, animationSettings) {
              if (this._animationRunning) {
                this._animationQueue = [];
                this._animationRunning = false;
              }
              if (animationSettings) {
                this._animationQueueSettings = animationSettings;
              } else if (!this._animationQueueSettings) {
                this._animationQueueSettings = animationSettings || this.animationSettings;
              }
              animationSettings = animationSettings || this._animationQueueSettings;
              this._animationQueue = this._animationQueue || [];
              this._animationQueue.push({
                props: props,
                animationSettings: animationSettings
              });
              return this;
            }
          }, {
            key: "start",
            value: function () {
              var _start = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18() {
                var animation;
                return _regenerator().w(function (_context19) {
                  while (1) switch (_context19.n) {
                    case 0:
                      animation = this._animationQueue.shift();
                    case 1:
                      if (!animation) {
                        _context19.n = 3;
                        break;
                      }
                      this._animationRunning = true;
                      _context19.n = 2;
                      return this.animate(animation.props, animation.animationSettings).start().waitUntilStopped();
                    case 2:
                      animation = this._animationQueue.shift();
                      _context19.n = 1;
                      break;
                    case 3:
                      this._animationRunning = false;
                      this._animationQueueSettings = void 0;
                    case 4:
                      return _context19.a(2);
                  }
                }, _callee18, this);
              }));
              function start() {
                return _start.apply(this, arguments);
              }
              return start;
            }()
          }, {
            key: "emit",
            value: function emit(event) {
              var current = this;
              var capitalizedEvent = "on".concat(event.charAt(0).toUpperCase()).concat(event.slice(1));
              for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key17 = 1; _key17 < _len12; _key17++) {
                args[_key17 - 1] = arguments[_key17];
              }
              while (current) {
                var handler = current[capitalizedEvent];
                if (isFunction(handler)) {
                  if (handler.call.apply(handler, [current, this].concat(args)) === true) {
                    return true;
                  }
                }
                current = current.parent;
              }
              return false;
            }
          }, {
            key: "setFocus",
            value: function setFocus() {
              var _this59 = this;
              if (this.rendered) {
                if (this.forwardFocus !== void 0) {
                  if (isFunc(this.forwardFocus)) {
                    if (this.forwardFocus.call(this, this) !== false) {
                      return;
                    }
                  } else {
                    var focusedIndex = typeof this.forwardFocus === "number" ? this.forwardFocus : null;
                    var nodes = this.children;
                    if (focusedIndex !== null && focusedIndex < nodes.length) {
                      var child = nodes[focusedIndex];
                      isElementNode(child) && child.setFocus();
                      return;
                    }
                  }
                }
                queueMicrotask(function () {
                  return setActiveElement$1(_this59);
                });
              } else {
                this._autofocus = true;
              }
            }
          }, {
            key: "_layoutOnLoad",
            value: function _layoutOnLoad() {
              var _this60 = this;
              this.lng.on("loaded", function () {
                _this60.parent.updateLayout();
              });
            }
          }, {
            key: "getText",
            value: function getText() {
              var result = "";
              for (var i = 0; i < this.children.length; i++) {
                result += this.children[i].text;
              }
              return result;
            }
          }, {
            key: "destroy",
            value: function destroy() {
              var _this61 = this;
              if (this.onDestroy) {
                var destroyPromise = this.onDestroy(this);
                if (destroyPromise instanceof Promise) {
                  destroyPromise.then(function () {
                    return _this61._destroy();
                  });
                } else {
                  this._destroy();
                }
              } else {
                this._destroy();
              }
            }
          }, {
            key: "_destroy",
            value: function _destroy() {
              if (isINode(this.lng)) {
                var _this$parent2;
                this.lng.destroy();
                if ((_this$parent2 = this.parent) !== null && _this$parent2 !== void 0 && _this$parent2.requiresLayout()) {
                  this.parent.updateLayout();
                }
              }
            }
          }, {
            key: "style",
            get: function get() {
              return this._style;
            },
            set: function set(style) {
              if (Config.lockStyles && this._style) {
                return;
              }
              if (!style) {
                return;
              }
              this._style = style;
              for (var key in this._style) {
                if (this[key] === void 0) {
                  this[key] = this._style[key];
                }
              }
            }
          }, {
            key: "hasChildren",
            get: function get() {
              return this.children.length > 0;
            }
          }, {
            key: "src",
            get: function get() {
              return this.lng.src;
            },
            set: function set(src) {
              if (typeof src === "string") {
                this.lng.src = src;
                if (!this.color && this.rendered) {
                  this.color = 4294967295;
                }
              } else {
                this.color = 0;
              }
            }
          }, {
            key: "getChildById",
            value: function getChildById(id) {
              return this.children.find(function (c) {
                return c.id === id;
              });
            }
          }, {
            key: "searchChildrenById",
            value: function searchChildrenById(id) {
              for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (isElementNode(child)) {
                  if (child.id === id) {
                    return child;
                  }
                  var found = child.searchChildrenById(id);
                  if (found) {
                    return found;
                  }
                }
              }
            }
          }, {
            key: "states",
            get: function get() {
              this._states = this._states || new States(this._stateChanged.bind(this));
              return this._states;
            },
            set: function set(states) {
              this._states = this._states ? this._states.merge(states) : new States(this._stateChanged.bind(this), states);
              if (this.rendered) {
                this._stateChanged();
              }
            }
          }, {
            key: "animationSettings",
            get: function get() {
              return this._animationSettings || Config.animationSettings;
            },
            set: function set(animationSettings) {
              this._animationSettings = animationSettings;
            }
          }, {
            key: "hidden",
            get: function get() {
              return this.alpha === 0;
            },
            set: function set(val) {
              this.alpha = val ? 0 : 1;
            }
          }, {
            key: "h",
            get: function get() {
              return this.height;
            },
            set: function set(h) {
              this.height = h;
            }
          }, {
            key: "w",
            get: function get() {
              return this.width;
            },
            set: function set(w) {
              this.width = w;
            }
            /**
             * Sets the autofocus state of the element.
             * When set to a truthy value, the element will automatically gain focus.
             * You can also set it to a signal to recalculate
             *
             * @param val - A value to determine if the element should autofocus.
             *              A truthy value enables autofocus, otherwise disables it.
             */
          }, {
            key: "autofocus",
            get: function get() {
              return this._autofocus;
            },
            set: function set(val) {
              var _this62 = this;
              this._autofocus = val;
              val && queueMicrotask(function () {
                return _this62.setFocus();
              });
            }
          }, {
            key: "requiresLayout",
            value: function requiresLayout() {
              return this.display === "flex" || this.onLayout;
            }
          }, {
            key: "updateLayoutOn",
            get: function get() {
              return null;
            },
            set: function set(v) {
              this.updateLayout();
            }
          }, {
            key: "updateLayout",
            value: function updateLayout() {
              var _this63 = this;
              if (this.hasChildren) {
                if (this.display === "flex" && this.flexGrow && this.width === 0) {
                  return;
                }
                var flexChanged = this.display === "flex" && calculateFlex(this);
                layoutQueue.delete(this);
                var onLayoutChanged = isFunc(this.onLayout) && this.onLayout.call(this, this);
                if ((flexChanged || onLayoutChanged) && this.parent) {
                  addToLayoutQueue(this.parent);
                }
                if (this._containsFlexGrow === true) {
                  this.children.forEach(function (c) {
                    if (c.display === "flex" && isElementNode(c)) {
                      calculateFlex(c);
                      isFunc(c.onLayout) && c.onLayout.call(c, c);
                      addToLayoutQueue(_this63);
                    }
                  });
                }
              }
            }
          }, {
            key: "_stateChanged",
            value: function _stateChanged() {
              var _this64 = this;
              if (this.forwardStates) {
                var states2 = this.states.slice();
                this.children.forEach(function (c) {
                  c.states = states2;
                });
              }
              var states = this.states;
              if (this._undoStyles || keyExists(this, states)) {
                var stylesToUndo;
                if (this._undoStyles && this._undoStyles.length) {
                  stylesToUndo = {};
                  this._undoStyles.forEach(function (styleKey) {
                    stylesToUndo[styleKey] = _this64.style[styleKey];
                  });
                }
                var numStates = states.length;
                if (numStates === 0) {
                  Object.assign(this, stylesToUndo);
                  this._undoStyles = [];
                  return;
                }
                var newStyles;
                if (numStates === 1) {
                  newStyles = this[states[0]];
                  newStyles = stylesToUndo ? _objectSpread(_objectSpread({}, stylesToUndo), newStyles) : newStyles;
                } else {
                  newStyles = states.reduce(function (acc, state) {
                    var styles = _this64[state];
                    return styles ? _objectSpread(_objectSpread({}, acc), styles) : acc;
                  }, stylesToUndo || {});
                }
                if (newStyles) {
                  this._undoStyles = Object.keys(newStyles);
                  if (newStyles.transition !== void 0) {
                    this.transition = newStyles.transition;
                  }
                  Object.assign(this, newStyles);
                } else {
                  this._undoStyles = [];
                }
              }
            }
          }, {
            key: "render",
            value: function render(topNode) {
              var _this$onCreate, _this$onRender2, _node$lng;
              var node = this;
              var parent = this.parent;
              if (!parent) {
                console.warn("Parent not set - no node created for: ", this);
                return;
              }
              if (!parent.rendered) {
                console.warn("Parent not rendered yet: ", this);
                return;
              }
              if (parent.requiresLayout()) {
                layoutQueue.add(parent);
              }
              if (this.rendered) {
                var _this$onRender;
                (_this$onRender = this.onRender) === null || _this$onRender === void 0 || _this$onRender.call(this, this);
                return;
              }
              if (this._states) {
                this._stateChanged();
              }
              var props = node.lng;
              var parentWidth = parent.width || 0;
              var parentHeight = parent.height || 0;
              props.x = props.x || 0;
              props.y = props.y || 0;
              props.parent = parent.lng;
              if (this.right || this.right === 0) {
                props.x = parentWidth - this.right;
                props.mountX = 1;
              }
              if (this.bottom || this.bottom === 0) {
                props.y = parentHeight - this.bottom;
                props.mountY = 1;
              }
              if (this.center) {
                this.centerX = this.centerY = true;
              }
              if (this.centerX) {
                props.x += parentWidth / 2;
                props.mountX = 0.5;
              }
              if (this.centerY) {
                props.y += parentHeight / 2;
                props.mountY = 0.5;
              }
              if (isElementText(node)) {
                var textProps = props;
                if (Config.fontSettings) {
                  for (var key in Config.fontSettings) {
                    if (textProps[key] === void 0) {
                      textProps[key] = Config.fontSettings[key];
                    }
                  }
                }
                textProps.text = textProps.text || node.getText();
                if (textProps.textAlign && !textProps.contain) {
                  console.warn("Text align requires contain: ", node.getText());
                }
                if (textProps.contain) {
                  if (!textProps.width) {
                    textProps.width = parentWidth - textProps.x - (textProps.marginRight || 0);
                  }
                  if (textProps.contain === "both" && !textProps.height && !textProps.maxLines) {
                    textProps.height = parentHeight - textProps.y - (textProps.marginBottom || 0);
                  } else if (textProps.maxLines === 1) {
                    textProps.height = textProps.height || textProps.lineHeight || textProps.fontSize;
                  }
                }
                if (SHADERS_ENABLED && node._effects) {
                  props.shader = convertEffectsToShader(node, node._effects);
                }
                node.lng = renderer$1.createTextNode(props);
                if (parent.requiresLayout()) {
                  if (!props.width || !props.height) {
                    node._layoutOnLoad();
                  }
                }
              } else {
                if (!props.texture) {
                  if (isNaN(props.width)) {
                    props.width = node.flexGrow ? 0 : parentWidth - props.x;
                    node._calcWidth = true;
                  }
                  if (isNaN(props.height)) {
                    props.height = parentHeight - props.y;
                    node._calcHeight = true;
                  }
                  if (props.rtt && !props.color) {
                    props.color = 4294967295;
                  }
                  if (!props.color && !props.src) {
                    props.color = 0;
                  }
                }
                if (SHADERS_ENABLED && node._effects) {
                  props.shader = convertEffectsToShader(node, node._effects);
                }
                node.lng = renderer$1.createNode(props);
                if (node._hasRenderedChildren) {
                  node._hasRenderedChildren = false;
                  var _iterator24 = _createForOfIteratorHelper(node.children),
                    _step24;
                  try {
                    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                      var child = _step24.value;
                      if (isElementNode(child) && isINode(child.lng)) {
                        child.lng.parent = node.lng;
                      }
                    }
                  } catch (err) {
                    _iterator24.e(err);
                  } finally {
                    _iterator24.f();
                  }
                }
              }
              node.rendered = true;
              if (node.autosize && parent.requiresLayout()) {
                node._layoutOnLoad();
              }
              (_this$onCreate = this.onCreate) === null || _this$onCreate === void 0 || _this$onCreate.call(this, this);
              (_this$onRender2 = this.onRender) === null || _this$onRender2 === void 0 || _this$onRender2.call(this, this);
              if (node.onEvent) {
                var _loop7 = function _loop7() {
                  var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i8], 2),
                    name = _Object$entries4$_i[0],
                    handler = _Object$entries4$_i[1];
                  node.lng.on(name, function (_inode, data) {
                    return handler.call(node, node, data);
                  });
                };
                for (var _i8 = 0, _Object$entries4 = Object.entries(node.onEvent); _i8 < _Object$entries4.length; _i8++) {
                  _loop7();
                }
              }
              if ((_node$lng = node.lng) !== null && _node$lng !== void 0 && _node$lng.div) {
                node.lng.div.element = node;
              }
              if (node._type === NodeType.Element) {
                var numChildren = node.children.length;
                for (var i = 0; i < numChildren; i++) {
                  var c = node.children[i];
                  if (isElementNode(c)) {
                    c.render();
                  }
                }
              }
              if (topNode && !layoutRunQueued) {
                layoutRunQueued = true;
                queueMicrotask(runLayout);
              }
              node._autofocus && node.setFocus();
            }
          }]);
        }(/*#__PURE__*/_wrapNativeSuper(Object));
        exports("E", ElementNode);
        var _loop8 = function _loop8() {
          var key = _LightningRendererNum[_i9];
          Object.defineProperty(ElementNode.prototype, key, {
            get: function get() {
              return this.lng[key];
            },
            set: function set(v) {
              this._sendToLightningAnimatable(key, v);
            }
          });
        };
        for (var _i9 = 0, _LightningRendererNum = LightningRendererNumberProps; _i9 < _LightningRendererNum.length; _i9++) {
          _loop8();
        }
        var _loop9 = function _loop9() {
          var key = _LightningRendererNon[_i0];
          Object.defineProperty(ElementNode.prototype, key, {
            get: function get() {
              return this.lng[key];
            },
            set: function set(v) {
              this.lng[key] = v;
            }
          });
        };
        for (var _i0 = 0, _LightningRendererNon = LightningRendererNonAnimatingProps; _i0 < _LightningRendererNon.length; _i0++) {
          _loop9();
        }
        function createEffectAccessor(key) {
          return {
            set: function set(value) {
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects), {}, _defineProperty({}, key, value)) : _defineProperty({}, key, value);
            },
            get: function get() {
              var _this$effects2;
              return (_this$effects2 = this.effects) === null || _this$effects2 === void 0 ? void 0 : _this$effects2[key];
            }
          };
        }
        Object.defineProperties(ElementNode.prototype, {
          border: borderAccessor(),
          borderLeft: borderAccessor("Left"),
          borderRight: borderAccessor("Right"),
          borderTop: borderAccessor("Top"),
          borderBottom: borderAccessor("Bottom"),
          linearGradient: createEffectAccessor("linearGradient"),
          radialGradient: createEffectAccessor("radialGradient"),
          radialProgress: createEffectAccessor("radialProgressGradient"),
          rounded: {
            set: function set(radius) {
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects), {}, {
                radius: {
                  radius: radius
                }
              }) : {
                radius: {
                  radius: radius
                }
              };
            },
            get: function get() {
              var _this$effects3;
              return (_this$effects3 = this.effects) === null || _this$effects3 === void 0 || (_this$effects3 = _this$effects3.radius) === null || _this$effects3 === void 0 ? void 0 : _this$effects3.radius;
            }
          },
          borderRadius: {
            set: function set(radius) {
              this.effects = this.effects ? _objectSpread(_objectSpread({}, this.effects), {}, {
                radius: {
                  radius: radius
                }
              }) : {
                radius: {
                  radius: radius
                }
              };
            },
            get: function get() {
              var _this$effects4;
              return (_this$effects4 = this.effects) === null || _this$effects4 === void 0 || (_this$effects4 = _this$effects4.radius) === null || _this$effects4 === void 0 ? void 0 : _this$effects4.radius;
            }
          }
        });
        var sharedConfig = {
          context: undefined,
          registry: undefined,
          effects: undefined,
          done: false,
          getContextId: function getContextId() {
            return _getContextId(this.context.count);
          },
          getNextContextId: function getNextContextId() {
            return _getContextId(this.context.count++);
          }
        };
        function _getContextId(count) {
          var num = String(count),
            len = num.length - 1;
          return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
        }
        function setHydrateContext(context) {
          sharedConfig.context = context;
        }
        var IS_DEV = false;
        var equalFn = function equalFn(a, b) {
          return a === b;
        };
        var $PROXY = Symbol("solid-proxy");
        var SUPPORTS_PROXY$1 = typeof Proxy === "function";
        var $TRACK = Symbol("solid-track");
        var signalOptions = {
          equals: equalFn
        };
        var runEffects = runQueue;
        var STALE = 1;
        var PENDING = 2;
        var UNOWNED = {
          owned: null,
          cleanups: null,
          context: null,
          owner: null
        };
        var NO_INIT = {};
        var Owner = null;
        var Transition = null;
        var ExternalSourceConfig = null;
        var Listener = null;
        var Updates = null;
        var Effects = null;
        var ExecCount = 0;
        function createRoot(fn, detachedOwner) {
          var listener = Listener,
            owner = Owner,
            unowned = fn.length === 0,
            current = detachedOwner === undefined ? owner : detachedOwner,
            root = unowned ? UNOWNED : {
              owned: null,
              cleanups: null,
              context: current ? current.context : null,
              owner: current
            },
            updateFn = unowned ? fn : function () {
              return fn(function () {
                return untrack(function () {
                  return cleanNode(root);
                });
              });
            };
          Owner = root;
          Listener = null;
          try {
            return runUpdates(updateFn, true);
          } finally {
            Listener = listener;
            Owner = owner;
          }
        }
        function createSignal(value, options) {
          options = options ? Object.assign({}, signalOptions, options) : signalOptions;
          var s = {
            value: value,
            observers: null,
            observerSlots: null,
            comparator: options.equals || undefined
          };
          var setter = function setter(value) {
            if (typeof value === "function") {
              if (Transition && Transition.running && Transition.sources.has(s)) value = value(s.tValue);else value = value(s.value);
            }
            return writeSignal(s, value);
          };
          return [readSignal.bind(s), setter];
        }
        function createComputed(fn, value, options) {
          var c = createComputation(fn, value, true, STALE);
          updateComputation(c);
        }
        function createRenderEffect(fn, value, options) {
          var c = createComputation(fn, value, false, STALE);
          updateComputation(c);
        }
        function createEffect(fn, value, options) {
          runEffects = runUserEffects;
          var c = createComputation(fn, value, false, STALE),
            s = SuspenseContext && useContext(SuspenseContext);
          if (s) c.suspense = s;
          c.user = true;
          Effects ? Effects.push(c) : updateComputation(c);
        }
        function createMemo(fn, value, options) {
          options = options ? Object.assign({}, signalOptions, options) : signalOptions;
          var c = createComputation(fn, value, true, 0);
          c.observers = null;
          c.observerSlots = null;
          c.comparator = options.equals || undefined;
          updateComputation(c);
          return readSignal.bind(c);
        }
        function isPromise(v) {
          return v && _typeof(v) === "object" && "then" in v;
        }
        function createResource(pSource, pFetcher, pOptions) {
          var source;
          var fetcher;
          var options;
          if (typeof pFetcher === "function") {
            source = pSource;
            fetcher = pFetcher;
            options = {};
          } else {
            source = true;
            fetcher = pSource;
            options = pFetcher || {};
          }
          var pr = null,
            initP = NO_INIT,
            id = null,
            loadedUnderTransition = false,
            scheduled = false,
            resolved = "initialValue" in options,
            dynamic = typeof source === "function" && createMemo(source);
          var contexts = new Set(),
            _ref31 = (options.storage || createSignal)(options.initialValue),
            _ref32 = _slicedToArray(_ref31, 2),
            value = _ref32[0],
            setValue = _ref32[1],
            _createSignal = createSignal(undefined),
            _createSignal2 = _slicedToArray(_createSignal, 2),
            error = _createSignal2[0],
            setError = _createSignal2[1],
            _createSignal3 = createSignal(undefined, {
              equals: false
            }),
            _createSignal4 = _slicedToArray(_createSignal3, 2),
            track = _createSignal4[0],
            trigger = _createSignal4[1],
            _createSignal5 = createSignal(resolved ? "ready" : "unresolved"),
            _createSignal6 = _slicedToArray(_createSignal5, 2),
            state = _createSignal6[0],
            setState = _createSignal6[1];
          if (sharedConfig.context) {
            id = sharedConfig.getNextContextId();
            if (options.ssrLoadFrom === "initial") initP = options.initialValue;else if (sharedConfig.load && sharedConfig.has(id)) initP = sharedConfig.load(id);
          }
          function loadEnd(p, v, error, key) {
            if (pr === p) {
              pr = null;
              key !== undefined && (resolved = true);
              if ((p === initP || v === initP) && options.onHydrated) queueMicrotask(function () {
                return options.onHydrated(key, {
                  value: v
                });
              });
              initP = NO_INIT;
              if (Transition && p && loadedUnderTransition) {
                Transition.promises.delete(p);
                loadedUnderTransition = false;
                runUpdates(function () {
                  Transition.running = true;
                  completeLoad(v, error);
                }, false);
              } else completeLoad(v, error);
            }
            return v;
          }
          function completeLoad(v, err) {
            runUpdates(function () {
              if (err === undefined) setValue(function () {
                return v;
              });
              setState(err !== undefined ? "errored" : resolved ? "ready" : "unresolved");
              setError(err);
              var _iterator25 = _createForOfIteratorHelper(contexts.keys()),
                _step25;
              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                  var c = _step25.value;
                  c.decrement();
                }
              } catch (err) {
                _iterator25.e(err);
              } finally {
                _iterator25.f();
              }
              contexts.clear();
            }, false);
          }
          function read() {
            var c = SuspenseContext && useContext(SuspenseContext),
              v = value(),
              err = error();
            if (err !== undefined && !pr) throw err;
            if (Listener && !Listener.user && c) {
              createComputed(function () {
                track();
                if (pr) {
                  if (c.resolved && Transition && loadedUnderTransition) Transition.promises.add(pr);else if (!contexts.has(c)) {
                    c.increment();
                    contexts.add(c);
                  }
                }
              });
            }
            return v;
          }
          function load() {
            var refetching = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            if (refetching !== false && scheduled) return;
            scheduled = false;
            var lookup = dynamic ? dynamic() : source;
            loadedUnderTransition = Transition && Transition.running;
            if (lookup == null || lookup === false) {
              loadEnd(pr, untrack(value));
              return;
            }
            if (Transition && pr) Transition.promises.delete(pr);
            var error;
            var p = initP !== NO_INIT ? initP : untrack(function () {
              try {
                return fetcher(lookup, {
                  value: value(),
                  refetching: refetching
                });
              } catch (fetcherError) {
                error = fetcherError;
              }
            });
            if (error !== undefined) {
              loadEnd(pr, undefined, castError(error), lookup);
              return;
            } else if (!isPromise(p)) {
              loadEnd(pr, p, undefined, lookup);
              return p;
            }
            pr = p;
            if ("v" in p) {
              if (p.s === 1) loadEnd(pr, p.v, undefined, lookup);else loadEnd(pr, undefined, castError(p.v), lookup);
              return p;
            }
            scheduled = true;
            queueMicrotask(function () {
              return scheduled = false;
            });
            runUpdates(function () {
              setState(resolved ? "refreshing" : "pending");
              trigger();
            }, false);
            return p.then(function (v) {
              return loadEnd(p, v, undefined, lookup);
            }, function (e) {
              return loadEnd(p, undefined, castError(e), lookup);
            });
          }
          Object.defineProperties(read, {
            state: {
              get: function get() {
                return state();
              }
            },
            error: {
              get: function get() {
                return error();
              }
            },
            loading: {
              get: function get() {
                var s = state();
                return s === "pending" || s === "refreshing";
              }
            },
            latest: {
              get: function get() {
                if (!resolved) return read();
                var err = error();
                if (err && !pr) throw err;
                return value();
              }
            }
          });
          var owner = Owner;
          if (dynamic) createComputed(function () {
            return owner = Owner, load(false);
          });else load(false);
          return [read, {
            refetch: function refetch(info) {
              return runWithOwner(owner, function () {
                return load(info);
              });
            },
            mutate: setValue
          }];
        }
        function createSelector(source) {
          var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : equalFn;
          var options = arguments.length > 2 ? arguments[2] : undefined;
          var subs = new Map();
          var node = createComputation(function (p) {
            var v = source();
            var _iterator26 = _createForOfIteratorHelper(subs.entries()),
              _step26;
            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var _step26$value = _slicedToArray(_step26.value, 2),
                  key = _step26$value[0],
                  val = _step26$value[1];
                if (fn(key, v) !== fn(key, p)) {
                  var _iterator27 = _createForOfIteratorHelper(val.values()),
                    _step27;
                  try {
                    for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                      var c = _step27.value;
                      c.state = STALE;
                      if (c.pure) Updates.push(c);else Effects.push(c);
                    }
                  } catch (err) {
                    _iterator27.e(err);
                  } finally {
                    _iterator27.f();
                  }
                }
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }
            return v;
          }, undefined, true, STALE);
          updateComputation(node);
          return function (key) {
            var listener = Listener;
            if (listener) {
              var l;
              if (l = subs.get(key)) l.add(listener);else subs.set(key, l = new Set([listener]));
              onCleanup(function () {
                l.delete(listener);
                !l.size && subs.delete(key);
              });
            }
            return fn(key, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value);
          };
        }
        function batch(fn) {
          return runUpdates(fn, false);
        }
        function untrack(fn) {
          if (Listener === null) return fn();
          var listener = Listener;
          Listener = null;
          try {
            if (ExternalSourceConfig) ;
            return fn();
          } finally {
            Listener = listener;
          }
        }
        function on(deps, fn, options) {
          var isArray = Array.isArray(deps);
          var prevInput;
          var defer = options && options.defer;
          return function (prevValue) {
            var input;
            if (isArray) {
              input = Array(deps.length);
              for (var i = 0; i < deps.length; i++) input[i] = deps[i]();
            } else input = deps();
            if (defer) {
              defer = false;
              return prevValue;
            }
            var result = untrack(function () {
              return fn(input, prevInput, prevValue);
            });
            prevInput = input;
            return result;
          };
        }
        function onMount(fn) {
          createEffect(function () {
            return untrack(fn);
          });
        }
        function onCleanup(fn) {
          if (Owner === null) ;else if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);
          return fn;
        }
        function getOwner() {
          return Owner;
        }
        function runWithOwner(o, fn) {
          var prev = Owner;
          var prevListener = Listener;
          Owner = o;
          Listener = null;
          try {
            return runUpdates(fn, true);
          } catch (err) {
            handleError(err);
          } finally {
            Owner = prev;
            Listener = prevListener;
          }
        }
        function startTransition(fn) {
          if (Transition && Transition.running) {
            fn();
            return Transition.done;
          }
          var l = Listener;
          var o = Owner;
          return Promise.resolve().then(function () {
            Listener = l;
            Owner = o;
            var t;
            if (SuspenseContext) {
              t = Transition || (Transition = {
                sources: new Set(),
                effects: [],
                promises: new Set(),
                disposed: new Set(),
                queue: new Set(),
                running: true
              });
              t.done || (t.done = new Promise(function (res) {
                return t.resolve = res;
              }));
              t.running = true;
            }
            runUpdates(fn, false);
            Listener = Owner = null;
            return t ? t.done : undefined;
          });
        }
        var _createSignal7 = /*@__PURE__*/createSignal(false),
          _createSignal8 = _slicedToArray(_createSignal7, 2),
          transPending = _createSignal8[0],
          setTransPending = _createSignal8[1];
        function resumeEffects(e) {
          Effects.push.apply(Effects, e);
          e.length = 0;
        }
        function createContext(defaultValue, options) {
          var id = Symbol("context");
          return {
            id: id,
            Provider: createProvider(id),
            defaultValue: defaultValue
          };
        }
        function useContext(context) {
          var value;
          return Owner && Owner.context && (value = Owner.context[context.id]) !== undefined ? value : context.defaultValue;
        }
        function children(fn) {
          var children = createMemo(fn);
          var memo = createMemo(function () {
            return resolveChildren(children());
          });
          memo.toArray = function () {
            var c = memo();
            return Array.isArray(c) ? c : c != null ? [c] : [];
          };
          return memo;
        }
        var SuspenseContext;
        function getSuspenseContext() {
          return SuspenseContext || (SuspenseContext = createContext());
        }
        function readSignal() {
          var _this65 = this;
          var runningTransition = Transition && Transition.running;
          if (this.sources && (runningTransition ? this.tState : this.state)) {
            if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);else {
              var updates = Updates;
              Updates = null;
              runUpdates(function () {
                return lookUpstream(_this65);
              }, false);
              Updates = updates;
            }
          }
          if (Listener) {
            var sSlot = this.observers ? this.observers.length : 0;
            if (!Listener.sources) {
              Listener.sources = [this];
              Listener.sourceSlots = [sSlot];
            } else {
              Listener.sources.push(this);
              Listener.sourceSlots.push(sSlot);
            }
            if (!this.observers) {
              this.observers = [Listener];
              this.observerSlots = [Listener.sources.length - 1];
            } else {
              this.observers.push(Listener);
              this.observerSlots.push(Listener.sources.length - 1);
            }
          }
          if (runningTransition && Transition.sources.has(this)) return this.tValue;
          return this.value;
        }
        function writeSignal(node, value, isComp) {
          var current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
          if (!node.comparator || !node.comparator(current, value)) {
            if (Transition) {
              var TransitionRunning = Transition.running;
              if (TransitionRunning || !isComp && Transition.sources.has(node)) {
                Transition.sources.add(node);
                node.tValue = value;
              }
              if (!TransitionRunning) node.value = value;
            } else node.value = value;
            if (node.observers && node.observers.length) {
              runUpdates(function () {
                for (var i = 0; i < node.observers.length; i += 1) {
                  var o = node.observers[i];
                  var _TransitionRunning = Transition && Transition.running;
                  if (_TransitionRunning && Transition.disposed.has(o)) continue;
                  if (_TransitionRunning ? !o.tState : !o.state) {
                    if (o.pure) Updates.push(o);else Effects.push(o);
                    if (o.observers) markDownstream(o);
                  }
                  if (!_TransitionRunning) o.state = STALE;else o.tState = STALE;
                }
                if (Updates.length > 10e5) {
                  Updates = [];
                  if (IS_DEV) ;
                  throw new Error();
                }
              }, false);
            }
          }
          return value;
        }
        function updateComputation(node) {
          if (!node.fn) return;
          cleanNode(node);
          var time = ExecCount;
          runComputation(node, Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value, time);
          if (Transition && !Transition.running && Transition.sources.has(node)) {
            queueMicrotask(function () {
              runUpdates(function () {
                Transition && (Transition.running = true);
                Listener = Owner = node;
                runComputation(node, node.tValue, time);
                Listener = Owner = null;
              }, false);
            });
          }
        }
        function runComputation(node, value, time) {
          var nextValue;
          var owner = Owner,
            listener = Listener;
          Listener = Owner = node;
          try {
            nextValue = node.fn(value);
          } catch (err) {
            if (node.pure) {
              if (Transition && Transition.running) {
                node.tState = STALE;
                node.tOwned && node.tOwned.forEach(cleanNode);
                node.tOwned = undefined;
              } else {
                node.state = STALE;
                node.owned && node.owned.forEach(cleanNode);
                node.owned = null;
              }
            }
            node.updatedAt = time + 1;
            return handleError(err);
          } finally {
            Listener = listener;
            Owner = owner;
          }
          if (!node.updatedAt || node.updatedAt <= time) {
            if (node.updatedAt != null && "observers" in node) {
              writeSignal(node, nextValue, true);
            } else if (Transition && Transition.running && node.pure) {
              Transition.sources.add(node);
              node.tValue = nextValue;
            } else node.value = nextValue;
            node.updatedAt = time;
          }
        }
        function createComputation(fn, init, pure) {
          var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : STALE;
          var options = arguments.length > 4 ? arguments[4] : undefined;
          var c = {
            fn: fn,
            state: state,
            updatedAt: null,
            owned: null,
            sources: null,
            sourceSlots: null,
            cleanups: null,
            value: init,
            owner: Owner,
            context: Owner ? Owner.context : null,
            pure: pure
          };
          if (Transition && Transition.running) {
            c.state = 0;
            c.tState = state;
          }
          if (Owner === null) ;else if (Owner !== UNOWNED) {
            if (Transition && Transition.running && Owner.pure) {
              if (!Owner.tOwned) Owner.tOwned = [c];else Owner.tOwned.push(c);
            } else {
              if (!Owner.owned) Owner.owned = [c];else Owner.owned.push(c);
            }
          }
          return c;
        }
        function runTop(node) {
          var runningTransition = Transition && Transition.running;
          if ((runningTransition ? node.tState : node.state) === 0) return;
          if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
          if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
          var ancestors = [node];
          while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
            if (runningTransition && Transition.disposed.has(node)) return;
            if (runningTransition ? node.tState : node.state) ancestors.push(node);
          }
          for (var i = ancestors.length - 1; i >= 0; i--) {
            node = ancestors[i];
            if (runningTransition) {
              var top = node,
                prev = ancestors[i + 1];
              while ((top = top.owner) && top !== prev) {
                if (Transition.disposed.has(top)) return;
              }
            }
            if ((runningTransition ? node.tState : node.state) === STALE) {
              updateComputation(node);
            } else if ((runningTransition ? node.tState : node.state) === PENDING) {
              var updates = Updates;
              Updates = null;
              runUpdates(function () {
                return lookUpstream(node, ancestors[0]);
              }, false);
              Updates = updates;
            }
          }
        }
        function runUpdates(fn, init) {
          if (Updates) return fn();
          var wait = false;
          if (!init) Updates = [];
          if (Effects) wait = true;else Effects = [];
          ExecCount++;
          try {
            var res = fn();
            completeUpdates(wait);
            return res;
          } catch (err) {
            if (!wait) Effects = null;
            Updates = null;
            handleError(err);
          }
        }
        function completeUpdates(wait) {
          if (Updates) {
            runQueue(Updates);
            Updates = null;
          }
          if (wait) return;
          var res;
          if (Transition) {
            if (!Transition.promises.size && !Transition.queue.size) {
              var sources = Transition.sources;
              var disposed = Transition.disposed;
              Effects.push.apply(Effects, Transition.effects);
              res = Transition.resolve;
              var _iterator28 = _createForOfIteratorHelper(Effects),
                _step28;
              try {
                for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                  var _e = _step28.value;
                  "tState" in _e && (_e.state = _e.tState);
                  delete _e.tState;
                }
              } catch (err) {
                _iterator28.e(err);
              } finally {
                _iterator28.f();
              }
              Transition = null;
              runUpdates(function () {
                var _iterator29 = _createForOfIteratorHelper(disposed),
                  _step29;
                try {
                  for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                    var d = _step29.value;
                    cleanNode(d);
                  }
                } catch (err) {
                  _iterator29.e(err);
                } finally {
                  _iterator29.f();
                }
                var _iterator30 = _createForOfIteratorHelper(sources),
                  _step30;
                try {
                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                    var v = _step30.value;
                    v.value = v.tValue;
                    if (v.owned) {
                      for (var i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
                    }
                    if (v.tOwned) v.owned = v.tOwned;
                    delete v.tValue;
                    delete v.tOwned;
                    v.tState = 0;
                  }
                } catch (err) {
                  _iterator30.e(err);
                } finally {
                  _iterator30.f();
                }
                setTransPending(false);
              }, false);
            } else if (Transition.running) {
              Transition.running = false;
              Transition.effects.push.apply(Transition.effects, Effects);
              Effects = null;
              setTransPending(true);
              return;
            }
          }
          var e = Effects;
          Effects = null;
          if (e.length) runUpdates(function () {
            return runEffects(e);
          }, false);
          if (res) res();
        }
        function runQueue(queue) {
          for (var i = 0; i < queue.length; i++) runTop(queue[i]);
        }
        function runUserEffects(queue) {
          var i,
            userLength = 0;
          for (i = 0; i < queue.length; i++) {
            var e = queue[i];
            if (!e.user) runTop(e);else queue[userLength++] = e;
          }
          if (sharedConfig.context) {
            if (sharedConfig.count) {
              var _sharedConfig$effects;
              sharedConfig.effects || (sharedConfig.effects = []);
              (_sharedConfig$effects = sharedConfig.effects).push.apply(_sharedConfig$effects, _toConsumableArray(queue.slice(0, userLength)));
              return;
            }
            setHydrateContext();
          }
          if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
            queue = [].concat(_toConsumableArray(sharedConfig.effects), _toConsumableArray(queue));
            userLength += sharedConfig.effects.length;
            delete sharedConfig.effects;
          }
          for (i = 0; i < userLength; i++) runTop(queue[i]);
        }
        function lookUpstream(node, ignore) {
          var runningTransition = Transition && Transition.running;
          if (runningTransition) node.tState = 0;else node.state = 0;
          for (var i = 0; i < node.sources.length; i += 1) {
            var source = node.sources[i];
            if (source.sources) {
              var state = runningTransition ? source.tState : source.state;
              if (state === STALE) {
                if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount)) runTop(source);
              } else if (state === PENDING) lookUpstream(source, ignore);
            }
          }
        }
        function markDownstream(node) {
          var runningTransition = Transition && Transition.running;
          for (var i = 0; i < node.observers.length; i += 1) {
            var o = node.observers[i];
            if (runningTransition ? !o.tState : !o.state) {
              if (runningTransition) o.tState = PENDING;else o.state = PENDING;
              if (o.pure) Updates.push(o);else Effects.push(o);
              o.observers && markDownstream(o);
            }
          }
        }
        function cleanNode(node) {
          var i;
          if (node.sources) {
            while (node.sources.length) {
              var source = node.sources.pop(),
                index = node.sourceSlots.pop(),
                obs = source.observers;
              if (obs && obs.length) {
                var n = obs.pop(),
                  s = source.observerSlots.pop();
                if (index < obs.length) {
                  n.sourceSlots[s] = index;
                  obs[index] = n;
                  source.observerSlots[index] = s;
                }
              }
            }
          }
          if (node.tOwned) {
            for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
            delete node.tOwned;
          }
          if (Transition && Transition.running && node.pure) {
            reset(node, true);
          } else if (node.owned) {
            for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
            node.owned = null;
          }
          if (node.cleanups) {
            for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
            node.cleanups = null;
          }
          if (Transition && Transition.running) node.tState = 0;else node.state = 0;
        }
        function reset(node, top) {
          if (!top) {
            node.tState = 0;
            Transition.disposed.add(node);
          }
          if (node.owned) {
            for (var i = 0; i < node.owned.length; i++) reset(node.owned[i]);
          }
        }
        function castError(err) {
          if (err instanceof Error) return err;
          return new Error(typeof err === "string" ? err : "Unknown error", {
            cause: err
          });
        }
        function handleError(err) {
          var owner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Owner;
          var error = castError(err);
          throw error;
        }
        function resolveChildren(children) {
          if (typeof children === "function" && !children.length) return resolveChildren(children());
          if (Array.isArray(children)) {
            var results = [];
            for (var i = 0; i < children.length; i++) {
              var result = resolveChildren(children[i]);
              Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
            }
            return results;
          }
          return children;
        }
        function createProvider(id, options) {
          return function provider(props) {
            var res;
            createRenderEffect(function () {
              return res = untrack(function () {
                Owner.context = _objectSpread(_objectSpread({}, Owner.context), {}, _defineProperty({}, id, props.value));
                return children(function () {
                  return props.children;
                });
              });
            }, undefined);
            return res;
          };
        }
        var FALLBACK = Symbol("fallback");
        function dispose(d) {
          for (var i = 0; i < d.length; i++) d[i]();
        }
        function mapArray(list, mapFn) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var items = [],
            mapped = [],
            disposers = [],
            len = 0,
            indexes = mapFn.length > 1 ? [] : null;
          onCleanup(function () {
            return dispose(disposers);
          });
          return function () {
            var newItems = list() || [],
              newLen = newItems.length,
              i,
              j;
            newItems[$TRACK];
            return untrack(function () {
              var newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
              if (newLen === 0) {
                if (len !== 0) {
                  dispose(disposers);
                  disposers = [];
                  items = [];
                  mapped = [];
                  len = 0;
                  indexes && (indexes = []);
                }
                if (options.fallback) {
                  items = [FALLBACK];
                  mapped[0] = createRoot(function (disposer) {
                    disposers[0] = disposer;
                    return options.fallback();
                  });
                  len = 1;
                }
              } else if (len === 0) {
                mapped = new Array(newLen);
                for (j = 0; j < newLen; j++) {
                  items[j] = newItems[j];
                  mapped[j] = createRoot(mapper);
                }
                len = newLen;
              } else {
                temp = new Array(newLen);
                tempdisposers = new Array(newLen);
                indexes && (tempIndexes = new Array(newLen));
                for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++);
                for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
                  temp[newEnd] = mapped[end];
                  tempdisposers[newEnd] = disposers[end];
                  indexes && (tempIndexes[newEnd] = indexes[end]);
                }
                newIndices = new Map();
                newIndicesNext = new Array(newEnd + 1);
                for (j = newEnd; j >= start; j--) {
                  item = newItems[j];
                  i = newIndices.get(item);
                  newIndicesNext[j] = i === undefined ? -1 : i;
                  newIndices.set(item, j);
                }
                for (i = start; i <= end; i++) {
                  item = items[i];
                  j = newIndices.get(item);
                  if (j !== undefined && j !== -1) {
                    temp[j] = mapped[i];
                    tempdisposers[j] = disposers[i];
                    indexes && (tempIndexes[j] = indexes[i]);
                    j = newIndicesNext[j];
                    newIndices.set(item, j);
                  } else disposers[i]();
                }
                for (j = start; j < newLen; j++) {
                  if (j in temp) {
                    mapped[j] = temp[j];
                    disposers[j] = tempdisposers[j];
                    if (indexes) {
                      indexes[j] = tempIndexes[j];
                      indexes[j](j);
                    }
                  } else mapped[j] = createRoot(mapper);
                }
                mapped = mapped.slice(0, len = newLen);
                items = newItems.slice(0);
              }
              return mapped;
            });
            function mapper(disposer) {
              disposers[j] = disposer;
              if (indexes) {
                var _createSignal9 = createSignal(j),
                  _createSignal0 = _slicedToArray(_createSignal9, 2),
                  s = _createSignal0[0],
                  set = _createSignal0[1];
                indexes[j] = set;
                return mapFn(newItems[j], s);
              }
              return mapFn(newItems[j]);
            }
          };
        }
        function indexArray(list, mapFn) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var items = [],
            mapped = [],
            disposers = [],
            signals = [],
            len = 0,
            i;
          onCleanup(function () {
            return dispose(disposers);
          });
          return function () {
            var newItems = list() || [],
              newLen = newItems.length;
            newItems[$TRACK];
            return untrack(function () {
              if (newLen === 0) {
                if (len !== 0) {
                  dispose(disposers);
                  disposers = [];
                  items = [];
                  mapped = [];
                  len = 0;
                  signals = [];
                }
                if (options.fallback) {
                  items = [FALLBACK];
                  mapped[0] = createRoot(function (disposer) {
                    disposers[0] = disposer;
                    return options.fallback();
                  });
                  len = 1;
                }
                return mapped;
              }
              if (items[0] === FALLBACK) {
                disposers[0]();
                disposers = [];
                items = [];
                mapped = [];
                len = 0;
              }
              for (i = 0; i < newLen; i++) {
                if (i < items.length && items[i] !== newItems[i]) {
                  signals[i](function () {
                    return newItems[i];
                  });
                } else if (i >= items.length) {
                  mapped[i] = createRoot(mapper);
                }
              }
              for (; i < items.length; i++) {
                disposers[i]();
              }
              len = signals.length = disposers.length = newLen;
              items = newItems.slice(0);
              return mapped = mapped.slice(0, len);
            });
            function mapper(disposer) {
              disposers[i] = disposer;
              var _createSignal1 = createSignal(newItems[i]),
                _createSignal10 = _slicedToArray(_createSignal1, 2),
                s = _createSignal10[0],
                set = _createSignal10[1];
              signals[i] = set;
              return mapFn(s, i);
            }
          };
        }
        function createComponent$1(Comp, props) {
          return untrack(function () {
            return Comp(props || {});
          });
        }
        function trueFn() {
          return true;
        }
        var propTraps = {
          get: function get(_, property, receiver) {
            if (property === $PROXY) return receiver;
            return _.get(property);
          },
          has: function has(_, property) {
            if (property === $PROXY) return true;
            return _.has(property);
          },
          set: trueFn,
          deleteProperty: trueFn,
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_, property) {
            return {
              configurable: true,
              enumerable: true,
              get: function get() {
                return _.get(property);
              },
              set: trueFn,
              deleteProperty: trueFn
            };
          },
          ownKeys: function ownKeys(_) {
            return _.keys();
          }
        };
        function resolveSource(s) {
          return !(s = typeof s === "function" ? s() : s) ? {} : s;
        }
        function resolveSources() {
          for (var i = 0, length = this.length; i < length; ++i) {
            var v = this[i]();
            if (v !== undefined) return v;
          }
        }
        function mergeProps$1() {
          for (var _len13 = arguments.length, sources = new Array(_len13), _key18 = 0; _key18 < _len13; _key18++) {
            sources[_key18] = arguments[_key18];
          }
          var proxy = false;
          for (var i = 0; i < sources.length; i++) {
            var s = sources[i];
            proxy = proxy || !!s && $PROXY in s;
            sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
          }
          if (SUPPORTS_PROXY$1 && proxy) {
            return new Proxy({
              get: function get(property) {
                for (var _i1 = sources.length - 1; _i1 >= 0; _i1--) {
                  var v = resolveSource(sources[_i1])[property];
                  if (v !== undefined) return v;
                }
              },
              has: function has(property) {
                for (var _i10 = sources.length - 1; _i10 >= 0; _i10--) {
                  if (property in resolveSource(sources[_i10])) return true;
                }
                return false;
              },
              keys: function keys() {
                var keys = [];
                for (var _i11 = 0; _i11 < sources.length; _i11++) keys.push.apply(keys, _toConsumableArray(Object.keys(resolveSource(sources[_i11]))));
                return _toConsumableArray(new Set(keys));
              }
            }, propTraps);
          }
          var sourcesMap = {};
          var defined = Object.create(null);
          for (var _i12 = sources.length - 1; _i12 >= 0; _i12--) {
            var source = sources[_i12];
            if (!source) continue;
            var sourceKeys = Object.getOwnPropertyNames(source);
            var _loop0 = function _loop0() {
              var key = sourceKeys[_i13];
              if (key === "__proto__" || key === "constructor") return 1; // continue
              var desc = Object.getOwnPropertyDescriptor(source, key);
              if (!defined[key]) {
                defined[key] = desc.get ? {
                  enumerable: true,
                  configurable: true,
                  get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
                } : desc.value !== undefined ? desc : undefined;
              } else {
                var _sources = sourcesMap[key];
                if (_sources) {
                  if (desc.get) _sources.push(desc.get.bind(source));else if (desc.value !== undefined) _sources.push(function () {
                    return desc.value;
                  });
                }
              }
            };
            for (var _i13 = sourceKeys.length - 1; _i13 >= 0; _i13--) {
              if (_loop0()) continue;
            }
          }
          var target = {};
          var definedKeys = Object.keys(defined);
          for (var _i14 = definedKeys.length - 1; _i14 >= 0; _i14--) {
            var key = definedKeys[_i14],
              desc = defined[key];
            if (desc && desc.get) Object.defineProperty(target, key, desc);else target[key] = desc ? desc.value : undefined;
          }
          return target;
        }
        function splitProps(props) {
          for (var _len14 = arguments.length, keys = new Array(_len14 > 1 ? _len14 - 1 : 0), _key19 = 1; _key19 < _len14; _key19++) {
            keys[_key19 - 1] = arguments[_key19];
          }
          if (SUPPORTS_PROXY$1 && $PROXY in props) {
            var blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
            var res = keys.map(function (k) {
              return new Proxy({
                get: function get(property) {
                  return k.includes(property) ? props[property] : undefined;
                },
                has: function has(property) {
                  return k.includes(property) && property in props;
                },
                keys: function keys() {
                  return k.filter(function (property) {
                    return property in props;
                  });
                }
              }, propTraps);
            });
            res.push(new Proxy({
              get: function get(property) {
                return blocked.has(property) ? undefined : props[property];
              },
              has: function has(property) {
                return blocked.has(property) ? false : property in props;
              },
              keys: function keys() {
                return Object.keys(props).filter(function (k) {
                  return !blocked.has(k);
                });
              }
            }, propTraps));
            return res;
          }
          var otherObject = {};
          var objects = keys.map(function () {
            return {};
          });
          var _iterator31 = _createForOfIteratorHelper(Object.getOwnPropertyNames(props)),
            _step31;
          try {
            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
              var propName = _step31.value;
              var desc = Object.getOwnPropertyDescriptor(props, propName);
              var isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
              var _blocked = false;
              var objectIndex = 0;
              var _iterator32 = _createForOfIteratorHelper(keys),
                _step32;
              try {
                for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                  var k = _step32.value;
                  if (k.includes(propName)) {
                    _blocked = true;
                    isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
                  }
                  ++objectIndex;
                }
              } catch (err) {
                _iterator32.e(err);
              } finally {
                _iterator32.f();
              }
              if (!_blocked) {
                isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
              }
            }
          } catch (err) {
            _iterator31.e(err);
          } finally {
            _iterator31.f();
          }
          return [].concat(_toConsumableArray(objects), [otherObject]);
        }
        function lazy(fn) {
          var comp;
          var p;
          var wrap = function wrap(props) {
            var ctx = sharedConfig.context;
            if (ctx) {
              var _createSignal11 = createSignal(),
                _createSignal12 = _slicedToArray(_createSignal11, 2),
                s = _createSignal12[0],
                set = _createSignal12[1];
              sharedConfig.count || (sharedConfig.count = 0);
              sharedConfig.count++;
              (p || (p = fn())).then(function (mod) {
                !sharedConfig.done && setHydrateContext(ctx);
                sharedConfig.count--;
                set(function () {
                  return mod.default;
                });
                setHydrateContext();
              });
              comp = s;
            } else if (!comp) {
              var _createResource = createResource(function () {
                  return (p || (p = fn())).then(function (mod) {
                    return mod.default;
                  });
                }),
                _createResource2 = _slicedToArray(_createResource, 1),
                _s = _createResource2[0];
              comp = _s;
            }
            var Comp;
            return createMemo(function () {
              return (Comp = comp()) ? untrack(function () {
                if (IS_DEV) ;
                if (!ctx || sharedConfig.done) return Comp(props);
                var c = sharedConfig.context;
                setHydrateContext(ctx);
                var r = Comp(props);
                setHydrateContext(c);
                return r;
              }) : "";
            });
          };
          wrap.preload = function () {
            return p || ((p = fn()).then(function (mod) {
              return comp = function comp() {
                return mod.default;
              };
            }), p);
          };
          return wrap;
        }
        var narrowedError = function narrowedError(name) {
          return "Stale read from <".concat(name, ">.");
        };
        function For(props) {
          var fallback = "fallback" in props && {
            fallback: function fallback() {
              return props.fallback;
            }
          };
          return createMemo(mapArray(function () {
            return props.each;
          }, props.children, fallback || undefined));
        }
        function Index(props) {
          var fallback = "fallback" in props && {
            fallback: function fallback() {
              return props.fallback;
            }
          };
          return createMemo(indexArray(function () {
            return props.each;
          }, props.children, fallback || undefined));
        }
        function Show(props) {
          var keyed = props.keyed;
          var conditionValue = createMemo(function () {
            return props.when;
          }, undefined, undefined);
          var condition = keyed ? conditionValue : createMemo(conditionValue, undefined, {
            equals: function equals(a, b) {
              return !a === !b;
            }
          });
          return createMemo(function () {
            var c = condition();
            if (c) {
              var child = props.children;
              var fn = typeof child === "function" && child.length > 0;
              return fn ? untrack(function () {
                return child(keyed ? c : function () {
                  if (!untrack(condition)) throw narrowedError("Show");
                  return conditionValue();
                });
              }) : child;
            }
            return props.fallback;
          }, undefined, undefined);
        }
        function Switch(props) {
          var chs = children(function () {
            return props.children;
          });
          var switchFunc = createMemo(function () {
            var ch = chs();
            var mps = Array.isArray(ch) ? ch : [ch];
            var func = function func() {
              return undefined;
            };
            var _loop1 = function _loop1() {
              var index = i;
              var mp = mps[i];
              var prevFunc = func;
              var conditionValue = createMemo(function () {
                return prevFunc() ? undefined : mp.when;
              }, undefined, undefined);
              var condition = mp.keyed ? conditionValue : createMemo(conditionValue, undefined, {
                equals: function equals(a, b) {
                  return !a === !b;
                }
              });
              func = function func() {
                return prevFunc() || (condition() ? [index, conditionValue, mp] : undefined);
              };
            };
            for (var i = 0; i < mps.length; i++) {
              _loop1();
            }
            return func;
          });
          return createMemo(function () {
            var sel = switchFunc()();
            if (!sel) return props.fallback;
            var _sel = _slicedToArray(sel, 3),
              index = _sel[0],
              conditionValue = _sel[1],
              mp = _sel[2];
            var child = mp.children;
            var fn = typeof child === "function" && child.length > 0;
            return fn ? untrack(function () {
              return child(mp.keyed ? conditionValue() : function () {
                var _untrack;
                if (((_untrack = untrack(switchFunc)()) === null || _untrack === void 0 ? void 0 : _untrack[0]) !== index) throw narrowedError("Match");
                return conditionValue();
              });
            }) : child;
          }, undefined, undefined);
        }
        function Match(props) {
          return props;
        }
        var SuspenseListContext = /* #__PURE__ */createContext();
        function Suspense(props) {
          var counter = 0,
            show,
            ctx,
            p,
            flicker,
            error;
          var _createSignal13 = createSignal(false),
            _createSignal14 = _slicedToArray(_createSignal13, 2),
            inFallback = _createSignal14[0],
            setFallback = _createSignal14[1],
            SuspenseContext = getSuspenseContext(),
            store = {
              increment: function increment() {
                if (++counter === 1) setFallback(true);
              },
              decrement: function decrement() {
                if (--counter === 0) setFallback(false);
              },
              inFallback: inFallback,
              effects: [],
              resolved: false
            },
            owner = getOwner();
          if (sharedConfig.context && sharedConfig.load) {
            var key = sharedConfig.getContextId();
            var ref = sharedConfig.load(key);
            if (ref) {
              if (_typeof(ref) !== "object" || ref.s !== 1) p = ref;else sharedConfig.gather(key);
            }
            if (p && p !== "$$f") {
              var _createSignal15 = createSignal(undefined, {
                  equals: false
                }),
                _createSignal16 = _slicedToArray(_createSignal15, 2),
                s = _createSignal16[0],
                set = _createSignal16[1];
              flicker = s;
              p.then(function () {
                if (sharedConfig.done) return set();
                sharedConfig.gather(key);
                setHydrateContext(ctx);
                set();
                setHydrateContext();
              }, function (err) {
                error = err;
                set();
              });
            }
          }
          var listContext = useContext(SuspenseListContext);
          if (listContext) show = listContext.register(store.inFallback);
          var dispose;
          onCleanup(function () {
            return dispose && dispose();
          });
          return createComponent$1(SuspenseContext.Provider, {
            value: store,
            get children() {
              return createMemo(function () {
                if (error) throw error;
                ctx = sharedConfig.context;
                if (flicker) {
                  flicker();
                  return flicker = undefined;
                }
                if (ctx && p === "$$f") setHydrateContext();
                var rendered = createMemo(function () {
                  return props.children;
                });
                return createMemo(function (prev) {
                  var inFallback = store.inFallback(),
                    _ref33 = show ? show() : {},
                    _ref33$showContent = _ref33.showContent,
                    showContent = _ref33$showContent === void 0 ? true : _ref33$showContent,
                    _ref33$showFallback = _ref33.showFallback,
                    showFallback = _ref33$showFallback === void 0 ? true : _ref33$showFallback;
                  if ((!inFallback || p && p !== "$$f") && showContent) {
                    store.resolved = true;
                    dispose && dispose();
                    dispose = ctx = p = undefined;
                    resumeEffects(store.effects);
                    return rendered();
                  }
                  if (!showFallback) return;
                  if (dispose) return prev;
                  return createRoot(function (disposer) {
                    dispose = disposer;
                    if (ctx) {
                      setHydrateContext({
                        id: ctx.id + "F",
                        count: 0
                      });
                      ctx = undefined;
                    }
                    return props.fallback;
                  }, owner);
                });
              });
            }
          });
        }
        var _createSignal17 = createSignal(void 0),
          _createSignal18 = _slicedToArray(_createSignal17, 2),
          activeElement = _createSignal18[0],
          setActiveElement = _createSignal18[1];
        exports("w", activeElement);
        function hexColor() {
          var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
          if (isInteger(color)) {
            return color;
          }
          if (typeof color === "string") {
            if (color.startsWith("#")) {
              return Number(color.replace("#", "0x") + (color.length === 7 ? "ff" : ""));
            }
            if (color.startsWith("0x")) {
              return Number(color);
            }
            return Number("0x" + (color.length === 6 ? color + "ff" : color));
          }
          return 0;
        }
        function combineStyles(style1, style2) {
          if (!style1) {
            return style2;
          }
          if (!style2) {
            return style1;
          }
          return _objectSpread(_objectSpread({}, style2), style1);
        }
        var clamp = function clamp(value, min, max) {
          return min < max ? Math.min(Math.max(value, min), max) : Math.min(Math.max(value, max), min);
        };
        function mod(n, m) {
          if (m === 0) return 0;
          return (n % m + m) % m;
        }
        var memo$1 = function memo$1(fn) {
          return createMemo(function () {
            return fn();
          });
        };
        function createRenderer$1(_ref34) {
          var createElement = _ref34.createElement,
            createTextNode = _ref34.createTextNode,
            isTextNode = _ref34.isTextNode,
            replaceText = _ref34.replaceText,
            insertNode = _ref34.insertNode,
            removeNode = _ref34.removeNode,
            setProperty = _ref34.setProperty,
            getParentNode = _ref34.getParentNode,
            getFirstChild = _ref34.getFirstChild,
            getNextSibling = _ref34.getNextSibling;
          function insert(parent, accessor, marker, initial) {
            if (marker !== undefined && !initial) initial = [];
            if (typeof accessor !== "function") return insertExpression(parent, accessor, initial, marker);
            createRenderEffect(function (current) {
              return insertExpression(parent, accessor(), current, marker);
            }, initial);
          }
          function insertExpression(parent, value, current, marker, unwrapArray) {
            while (typeof current === "function") current = current();
            if (value === current) return current;
            var t = _typeof(value),
              multi = marker !== undefined;
            if (t === "string" || t === "number") {
              if (t === "number") value = value.toString();
              if (multi) {
                var node = current[0];
                if (node && isTextNode(node)) {
                  replaceText(node, value);
                } else node = createTextNode(value);
                current = cleanChildren(parent, current, marker, node);
              } else {
                if (current !== "" && typeof current === "string") {
                  replaceText(getFirstChild(parent), current = value);
                } else {
                  cleanChildren(parent, current, marker, createTextNode(value));
                  current = value;
                }
              }
            } else if (value == null || t === "boolean") {
              current = cleanChildren(parent, current, marker);
            } else if (t === "function") {
              createRenderEffect(function () {
                var v = value();
                while (typeof v === "function") v = v();
                current = insertExpression(parent, v, current, marker);
              });
              return function () {
                return current;
              };
            } else if (Array.isArray(value)) {
              var array = [];
              if (normalizeIncomingArray(array, value, unwrapArray)) {
                createRenderEffect(function () {
                  return current = insertExpression(parent, array, current, marker, true);
                });
                return function () {
                  return current;
                };
              }
              if (array.length === 0) {
                var replacement = cleanChildren(parent, current, marker);
                if (multi) return current = replacement;
              } else {
                if (Array.isArray(current)) {
                  if (current.length === 0) {
                    appendNodes(parent, array, marker);
                  } else reconcileArrays(parent, current, array);
                } else if (current == null || current === "") {
                  appendNodes(parent, array);
                } else {
                  reconcileArrays(parent, multi && current || [getFirstChild(parent)], array);
                }
              }
              current = array;
            } else {
              if (Array.isArray(current)) {
                if (multi) return current = cleanChildren(parent, current, marker, value);
                cleanChildren(parent, current, null, value);
              } else if (current == null || current === "" || !getFirstChild(parent)) {
                insertNode(parent, value);
              } else replaceNode(parent, value, getFirstChild(parent));
              current = value;
            }
            return current;
          }
          function normalizeIncomingArray(normalized, array, unwrap) {
            var dynamic = false;
            for (var i = 0, len = array.length; i < len; i++) {
              var item = array[i],
                t = void 0;
              if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {
                dynamic = normalizeIncomingArray(normalized, item) || dynamic;
              } else if ((t = _typeof(item)) === "string" || t === "number") {
                normalized.push(createTextNode(item));
              } else if (t === "function") {
                if (unwrap) {
                  while (typeof item === "function") item = item();
                  dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item]) || dynamic;
                } else {
                  normalized.push(item);
                  dynamic = true;
                }
              } else normalized.push(item);
            }
            return dynamic;
          }
          function reconcileArrays(parentNode, a, b) {
            var bLength = b.length,
              aEnd = a.length,
              bEnd = bLength,
              aStart = 0,
              bStart = 0,
              after = getNextSibling(a[aEnd - 1]),
              map = null;
            while (aStart < aEnd || bStart < bEnd) {
              if (a[aStart] === b[bStart]) {
                aStart++;
                bStart++;
                continue;
              }
              while (a[aEnd - 1] === b[bEnd - 1]) {
                aEnd--;
                bEnd--;
              }
              if (aEnd === aStart) {
                var node = bEnd < bLength ? bStart ? getNextSibling(b[bStart - 1]) : b[bEnd - bStart] : after;
                while (bStart < bEnd) insertNode(parentNode, b[bStart++], node);
              } else if (bEnd === bStart) {
                while (aStart < aEnd) {
                  if (!map || !map.has(a[aStart])) removeNode(parentNode, a[aStart]);
                  aStart++;
                }
              } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
                var _node = getNextSibling(a[--aEnd]);
                insertNode(parentNode, b[bStart++], getNextSibling(a[aStart++]));
                insertNode(parentNode, b[--bEnd], _node);
                a[aEnd] = b[bEnd];
              } else {
                if (!map) {
                  map = new Map();
                  var i = bStart;
                  while (i < bEnd) map.set(b[i], i++);
                }
                var index = map.get(a[aStart]);
                if (index != null) {
                  if (bStart < index && index < bEnd) {
                    var _i15 = aStart,
                      sequence = 1,
                      t = void 0;
                    while (++_i15 < aEnd && _i15 < bEnd) {
                      if ((t = map.get(a[_i15])) == null || t !== index + sequence) break;
                      sequence++;
                    }
                    if (sequence > index - bStart) {
                      var _node2 = a[aStart];
                      while (bStart < index) insertNode(parentNode, b[bStart++], _node2);
                    } else replaceNode(parentNode, b[bStart++], a[aStart++]);
                  } else aStart++;
                } else removeNode(parentNode, a[aStart++]);
              }
            }
          }
          function cleanChildren(parent, current, marker, replacement) {
            if (marker === undefined) {
              var removed;
              while (removed = getFirstChild(parent)) removeNode(parent, removed);
              replacement && insertNode(parent, replacement);
              return "";
            }
            var node = replacement || createTextNode("");
            if (current.length) {
              var inserted = false;
              for (var i = current.length - 1; i >= 0; i--) {
                var el = current[i];
                if (node !== el) {
                  var isParent = getParentNode(el) === parent;
                  if (!inserted && !i) isParent ? replaceNode(parent, node, el) : insertNode(parent, node, marker);else isParent && removeNode(parent, el);
                } else inserted = true;
              }
            } else insertNode(parent, node, marker);
            return [node];
          }
          function appendNodes(parent, array, marker) {
            for (var i = 0, len = array.length; i < len; i++) insertNode(parent, array[i], marker);
          }
          function replaceNode(parent, newNode, oldNode) {
            insertNode(parent, newNode, oldNode);
            removeNode(parent, oldNode);
          }
          function spreadExpression(node, props) {
            var prevProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var skipChildren = arguments.length > 3 ? arguments[3] : undefined;
            props || (props = {});
            if (!skipChildren) {
              createRenderEffect(function () {
                return prevProps.children = insertExpression(node, props.children, prevProps.children);
              });
            }
            createRenderEffect(function () {
              return props.ref && props.ref(node);
            });
            createRenderEffect(function () {
              for (var prop in props) {
                if (prop === "children" || prop === "ref") continue;
                var value = props[prop];
                if (value === prevProps[prop]) continue;
                setProperty(node, prop, value, prevProps[prop]);
                prevProps[prop] = value;
              }
            });
            return prevProps;
          }
          return {
            render: function render(code, element) {
              var disposer;
              createRoot(function (dispose) {
                disposer = dispose;
                insert(element, code());
              });
              return disposer;
            },
            insert: insert,
            spread: function spread(node, accessor, skipChildren) {
              if (typeof accessor === "function") {
                createRenderEffect(function (current) {
                  return spreadExpression(node, accessor(), current, skipChildren);
                });
              } else spreadExpression(node, accessor, undefined, skipChildren);
            },
            createElement: createElement,
            createTextNode: createTextNode,
            insertNode: insertNode,
            setProp: function setProp(node, name, value, prev) {
              setProperty(node, name, value, prev);
              return value;
            },
            mergeProps: mergeProps$1,
            effect: createRenderEffect,
            memo: memo$1,
            createComponent: createComponent$1,
            use: function use(fn, element, arg) {
              return untrack(function () {
                return fn(element, arg);
              });
            }
          };
        }
        function createRenderer$2(options) {
          var renderer = createRenderer$1(options);
          renderer.mergeProps = mergeProps$1;
          return renderer;
        }
        Object.defineProperty(ElementNode.prototype, "preserve", {
          get: function get() {
            return this._queueDelete === 0;
          },
          set: function set(v) {
            this._queueDelete = v ? 0 : void 0;
          }
        });
        var elementDeleteQueue = [];
        function flushDeleteQueue() {
          var _iterator33 = _createForOfIteratorHelper(elementDeleteQueue),
            _step33;
          try {
            for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
              var el = _step33.value;
              if (Number(el._queueDelete) < 0) {
                el.destroy();
              }
              el._queueDelete = void 0;
            }
          } catch (err) {
            _iterator33.e(err);
          } finally {
            _iterator33.f();
          }
          elementDeleteQueue.length = 0;
        }
        function pushDeleteQueue(node, n) {
          if (node._queueDelete === void 0) {
            node._queueDelete = n;
            if (elementDeleteQueue.push(node) === 1) {
              queueMicrotask(flushDeleteQueue);
            }
          } else {
            node._queueDelete += n;
          }
        }
        var nodeOpts = {
          createElement: function createElement(name) {
            return new ElementNode(name);
          },
          createTextNode: function createTextNode(text) {
            return {
              _type: NodeType.Text,
              text: text
            };
          },
          replaceText: function replaceText(node, value) {
            log("Replace Text: ", node, value);
            node.text = value;
            var parent = node.parent;
            parent.text = parent.getText();
          },
          setProperty: function setProperty(node, name) {
            var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            node[name] = value;
          },
          insertNode: function insertNode(parent, node, anchor) {
            log("INSERT: ", parent, node, anchor);
            var prevParent = node.parent;
            parent.insertChild(node, anchor);
            if (node instanceof ElementNode) {
              node.parent.rendered && node.render(true);
              if (prevParent !== void 0) {
                pushDeleteQueue(node, 1);
              }
            } else if (isElementText(parent)) {
              parent.text = parent.getText();
            }
          },
          isTextNode: function isTextNode(node) {
            return isElementText(node);
          },
          removeNode: function removeNode(parent, node) {
            log("REMOVE: ", parent, node);
            parent.removeChild(node);
            if (node instanceof ElementNode) {
              pushDeleteQueue(node, -1);
            } else if (isElementText(parent)) {
              parent.text = parent.getText();
            }
          },
          getParentNode: function getParentNode(node) {
            return node.parent;
          },
          getFirstChild: function getFirstChild(node) {
            return node.children[0];
          },
          getNextSibling: function getNextSibling(node) {
            var children = node.parent.children || [];
            var index = children.indexOf(node) + 1;
            if (index < children.length) {
              return children[index];
            }
            return void 0;
          }
        };
        var solidRenderer = createRenderer$2(nodeOpts);
        var renderer;
        var rootNode = nodeOpts.createElement("App");
        var render$1 = function render$1(code) {
          return solidRenderer.render(code, rootNode);
        };
        function createRenderer(rendererOptions, node) {
          var options = Config.rendererOptions;
          renderer = startLightningRenderer(options, "app");
          Config.setActiveElement = setActiveElement;
          rootNode.lng = renderer.root;
          rootNode.rendered = true;
          renderer.on("idle", function () {
            tasksEnabled = true;
            processTasks();
          });
          return {
            renderer: renderer,
            rootNode: rootNode,
            render: render$1
          };
        }
        var effect = solidRenderer.effect,
          memo = solidRenderer.memo,
          createComponent = solidRenderer.createComponent,
          createElement = solidRenderer.createElement,
          createTextNode = solidRenderer.createTextNode,
          insertNode = solidRenderer.insertNode,
          insert = solidRenderer.insert,
          spread = solidRenderer.spread,
          setProp = solidRenderer.setProp,
          mergeProps = solidRenderer.mergeProps,
          use = solidRenderer.use;
        exports({
          a7: effect,
          B: memo,
          c: createComponent,
          l: createElement,
          aa: createTextNode,
          a5: insertNode,
          r: insert,
          q: spread,
          a4: setProp,
          m: mergeProps,
          p: use
        });
        var taskQueue = [];
        var tasksEnabled = false;
        createRoot(function () {
          createRenderEffect(function () {
            activeElement();
            tasksEnabled = false;
          });
        });
        function scheduleTask(callback) {
          var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "low";
          if (priority === "high") {
            taskQueue.unshift(callback);
          } else {
            taskQueue.push(callback);
          }
          processTasks();
        }
        function processTasks() {
          if (tasksEnabled && taskQueue.length) {
            setTimeout(function () {
              var task = taskQueue.shift();
              if (task) {
                task();
                processTasks();
              }
            }, Config.taskDelay || 50);
          }
        }
        function Dynamic(props) {
          var _splitProps = splitProps(props, ["component"]),
            _splitProps2 = _slicedToArray(_splitProps, 2),
            p = _splitProps2[0],
            others = _splitProps2[1];
          var cached = createMemo(function () {
            return p.component;
          });
          return createMemo(function () {
            var component = cached();
            switch (_typeof(component)) {
              case "function":
                return untrack(function () {
                  return component(others);
                });
              case "string":
                {
                  var el = createElement(component);
                  spread(el, others);
                  return el;
                }
            }
          });
        }
        var View = exports("V", function (props) {
          var el = createElement("node");
          spread(el, props, false);
          return el;
        });
        var Text = exports("T", function (props) {
          var el = createElement("text");
          spread(el, props, false);
          return el;
        });

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Number of floating point numbers that represent a single glyph in the SDF vertex buffer.
         *
         * @remarks
         * The vertex buffer contains:
         *  - 6 vertex positions
         *  - 6 texture coordinates
         *  - = 12 positions/coordinates per glyph
         *
         * Each vertex position and texture coordinate consist of 2 floating point numbers (x/y).
         * So there are 12 * 2 = 24 floating point numbers that make up a single glyph.
         */
        var FLOATS_PER_GLYPH = 24;

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Gets the start conditions for the layout loop.
         *
         * @remarks
         * Returns `undefined` if the layout loop should not be run.
         *
         * @param fontSize
         * @param fontSizeRatio
         * @param sdfLineHeight
         * @param renderWindow
         * @param lineCache
         * @param textH
         * @returns
         */
        function getStartConditions(sdfFontSize, sdfLineHeight, fontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH) {
          // State variables
          var startLineIndex = Math.min(Math.max(renderWindow.firstLineIdx, 0), lineCache.length);
          var sdfStartX = 0;
          var metrics = fontFace.metrics;
          assertTruthy(fontFace.data);
          /**
           * Bare line height is the distance between the ascender and descender of the font.
           * without the line gap metric.
           */
          var sdfBareLineHeight = (metrics.ascender - metrics.descender) * sdfFontSize;
          var sdfVerticalAlignYOffset = 0;
          if (verticalAlign === 'middle') {
            sdfVerticalAlignYOffset = (sdfLineHeight - sdfBareLineHeight) / 2;
          } else if (verticalAlign === 'bottom') {
            sdfVerticalAlignYOffset = sdfLineHeight - sdfBareLineHeight;
          }
          var sdfOffsetY = offsetY / fontSizeRatio;
          /**
           * This is the position from the top of the text drawing line to where the
           * baseline of the text will be according to the encoded positioning data for
           * each glyph in the SDF data. This also happens to be the ascender value
           * that is encoded into the font data.
           */
          var sdfEncodedAscender = fontFace.data.common.base;
          /**
           * This is the ascender that is configured and overridable in the font face.
           */
          var sdfConfiguredAscender = metrics.ascender * sdfFontSize;
          /**
           * If the configured ascender is different from the SDF data's encoded
           * ascender, the offset of the text will be adjusted by the difference.
           */
          var sdfAscenderAdjOffset = sdfConfiguredAscender - sdfEncodedAscender;
          var sdfStartY = sdfOffsetY + sdfAscenderAdjOffset + startLineIndex * sdfLineHeight + sdfVerticalAlignYOffset; // TODO: Figure out what determines the initial y offset of text.
          // Don't attempt to render anything if we know we're starting past the established end of the text
          if (textH && sdfStartY >= textH / fontSizeRatio) {
            return;
          }
          return {
            sdfX: sdfStartX,
            sdfY: sdfStartY,
            lineIndex: startLineIndex
          };
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * A wrapper Generator class that makes a generator peekable.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var PeekableIterator = /*#__PURE__*/function () {
          function PeekableIterator(iterator) {
            var indexBase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            _classCallCheck(this, PeekableIterator);
            _defineProperty(this, "iterator", void 0);
            _defineProperty(this, "peekBuffer", []);
            _defineProperty(this, "_lastIndex", void 0);
            this.iterator = iterator;
            this.iterator = iterator;
            this._lastIndex = indexBase - 1;
            this.peekBuffer = [];
          }
          return _createClass(PeekableIterator, [{
            key: "next",
            value: function next() {
              var nextResult = this.peekBuffer.length > 0 ?
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              this.peekBuffer.pop() : this.iterator.next();
              if (nextResult.done) {
                this._lastIndex = -1;
              } else {
                this._lastIndex++;
              }
              return nextResult;
            }
          }, {
            key: "peek",
            value: function peek() {
              if (this.peekBuffer.length > 0) {
                // We know that the buffer is not empty, so we can safely use the
                // non-null assertion operator
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return this.peekBuffer[0];
              }
              var result = this.iterator.next();
              this.peekBuffer.push(result);
              return result;
            }
          }, {
            key: "lastIndex",
            get: function get() {
              return this._lastIndex;
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        // Reversible Generator Wrapper Class
        /**
         * Generator function that yields each Unicode code point in the given string.
         */
        function getUnicodeCodepoints(text) {
          var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return /*#__PURE__*/_regenerator().m(function _callee19() {
            var i, codePoint;
            return _regenerator().w(function (_context20) {
              while (1) switch (_context20.n) {
                case 0:
                  i = start;
                case 1:
                  if (!(i < text.length)) {
                    _context20.n = 4;
                    break;
                  }
                  codePoint = text.codePointAt(i);
                  if (!(codePoint === undefined)) {
                    _context20.n = 2;
                    break;
                  }
                  throw new Error('Invalid Unicode code point');
                case 2:
                  _context20.n = 3;
                  return codePoint;
                case 3:
                  i += codePoint <= 0xffff ? 1 : 2;
                  _context20.n = 1;
                  break;
                case 4:
                  return _context20.a(2);
              }
            }, _callee19);
          })();
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Measures a single-line of text width ignoring any unmapped glyphs including line breaks
         *
         * @param text
         * @param shaperProps
         * @param shaper
         * @returns
         */
        function measureText(text, shaperProps, shaper) {
          var glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, 0), 0));
          var width = 0;
          var _iterator34 = _createForOfIteratorHelper(glyphs),
            _step34;
          try {
            for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
              var glyph = _step34.value;
              if (glyph.mapped && glyph.codepoint !== 8203) {
                // Skip ZWSP (\u200B)
                width += glyph.xAdvance;
              }
            }
          } catch (err) {
            _iterator34.e(err);
          } finally {
            _iterator34.f();
          }
          return width;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        function layoutText(curLineIndex, startX, startY, text, textAlign, width, height, fontSize, lineHeight, letterSpacing,
        /**
         * Mutated
         */
        vertexBuffer, contain,
        /**
         * Mutated
         */
        lineCache, rwSdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines) {
          assertTruthy(trFontFace.loaded);
          assertTruthy(trFontFace.data);
          assertTruthy(trFontFace.shaper);
          // Regardless of fontSize (or other scaling properties), we layout the vertices of each glyph
          // using the fixed coordinate space determined by font size used to produce the atlas.
          // Scaling for display is handled by shader uniforms inexpensively.
          // So we have:
          //  - vertex space: the space in which the vertices of each glyph are laid out
          //  - screen space: the screen pixel space
          // Input properties such as x, y, w, fontSize, letterSpacing, etc. are all expressed in screen space.
          // We convert these to the vertex space by dividing them the `fontSizeRatio` factor.
          /**
           * See above
           */
          var fontSizeRatio = fontSize / trFontFace.data.info.size;
          /**
           * `lineHeight` in vertex coordinates
           */
          var vertexLineHeight = lineHeight / fontSizeRatio;
          /**
           * `w` in vertex coordinates
           */
          var vertexW = width / fontSizeRatio;
          /**
           * `letterSpacing` in vertex coordinates
           */
          var vertexLSpacing = letterSpacing / fontSizeRatio;
          var startingLineCacheEntry = lineCache[curLineIndex];
          var startingCodepointIndex = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.codepointIndex) || 0;
          var startingMaxX = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.maxX) || 0;
          var startingMaxY = (startingLineCacheEntry === null || startingLineCacheEntry === void 0 ? void 0 : startingLineCacheEntry.maxY) || 0;
          var maxX = startingMaxX;
          var maxY = startingMaxY;
          var curX = startX;
          var curY = startY;
          var bufferOffset = 0;
          /**
           * Buffer offset to last word boundry. This is -1 when we aren't in a word boundry.
           */
          var lastWord = {
            codepointIndex: -1,
            bufferOffset: -1,
            xStart: -1
          };
          var shaper = trFontFace.shaper;
          var shaperProps = {
            letterSpacing: vertexLSpacing
          };
          // HACK: The space is used as a word boundary. When a text ends with a space, we need to
          // add an extra space to ensure the space is included in the line width calculation.
          if (text.endsWith(' ')) {
            text += ' ';
          }
          // Get glyphs
          var glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, startingCodepointIndex), startingCodepointIndex));
          var glyphResult;
          var curLineBufferStart = -1;
          var bufferLineInfos = [];
          var vertexTruncateHeight = height / fontSizeRatio;
          var overflowSuffVertexWidth = measureText(overflowSuffix, shaperProps, shaper);
          // Line-by-line layout
          var moreLines = true;
          while (moreLines) {
            var nextLineWillFit = (maxLines === 0 || curLineIndex + 1 < maxLines) && (contain !== 'both' || scrollable || curY + vertexLineHeight + trFontFace.maxCharHeight <= vertexTruncateHeight);
            var lineVertexW = nextLineWillFit ? vertexW : vertexW - overflowSuffVertexWidth;
            /**
             * Vertex X position to the beginning of the last word boundary. This becomes -1 when we start traversing a word.
             */
            var xStartLastWordBoundary = 0;
            var lineIsBelowWindowTop = curY + trFontFace.maxCharHeight >= rwSdf.y1;
            var lineIsAboveWindowBottom = curY <= rwSdf.y2;
            var lineIsWithinWindow = lineIsBelowWindowTop && lineIsAboveWindowBottom;
            // Layout glyphs in this line
            // Any break statements in this while loop will trigger a line break
            while ((glyphResult = glyphs.next()) && !glyphResult.done) {
              var glyph = glyphResult.value;
              if (curLineIndex === lineCache.length) {
                lineCache.push({
                  codepointIndex: glyph.cluster,
                  maxY: maxY,
                  maxX: maxX
                });
              } else if (curLineIndex > lineCache.length) {
                throw new Error('Unexpected lineCache length');
              }
              // If we encounter a word boundary (white space or newline) we invalidate
              // the lastWord and set the xStartLastWordBoundary if we haven't already.
              if (glyph.codepoint === 32 || glyph.codepoint === 10 || glyph.codepoint === 8203) {
                if (lastWord.codepointIndex !== -1) {
                  lastWord.codepointIndex = -1;
                  xStartLastWordBoundary = curX;
                }
              } else if (lastWord.codepointIndex === -1) {
                lastWord.codepointIndex = glyph.cluster;
                lastWord.bufferOffset = bufferOffset;
                lastWord.xStart = xStartLastWordBoundary;
              }
              if (glyph.mapped) {
                // Mapped glyph
                var charEndX = curX + glyph.xOffset + glyph.width;
                // Word wrap check
                if (
                // We are containing the text
                contain !== 'none' &&
                // The current glyph reaches outside the contained width
                charEndX >= lineVertexW &&
                // There is a last word that we can break to the next line
                lastWord.codepointIndex !== -1 &&
                // Prevents infinite loop when a single word is longer than the width
                lastWord.xStart > 0) {
                  // The current word is about to go off the edge of the container width
                  // Reinitialize the iterator starting at the last word
                  // and proceeding to the next line
                  if (nextLineWillFit) {
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(text, lastWord.codepointIndex), lastWord.codepointIndex));
                    bufferOffset = lastWord.bufferOffset;
                    break;
                  } else {
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
                    curX = lastWord.xStart;
                    bufferOffset = lastWord.bufferOffset;
                    // HACK: For the rest of the line when inserting the overflow suffix,
                    // set contain = 'none' to prevent an infinite loop.
                    contain = 'none';
                  }
                } else {
                  // This glyph fits, so we can add it to the buffer
                  var quadX = curX + glyph.xOffset;
                  var quadY = curY + glyph.yOffset;
                  // Only add to buffer for rendering if the line is within the render window
                  if (lineIsWithinWindow) {
                    if (curLineBufferStart === -1) {
                      curLineBufferStart = bufferOffset;
                    }
                    var atlasEntry = trFontFace.getAtlasEntry(glyph.glyphId);
                    // Add texture coordinates
                    var u = atlasEntry.x / trFontFace.data.common.scaleW;
                    var v = atlasEntry.y / trFontFace.data.common.scaleH;
                    var uvWidth = atlasEntry.width / trFontFace.data.common.scaleW;
                    var uvHeight = atlasEntry.height / trFontFace.data.common.scaleH;
                    // TODO: (Performance) We can optimize this by using ELEMENT_ARRAY_BUFFER
                    // eliminating the need to duplicate vertices
                    // Top-left
                    vertexBuffer[bufferOffset++] = quadX;
                    vertexBuffer[bufferOffset++] = quadY;
                    vertexBuffer[bufferOffset++] = u;
                    vertexBuffer[bufferOffset++] = v;
                    // Top-right
                    vertexBuffer[bufferOffset++] = quadX + glyph.width;
                    vertexBuffer[bufferOffset++] = quadY;
                    vertexBuffer[bufferOffset++] = u + uvWidth;
                    vertexBuffer[bufferOffset++] = v;
                    // Bottom-left
                    vertexBuffer[bufferOffset++] = quadX;
                    vertexBuffer[bufferOffset++] = quadY + glyph.height;
                    vertexBuffer[bufferOffset++] = u;
                    vertexBuffer[bufferOffset++] = v + uvHeight;
                    // Bottom-right
                    vertexBuffer[bufferOffset++] = quadX + glyph.width;
                    vertexBuffer[bufferOffset++] = quadY + glyph.height;
                    vertexBuffer[bufferOffset++] = u + uvWidth;
                    vertexBuffer[bufferOffset++] = v + uvHeight;
                  }
                  maxY = Math.max(maxY, quadY + glyph.height);
                  maxX = Math.max(maxX, quadX + glyph.width);
                  curX += glyph.xAdvance;
                }
              } else {
                // Unmapped character
                // Handle newlines
                if (glyph.codepoint === 10) {
                  if (nextLineWillFit) {
                    // The whole line fit, so we can break to the next line
                    break;
                  } else {
                    // The whole line won't fit, so we need to add the overflow suffix
                    glyphs = shaper.shapeText(shaperProps, new PeekableIterator(getUnicodeCodepoints(overflowSuffix, 0), 0));
                    // HACK: For the rest of the line when inserting the overflow suffix,
                    // set contain = 'none' to prevent an infinite loop.
                    contain = 'none';
                  }
                }
              }
            }
            // Prepare for the next line...
            if (curLineBufferStart !== -1) {
              bufferLineInfos.push({
                bufferStart: curLineBufferStart,
                bufferEnd: bufferOffset
              });
              curLineBufferStart = -1;
            }
            curX = 0;
            curY += vertexLineHeight;
            curLineIndex++;
            lastWord.codepointIndex = -1;
            xStartLastWordBoundary = 0;
            // Figure out if there are any more lines to render...
            if (!forceFullLayoutCalc && contain === 'both' && curY > rwSdf.y2) {
              // Stop layout calculation early (for performance purposes) if:
              // - We're not forcing a full layout calculation (for width/height calculation)
              // - ...and we're containing the text vertically+horizontally (contain === 'both')
              // - ...and we have a render window
              // - ...and the next line is below the bottom of the render window
              moreLines = false;
            } else if (glyphResult && glyphResult.done) {
              // If we've reached the end of the text, we know we're done
              moreLines = false;
            } else if (!nextLineWillFit) {
              // If we're contained vertically+horizontally (contain === 'both')
              // but not scrollable and the next line won't fit, we're done.
              moreLines = false;
            }
          }
          // Use textAlign to determine if we need to adjust the x position of the text
          // in the buffer line by line
          if (textAlign === 'center') {
            var vertexTextW = contain === 'none' ? maxX : vertexW;
            for (var i = 0; i < bufferLineInfos.length; i++) {
              var line = bufferLineInfos[i];
              // - 4 = the x position of a rightmost vertex
              var lineWidth =
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              vertexBuffer[line.bufferEnd - 4] - vertexBuffer[line.bufferStart];
              var xOffset = (vertexTextW - lineWidth) / 2;
              for (var j = line.bufferStart; j < line.bufferEnd; j += 4) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vertexBuffer[j] += xOffset;
              }
            }
          } else if (textAlign === 'right') {
            var _vertexTextW = contain === 'none' ? maxX : vertexW;
            for (var _i16 = 0; _i16 < bufferLineInfos.length; _i16++) {
              var _line = bufferLineInfos[_i16];
              var _lineWidth = _line.bufferEnd === _line.bufferStart ? 0 :
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              vertexBuffer[_line.bufferEnd - 4] - vertexBuffer[_line.bufferStart];
              var _xOffset = _vertexTextW - _lineWidth;
              for (var _j = _line.bufferStart; _j < _line.bufferEnd; _j += 4) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                vertexBuffer[_j] += _xOffset;
              }
            }
          }
          return {
            bufferNumFloats: bufferOffset,
            bufferNumQuads: bufferOffset / 16,
            layoutNumCharacters: glyphResult.done ? text.length - startingCodepointIndex : glyphResult.value.cluster - startingCodepointIndex + 1,
            fullyProcessed: !!glyphResult.done,
            maxX: maxX,
            maxY: maxY,
            numLines: lineCache.length
          };
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Round up to the nearest multiple of the given number.
         *
         * @param value
         * @param multiple
         * @returns
         */
        function roundUpToMultiple(value, multiple) {
          return Math.ceil(value / multiple) * multiple;
        }
        /**
         * Round down to the nearest multiple of the given number.
         *
         * @param value
         * @param multiple
         * @returns
         */
        function roundDownToMultiple(value, multiple) {
          return Math.floor(value / multiple) * multiple;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Create a render window from the given parameters.
         *
         * @remarks
         * The render window is a rectangle that defines the area of the text that
         * should be rendered. It is used to skip rendering parts of the text that
         * are outside of the render window. The render window is relative to the
         * text's top left corner of the overrall text.
         *
         * @param x The x coordinate of the text element's top left corner relative to the screen.
         * @param y The y coordinate of the text element's top left corner relative to the screen.
         * @param scrollY The amount of pixels to scroll the text vertically.
         * @param lineHeight The number of extra lines to render above and below the visible window.
         * @param visibleWindow The visible window of the text element relative to the screen
         * @returns
         */
        function setRenderWindow(outRenderWindow, x, y, scrollY, lineHeight, bufferMargin, visibleWindow, fontSizeRatio) {
          var screen = outRenderWindow.screen,
            sdf = outRenderWindow.sdf;
          if (!isBoundPositive(visibleWindow)) {
            screen.x1 = 0;
            screen.y1 = 0;
            screen.x2 = 0;
            screen.y2 = 0;
            sdf.x1 = 0;
            sdf.y1 = 0;
            sdf.x2 = 0;
            sdf.y2 = 0;
            outRenderWindow.numLines = 0;
            outRenderWindow.firstLineIdx = 0;
          } else {
            var x1 = visibleWindow.x1 - x;
            var x2 = x1 + (visibleWindow.x2 - visibleWindow.x1);
            var y1Base = visibleWindow.y1 - y + scrollY;
            var y1 = roundDownToMultiple(y1Base - bufferMargin, lineHeight || 1);
            var y2 = roundUpToMultiple(y1Base + (visibleWindow.y2 - visibleWindow.y1) + bufferMargin, lineHeight || 1);
            screen.x1 = x1;
            screen.y1 = y1;
            screen.x2 = x2;
            screen.y2 = y2;
            sdf.x1 = x1 / fontSizeRatio;
            sdf.y1 = y1 / fontSizeRatio;
            sdf.x2 = x2 / fontSizeRatio;
            sdf.y2 = y2 / fontSizeRatio;
            outRenderWindow.numLines = Math.ceil((y2 - y1) / lineHeight);
            outRenderWindow.firstLineIdx = lineHeight ? Math.floor(y1 / lineHeight) : 0;
          }
          outRenderWindow.valid = true;
        }

        /**
         * Calculate the default line height given normalized font metrics
         *
         * @remarks
         * This method may be used for both the WebTrFontFace and SdfTrFontFace font types.
         *
         * @param metrics
         * @param fontSize
         * @returns
         */
        function calcDefaultLineHeight(metrics, fontSize) {
          return fontSize * (metrics.ascender - metrics.descender + metrics.lineGap);
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Ephemeral rect object used for calculations
         */
        var tmpRect = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        /**
         * Singleton class for rendering text using signed distance fields.
         *
         * @remarks
         * SdfTextRenderer supports both single-channel and multi-channel signed distance fields.
         */
        var SdfTextRenderer = /*#__PURE__*/function (_TextRenderer2) {
          function SdfTextRenderer(stage) {
            var _this66;
            _classCallCheck(this, SdfTextRenderer);
            _this66 = _callSuper(this, SdfTextRenderer, [stage]);
            /**
             * Map of font family names to a set of font faces.
             */
            _defineProperty(_this66, "ssdfFontFamilies", {});
            _defineProperty(_this66, "msdfFontFamilies", {});
            _defineProperty(_this66, "fontFamilyArray", [_this66.ssdfFontFamilies, _this66.msdfFontFamilies]);
            _defineProperty(_this66, "sdfShader", void 0);
            _defineProperty(_this66, "rendererBounds", void 0);
            _defineProperty(_this66, "type", 'sdf');
            _this66.sdfShader = _this66.stage.shManager.loadShader('SdfShader', {
              transform: new Float32Array(),
              color: 0,
              size: 0,
              scrollY: 0,
              distanceRange: 0,
              debug: false
            }).shader;
            _this66.rendererBounds = {
              x1: 0,
              y1: 0,
              x2: _this66.stage.options.appWidth,
              y2: _this66.stage.options.appHeight
            };
            return _this66;
          }
          //#region Overrides
          _inherits(SdfTextRenderer, _TextRenderer2);
          return _createClass(SdfTextRenderer, [{
            key: "getPropertySetters",
            value: function getPropertySetters() {
              var _this67 = this;
              return {
                fontFamily: function fontFamily(state, value) {
                  state.props.fontFamily = value;
                  _this67.releaseFontFace(state);
                  _this67.invalidateLayoutCache(state);
                },
                fontWeight: function fontWeight(state, value) {
                  state.props.fontWeight = value;
                  _this67.releaseFontFace(state);
                  _this67.invalidateLayoutCache(state);
                },
                fontStyle: function fontStyle(state, value) {
                  state.props.fontStyle = value;
                  _this67.releaseFontFace(state);
                  _this67.invalidateLayoutCache(state);
                },
                fontStretch: function fontStretch(state, value) {
                  state.props.fontStretch = value;
                  _this67.releaseFontFace(state);
                  _this67.invalidateLayoutCache(state);
                },
                fontSize: function fontSize(state, value) {
                  state.props.fontSize = value;
                  _this67.invalidateLayoutCache(state);
                },
                text: function text(state, value) {
                  state.props.text = value;
                  _this67.invalidateLayoutCache(state);
                },
                textAlign: function textAlign(state, value) {
                  state.props.textAlign = value;
                  _this67.invalidateLayoutCache(state);
                },
                color: function color(state, value) {
                  state.props.color = value;
                },
                x: function x(state, value) {
                  state.props.x = value;
                  if (state.elementBounds.valid) {
                    _this67.setElementBoundsX(state);
                    // Only schedule an update if the text is not already rendered
                    // (renderWindow is invalid) and the element possibly overlaps the screen
                    // This is to avoid unnecessary updates when we know text is off-screen
                    if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, _this67.rendererBounds)) {
                      _this67.scheduleUpdateState(state);
                    }
                  }
                },
                y: function y(state, value) {
                  state.props.y = value;
                  if (state.elementBounds.valid) {
                    _this67.setElementBoundsY(state);
                    // See x() for explanation
                    if (!state.renderWindow.valid && boundsOverlap(state.elementBounds, _this67.rendererBounds)) {
                      _this67.scheduleUpdateState(state);
                    }
                  }
                },
                contain: function contain(state, value) {
                  state.props.contain = value;
                  _this67.invalidateLayoutCache(state);
                },
                width: function width(state, value) {
                  state.props.width = value;
                  // Only invalidate layout cache if we're containing in the horizontal direction
                  if (state.props.contain !== 'none') {
                    _this67.invalidateLayoutCache(state);
                  }
                },
                height: function height(state, value) {
                  state.props.height = value;
                  // Only invalidate layout cache if we're containing in the vertical direction
                  if (state.props.contain === 'both') {
                    _this67.invalidateLayoutCache(state);
                  }
                },
                offsetY: function offsetY(state, value) {
                  state.props.offsetY = value;
                  _this67.invalidateLayoutCache(state);
                },
                scrollable: function scrollable(state, value) {
                  state.props.scrollable = value;
                  _this67.invalidateLayoutCache(state);
                },
                scrollY: function scrollY(state, value) {
                  state.props.scrollY = value;
                  // Scrolling doesn't need to invalidate any caches, but it does need to
                  // schedule an update
                  _this67.scheduleUpdateState(state);
                },
                letterSpacing: function letterSpacing(state, value) {
                  state.props.letterSpacing = value;
                  _this67.invalidateLayoutCache(state);
                },
                lineHeight: function lineHeight(state, value) {
                  state.props.lineHeight = value;
                  state.resLineHeight = undefined;
                  _this67.invalidateLayoutCache(state);
                },
                maxLines: function maxLines(state, value) {
                  state.props.maxLines = value;
                  _this67.invalidateLayoutCache(state);
                },
                textBaseline: function textBaseline(state, value) {
                  state.props.textBaseline = value;
                  _this67.invalidateLayoutCache(state);
                },
                verticalAlign: function verticalAlign(state, value) {
                  state.props.verticalAlign = value;
                  _this67.invalidateLayoutCache(state);
                },
                overflowSuffix: function overflowSuffix(state, value) {
                  state.props.overflowSuffix = value;
                  _this67.invalidateLayoutCache(state);
                },
                debug: function debug(state, value) {
                  state.props.debug = value;
                }
              };
            }
          }, {
            key: "canRenderFont",
            value: function canRenderFont(props) {
              // TODO: Support matching on font stretch, weight and style (if/when needed)
              // For now we just match on the font family name
              // '$$SDF_FAILURE_TEST$$' is used to test the 'failure' event coming from text
              var fontFamily = props.fontFamily;
              return fontFamily in this.ssdfFontFamilies || fontFamily in this.msdfFontFamilies || fontFamily === '$$SDF_FAILURE_TEST$$';
            }
          }, {
            key: "isFontFaceSupported",
            value: function isFontFaceSupported(fontFace) {
              return fontFace instanceof SdfTrFontFace;
            }
          }, {
            key: "addFontFace",
            value: function addFontFace(fontFace) {
              var familyName = fontFace.fontFamily;
              var fontFamiles = fontFace.type === 'ssdf' ? this.ssdfFontFamilies : fontFace.type === 'msdf' ? this.msdfFontFamilies : undefined;
              if (!fontFamiles) {
                console.warn("Invalid font face type: ".concat(fontFace.type));
                return;
              }
              var faceSet = fontFamiles[familyName];
              if (!faceSet) {
                faceSet = new Set();
                fontFamiles[familyName] = faceSet;
              }
              faceSet.add(fontFace);
            }
          }, {
            key: "createState",
            value: function createState(props) {
              return {
                props: props,
                status: 'initialState',
                updateScheduled: false,
                emitter: new EventEmitter(),
                lineCache: [],
                forceFullLayoutCalc: false,
                renderWindow: {
                  screen: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                  },
                  sdf: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0
                  },
                  firstLineIdx: 0,
                  numLines: 0,
                  valid: false
                },
                elementBounds: {
                  x1: 0,
                  y1: 0,
                  x2: 0,
                  y2: 0,
                  valid: false
                },
                clippingRect: {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0,
                  valid: false
                },
                bufferNumFloats: 0,
                bufferNumQuads: 0,
                vertexBuffer: undefined,
                webGlBuffers: null,
                bufferUploaded: false,
                textH: undefined,
                textW: undefined,
                distanceRange: 0,
                trFontFace: undefined,
                isRenderable: false,
                resLineHeight: undefined,
                debugData: {
                  updateCount: 0,
                  layoutCount: 0,
                  lastLayoutNumCharacters: 0,
                  layoutSum: 0,
                  drawSum: 0,
                  drawCount: 0,
                  bufferSize: 0
                }
              };
            }
          }, {
            key: "updateState",
            value: function updateState(state) {
              var _this68 = this;
              var trFontFace = state.trFontFace;
              var textH = state.textH,
                lineCache = state.lineCache,
                debugData = state.debugData,
                forceFullLayoutCalc = state.forceFullLayoutCalc;
              debugData.updateCount++;
              // On the first update call we need to set the status to loading
              if (state.status === 'initialState') {
                this.setStatus(state, 'loading');
              }
              // Resolve font face if we haven't yet
              if (trFontFace === undefined) {
                trFontFace = this.resolveFontFace(state.props);
                state.trFontFace = trFontFace;
                if (trFontFace === undefined) {
                  var msg = "SdfTextRenderer: Could not resolve font face for family: '".concat(state.props.fontFamily, "'");
                  console.error(msg);
                  this.setStatus(state, 'failed', new Error(msg));
                  return;
                }
                trFontFace.texture.setRenderableOwner(state.props.fontFamily, true);
              }
              // If the font hasn't been loaded yet, stop here.
              // Listen for the 'loaded' event and forward fontLoaded event
              if (trFontFace.loaded === false) {
                trFontFace.once('loaded', function () {
                  _this68.scheduleUpdateState(state);
                });
                return;
              }
              // If the font is loaded then so should the data
              assertTruthy(trFontFace.data);
              assertTruthy(trFontFace.metrics);
              var _state$props = state.props,
                text = _state$props.text,
                fontSize = _state$props.fontSize,
                x = _state$props.x,
                y = _state$props.y,
                contain = _state$props.contain,
                width = _state$props.width,
                height = _state$props.height,
                verticalAlign = _state$props.verticalAlign,
                scrollable = _state$props.scrollable,
                overflowSuffix = _state$props.overflowSuffix,
                maxLines = _state$props.maxLines;
              // scrollY only has an effect when contain === 'both' and scrollable === true
              var scrollY = contain === 'both' && scrollable ? state.props.scrollY : 0;
              var renderWindow = state.renderWindow;
              /**
               * The font size of the SDF font face (the basis for SDF space units)
               */
              var sdfFontSize = trFontFace.data.info.size;
              /**
               * Divide screen space units by this to get the SDF space units
               * Mulitple SDF space units by this to get screen space units
               */
              var fontSizeRatio = fontSize / sdfFontSize;
              // If not already resolved, resolve the line height and store it in the state
              var resLineHeight = state.resLineHeight;
              if (resLineHeight === undefined) {
                var lineHeight = state.props.lineHeight;
                // If lineHeight is undefined, use the maxCharHeight from the font face
                if (lineHeight === undefined) {
                  resLineHeight = calcDefaultLineHeight(trFontFace.metrics, fontSize);
                } else {
                  resLineHeight = lineHeight;
                }
                state.resLineHeight = resLineHeight;
              }
              // Needed in renderWindow calculation
              var sdfLineHeight = resLineHeight / fontSizeRatio;
              state.distanceRange = fontSizeRatio * trFontFace.data.distanceField.distanceRange;
              // Allocate buffers if needed
              var neededLength = text.length * FLOATS_PER_GLYPH;
              var vertexBuffer = state.vertexBuffer;
              if (!vertexBuffer || vertexBuffer.length < neededLength) {
                vertexBuffer = new Float32Array(neededLength * 2);
              }
              var elementBounds = state.elementBounds;
              if (!elementBounds.valid) {
                this.setElementBoundsX(state);
                this.setElementBoundsY(state);
                elementBounds.valid = true;
              }
              // Return early if we're still viewing inside the established render window
              // No need to re-render what we've already rendered
              // (Only if there's an established renderWindow and we're not suppressing early exit)
              if (!forceFullLayoutCalc && renderWindow.valid) {
                var rwScreen = renderWindow.screen;
                if (x + rwScreen.x1 <= elementBounds.x1 && x + rwScreen.x2 >= elementBounds.x2 && y - scrollY + rwScreen.y1 <= elementBounds.y1 && y - scrollY + rwScreen.y2 >= elementBounds.y2) {
                  this.setStatus(state, 'loaded');
                  return;
                }
                // Otherwise invalidate the renderWindow so it can be redone
                renderWindow.valid = false;
                this.setStatus(state, 'loading');
              }
              var _state$props2 = state.props,
                offsetY = _state$props2.offsetY,
                textAlign = _state$props2.textAlign;
              // Create a new renderWindow if needed
              if (!renderWindow.valid) {
                var isPossiblyOnScreen = boundsOverlap(elementBounds, this.rendererBounds);
                if (!isPossiblyOnScreen) {
                  // If the element is not possibly on screen, we can skip the layout and rendering completely
                  return;
                }
                setRenderWindow(renderWindow, x, y, scrollY, resLineHeight, contain === 'both' ? elementBounds.y2 - elementBounds.y1 : 0, elementBounds, fontSizeRatio);
                // console.log('newRenderWindow', renderWindow);
              }
              var start = getStartConditions(sdfFontSize, sdfLineHeight, trFontFace, verticalAlign, offsetY, fontSizeRatio, renderWindow, lineCache, textH);
              if (!start) {
                // Nothing to render, return early, but still mark as loaded (since the text is just scrolled
                // out of view)
                this.setStatus(state, 'loaded');
                return;
              }
              var letterSpacing = state.props.letterSpacing;
              var out2 = layoutText(start.lineIndex, start.sdfX, start.sdfY, text, textAlign, width, height, fontSize, resLineHeight, letterSpacing, vertexBuffer, contain, lineCache, renderWindow.sdf, trFontFace, forceFullLayoutCalc, scrollable, overflowSuffix, maxLines);
              state.bufferUploaded = false;
              state.bufferNumFloats = out2.bufferNumFloats;
              state.bufferNumQuads = out2.bufferNumQuads;
              state.vertexBuffer = vertexBuffer;
              state.renderWindow = renderWindow;
              debugData.lastLayoutNumCharacters = out2.layoutNumCharacters;
              debugData.bufferSize = vertexBuffer.byteLength;
              // If we didn't exit early, we know we have completely computed w/h
              if (out2.fullyProcessed) {
                state.textW = out2.maxX * fontSizeRatio;
                state.textH = out2.numLines * sdfLineHeight * fontSizeRatio;
              }
              // if (state.props.debug.printLayoutTime) {
              //   debugData.layoutSum += performance.now() - updateStartTime;
              //   debugData.layoutCount++;
              // }
              this.setStatus(state, 'loaded');
            }
          }, {
            key: "renderQuads",
            value: function renderQuads(state, transform, clippingRect, alpha, parentHasRenderTexture, framebufferDimensions) {
              var _trFontFace$data, _state$trFontFace;
              if (!state.vertexBuffer) {
                // Nothing to draw
                return;
              }
              var renderer = this.stage.renderer;
              var _state$props3 = state.props,
                fontSize = _state$props3.fontSize,
                color = _state$props3.color,
                contain = _state$props3.contain,
                scrollable = _state$props3.scrollable,
                zIndex = _state$props3.zIndex,
                debug = _state$props3.debug;
              // scrollY only has an effect when contain === 'both' and scrollable === true
              var scrollY = contain === 'both' && scrollable ? state.props.scrollY : 0;
              var _state$textW = state.textW,
                textW = _state$textW === void 0 ? 0 : _state$textW,
                _state$textH = state.textH,
                textH = _state$textH === void 0 ? 0 : _state$textH,
                distanceRange = state.distanceRange,
                vertexBuffer = state.vertexBuffer,
                bufferUploaded = state.bufferUploaded,
                trFontFace = state.trFontFace,
                elementBounds = state.elementBounds;
              var webGlBuffers = state.webGlBuffers;
              if (!webGlBuffers) {
                var glw = renderer.glw;
                var stride = 4 * Float32Array.BYTES_PER_ELEMENT;
                var webGlBuffer = glw.createBuffer();
                state.webGlBuffers = new BufferCollection([{
                  buffer: webGlBuffer,
                  attributes: {
                    a_position: {
                      name: 'a_position',
                      size: 2,
                      // 2 components per iteration
                      type: glw.FLOAT,
                      // the data is 32bit floats
                      normalized: false,
                      // don't normalize the data
                      stride: stride,
                      // 0 = move forward size * sizeof(type) each iteration to get the next position
                      offset: 0 // start at the beginning of the buffer
                    },
                    a_textureCoordinate: {
                      name: 'a_textureCoordinate',
                      size: 2,
                      type: glw.FLOAT,
                      normalized: false,
                      stride: stride,
                      offset: 2 * Float32Array.BYTES_PER_ELEMENT
                    }
                  }
                }]);
                state.bufferUploaded = false;
                assertTruthy(state.webGlBuffers);
                webGlBuffers = state.webGlBuffers;
              }
              if (!bufferUploaded) {
                var _webGlBuffers$getBuff, _webGlBuffers;
                var _glw = renderer.glw;
                var buffer = (_webGlBuffers$getBuff = (_webGlBuffers = webGlBuffers) === null || _webGlBuffers === void 0 ? void 0 : _webGlBuffers.getBuffer('a_textureCoordinate')) !== null && _webGlBuffers$getBuff !== void 0 ? _webGlBuffers$getBuff : null;
                _glw.arrayBufferData(buffer, vertexBuffer, _glw.STATIC_DRAW);
                state.bufferUploaded = true;
              }
              if (scrollable && contain === 'both') {
                assertTruthy(elementBounds.valid);
                var elementRect = convertBoundToRect(elementBounds, tmpRect);
                if (clippingRect.valid) {
                  state.clippingRect.valid = true;
                  clippingRect = intersectRect(clippingRect, elementRect, state.clippingRect);
                } else {
                  state.clippingRect.valid = true;
                  clippingRect = copyRect(elementRect, state.clippingRect);
                }
              }
              var renderOp = new WebGlCoreRenderOp(renderer.glw, renderer.options, webGlBuffers, this.sdfShader, {
                transform: transform.getFloatArr(),
                // IMPORTANT: The SDF Shader expects the color NOT to be premultiplied
                // for the best blending results. Which is why we use `mergeColorAlpha`
                // instead of `mergeColorAlphaPremultiplied` here.
                color: mergeColorAlpha(color, alpha),
                size: fontSize / (((_trFontFace$data = trFontFace.data) === null || _trFontFace$data === void 0 ? void 0 : _trFontFace$data.info.size) || 0),
                scrollY: scrollY,
                distanceRange: distanceRange,
                debug: debug.sdfShaderDebug
              }, alpha, clippingRect, {
                height: textH,
                width: textW
              }, 0, zIndex, false, parentHasRenderTexture, framebufferDimensions);
              var texture = (_state$trFontFace = state.trFontFace) === null || _state$trFontFace === void 0 ? void 0 : _state$trFontFace.texture;
              var ctxTexture = texture.ctxTexture;
              renderOp.addTexture(ctxTexture);
              renderOp.length = state.bufferNumFloats;
              renderOp.numQuads = state.bufferNumQuads;
              renderer.addRenderOp(renderOp);
              // if (!debug.disableScissor) {
              //   renderer.enableScissor(
              //     visibleRect.x,
              //     visibleRect.y,
              //     visibleRect.w,
              //     visibleRect.h,
              //   );
              // }
              // Draw the arrays
              // gl.drawArrays(
              //   gl.TRIANGLES, // Primitive type
              //   0,
              //   bufferNumVertices, // Number of verticies
              // );
              // renderer.disableScissor();
              // if (debug.showElementRect) {
              //   this.renderer.drawBorder(
              //     Colors.Blue,
              //     elementRect.x,
              //     elementRect.y,
              //     elementRect.w,
              //     elementRect.h,
              //   );
              // }
              // if (debug.showVisibleRect) {
              //   this.renderer.drawBorder(
              //     Colors.Green,
              //     visibleRect.x,
              //     visibleRect.y,
              //     visibleRect.w,
              //     visibleRect.h,
              //   );
              // }
              // if (debug.showRenderWindow && renderWindow) {
              //   this.renderer.drawBorder(
              //     Colors.Red,
              //     x + renderWindow.x1,
              //     y + renderWindow.y1 - scrollY,
              //     x + renderWindow.x2 - (x + renderWindow.x1),
              //     y + renderWindow.y2 - scrollY - (y + renderWindow.y1 - scrollY),
              //   );
              // }
              // if (debug.printLayoutTime) {
              //   debugData.drawSum += performance.now() - drawStartTime;
              //   debugData.drawCount++;
              // }
            }
          }, {
            key: "setIsRenderable",
            value: function setIsRenderable(state, renderable) {
              var _state$trFontFace2;
              _superPropGet(SdfTextRenderer, "setIsRenderable", this, 3)([state, renderable]);
              (_state$trFontFace2 = state.trFontFace) === null || _state$trFontFace2 === void 0 || _state$trFontFace2.texture.setRenderableOwner(state.props.fontFamily, renderable);
            }
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              var _state$trFontFace3;
              _superPropGet(SdfTextRenderer, "destroyState", this, 3)([state]);
              // If there's a Font Face assigned we must free the owner relation to its texture
              (_state$trFontFace3 = state.trFontFace) === null || _state$trFontFace3 === void 0 || _state$trFontFace3.texture.setRenderableOwner(state.props.fontFamily, false);
            }
            //#endregion Overrides
          }, {
            key: "resolveFontFace",
            value: function resolveFontFace(props) {
              return this.stage.fontManager.resolveFontFace(this.fontFamilyArray, props, 'sdf');
            }
            /**
             * Release the loaded SDF font face
             *
             * @param state
             */
          }, {
            key: "releaseFontFace",
            value: function releaseFontFace(state) {
              state.resLineHeight = undefined;
              if (state.trFontFace) {
                state.trFontFace.texture.setRenderableOwner(state.props.fontFamily, false);
                state.trFontFace = undefined;
              }
            }
            /**
             * Invalidate the layout cache stored in the state. This will cause the text
             * to be re-layed out on the next update.
             *
             * @remarks
             * This also invalidates the visible window cache.
             *
             * @param state
             */
          }, {
            key: "invalidateLayoutCache",
            value: function invalidateLayoutCache(state) {
              state.renderWindow.valid = false;
              state.elementBounds.valid = false;
              state.textH = undefined;
              state.textW = undefined;
              state.lineCache = [];
              this.setStatus(state, 'loading');
              this.scheduleUpdateState(state);
            }
          }, {
            key: "setElementBoundsX",
            value: function setElementBoundsX(state) {
              var _state$props4 = state.props,
                x = _state$props4.x,
                contain = _state$props4.contain,
                width = _state$props4.width;
              var elementBounds = state.elementBounds;
              elementBounds.x1 = x;
              elementBounds.x2 = contain !== 'none' ? x + width : Infinity;
            }
          }, {
            key: "setElementBoundsY",
            value: function setElementBoundsY(state) {
              var _state$props5 = state.props,
                y = _state$props5.y,
                contain = _state$props5.contain,
                height = _state$props5.height;
              var elementBounds = state.elementBounds;
              elementBounds.y1 = y;
              elementBounds.y2 = contain === 'both' ? y + height : Infinity;
            }
          }]);
        }(TextRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Returns CSS font setting string for use in canvas context.
         *
         * @param fontFace
         * @param fontStyle
         * @param fontSize
         * @param precision
         * @param defaultFontFace
         * @returns
         */
        /**
         * Returns true if the given character is a zero-width space.
         *
         * @param space
         */
        function isZeroWidthSpace(space) {
          return space === '' || space === "\u200B";
        }
        /**
         * Get the font metrics for a font face.
         *
         * @remarks
         * This function will attempt to grab the explicitly defined metrics from the
         * font face first. If the font face does not have metrics defined, it will
         * attempt to calculate the metrics using the browser's measureText method.
         *
         * If the browser does not support the font metrics API, it will use some
         * default values.
         *
         * @param context
         * @param fontFace
         * @param fontSize
         * @returns
         */
        function getWebFontMetrics(context, fontFace, fontSize) {
          if (fontFace.metrics) {
            return fontFace.metrics;
          }
          // If the font face doesn't have metrics defined, we fallback to using the
          // browser's measureText method to calculate take a best guess at the font
          // actual font's metrics.
          // - fontBoundingBox[Ascent|Descent] is the best estimate but only supported
          //   in Chrome 87+ (2020), Firefox 116+ (2023), and Safari 11.1+ (2018).
          //   - It is an estimate as it can vary between browsers.
          // - actualBoundingBox[Ascent|Descent] is less accurate and supported in
          //   Chrome 77+ (2019), Firefox 74+ (2020), and Safari 11.1+ (2018).
          // - If neither are supported, we'll use some default values which will
          //   get text on the screen but likely not be great.
          // NOTE: It's been decided not to rely on fontBoundingBox[Ascent|Descent]
          // as it's browser support is limited and it also tends to produce higher than
          // expected values. It is instead HIGHLY RECOMMENDED that developers provide
          // explicit metrics in the font face definition.
          var browserMetrics = context.measureText('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz');
          console.warn("Font metrics not provided for Canvas Web font ".concat(fontFace.fontFamily, ". ") + 'Using fallback values. It is HIGHLY recommended you use the latest ' + 'version of the Lightning 3 `msdf-generator` tool to extract the default ' + 'metrics for the font and provide them in the Canvas Web font definition.');
          var metrics;
          if (browserMetrics.actualBoundingBoxDescent && browserMetrics.actualBoundingBoxAscent) {
            metrics = {
              ascender: browserMetrics.actualBoundingBoxAscent / fontSize,
              descender: -browserMetrics.actualBoundingBoxDescent / fontSize,
              lineGap: 0.2
            };
          } else {
            // If the browser doesn't support the font metrics API, we'll use some
            // default values.
            metrics = {
              ascender: 0.8,
              descender: -0.2,
              lineGap: 0.2
            };
          }
          // Save the calculated metrics to the font face for future use.
          fontFace.metrics = metrics;
          return metrics;
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /* eslint-disable @typescript-eslint/no-non-null-assertion */
        var MAX_TEXTURE_DIMENSION = 2048;
        /**
         * Calculate height for the canvas
         *
         * @param textBaseline
         * @param fontSize
         * @param lineHeight
         * @param numLines
         * @param offsetY
         * @returns
         */
        function calcHeight(textBaseline, fontSize, lineHeight, numLines, offsetY) {
          var baselineOffset = textBaseline !== 'bottom' ? 0.5 * fontSize : 0;
          return lineHeight * (numLines - 1) + baselineOffset + Math.max(lineHeight, fontSize) + (offsetY || 0);
        }
        var LightningTextTextureRenderer = /*#__PURE__*/function () {
          function LightningTextTextureRenderer(canvas, context) {
            _classCallCheck(this, LightningTextTextureRenderer);
            _defineProperty(this, "_canvas", void 0);
            _defineProperty(this, "_context", void 0);
            _defineProperty(this, "_settings", void 0);
            this._canvas = canvas;
            this._context = context;
            this._settings = this.mergeDefaults({});
          }
          return _createClass(LightningTextTextureRenderer, [{
            key: "settings",
            get: function get() {
              return this._settings;
            },
            set: function set(v) {
              this._settings = this.mergeDefaults(v);
            }
          }, {
            key: "getPrecision",
            value: function getPrecision() {
              return this._settings.precision;
            }
          }, {
            key: "setFontProperties",
            value: function setFontProperties() {
              this._context.font = this._getFontSetting();
              this._context.textBaseline = this._settings.textBaseline;
            }
          }, {
            key: "_getFontSetting",
            value: function _getFontSetting() {
              var ff = [this._settings.fontFamily];
              var ffs = [];
              for (var i = 0, n = ff.length; i < n; i++) {
                if (ff[i] === 'serif' || ff[i] === 'sans-serif') {
                  ffs.push(ff[i]);
                } else {
                  ffs.push("\"".concat(ff[i], "\""));
                }
              }
              return "".concat(this._settings.fontStyle, " ").concat(this._settings.fontSize * this.getPrecision(), "px ").concat(ffs.join(','));
            }
          }, {
            key: "_load",
            value: function _load() {
              var _this69 = this;
              if (document.fonts) {
                var fontSetting = this._getFontSetting();
                try {
                  if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(function (err) {
                      // Just load the fallback font.
                      console.warn('[Lightning] Font load error', err, fontSetting);
                    }).then(function () {
                      if (!document.fonts.check(fontSetting, _this69._settings.text)) {
                        console.warn('[Lightning] Font not found', fontSetting);
                      }
                    });
                  }
                } catch (e) {
                  console.warn("[Lightning] Can't check font loading for " + fontSetting);
                }
              }
            }
          }, {
            key: "calculateRenderInfo",
            value: function calculateRenderInfo() {
              var renderInfo = {};
              var precision = this.getPrecision();
              var paddingLeft = this._settings.paddingLeft * precision;
              var paddingRight = this._settings.paddingRight * precision;
              var fontSize = this._settings.fontSize * precision;
              var offsetY = this._settings.offsetY === null ? null : this._settings.offsetY * precision;
              var w = this._settings.w * precision;
              var h = this._settings.h * precision;
              var wordWrapWidth = this._settings.wordWrapWidth * precision;
              var cutSx = this._settings.cutSx * precision;
              var cutEx = this._settings.cutEx * precision;
              var cutSy = this._settings.cutSy * precision;
              var cutEy = this._settings.cutEy * precision;
              var letterSpacing = (this._settings.letterSpacing || 0) * precision;
              var textIndent = this._settings.textIndent * precision;
              var trFontFace = this._settings.trFontFace;
              // Set font properties.
              this.setFontProperties();
              var metrics = getWebFontMetrics(this._context, trFontFace, fontSize);
              var defLineHeight = calcDefaultLineHeight(metrics, fontSize) * precision;
              var lineHeight = this._settings.lineHeight !== null ? this._settings.lineHeight * precision : defLineHeight;
              var maxHeight = this._settings.maxHeight;
              var containedMaxLines = maxHeight !== null && lineHeight > 0 ? Math.floor(maxHeight / lineHeight) : 0;
              var setMaxLines = this._settings.maxLines;
              var calcMaxLines = containedMaxLines > 0 && setMaxLines > 0 ? Math.min(containedMaxLines, setMaxLines) : Math.max(containedMaxLines, setMaxLines);
              // Total width.
              var width = w || 2048 / this.getPrecision();
              // Inner width.
              var innerWidth = width - paddingLeft;
              if (innerWidth < 10) {
                width += 10 - innerWidth;
                innerWidth = 10;
              }
              if (!wordWrapWidth) {
                wordWrapWidth = innerWidth;
              }
              // Text overflow
              if (this._settings.textOverflow && !this._settings.wordWrap) {
                var suffix;
                switch (this._settings.textOverflow) {
                  case 'clip':
                    suffix = '';
                    break;
                  case 'ellipsis':
                    suffix = this._settings.overflowSuffix;
                    break;
                  default:
                    suffix = this._settings.textOverflow;
                }
                this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix);
              }
              // word wrap
              // preserve original text
              var linesInfo;
              if (this._settings.wordWrap) {
                linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
              } else {
                linesInfo = {
                  l: this._settings.text.split(/(?:\r\n|\r|\n)/),
                  n: []
                };
                var n = linesInfo.l.length;
                for (var i = 0; i < n - 1; i++) {
                  linesInfo.n.push(i);
                }
              }
              var lines = linesInfo.l;
              if (calcMaxLines && lines.length > calcMaxLines) {
                var usedLines = lines.slice(0, calcMaxLines);
                var otherLines = null;
                if (this._settings.overflowSuffix) {
                  // Wrap again with max lines suffix enabled.
                  var _w = this._settings.overflowSuffix ? this.measureText(this._settings.overflowSuffix) : 0;
                  var al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - _w, letterSpacing, textIndent);
                  usedLines[usedLines.length - 1] = "".concat(al.l[0]).concat(this._settings.overflowSuffix);
                  otherLines = [al.l.length > 1 ? al.l[1] : ''];
                } else {
                  otherLines = [''];
                }
                // Re-assemble the remaining text.
                var _i17;
                var _n = lines.length;
                var j = 0;
                var m = linesInfo.n.length;
                for (_i17 = calcMaxLines; _i17 < _n; _i17++) {
                  otherLines[j] += "".concat(otherLines[j] ? ' ' : '').concat(lines[_i17]);
                  if (_i17 + 1 < m && linesInfo.n[_i17 + 1]) {
                    j++;
                  }
                }
                renderInfo.remainingText = otherLines.join('\n');
                renderInfo.moreTextLines = true;
                lines = usedLines;
              } else {
                renderInfo.moreTextLines = false;
                renderInfo.remainingText = '';
              }
              // calculate text width
              var maxLineWidth = 0;
              var lineWidths = [];
              for (var _i18 = 0; _i18 < lines.length; _i18++) {
                var lineWidth = this.measureText(lines[_i18], letterSpacing) + (_i18 === 0 ? textIndent : 0);
                lineWidths.push(lineWidth);
                maxLineWidth = Math.max(maxLineWidth, lineWidth);
              }
              renderInfo.lineWidths = lineWidths;
              if (!w) {
                // Auto-set width to max text length.
                width = maxLineWidth + paddingLeft + paddingRight;
                innerWidth = maxLineWidth;
              }
              // If word wrap is enabled the width needs to be the width of the text.
              if (this._settings.wordWrap && w > maxLineWidth && this._settings.textAlign === 'left' && lines.length === 1) {
                width = maxLineWidth + paddingLeft + paddingRight;
              }
              var height;
              if (h) {
                height = h;
              } else {
                height = calcHeight(this._settings.textBaseline, fontSize, lineHeight, lines.length, offsetY);
              }
              if (offsetY === null) {
                offsetY = fontSize;
              }
              renderInfo.w = width;
              renderInfo.h = height;
              renderInfo.lines = lines;
              renderInfo.precision = precision;
              if (!width) {
                // To prevent canvas errors.
                width = 1;
              }
              if (!height) {
                // To prevent canvas errors.
                height = 1;
              }
              if (cutSx || cutEx) {
                width = Math.min(width, cutEx - cutSx);
              }
              if (cutSy || cutEy) {
                height = Math.min(height, cutEy - cutSy);
              }
              renderInfo.width = width;
              renderInfo.innerWidth = innerWidth;
              renderInfo.height = height;
              renderInfo.fontSize = fontSize;
              renderInfo.cutSx = cutSx;
              renderInfo.cutSy = cutSy;
              renderInfo.cutEx = cutEx;
              renderInfo.cutEy = cutEy;
              renderInfo.lineHeight = lineHeight;
              renderInfo.defLineHeight = defLineHeight;
              renderInfo.lineWidths = lineWidths;
              renderInfo.offsetY = offsetY;
              renderInfo.paddingLeft = paddingLeft;
              renderInfo.paddingRight = paddingRight;
              renderInfo.letterSpacing = letterSpacing;
              renderInfo.textIndent = textIndent;
              renderInfo.metrics = metrics;
              return renderInfo;
            }
          }, {
            key: "draw",
            value: function draw(renderInfo, linesOverride) {
              var precision = this.getPrecision();
              // Allow lines to be overriden for partial rendering.
              var lines = (linesOverride === null || linesOverride === void 0 ? void 0 : linesOverride.lines) || renderInfo.lines;
              var lineWidths = (linesOverride === null || linesOverride === void 0 ? void 0 : linesOverride.lineWidths) || renderInfo.lineWidths;
              var height = linesOverride ? calcHeight(this._settings.textBaseline, renderInfo.fontSize, renderInfo.lineHeight, linesOverride.lines.length, this._settings.offsetY === null ? null : this._settings.offsetY * precision) : renderInfo.height;
              // Add extra margin to prevent issue with clipped text when scaling.
              this._canvas.width = Math.min(Math.ceil(renderInfo.width + this._settings.textRenderIssueMargin), MAX_TEXTURE_DIMENSION);
              this._canvas.height = Math.min(Math.ceil(height), MAX_TEXTURE_DIMENSION);
              // Canvas context has been reset.
              this.setFontProperties();
              if (renderInfo.fontSize >= 128) {
                // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
                this._context.globalAlpha = 0.01;
                this._context.fillRect(0, 0, 0.01, 0.01);
                this._context.globalAlpha = 1.0;
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
              }
              var linePositionX;
              var linePositionY;
              var drawLines = [];
              var metrics = renderInfo.metrics;
              /**
               * Ascender (in pixels)
               */
              var ascenderPx = metrics ? metrics.ascender * renderInfo.fontSize : renderInfo.fontSize;
              /**
               * Bare line height is the distance between the ascender and descender of the font.
               * without the line gap metric.
               */
              var bareLineHeightPx = (metrics.ascender - metrics.descender) * renderInfo.fontSize;
              // Draw lines line by line.
              for (var i = 0, n = lines.length; i < n; i++) {
                linePositionX = i === 0 ? renderInfo.textIndent : 0;
                // By default, text is aligned to top
                linePositionY = i * renderInfo.lineHeight + ascenderPx;
                if (this._settings.verticalAlign == 'middle') {
                  linePositionY += (renderInfo.lineHeight - bareLineHeightPx) / 2;
                } else if (this._settings.verticalAlign == 'bottom') {
                  linePositionY += renderInfo.lineHeight - bareLineHeightPx;
                }
                if (this._settings.textAlign === 'right') {
                  linePositionX += renderInfo.innerWidth - lineWidths[i];
                } else if (this._settings.textAlign === 'center') {
                  linePositionX += (renderInfo.innerWidth - lineWidths[i]) / 2;
                }
                linePositionX += renderInfo.paddingLeft;
                drawLines.push({
                  text: lines[i],
                  x: linePositionX,
                  y: linePositionY,
                  w: lineWidths[i]
                });
              }
              // Highlight.
              if (this._settings.highlight) {
                var color = this._settings.highlightColor;
                var hlHeight = this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5;
                var offset = this._settings.highlightOffset * precision;
                var hlPaddingLeft = this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft;
                var hlPaddingRight = this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight;
                this._context.fillStyle = getRgbaString(color);
                for (var _i19 = 0; _i19 < drawLines.length; _i19++) {
                  var drawLine = drawLines[_i19];
                  this._context.fillRect(drawLine.x - hlPaddingLeft, drawLine.y - renderInfo.offsetY + offset, drawLine.w + hlPaddingRight + hlPaddingLeft, hlHeight);
                }
              }
              // Text shadow.
              var prevShadowSettings = null;
              if (this._settings.shadow) {
                prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];
                this._context.shadowColor = getRgbaString(this._settings.shadowColor);
                this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
                this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
                this._context.shadowBlur = this._settings.shadowBlur * precision;
              }
              this._context.fillStyle = getRgbaString(this._settings.textColor);
              for (var _i20 = 0, _n2 = drawLines.length; _i20 < _n2; _i20++) {
                var _drawLine = drawLines[_i20];
                if (renderInfo.letterSpacing === 0) {
                  this._context.fillText(_drawLine.text, _drawLine.x, _drawLine.y);
                } else {
                  var textSplit = _drawLine.text.split('');
                  var x = _drawLine.x;
                  for (var _i21 = 0, j = textSplit.length; _i21 < j; _i21++) {
                    this._context.fillText(textSplit[_i21], x, _drawLine.y);
                    x += this.measureText(textSplit[_i21], renderInfo.letterSpacing);
                  }
                }
              }
              if (prevShadowSettings) {
                this._context.shadowColor = prevShadowSettings[0];
                this._context.shadowOffsetX = prevShadowSettings[1];
                this._context.shadowOffsetY = prevShadowSettings[2];
                this._context.shadowBlur = prevShadowSettings[3];
              }
              if (renderInfo.cutSx || renderInfo.cutSy) {
                this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
              }
            }
          }, {
            key: "wrapWord",
            value: function wrapWord(word, wordWrapWidth, suffix) {
              var suffixWidth = this._context.measureText(suffix).width;
              var wordLen = word.length;
              var wordWidth = this._context.measureText(word).width;
              /* If word fits wrapWidth, do nothing */
              if (wordWidth <= wordWrapWidth) {
                return word;
              }
              /* Make initial guess for text cuttoff */
              var cutoffIndex = Math.floor(wordWrapWidth * wordLen / wordWidth);
              var truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
              /* In case guess was overestimated, shrink it letter by letter. */
              if (truncWordWidth > wordWrapWidth) {
                while (cutoffIndex > 0) {
                  truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                  if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                  } else {
                    break;
                  }
                }
                /* In case guess was underestimated, extend it letter by letter. */
              } else {
                while (cutoffIndex < wordLen) {
                  truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                  if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                  } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -= 1;
                    break;
                  }
                }
              }
              /* If wrapWidth is too short to even contain suffix alone, return empty string */
              return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
            }
            /**
             * Applies newlines to a string to have it optimally fit into the horizontal
             * bounds set by the Text object's wordWrapWidth property.
             */
          }, {
            key: "wrapText",
            value: function wrapText(text, wordWrapWidth, letterSpacing) {
              var indent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var spaceRegex = / |\u200B/g; // ZWSP and spaces
              var lines = text.split(/\r?\n/g);
              var allLines = [];
              var realNewlines = [];
              for (var i = 0; i < lines.length; i++) {
                var resultLines = [];
                var result = '';
                var spaceLeft = wordWrapWidth - indent;
                // Split the line into words, considering ZWSP
                var words = lines[i].split(spaceRegex);
                var spaces = lines[i].match(spaceRegex) || [];
                for (var j = 0; j < words.length; j++) {
                  var space = spaces[j - 1] || '';
                  var word = words[j];
                  var wordWidth = this.measureText(word, letterSpacing);
                  var wordWidthWithSpace = isZeroWidthSpace(space) ? wordWidth : wordWidth + this.measureText(space, letterSpacing);
                  if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    if (j > 0) {
                      resultLines.push(result);
                      result = '';
                    }
                    result += word;
                    spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                  } else {
                    spaceLeft -= wordWidthWithSpace;
                    result += space + word;
                  }
                }
                resultLines.push(result);
                result = '';
                allLines = allLines.concat(resultLines);
                if (i < lines.length - 1) {
                  realNewlines.push(allLines.length);
                }
              }
              return {
                l: allLines,
                n: realNewlines
              };
            }
          }, {
            key: "measureText",
            value: function measureText(word) {
              var _this70 = this;
              var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              if (!space) {
                return this._context.measureText(word).width;
              }
              // Split word into characters, but skip ZWSP in the width calculation
              return word.split('').reduce(function (acc, char) {
                // Check if the character is a zero-width space and skip it
                if (isZeroWidthSpace(char)) {
                  return acc;
                }
                return acc + _this70._context.measureText(char).width + space;
              }, 0);
            }
          }, {
            key: "mergeDefaults",
            value: function mergeDefaults(settings) {
              return _objectSpread({
                text: '',
                w: 0,
                h: 0,
                fontStyle: 'normal',
                fontSize: 40,
                fontFamily: null,
                trFontFace: null,
                wordWrap: true,
                wordWrapWidth: 0,
                wordBreak: false,
                textOverflow: '',
                lineHeight: null,
                textBaseline: 'alphabetic',
                textAlign: 'left',
                verticalAlign: 'top',
                offsetY: null,
                maxLines: 0,
                maxHeight: null,
                overflowSuffix: '...',
                textColor: [1.0, 1.0, 1.0, 1.0],
                paddingLeft: 0,
                paddingRight: 0,
                shadow: false,
                shadowColor: [0.0, 0.0, 0.0, 1.0],
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                shadowBlur: 5,
                highlight: false,
                highlightHeight: 0,
                highlightColor: [0.0, 0.0, 0.0, 1.0],
                highlightOffset: 0,
                highlightPaddingLeft: 0,
                highlightPaddingRight: 0,
                letterSpacing: 0,
                textIndent: 0,
                cutSx: 0,
                cutEx: 0,
                cutSy: 0,
                cutEy: 0,
                advancedRenderer: false,
                fontBaselineRatio: 0,
                precision: 1,
                textRenderIssueMargin: 0
              }, settings);
            }
          }]);
        }();
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var resolvedGlobal = typeof self === 'undefined' ? globalThis : self;
        /**
         * Global font set regardless of if run in the main thread or a web worker
         */
        var globalFontSet = ((_resolvedGlobal$docum = resolvedGlobal.document) === null || _resolvedGlobal$docum === void 0 ? void 0 : _resolvedGlobal$docum.fonts) || resolvedGlobal.fonts;
        function getFontCssString(props) {
          var fontFamily = props.fontFamily,
            fontStyle = props.fontStyle,
            fontWeight = props.fontWeight,
            fontStretch = props.fontStretch,
            fontSize = props.fontSize;
          return [fontStyle, fontWeight, fontStretch, "".concat(fontSize, "px"), fontFamily].join(' ');
        }
        var CanvasTextRenderer = /*#__PURE__*/function (_TextRenderer3) {
          function CanvasTextRenderer(stage) {
            var _this71;
            _classCallCheck(this, CanvasTextRenderer);
            _this71 = _callSuper(this, CanvasTextRenderer, [stage]);
            _defineProperty(_this71, "canvas", void 0);
            _defineProperty(_this71, "context", void 0);
            /**
             * Font family map used to store web font faces that were added to the
             * canvas text renderer.
             */
            _defineProperty(_this71, "fontFamilies", {});
            _defineProperty(_this71, "fontFamilyArray", [_this71.fontFamilies]);
            _defineProperty(_this71, "type", 'canvas');
            _defineProperty(_this71, "loadFont", function (state) {
              var cssString = getFontCssString(state.props);
              var trFontFace = _this71.stage.fontManager.resolveFontFace(_this71.fontFamilyArray, state.props, 'canvas');
              state.fontInfo = {
                fontFace: trFontFace,
                cssString: cssString,
                // TODO: For efficiency we would use this here but it's not reliable on WPE -> document.fonts.check(cssString),
                loaded: false
              };
              // If font is not loaded, set up a handler to update the font info when the font loads
              if (!state.fontInfo.loaded) {
                globalFontSet.load(cssString).then(_this71.onFontLoaded.bind(_this71, state, cssString)).catch(_this71.onFontLoadError.bind(_this71, state, cssString));
                return;
              }
            });
            if (typeof OffscreenCanvas !== 'undefined') {
              _this71.canvas = new OffscreenCanvas(0, 0);
            } else {
              _this71.canvas = document.createElement('canvas');
            }
            var context = _this71.canvas.getContext('2d', {
              willReadFrequently: true
            });
            if (!context) {
              // A browser may appear to support OffscreenCanvas but not actually support the Canvas '2d' context
              // Here we try getting the context again after falling back to an HTMLCanvasElement.
              // See: https://github.com/lightning-js/renderer/issues/26#issuecomment-1750438486
              _this71.canvas = document.createElement('canvas');
              context = _this71.canvas.getContext('2d', {
                willReadFrequently: true
              });
            }
            _this71.context = context;
            // Install the default 'san-serif' font face
            _this71.addFontFace(new WebTrFontFace({
              fontFamily: 'sans-serif',
              descriptors: {},
              fontUrl: ''
            }));
            return _this71;
          }
          //#region Overrides
          _inherits(CanvasTextRenderer, _TextRenderer3);
          return _createClass(CanvasTextRenderer, [{
            key: "getPropertySetters",
            value: function getPropertySetters() {
              var _this72 = this;
              return {
                fontFamily: function fontFamily(state, value) {
                  state.props.fontFamily = value;
                  state.fontInfo = undefined;
                  _this72.invalidateLayoutCache(state);
                },
                fontWeight: function fontWeight(state, value) {
                  state.props.fontWeight = value;
                  state.fontInfo = undefined;
                  _this72.invalidateLayoutCache(state);
                },
                fontStyle: function fontStyle(state, value) {
                  state.props.fontStyle = value;
                  state.fontInfo = undefined;
                  _this72.invalidateLayoutCache(state);
                },
                fontStretch: function fontStretch(state, value) {
                  state.props.fontStretch = value;
                  state.fontInfo = undefined;
                  _this72.invalidateLayoutCache(state);
                },
                fontSize: function fontSize(state, value) {
                  state.props.fontSize = value;
                  state.fontInfo = undefined;
                  _this72.invalidateLayoutCache(state);
                },
                text: function text(state, value) {
                  state.props.text = value;
                  _this72.invalidateLayoutCache(state);
                },
                textAlign: function textAlign(state, value) {
                  state.props.textAlign = value;
                  _this72.invalidateLayoutCache(state);
                },
                color: function color(state, value) {
                  state.props.color = value;
                  _this72.invalidateLayoutCache(state);
                },
                x: function x(state, value) {
                  state.props.x = value;
                },
                y: function y(state, value) {
                  state.props.y = value;
                },
                contain: function contain(state, value) {
                  state.props.contain = value;
                  _this72.invalidateLayoutCache(state);
                },
                width: function width(state, value) {
                  state.props.width = value;
                  // Only invalidate layout cache if we're containing in the horizontal direction
                  if (state.props.contain !== 'none') {
                    _this72.invalidateLayoutCache(state);
                  }
                },
                height: function height(state, value) {
                  state.props.height = value;
                  // Only invalidate layout cache if we're containing in the vertical direction
                  if (state.props.contain === 'both') {
                    _this72.invalidateLayoutCache(state);
                  }
                },
                offsetY: function offsetY(state, value) {
                  state.props.offsetY = value;
                  _this72.invalidateLayoutCache(state);
                },
                scrollY: function scrollY(state, value) {
                  state.props.scrollY = value;
                },
                letterSpacing: function letterSpacing(state, value) {
                  state.props.letterSpacing = value;
                  _this72.invalidateLayoutCache(state);
                },
                lineHeight: function lineHeight(state, value) {
                  state.props.lineHeight = value;
                  _this72.invalidateLayoutCache(state);
                },
                maxLines: function maxLines(state, value) {
                  state.props.maxLines = value;
                  _this72.invalidateLayoutCache(state);
                },
                textBaseline: function textBaseline(state, value) {
                  state.props.textBaseline = value;
                  _this72.invalidateLayoutCache(state);
                },
                verticalAlign: function verticalAlign(state, value) {
                  state.props.verticalAlign = value;
                  _this72.invalidateLayoutCache(state);
                },
                overflowSuffix: function overflowSuffix(state, value) {
                  state.props.overflowSuffix = value;
                  _this72.invalidateLayoutCache(state);
                }
              };
            }
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
          }, {
            key: "canRenderFont",
            value: function canRenderFont(props) {
              // The canvas renderer can render any font because it automatically
              // falls back to system fonts. The CanvasTextRenderer should be
              // checked last if other renderers are preferred.
              return true;
            }
          }, {
            key: "isFontFaceSupported",
            value: function isFontFaceSupported(fontFace) {
              return fontFace instanceof WebTrFontFace;
            }
          }, {
            key: "addFontFace",
            value: function addFontFace(fontFace) {
              var fontFamily = fontFace.fontFamily;
              // Add the font face to the document
              // Except for the 'sans-serif' font family, which the Renderer provides
              // as a special default fallback.
              if (fontFamily !== 'sans-serif') {
                // @ts-expect-error `add()` method should be available from a FontFaceSet
                // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                globalFontSet.add(fontFace.fontFace);
              }
              var faceSet = this.fontFamilies[fontFamily];
              if (!faceSet) {
                faceSet = new Set();
                this.fontFamilies[fontFamily] = faceSet;
              }
              faceSet.add(fontFace);
            }
          }, {
            key: "createState",
            value: function createState(props, node) {
              return {
                node: node,
                props: props,
                status: 'initialState',
                updateScheduled: false,
                emitter: new EventEmitter(),
                textureNode: undefined,
                lightning2TextRenderer: new LightningTextTextureRenderer(this.canvas, this.context),
                renderInfo: undefined,
                forceFullLayoutCalc: false,
                textW: 0,
                textH: 0,
                fontInfo: undefined,
                isRenderable: false,
                debugData: {
                  updateCount: 0,
                  layoutCount: 0,
                  drawCount: 0,
                  lastLayoutNumCharacters: 0,
                  layoutSum: 0,
                  drawSum: 0,
                  bufferSize: 0
                }
              };
            }
          }, {
            key: "updateState",
            value: function updateState(state) {
              // On the first update call we need to set the status to loading
              if (state.status === 'initialState') {
                this.setStatus(state, 'loading');
                // check if we're on screen
                // if (this.isValidOnScreen(state) === true) {
                //   this.setStatus(state, 'loading');
                // }
              }
              if (state.status === 'loaded') {
                // If we're loaded, we don't need to do anything
                return;
              }
              // If fontInfo is invalid, we need to establish it
              if (!state.fontInfo) {
                return this.loadFont(state);
              }
              // If we're waiting for a font face to load, don't render anything
              if (!state.fontInfo.loaded) {
                return;
              }
              if (!state.renderInfo) {
                state.renderInfo = this.calculateRenderInfo(state);
                state.textH = state.renderInfo.lineHeight * state.renderInfo.lines.length;
                state.textW = state.renderInfo.width;
                this.renderSingleCanvasPage(state);
              }
              // handle scrollable text !!!
              // if (state.isScrollable === true) {
              //   return this.renderScrollableCanvasPages(state);
              // }
              // handle single page text
            }
          }, {
            key: "renderSingleCanvasPage",
            value: function renderSingleCanvasPage(state) {
              assertTruthy(state.renderInfo);
              var node = state.node;
              var texture = this.stage.txManager.createTexture('ImageTexture', {
                premultiplyAlpha: true,
                src: function (lightning2TextRenderer, renderInfo) {
                  lightning2TextRenderer.draw(renderInfo, {
                    lines: renderInfo.lines,
                    lineWidths: renderInfo.lineWidths
                  });
                  if (this.canvas.width === 0 || this.canvas.height === 0) {
                    return null;
                  }
                  return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                }.bind(this, state.lightning2TextRenderer, state.renderInfo)
              });
              if (state.textureNode) {
                // Use the existing texture node
                state.textureNode.texture = texture;
                // Update the alpha
                state.textureNode.alpha = getNormalizedAlphaComponent(state.props.color);
              } else {
                // Create a new texture node
                var textureNode = this.stage.createNode({
                  parent: node,
                  texture: texture,
                  autosize: true,
                  // The alpha channel of the color is ignored when rasterizing the text
                  // texture so we need to pass it directly to the texture node.
                  alpha: getNormalizedAlphaComponent(state.props.color)
                });
                state.textureNode = textureNode;
              }
              this.setStatus(state, 'loaded');
            }
          }, {
            key: "calculateRenderInfo",
            value: function calculateRenderInfo(state) {
              var _state$fontInfo, _state$props$lineHeig;
              state.lightning2TextRenderer.settings = {
                text: state.props.text,
                textAlign: state.props.textAlign,
                fontFamily: state.props.fontFamily,
                trFontFace: (_state$fontInfo = state.fontInfo) === null || _state$fontInfo === void 0 ? void 0 : _state$fontInfo.fontFace,
                fontSize: state.props.fontSize,
                fontStyle: [state.props.fontStretch, state.props.fontStyle, state.props.fontWeight].join(' '),
                textColor: getNormalizedRgbaComponents(state.props.color),
                offsetY: state.props.offsetY,
                wordWrap: state.props.contain !== 'none',
                wordWrapWidth: state.props.contain === 'none' ? undefined : state.props.width,
                letterSpacing: state.props.letterSpacing,
                lineHeight: (_state$props$lineHeig = state.props.lineHeight) !== null && _state$props$lineHeig !== void 0 ? _state$props$lineHeig : null,
                maxLines: state.props.maxLines,
                maxHeight: state.props.contain === 'both' ? state.props.height - state.props.offsetY : null,
                textBaseline: state.props.textBaseline,
                verticalAlign: state.props.verticalAlign,
                overflowSuffix: state.props.overflowSuffix,
                w: state.props.contain !== 'none' ? state.props.width : undefined
              };
              state.renderInfo = state.lightning2TextRenderer.calculateRenderInfo();
              return state.renderInfo;
            }
          }, {
            key: "renderQuads",
            value: function renderQuads() {
              // Do nothing. The renderer will render the child node(s) that were created
              // in the state update.
              return;
            }
          }, {
            key: "destroyState",
            value: function destroyState(state) {
              if (state.status === 'destroyed') {
                return;
              }
              _superPropGet(CanvasTextRenderer, "destroyState", this, 3)([state]);
              if (state.textureNode) {
                state.textureNode.destroy();
                delete state.textureNode;
              }
              delete state.renderInfo;
            }
            //#endregion Overrides
            /**
             * Invalidate the layout cache stored in the state. This will cause the text
             * to be re-rendered on the next update.
             *
             * @remarks
             * This also invalidates the visible window cache.
             *
             * @param state
             */
          }, {
            key: "invalidateLayoutCache",
            value: function invalidateLayoutCache(state) {
              state.renderInfo = undefined;
              this.setStatus(state, 'loading');
              this.scheduleUpdateState(state);
            }
          }, {
            key: "onFontLoaded",
            value: function onFontLoaded(state, cssString) {
              var _state$fontInfo2;
              if (cssString !== ((_state$fontInfo2 = state.fontInfo) === null || _state$fontInfo2 === void 0 ? void 0 : _state$fontInfo2.cssString) || !state.fontInfo) {
                return;
              }
              state.fontInfo.loaded = true;
              this.scheduleUpdateState(state);
            }
          }, {
            key: "onFontLoadError",
            value: function onFontLoadError(state, cssString, error) {
              var _state$fontInfo3;
              if (cssString !== ((_state$fontInfo3 = state.fontInfo) === null || _state$fontInfo3 === void 0 ? void 0 : _state$fontInfo3.cssString) || !state.fontInfo) {
                return;
              }
              // Font didn't actually load, but we'll log the error and mark it as loaded
              // because the browser can still render with a fallback font.
              state.fontInfo.loaded = true;
              console.error("CanvasTextRenderer: Error loading font '".concat(state.fontInfo.cssString, "'"), error);
              this.scheduleUpdateState(state);
            }
          }]);
        }(TextRenderer);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var WHITE = {
          isWhite: true,
          a: 1,
          r: 0xff,
          g: 0xff,
          b: 0xff
        };
        /**
         * Extract color components
         */
        function parseColor(abgr) {
          if (abgr === 0xffffffff) {
            return WHITE;
          }
          var a = (abgr >>> 24 & 0xff) / 255;
          var b = abgr >>> 16 & 0xff & 0xff;
          var g = abgr >>> 8 & 0xff & 0xff;
          var r = abgr & 0xff & 0xff;
          return {
            isWhite: false,
            a: a,
            r: r,
            g: g,
            b: b
          };
        }
        /**
         * Extract color components
         */
        function parseColorRgba(rgba) {
          if (rgba === 0xffffffff) {
            return WHITE;
          }
          var r = rgba >>> 24 & 0xff;
          var g = rgba >>> 16 & 0xff & 0xff;
          var b = rgba >>> 8 & 0xff & 0xff;
          var a = (rgba & 0xff & 0xff) / 255;
          return {
            isWhite: false,
            r: r,
            g: g,
            b: b,
            a: a
          };
        }
        /**
         * Format a parsed color into a rgba CSS color
         */
        function formatRgba(_ref35) {
          var a = _ref35.a,
            r = _ref35.r,
            g = _ref35.g,
            b = _ref35.b;
          return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CanvasCoreTexture = /*#__PURE__*/function (_CoreContextTexture3) {
          function CanvasCoreTexture() {
            var _this73;
            _classCallCheck(this, CanvasCoreTexture);
            for (var _len15 = arguments.length, args = new Array(_len15), _key20 = 0; _key20 < _len15; _key20++) {
              args[_key20] = arguments[_key20];
            }
            _this73 = _callSuper(this, CanvasCoreTexture, [].concat(args));
            _defineProperty(_this73, "image", void 0);
            _defineProperty(_this73, "tintCache", void 0);
            return _this73;
          }
          _inherits(CanvasCoreTexture, _CoreContextTexture3);
          return _createClass(CanvasCoreTexture, [{
            key: "load",
            value: function () {
              var _load2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20() {
                var size, _t11;
                return _regenerator().w(function (_context21) {
                  while (1) switch (_context21.p = _context21.n) {
                    case 0:
                      this.textureSource.setState('loading');
                      _context21.p = 1;
                      _context21.n = 2;
                      return this.onLoadRequest();
                    case 2:
                      size = _context21.v;
                      this.textureSource.setState('loaded', size);
                      this.updateMemSize();
                      _context21.n = 4;
                      break;
                    case 3:
                      _context21.p = 3;
                      _t11 = _context21.v;
                      this.textureSource.setState('failed', _t11);
                      throw _t11;
                    case 4:
                      return _context21.a(2);
                  }
                }, _callee20, this, [[1, 3]]);
              }));
              function load() {
                return _load2.apply(this, arguments);
              }
              return load;
            }()
          }, {
            key: "release",
            value: function release() {
              this.image = undefined;
              this.tintCache = undefined;
            }
          }, {
            key: "free",
            value: function free() {
              this.release();
              this.textureSource.setState('freed');
              this.setTextureMemUse(0);
              this.textureSource.freeTextureData();
            }
          }, {
            key: "updateMemSize",
            value: function updateMemSize() {
              // Counting memory usage for:
              // - main image
              // - tinted image
              var mult = this.tintCache ? 8 : 4;
              if (this.textureSource.dimensions) {
                var _this$textureSource$d = this.textureSource.dimensions,
                  width = _this$textureSource$d.width,
                  height = _this$textureSource$d.height;
                this.setTextureMemUse(width * height * mult);
              }
            }
          }, {
            key: "hasImage",
            value: function hasImage() {
              return this.image !== undefined;
            }
          }, {
            key: "getImage",
            value: function getImage(color) {
              var _this$tintCache;
              var image = this.image;
              if (color.isWhite) {
                if (this.tintCache) {
                  this.tintCache = undefined;
                  this.updateMemSize();
                }
                return image;
              }
              var key = formatRgba(color);
              if (((_this$tintCache = this.tintCache) === null || _this$tintCache === void 0 ? void 0 : _this$tintCache.key) === key) {
                return this.tintCache.image;
              }
              var tintedImage = this.tintTexture(image, key);
              this.tintCache = {
                key: key,
                image: tintedImage
              };
              this.updateMemSize();
              return tintedImage;
            }
          }, {
            key: "tintTexture",
            value: function tintTexture(source, color) {
              var width = source.width,
                height = source.height;
              var canvas = document.createElement('canvas');
              canvas.width = width;
              canvas.height = height;
              var ctx = canvas.getContext('2d');
              if (ctx) {
                // fill with target color
                ctx.fillStyle = color;
                ctx.globalCompositeOperation = 'copy';
                ctx.fillRect(0, 0, width, height);
                // multiply with image, resulting in non-transparent tinted image
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
                // apply original image alpha
                ctx.globalCompositeOperation = 'destination-in';
                ctx.drawImage(source, 0, 0, width, height, 0, 0, width, height);
              }
              return canvas;
            }
          }, {
            key: "onLoadRequest",
            value: function () {
              var _onLoadRequest4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21() {
                var _this$textureSource2;
                var data, canvas, ctx;
                return _regenerator().w(function (_context22) {
                  while (1) switch (_context22.n) {
                    case 0:
                      assertTruthy((_this$textureSource2 = this.textureSource) === null || _this$textureSource2 === void 0 || (_this$textureSource2 = _this$textureSource2.textureData) === null || _this$textureSource2 === void 0 ? void 0 : _this$textureSource2.data);
                      data = this.textureSource.textureData.data; // TODO: canvas from text renderer should be able to provide the canvas directly
                      // instead of having to re-draw it into a new canvas...
                      if (!(data instanceof ImageData)) {
                        _context22.n = 1;
                        break;
                      }
                      canvas = document.createElement('canvas');
                      canvas.width = data.width;
                      canvas.height = data.height;
                      ctx = canvas.getContext('2d');
                      if (ctx) ctx.putImageData(data, 0, 0);
                      this.image = canvas;
                      return _context22.a(2, {
                        width: data.width,
                        height: data.height
                      });
                    case 1:
                      if (!(typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap || data instanceof HTMLImageElement)) {
                        _context22.n = 2;
                        break;
                      }
                      this.image = data;
                      return _context22.a(2, {
                        width: data.width,
                        height: data.height
                      });
                    case 2:
                      return _context22.a(2, {
                        width: 0,
                        height: 0
                      });
                  }
                }, _callee21, this);
              }));
              function onLoadRequest() {
                return _onLoadRequest4.apply(this, arguments);
              }
              return onLoadRequest;
            }()
          }]);
        }(CoreContextTexture);
        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        /**
         * Extract `RoundedRectangle` shader radius to apply as a clipping
         */
        function getRadius(quad) {
          if (quad.shader instanceof UnsupportedShader) {
            var shType = quad.shader.shType;
            if (shType === ROUNDED_RECTANGLE_SHADER_TYPE) {
              var _quad$shaderProps$rad, _quad$shaderProps;
              return (_quad$shaderProps$rad = (_quad$shaderProps = quad.shaderProps) === null || _quad$shaderProps === void 0 ? void 0 : _quad$shaderProps.radius) !== null && _quad$shaderProps$rad !== void 0 ? _quad$shaderProps$rad : 0;
            } else if (shType === 'DynamicShader') {
              var _quad$shaderProps2;
              var effects = (_quad$shaderProps2 = quad.shaderProps) === null || _quad$shaderProps2 === void 0 ? void 0 : _quad$shaderProps2.effects;
              if (effects) {
                var _effect4 = effects.find(function (effect) {
                  var _effect$props;
                  return effect.type === 'radius' && (effect === null || effect === void 0 || (_effect$props = effect.props) === null || _effect$props === void 0 ? void 0 : _effect$props.radius);
                });
                return _effect4 && _effect4.type === 'radius' && _effect4.props.radius || 0;
              }
            }
          }
          return 0;
        }
        /**
         * Extract `RoundedRectangle` shader radius to apply as a clipping */
        function getBorder(quad) {
          var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
          if (quad.shader instanceof UnsupportedShader) {
            var shType = quad.shader.shType;
            if (shType === 'DynamicShader') {
              var _quad$shaderProps3;
              var effects = (_quad$shaderProps3 = quad.shaderProps) === null || _quad$shaderProps3 === void 0 ? void 0 : _quad$shaderProps3.effects;
              if (effects && effects.length) {
                var _effect5 = effects.find(function (effect) {
                  return effect.type === "border".concat(direction) && effect.props && effect.props.width;
                });
                return _effect5 && _effect5.props;
              }
            }
          }
          return undefined;
        }
        function roundRect(x, y, width, height, radius) {
          var context = Object.getPrototypeOf(this);
          if (!context.roundRect) {
            var fixOverlappingCorners = function fixOverlappingCorners(radii) {
              var maxRadius = Math.min(width / 2, height / 2);
              var totalHorizontal = radii.topLeft + radii.topRight + radii.bottomRight + radii.bottomLeft;
              if (totalHorizontal > width || totalHorizontal > height) {
                var scale = maxRadius / Math.max(radii.topLeft, radii.topRight, radii.bottomRight, radii.bottomLeft);
                radii.topLeft *= scale;
                radii.topRight *= scale;
                radii.bottomRight *= scale;
                radii.bottomLeft *= scale;
              }
            };
            var radii = typeof radius === 'number' ? {
              topLeft: radius,
              topRight: radius,
              bottomRight: radius,
              bottomLeft: radius
            } : _objectSpread({
              topLeft: 0,
              topRight: 0,
              bottomRight: 0,
              bottomLeft: 0
            }, radius);
            fixOverlappingCorners(radii);
            this.moveTo(x + radii.topLeft, y);
            this.lineTo(x + width - radii.topRight, y);
            this.ellipse(x + width - radii.topRight, y + radii.topRight, radii.topRight, radii.topRight, 0, 1.5 * Math.PI, 2 * Math.PI);
            this.lineTo(x + width, y + height - radii.bottomRight);
            this.ellipse(x + width - radii.bottomRight, y + height - radii.bottomRight, radii.bottomRight, radii.bottomRight, 0, 0, 0.5 * Math.PI);
            this.lineTo(x + radii.bottomLeft, y + height);
            this.ellipse(x + radii.bottomLeft, y + height - radii.bottomLeft, radii.bottomLeft, radii.bottomLeft, 0, 0.5 * Math.PI, Math.PI);
            this.lineTo(x, y + radii.topLeft);
            this.ellipse(x + radii.topLeft, y + radii.topLeft, radii.topLeft, radii.topLeft, 0, Math.PI, 1.5 * Math.PI);
          } else {
            this.roundRect(x, y, width, height, radius);
          }
        }
        function strokeLine(ctx, x, y, width, height) {
          var lineWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          var color = arguments.length > 6 ? arguments[6] : undefined;
          var direction = arguments.length > 7 ? arguments[7] : undefined;
          if (!lineWidth) {
            return;
          }
          var sx,
            sy = 0;
          var ex,
            ey = 0;
          switch (direction) {
            case 'Top':
              sx = x;
              sy = y;
              ex = width + x;
              ey = y;
              break;
            case 'Right':
              sx = x + width;
              sy = y;
              ex = x + width;
              ey = y + height;
              break;
            case 'Bottom':
              sx = x;
              sy = y + height;
              ex = x + width;
              ey = y + height;
              break;
            case 'Left':
              sx = x;
              sy = y;
              ex = x;
              ey = y + height;
              break;
          }
          ctx.beginPath();
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = formatRgba(parseColorRgba(color !== null && color !== void 0 ? color : 0));
          ctx.moveTo(sx, sy);
          ctx.lineTo(ex, ey);
          ctx.stroke();
        }

        /*
         * If not stated otherwise in this file or this component's LICENSE file the
         * following copyright and licenses apply:
         *
         * Copyright 2023 Comcast Cable Communications Management, LLC.
         *
         * Licensed under the Apache License, Version 2.0 (the License);
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         *
         * http://www.apache.org/licenses/LICENSE-2.0
         *
         * Unless required by applicable law or agreed to in writing, software
         * distributed under the License is distributed on an "AS IS" BASIS,
         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
         * See the License for the specific language governing permissions and
         * limitations under the License.
         */
        var CanvasCoreRenderer = /*#__PURE__*/function (_CoreRenderer3) {
          function CanvasCoreRenderer(options) {
            var _this74;
            _classCallCheck(this, CanvasCoreRenderer);
            _this74 = _callSuper(this, CanvasCoreRenderer, [options]);
            _defineProperty(_this74, "context", void 0);
            _defineProperty(_this74, "canvas", void 0);
            _defineProperty(_this74, "pixelRatio", void 0);
            _defineProperty(_this74, "clearColor", void 0);
            _defineProperty(_this74, "renderToTextureActive", false);
            _defineProperty(_this74, "activeRttNode", null);
            _defineProperty(_this74, "defShaderCtr", void 0);
            _this74.mode = 'canvas';
            _this74.shManager.renderer = _this74;
            var canvas = options.canvas,
              pixelRatio = options.pixelRatio,
              clearColor = options.clearColor;
            _this74.canvas = canvas;
            _this74.context = canvas.getContext('2d');
            _this74.pixelRatio = pixelRatio;
            _this74.clearColor = clearColor ? getRgbaComponents(clearColor) : undefined;
            // Stub for default shader controller since the canvas renderer does not
            // (really) support the concept of a shader (yet)
            _this74.defShaderCtr = {
              type: 'DefaultShader',
              props: {},
              shader: new UnsupportedShader('DefaultShader'),
              getResolvedProps: function getResolvedProps() {
                return function () {
                  return {};
                };
              }
            };
            return _this74;
          }
          _inherits(CanvasCoreRenderer, _CoreRenderer3);
          return _createClass(CanvasCoreRenderer, [{
            key: "reset",
            value: function reset() {
              this.canvas.width = this.canvas.width; // quick reset canvas
              var ctx = this.context;
              if (this.clearColor) {
                var _this$clearColor = _slicedToArray(this.clearColor, 4),
                  r = _this$clearColor[0],
                  g = _this$clearColor[1],
                  b = _this$clearColor[2],
                  a = _this$clearColor[3];
                ctx.fillStyle = "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a / 255, ")");
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
              }
              ctx.scale(this.pixelRatio, this.pixelRatio);
            }
          }, {
            key: "render",
            value: function render() {
              // noop
            }
          }, {
            key: "addQuad",
            value: function addQuad(quad) {
              var _texture2;
              var ctx = this.context;
              var tx = quad.tx,
                ty = quad.ty,
                width = quad.width,
                height = quad.height,
                alpha = quad.alpha,
                colorTl = quad.colorTl,
                colorTr = quad.colorTr,
                colorBr = quad.colorBr,
                ta = quad.ta,
                tb = quad.tb,
                tc = quad.tc,
                td = quad.td,
                clippingRect = quad.clippingRect;
              var texture = quad.texture;
              var ctxTexture = undefined;
              var frame;
              var textureType = (_texture2 = texture) === null || _texture2 === void 0 ? void 0 : _texture2.type;
              // The Canvas2D renderer only supports image and color textures and subTexture images
              if (textureType !== TextureType.image && textureType !== TextureType.color && textureType !== TextureType.subTexture && textureType !== TextureType.noise) {
                return;
              }
              if (texture) {
                if (texture instanceof SubTexture) {
                  frame = texture.props;
                  texture = texture.parentTexture;
                }
                ctxTexture = texture.ctxTexture;
                if (texture.state === 'freed') {
                  return;
                }
                if (texture.state !== 'loaded') {
                  return;
                }
              }
              var color = parseColor(colorTl);
              var hasTransform = ta !== 1;
              var hasClipping = clippingRect.width !== 0 && clippingRect.height !== 0;
              var hasGradient = colorTl !== colorTr || colorTl !== colorBr;
              var hasQuadShader = Boolean(quad.shader);
              var radius = hasQuadShader ? getRadius(quad) : 0;
              var border = hasQuadShader ? getBorder(quad) : undefined;
              if (hasTransform || hasClipping || radius) {
                ctx.save();
              }
              if (hasClipping) {
                var path = new Path2D();
                var x = clippingRect.x,
                  y = clippingRect.y,
                  _width2 = clippingRect.width,
                  _height2 = clippingRect.height;
                path.rect(x, y, _width2, _height2);
                ctx.clip(path);
              }
              if (hasTransform) {
                // Quad transform:
                // | ta tb tx |
                // | tc td ty |
                // | 0  0  1  |
                // C2D transform:
                // | a  c  e  |
                // | b  d  f  |
                // | 0  0  1  |
                var scale = this.pixelRatio;
                ctx.setTransform(ta, tc, tb, td, tx * scale, ty * scale);
                ctx.scale(scale, scale);
                ctx.translate(-tx, -ty);
              }
              if (radius) {
                var _path = new Path2D();
                roundRect.call(_path, tx, ty, width, height, radius);
                ctx.clip(_path);
              }
              if ((textureType === TextureType.image || textureType === TextureType.subTexture || textureType === TextureType.noise) && ctxTexture) {
                var _color$a;
                var image = ctxTexture.getImage(color);
                ctx.globalAlpha = (_color$a = color.a) !== null && _color$a !== void 0 ? _color$a : alpha;
                if (frame) {
                  ctx.drawImage(image, frame.x, frame.y, frame.width, frame.height, tx, ty, width, height);
                } else {
                  try {
                    ctx.drawImage(image, tx, ty, width, height);
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                  } catch (error) {
                    // noop
                  }
                }
                ctx.globalAlpha = 1;
              } else if (textureType === TextureType.color && hasGradient) {
                var endX = tx;
                var endY = ty;
                var endColor;
                if (colorTl === colorTr) {
                  // vertical
                  endX = tx;
                  endY = ty + height;
                  endColor = parseColor(colorBr);
                } else {
                  // horizontal
                  endX = tx + width;
                  endY = ty;
                  endColor = parseColor(colorTr);
                }
                var gradient = ctx.createLinearGradient(tx, ty, endX, endY);
                gradient.addColorStop(0, formatRgba(color));
                gradient.addColorStop(1, formatRgba(endColor));
                ctx.fillStyle = gradient;
                ctx.fillRect(tx, ty, width, height);
              } else if (textureType === TextureType.color) {
                ctx.fillStyle = formatRgba(color);
                ctx.fillRect(tx, ty, width, height);
              }
              if (border && border.width) {
                var _border$color;
                var borderWidth = border.width;
                var borderInnerWidth = border.width / 2;
                var borderColor = formatRgba(parseColorRgba((_border$color = border.color) !== null && _border$color !== void 0 ? _border$color : 0));
                ctx.beginPath();
                ctx.lineWidth = borderWidth;
                ctx.strokeStyle = borderColor;
                ctx.globalAlpha = alpha;
                if (radius) {
                  roundRect.call(ctx, tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth, radius);
                  ctx.stroke();
                } else {
                  ctx.strokeRect(tx + borderInnerWidth, ty + borderInnerWidth, width - borderWidth, height - borderWidth);
                }
                ctx.globalAlpha = 1;
              } else if (hasQuadShader) {
                var borderTop = getBorder(quad, 'Top');
                var borderRight = getBorder(quad, 'Right');
                var borderBottom = getBorder(quad, 'Bottom');
                var borderLeft = getBorder(quad, 'Left');
                if (borderTop) {
                  strokeLine(ctx, tx, ty, width, height, borderTop.width, borderTop.color, 'Top');
                }
                if (borderRight) {
                  strokeLine(ctx, tx, ty, width, height, borderRight.width, borderRight.color, 'Right');
                }
                if (borderBottom) {
                  strokeLine(ctx, tx, ty, width, height, borderBottom.width, borderBottom.color, 'Bottom');
                }
                if (borderLeft) {
                  strokeLine(ctx, tx, ty, width, height, borderLeft.width, borderLeft.color, 'Left');
                }
              }
              if (hasTransform || hasClipping || radius) {
                ctx.restore();
              }
            }
          }, {
            key: "createCtxTexture",
            value: function createCtxTexture(textureSource) {
              return new CanvasCoreTexture(this.txMemManager, textureSource);
            }
          }, {
            key: "getShaderManager",
            value: function getShaderManager() {
              return this.shManager;
            }
          }, {
            key: "getDefShaderCtr",
            value: function getDefShaderCtr() {
              return this.defShaderCtr;
            }
          }, {
            key: "renderRTTNodes",
            value: function renderRTTNodes() {
              // noop
            }
          }, {
            key: "removeRTTNode",
            value: function removeRTTNode(node) {
              // noop
            }
          }, {
            key: "renderToTexture",
            value: function renderToTexture(node) {
              // noop
            }
          }, {
            key: "getBufferInfo",
            value: function getBufferInfo() {
              return null;
            }
          }, {
            key: "getQuadCount",
            value: function getQuadCount() {
              return null;
            }
            /**
             * Updates the clear color of the canvas renderer.
             *
             * @param color - The color to set as the clear color.
             */
          }, {
            key: "updateClearColor",
            value: function updateClearColor(color) {
              this.clearColor = color ? getRgbaComponents(color) : undefined;
            }
          }]);
        }(CoreRenderer);
        var _createSignal19 = createSignal([]),
          _createSignal20 = _slicedToArray(_createSignal19, 2),
          focusPath = _createSignal20[0],
          setFocusPath = _createSignal20[1];
        var useFocusManager = function useFocusManager(userKeyMap, keyHoldOptions) {
          var owner = getOwner();
          var ownerContext = runWithOwner.bind(void 0, owner);
          Config.setActiveElement = function (activeElm) {
            return ownerContext(function () {
              return setActiveElement(activeElm);
            });
          };
          var _useFocusManager$ = useFocusManager$1({
              userKeyMap: userKeyMap,
              keyHoldOptions: keyHoldOptions,
              ownerContext: ownerContext
            }),
            cleanup = _useFocusManager$.cleanup,
            focusPathCore = _useFocusManager$.focusPath;
          createEffect(on(activeElement, function () {
            setFocusPath(_toConsumableArray(focusPathCore()));
          }, {
            defer: true
          }));
          onCleanup(cleanup);
        };
        function flattenStrings() {
          var series = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          var flattenedSeries = [];
          var i;
          for (i = 0; i < series.length; i++) {
            var s = series[i];
            if (typeof s === "string" && !s.includes("PAUSE-")) {
              flattenedSeries.push(series[i]);
            } else {
              break;
            }
          }
          return [flattenedSeries.join(",\b ")].concat(series.slice(i));
        }
        function delay(pause) {
          return new Promise(function (resolve) {
            setTimeout(resolve, pause);
          });
        }
        function speak(phrase, utterances) {
          var lang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en-US";
          var voiceName = arguments.length > 3 ? arguments[3] : undefined;
          var synth = window.speechSynthesis;
          return new Promise(function (resolve, reject) {
            var selectedVoice;
            if (voiceName) {
              var availableVoices = synth.getVoices();
              selectedVoice = availableVoices.find(function (v) {
                return v.name === voiceName;
              }) || availableVoices[0];
            }
            var utterance = new SpeechSynthesisUtterance(phrase);
            utterance.lang = lang;
            if (selectedVoice) {
              utterance.voice = selectedVoice;
            }
            utterance.onend = function () {
              resolve();
            };
            utterance.onerror = function (e) {
              reject(e);
            };
            utterances.push(utterance);
            synth.speak(utterance);
          });
        }
        function speakSeries(series, lang, voice) {
          var root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
          var synth = window.speechSynthesis;
          var remainingPhrases = flattenStrings(Array.isArray(series) ? series : [series]);
          var nestedSeriesResults = [];
          var utterances = [];
          var active = true;
          var seriesChain = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22() {
            var phrase, pause, totalRetries, retriesLeft, _totalRetries, _retriesLeft, text, objectLang, objectVoice, seriesResult, _seriesResult, _t12, _t13;
            return _regenerator().w(function (_context23) {
              while (1) switch (_context23.p = _context23.n) {
                case 0:
                  _context23.p = 0;
                case 1:
                  if (!(active && remainingPhrases.length)) {
                    _context23.n = 34;
                    break;
                  }
                  _context23.n = 2;
                  return Promise.resolve(remainingPhrases.shift());
                case 2:
                  phrase = _context23.v;
                  if (active) {
                    _context23.n = 3;
                    break;
                  }
                  return _context23.a(3, 34);
                case 3:
                  if (!(typeof phrase === "string" && phrase.includes("PAUSE-"))) {
                    _context23.n = 5;
                    break;
                  }
                  pause = Number(phrase.split("PAUSE-")[1]) * 1e3;
                  if (isNaN(pause)) {
                    _context23.n = 4;
                    break;
                  }
                  _context23.n = 4;
                  return delay(pause);
                case 4:
                  _context23.n = 33;
                  break;
                case 5:
                  if (!(typeof phrase === "string")) {
                    _context23.n = 18;
                    break;
                  }
                  if (phrase) {
                    _context23.n = 6;
                    break;
                  }
                  return _context23.a(3, 1);
                case 6:
                  totalRetries = 3;
                  retriesLeft = totalRetries;
                case 7:
                  if (!(active && retriesLeft > 0)) {
                    _context23.n = 17;
                    break;
                  }
                  _context23.p = 8;
                  _context23.n = 9;
                  return speak(phrase, utterances, lang, voice);
                case 9:
                  retriesLeft = 0;
                  _context23.n = 16;
                  break;
                case 10:
                  _context23.p = 10;
                  _t12 = _context23.v;
                  if (!(_t12 instanceof SpeechSynthesisErrorEvent)) {
                    _context23.n = 15;
                    break;
                  }
                  if (!(_t12.error === "network")) {
                    _context23.n = 12;
                    break;
                  }
                  retriesLeft--;
                  console.warn("Speech synthesis network error. Retries left: ".concat(retriesLeft));
                  _context23.n = 11;
                  return delay(500 * (totalRetries - retriesLeft));
                case 11:
                  _context23.n = 14;
                  break;
                case 12:
                  if (!(_t12.error === "canceled" || _t12.error === "interrupted")) {
                    _context23.n = 13;
                    break;
                  }
                  retriesLeft = 0;
                  _context23.n = 14;
                  break;
                case 13:
                  throw new Error("SpeechSynthesisErrorEvent: ".concat(_t12.error));
                case 14:
                  _context23.n = 16;
                  break;
                case 15:
                  throw _t12;
                case 16:
                  _context23.n = 7;
                  break;
                case 17:
                  _context23.n = 33;
                  break;
                case 18:
                  if (!(phrase instanceof SpeechSynthesisUtterance)) {
                    _context23.n = 30;
                    break;
                  }
                  _totalRetries = 3;
                  _retriesLeft = _totalRetries;
                  text = phrase.text;
                  objectLang = phrase === null || phrase === void 0 ? void 0 : phrase.lang;
                  objectVoice = phrase === null || phrase === void 0 ? void 0 : phrase.voice;
                case 19:
                  if (!(active && _retriesLeft > 0)) {
                    _context23.n = 29;
                    break;
                  }
                  _context23.p = 20;
                  _context23.n = 21;
                  return speak(text, utterances, objectLang, objectVoice === null || objectVoice === void 0 ? void 0 : objectVoice.name);
                case 21:
                  _retriesLeft = 0;
                  _context23.n = 28;
                  break;
                case 22:
                  _context23.p = 22;
                  _t13 = _context23.v;
                  if (!(_t13 instanceof SpeechSynthesisErrorEvent)) {
                    _context23.n = 27;
                    break;
                  }
                  if (!(_t13.error === "network")) {
                    _context23.n = 24;
                    break;
                  }
                  _retriesLeft--;
                  console.warn("Speech synthesis network error. Retries left: ".concat(_retriesLeft));
                  _context23.n = 23;
                  return delay(500 * (_totalRetries - _retriesLeft));
                case 23:
                  _context23.n = 26;
                  break;
                case 24:
                  if (!(_t13.error === "canceled" || _t13.error === "interrupted")) {
                    _context23.n = 25;
                    break;
                  }
                  _retriesLeft = 0;
                  _context23.n = 26;
                  break;
                case 25:
                  throw new Error("SpeechSynthesisErrorEvent: ".concat(_t13.error));
                case 26:
                  _context23.n = 28;
                  break;
                case 27:
                  throw _t13;
                case 28:
                  _context23.n = 19;
                  break;
                case 29:
                  _context23.n = 33;
                  break;
                case 30:
                  if (!(typeof phrase === "function")) {
                    _context23.n = 32;
                    break;
                  }
                  seriesResult = speakSeries(phrase(), lang, voice, false);
                  nestedSeriesResults.push(seriesResult);
                  _context23.n = 31;
                  return seriesResult.series;
                case 31:
                  _context23.n = 33;
                  break;
                case 32:
                  if (!Array.isArray(phrase)) {
                    _context23.n = 33;
                    break;
                  }
                  _seriesResult = speakSeries(phrase, lang, voice, false);
                  nestedSeriesResults.push(_seriesResult);
                  _context23.n = 33;
                  return _seriesResult.series;
                case 33:
                  _context23.n = 1;
                  break;
                case 34:
                  _context23.p = 34;
                  active = false;
                  return _context23.f(34);
                case 35:
                  return _context23.a(2);
              }
            }, _callee22, null, [[20, 22], [8, 10], [0,, 34, 35]]);
          }))();
          return {
            series: seriesChain,
            get active() {
              return active;
            },
            append: function append(toSpeak) {
              remainingPhrases.push(toSpeak);
            },
            cancel: function cancel() {
              if (!active) {
                return;
              }
              if (root) {
                synth.cancel();
              }
              nestedSeriesResults.forEach(function (nestedSeriesResult) {
                nestedSeriesResult.cancel();
              });
              active = false;
            }
          };
        }
        var currentSeries;
        function SpeechEngine(toSpeak) {
          var lang = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
          var voice = arguments.length > 2 ? arguments[2] : undefined;
          currentSeries && currentSeries.cancel();
          currentSeries = speakSeries(toSpeak, lang, voice);
          return currentSeries;
        }
        var voidFn = function voidFn() {
          return undefined;
        };
        var isServer = false;

        /**
         * Creates a callback that is debounced and cancellable. The debounced callback is called on **trailing** edge.
         *
         * The timeout will be automatically cleared on root dispose.
         *
         * @param callback The callback to debounce
         * @param wait The duration to debounce in milliseconds
         * @returns The debounced function
         *
         * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/scheduled#debounce
         *
         * @example
         * ```ts
         * const fn = debounce((message: string) => console.log(message), 250);
         * fn('Hello!');
         * fn.clear() // clears a timeout in progress
         * ```
         */
        var debounce = exports("v", function (callback, wait) {
          var timeoutId;
          var clear = function clear() {
            return clearTimeout(timeoutId);
          };
          if (getOwner()) onCleanup(clear);
          var debounced = function debounced() {
            for (var _len16 = arguments.length, args = new Array(_len16), _key21 = 0; _key21 < _len16; _key21++) {
              args[_key21] = arguments[_key21];
            }
            if (timeoutId !== undefined) clear();
            timeoutId = setTimeout(function () {
              return callback.apply(void 0, args);
            }, wait);
          };
          return Object.assign(debounced, {
            clear: clear
          });
        });
        var resetFocusPathTimer;
        var prevFocusPath = [];
        var currentlySpeaking;
        var voiceOutDisabled = false;
        var fiveMinutes = 3e5;
        function debounceWithFlush(callback, time) {
          var trigger = debounce(callback, time);
          var scopedValue;
          var debounced = function debounced(newValue) {
            scopedValue = newValue;
            trigger(newValue);
          };
          debounced.flush = function () {
            trigger.clear();
            callback(scopedValue);
          };
          debounced.clear = trigger.clear;
          return debounced;
        }
        function getElmName(elm) {
          return elm.id || elm.name;
        }
        function onFocusChangeCore() {
          var focusPath2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          if (!Announcer.onFocusChange || !Announcer.enabled) {
            return;
          }
          var loaded = focusPath2.every(function (elm) {
            return !elm.loading;
          });
          var focusDiff = focusPath2.filter(function (elm) {
            return !prevFocusPath.includes(elm);
          });
          resetFocusPathTimer();
          if (!loaded && Announcer.onFocusChange) {
            Announcer.onFocusChange([]);
            return;
          }
          prevFocusPath = focusPath2.slice(0);
          var toAnnounceText = [];
          var toAnnounce = focusDiff.reverse().reduce(function (acc, elm) {
            if (elm.announce) {
              acc.push([getElmName(elm), "Announce", elm.announce]);
              toAnnounceText.push(elm.announce);
            } else if (elm.title) {
              acc.push([getElmName(elm), "Title", elm.title]);
              toAnnounceText.push(elm.title);
            } else {
              acc.push([getElmName(elm), "No Announce", ""]);
            }
            return acc;
          }, []);
          focusDiff.reverse().reduce(function (acc, elm) {
            if (elm.announceContext) {
              acc.push([getElmName(elm), "Context", elm.announceContext]);
              toAnnounceText.push(elm.announceContext);
            } else {
              acc.push([getElmName(elm), "No Context", ""]);
            }
            return acc;
          }, toAnnounce);
          if (Announcer.debug) {
            console.table(toAnnounce);
          }
          if (toAnnounceText.length) {
            return Announcer.speak(toAnnounceText.reduce(function (acc, val) {
              return acc.concat(val);
            }, []));
          }
        }
        function textToSpeech(toSpeak, lang, voice) {
          if (voiceOutDisabled) {
            return;
          }
          return currentlySpeaking = SpeechEngine(toSpeak, lang, voice);
        }
        var Announcer = exports("A", {
          debug: false,
          enabled: true,
          lang: "en-US",
          cancel: function cancel() {
            currentlySpeaking && currentlySpeaking.cancel();
          },
          clearPrevFocus: function clearPrevFocus() {
            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            prevFocusPath = prevFocusPath.slice(0, depth);
            resetFocusPathTimer();
          },
          speak: function speak(text) {
            var _ref37 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref37$append = _ref37.append,
              append = _ref37$append === void 0 ? false : _ref37$append,
              _ref37$notification = _ref37.notification,
              notification = _ref37$notification === void 0 ? false : _ref37$notification;
            if (Announcer.onFocusChange && Announcer.enabled) {
              if (append && currentlySpeaking && currentlySpeaking.active) {
                currentlySpeaking.append(text);
              } else {
                Announcer.cancel();
                textToSpeech(text, Announcer.lang, Announcer.voice);
              }
              if (notification) {
                var _currentlySpeaking;
                voiceOutDisabled = true;
                (_currentlySpeaking = currentlySpeaking) === null || _currentlySpeaking === void 0 || _currentlySpeaking.series.finally(function () {
                  voiceOutDisabled = false;
                  Announcer.refresh();
                }).catch(console.error);
              }
            }
            return currentlySpeaking;
          },
          refresh: function refresh() {
            var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            Announcer.clearPrevFocus(depth);
            Announcer.onFocusChange && Announcer.onFocusChange(untrack(function () {
              return focusPath();
            }));
          },
          setupTimers: function setupTimers() {
            var _ref38 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref38$focusDebounce = _ref38.focusDebounce,
              focusDebounce = _ref38$focusDebounce === void 0 ? 400 : _ref38$focusDebounce,
              _ref38$focusChangeTim = _ref38.focusChangeTimeout,
              focusChangeTimeout = _ref38$focusChangeTim === void 0 ? fiveMinutes : _ref38$focusChangeTim;
            Announcer.onFocusChange = debounceWithFlush(onFocusChangeCore, focusDebounce);
            resetFocusPathTimer = debounceWithFlush(function () {
              prevFocusPath = [];
            }, focusChangeTimeout);
          }
        });
        var doOnce = false;
        var useAnnouncer = function useAnnouncer(options) {
          if (doOnce) {
            return Announcer;
          }
          doOnce = true;
          Announcer.setupTimers(options);
          createEffect(on(focusPath, Announcer.onFocusChange, {
            defer: true
          }));
          return Announcer;
        };
        function createLazy(component, props, keyHandler) {
          var _createSignal21 = createSignal(props.sync ? props.upCount : 0),
            _createSignal22 = _slicedToArray(_createSignal21, 2),
            offset = _createSignal22[0],
            setOffset = _createSignal22[1];
          var timeoutId = null;
          var viewRef;
          var buffer = createMemo(function () {
            var _props$style;
            if (typeof props.buffer === "number") {
              return props.buffer;
            }
            var scroll = props.scroll || ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.scroll);
            if (!scroll || scroll === "auto" || scroll === "always") return props.upCount + 1;
            if (scroll === "center") return Math.ceil(props.upCount / 2) + 1;
            return 2;
          });
          createRenderEffect(function () {
            return setOffset(function (offset2) {
              return Math.max(offset2, (props.selected || 0) + buffer());
            });
          });
          if (!props.sync || props.eagerLoad) {
            createEffect(function () {
              if (props.each) {
                var _loadItems = function loadItems() {
                  var count = untrack(offset);
                  if (count < props.upCount) {
                    setOffset(count + 1);
                    timeoutId = setTimeout(_loadItems, 16);
                    count++;
                  } else if (props.eagerLoad) {
                    var maxOffset = props.each ? props.each.length : 0;
                    if (count >= maxOffset) return;
                    setOffset(function (prev) {
                      return Math.min(prev + 1, maxOffset);
                    });
                    scheduleTask(_loadItems);
                  }
                };
                _loadItems();
              }
            });
          }
          var items = createMemo(function () {
            return Array.isArray(props.each) ? props.each.slice(0, offset()) : [];
          });
          function lazyScrollToIndex(index) {
            setOffset(Math.max(index, 0) + buffer());
            queueMicrotask(function () {
              return viewRef.scrollToIndex(index);
            });
          }
          var updateOffset = function updateOffset(_event, container) {
            var _props$delay;
            var maxOffset = props.each ? props.each.length : 0;
            var selected = container.selected || 0;
            var numChildren = container.children.length;
            if (offset() >= maxOffset || selected < numChildren - buffer()) return;
            if (!props.delay) {
              setOffset(function (prev) {
                return Math.min(prev + 1, maxOffset);
              });
              return;
            }
            if (timeoutId) {
              clearTimeout(timeoutId);
              setOffset(function (prev) {
                return Math.min(prev + 1, maxOffset);
              });
            }
            timeoutId = setTimeout(function () {
              setOffset(function (prev) {
                return Math.min(prev + 1, maxOffset);
              });
              timeoutId = null;
            }, (_props$delay = props.delay) !== null && _props$delay !== void 0 ? _props$delay : 0);
          };
          var handler = keyHandler(updateOffset);
          return createComponent(Dynamic, mergeProps(props, {
            component: component
          }, handler, {
            lazyScrollToIndex: lazyScrollToIndex,
            ref: function ref(r$) {
              var _ref$ = chainRefs(function (el) {
                viewRef = el;
              }, props.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get children() {
              return createComponent(Index, {
                get each() {
                  return items();
                },
                get children() {
                  return props.children;
                }
              });
            }
          }));
        }
        function LazyRow(props) {
          return createLazy(Row, props, function (updateOffset) {
            return {
              onRight: updateOffset
            };
          });
        }
        function LazyColumn(props) {
          return createLazy(Column, props, function (updateOffset) {
            return {
              onDown: updateOffset
            };
          });
        }
        var Image$1 = function Image$1(props) {
          var _createSignal23 = createSignal(null),
            _createSignal24 = _slicedToArray(_createSignal23, 2),
            texture = _createSignal24[0],
            setTexture = _createSignal24[1];
          var _createSignal25 = createSignal(props.placeholder || null),
            _createSignal26 = _slicedToArray(_createSignal25, 2),
            src = _createSignal26[0],
            setSrc = _createSignal26[1];
          createRenderEffect(function () {
            var srcTexture = renderer$1.createTexture("ImageTexture", props);
            if (props.fallback) {
              srcTexture.once("failed", function () {
                if (props.fallback === props.placeholder) {
                  return;
                }
                setSrc(props.fallback);
              });
            }
            srcTexture.getTextureData().then(function (resp) {
              if (resp.data) setTexture(srcTexture);
            });
          });
          return function () {
            var _el$ = createElement("view");
            spread(_el$, mergeProps(props, {
              get src() {
                return src();
              },
              get color() {
                return props.color || 4294967295;
              },
              get texture() {
                return texture();
              }
            }), false);
            return _el$;
          }();
        };
        function createBeforeLeave() {
          var listeners = new Set();
          function subscribe(listener) {
            listeners.add(listener);
            return function () {
              return listeners.delete(listener);
            };
          }
          var ignore = false;
          function confirm(to, options) {
            if (ignore) return !(ignore = false);
            var e = {
              to: to,
              options: options,
              defaultPrevented: false,
              preventDefault: function preventDefault() {
                return e.defaultPrevented = true;
              }
            };
            var _iterator35 = _createForOfIteratorHelper(listeners),
              _step35;
            try {
              var _loop10 = function _loop10() {
                var l = _step35.value;
                l.listener(_objectSpread(_objectSpread({}, e), {}, {
                  from: l.location,
                  retry: function retry(force) {
                    force && (ignore = true);
                    l.navigate(to, _objectSpread(_objectSpread({}, options), {}, {
                      resolve: false
                    }));
                  }
                }));
              };
              for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                _loop10();
              }
            } catch (err) {
              _iterator35.e(err);
            } finally {
              _iterator35.f();
            }
            return !e.defaultPrevented;
          }
          return {
            subscribe: subscribe,
            confirm: confirm
          };
        }
        // The following supports browser initiated blocking (eg back/forward)
        var depth;
        function saveCurrentDepth() {
          if (!window.history.state || window.history.state._depth == null) {
            window.history.replaceState(_objectSpread(_objectSpread({}, window.history.state), {}, {
              _depth: window.history.length - 1
            }), "");
          }
          depth = window.history.state._depth;
        }
        {
          saveCurrentDepth();
        }
        function keepDepth(state) {
          return _objectSpread(_objectSpread({}, state), {}, {
            _depth: window.history.state && window.history.state._depth
          });
        }
        function notifyIfNotBlocked(notify, block) {
          var ignore = false;
          return function () {
            var prevDepth = depth;
            saveCurrentDepth();
            var delta = prevDepth == null ? null : depth - prevDepth;
            if (ignore) {
              ignore = false;
              return;
            }
            if (delta && block(delta)) {
              ignore = true;
              window.history.go(-delta);
            } else {
              notify();
            }
          };
        }
        var hasSchemeRegex = /^(?:[a-z0-9]+:)?\/\//i;
        var trimPathRegex = /^\/+|(\/)\/+$/g;
        var mockBase = "http://sr";
        function normalizePath(path) {
          var omitSlash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var s = path.replace(trimPathRegex, "$1");
          return s ? omitSlash || /^[?#]/.test(s) ? s : "/" + s : "";
        }
        function _resolvePath(base, path, from) {
          if (hasSchemeRegex.test(path)) {
            return undefined;
          }
          var basePath = normalizePath(base);
          var fromPath = from && normalizePath(from);
          var result = "";
          if (!fromPath || path.startsWith("/")) {
            result = basePath;
          } else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {
            result = basePath + fromPath;
          } else {
            result = fromPath;
          }
          return (result || "/") + normalizePath(path, !result);
        }
        function invariant(value, message) {
          if (value == null) {
            throw new Error(message);
          }
          return value;
        }
        function joinPaths(from, to) {
          return normalizePath(from).replace(/\/*(\*.*)?$/g, "") + normalizePath(to);
        }
        function extractSearchParams(url) {
          var params = {};
          url.searchParams.forEach(function (value, key) {
            if (key in params) {
              if (Array.isArray(params[key])) params[key].push(value);else params[key] = [params[key], value];
            } else params[key] = value;
          });
          return params;
        }
        function createMatcher(path, partial, matchFilters) {
          var _path$split = path.split("/*", 2),
            _path$split2 = _slicedToArray(_path$split, 2),
            pattern = _path$split2[0],
            splat = _path$split2[1];
          var segments = pattern.split("/").filter(Boolean);
          var len = segments.length;
          return function (location) {
            var locSegments = location.split("/").filter(Boolean);
            var lenDiff = locSegments.length - len;
            if (lenDiff < 0 || lenDiff > 0 && splat === undefined && !partial) {
              return null;
            }
            var match = {
              path: len ? "" : "/",
              params: {}
            };
            var matchFilter = function matchFilter(s) {
              return matchFilters === undefined ? undefined : matchFilters[s];
            };
            for (var i = 0; i < len; i++) {
              var segment = segments[i];
              var dynamic = segment[0] === ":";
              var locSegment = dynamic ? locSegments[i] : locSegments[i].toLowerCase();
              var key = dynamic ? segment.slice(1) : segment.toLowerCase();
              if (dynamic && matchSegment(locSegment, matchFilter(key))) {
                match.params[key] = locSegment;
              } else if (dynamic || !matchSegment(locSegment, key)) {
                return null;
              }
              match.path += "/".concat(locSegment);
            }
            if (splat) {
              var remainder = lenDiff ? locSegments.slice(-lenDiff).join("/") : "";
              if (matchSegment(remainder, matchFilter(splat))) {
                match.params[splat] = remainder;
              } else {
                return null;
              }
            }
            return match;
          };
        }
        function matchSegment(input, filter) {
          var isEqual = function isEqual(s) {
            return s === input;
          };
          if (filter === undefined) {
            return true;
          } else if (typeof filter === "string") {
            return isEqual(filter);
          } else if (typeof filter === "function") {
            return filter(input);
          } else if (Array.isArray(filter)) {
            return filter.some(isEqual);
          } else if (filter instanceof RegExp) {
            return filter.test(input);
          }
          return false;
        }
        function scoreRoute(route) {
          var _route$pattern$split = route.pattern.split("/*", 2),
            _route$pattern$split2 = _slicedToArray(_route$pattern$split, 2),
            pattern = _route$pattern$split2[0],
            splat = _route$pattern$split2[1];
          var segments = pattern.split("/").filter(Boolean);
          return segments.reduce(function (score, segment) {
            return score + (segment.startsWith(":") ? 2 : 3);
          }, segments.length - (splat === undefined ? 0 : 1));
        }
        function createMemoObject(fn) {
          var map = new Map();
          var owner = getOwner();
          return new Proxy({}, {
            get: function get(_, property) {
              if (!map.has(property)) {
                runWithOwner(owner, function () {
                  return map.set(property, createMemo(function () {
                    return fn()[property];
                  }));
                });
              }
              return map.get(property)();
            },
            getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
              return {
                enumerable: true,
                configurable: true
              };
            },
            ownKeys: function ownKeys() {
              return Reflect.ownKeys(fn());
            }
          });
        }
        function expandOptionals(pattern) {
          var match = /(\/?\:[^\/]+)\?/.exec(pattern);
          if (!match) return [pattern];
          var prefix = pattern.slice(0, match.index);
          var suffix = pattern.slice(match.index + match[0].length);
          var prefixes = [prefix, prefix += match[1]];
          // This section handles adjacent optional params. We don't actually want all permuations since
          // that will lead to equivalent routes which have the same number of params. For example
          // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can
          // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps
          // ensure predictability where earlier params have precidence.
          while (match = /^(\/\:[^\/]+)\?/.exec(suffix)) {
            prefixes.push(prefix += match[1]);
            suffix = suffix.slice(match[0].length);
          }
          return expandOptionals(suffix).reduce(function (results, expansion) {
            return [].concat(_toConsumableArray(results), _toConsumableArray(prefixes.map(function (p) {
              return p + expansion;
            })));
          }, []);
        }
        var MAX_REDIRECTS = 100;
        var RouterContextObj = createContext();
        var RouteContextObj = createContext();
        var useRouter = function useRouter() {
          return invariant(useContext(RouterContextObj), "<A> and 'use' router primitives can be only used inside a Route.");
        };
        /**
         * Retrieves method to do navigation. The method accepts a path to navigate to and an optional object with the following options:
         *
         * - resolve (*boolean*, default `true`): resolve the path against the current route
         * - replace (*boolean*, default `false`): replace the history entry
         * - scroll (*boolean*, default `true`): scroll to top after navigation
         * - state (*any*, default `undefined`): pass custom state to `location.state`
         *
         * **Note**: The state is serialized using the structured clone algorithm which does not support all object types.
         *
         * @example
         * ```js
         * const navigate = useNavigate();
         *
         * if (unauthorized) {
         *   navigate("/login", { replace: true });
         * }
         * ```
         */
        var useNavigate = exports("u", function () {
          return useRouter().navigatorFactory();
        });
        /**
         * Retrieves reactive `location` object useful for getting things like `pathname`.
         *
         * @example
         * ```js
         * const location = useLocation();
         *
         * const pathname = createMemo(() => parsePath(location.pathname));
         * ```
         */
        var useLocation = function useLocation() {
          return useRouter().location;
        };
        /**
         * usePreloadRoute returns a function that can be used to preload a route manual.
         * This is what happens automatically with link hovering and similar focus based behavior, but it is available here as an API.
         *
         * @example
         * ```js
         * const preload = usePreloadRoute();
         *
         * preload(`/users/settings`, { preloadData: true });
         * ```
         */
        var usePreloadRoute = function usePreloadRoute() {
          var pre = useRouter().preloadRoute;
          return function (url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return pre(url instanceof URL ? url : new URL(url, mockBase), options.preloadData);
          };
        };
        /**
         * `useMatch` takes an accessor that returns the path and creates a `Memo` that returns match information if the current path matches the provided path.
         * Useful for determining if a given path matches the current route.
         *
         * @example
         * ```js
         * const match = useMatch(() => props.href);
         *
         * return <div classList={{ active: Boolean(match()) }} />;
         * ```
         */
        var useMatch = function useMatch(path, matchFilters) {
          var location = useLocation();
          var matchers = createMemo(function () {
            return expandOptionals(path()).map(function (path) {
              return createMatcher(path, undefined, matchFilters);
            });
          });
          return createMemo(function () {
            var _iterator36 = _createForOfIteratorHelper(matchers()),
              _step36;
            try {
              for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                var matcher = _step36.value;
                var match = matcher(location.pathname);
                if (match) return match;
              }
            } catch (err) {
              _iterator36.e(err);
            } finally {
              _iterator36.f();
            }
          });
        };
        /**
         * Retrieves a reactive, store-like object containing the current route path parameters as defined in the Route.
         *
         * @example
         * ```js
         * const params = useParams();
         *
         * // fetch user based on the id path parameter
         * const [user] = createResource(() => params.id, fetchUser);
         * ```
         */
        var useParams = exports("_", function () {
          return useRouter().params;
        });
        function createRoutes(routeDef) {
          var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var component = routeDef.component,
            preload = routeDef.preload,
            load = routeDef.load,
            children = routeDef.children,
            info = routeDef.info;
          var isLeaf = !children || Array.isArray(children) && !children.length;
          var shared = {
            key: routeDef,
            component: component,
            preload: preload || load,
            info: info
          };
          return asArray(routeDef.path).reduce(function (acc, originalPath) {
            var _iterator37 = _createForOfIteratorHelper(expandOptionals(originalPath)),
              _step37;
            try {
              for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
                var expandedPath = _step37.value;
                var path = joinPaths(base, expandedPath);
                var pattern = isLeaf ? path : path.split("/*", 1)[0];
                pattern = pattern.split("/").map(function (s) {
                  return s.startsWith(":") || s.startsWith("*") ? s : encodeURIComponent(s);
                }).join("/");
                acc.push(_objectSpread(_objectSpread({}, shared), {}, {
                  originalPath: originalPath,
                  pattern: pattern,
                  matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)
                }));
              }
            } catch (err) {
              _iterator37.e(err);
            } finally {
              _iterator37.f();
            }
            return acc;
          }, []);
        }
        function createBranch(routes) {
          var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          return {
            routes: routes,
            score: scoreRoute(routes[routes.length - 1]) * 10000 - index,
            matcher: function matcher(location) {
              var matches = [];
              for (var i = routes.length - 1; i >= 0; i--) {
                var route = routes[i];
                var match = route.matcher(location);
                if (!match) {
                  return null;
                }
                matches.unshift(_objectSpread(_objectSpread({}, match), {}, {
                  route: route
                }));
              }
              return matches;
            }
          };
        }
        function asArray(value) {
          return Array.isArray(value) ? value : [value];
        }
        function createBranches(routeDef) {
          var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var stack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var branches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
          var routeDefs = asArray(routeDef);
          for (var i = 0, len = routeDefs.length; i < len; i++) {
            var def = routeDefs[i];
            if (def && _typeof(def) === "object") {
              if (!def.hasOwnProperty("path")) def.path = "";
              var routes = createRoutes(def, base);
              var _iterator38 = _createForOfIteratorHelper(routes),
                _step38;
              try {
                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                  var route = _step38.value;
                  stack.push(route);
                  var isEmptyArray = Array.isArray(def.children) && def.children.length === 0;
                  if (def.children && !isEmptyArray) {
                    createBranches(def.children, route.pattern, stack, branches);
                  } else {
                    var branch = createBranch(_toConsumableArray(stack), branches.length);
                    branches.push(branch);
                  }
                  stack.pop();
                }
              } catch (err) {
                _iterator38.e(err);
              } finally {
                _iterator38.f();
              }
            }
          }
          // Stack will be empty on final return
          return stack.length ? branches : branches.sort(function (a, b) {
            return b.score - a.score;
          });
        }
        function getRouteMatches(branches, location) {
          for (var i = 0, len = branches.length; i < len; i++) {
            var match = branches[i].matcher(location);
            if (match) {
              return match;
            }
          }
          return [];
        }
        function createLocation(path, state, queryWrapper) {
          var origin = new URL(mockBase);
          var url = createMemo(function (prev) {
            var path_ = path();
            try {
              return new URL(path_, origin);
            } catch (err) {
              console.error("Invalid path ".concat(path_));
              return prev;
            }
          }, origin, {
            equals: function equals(a, b) {
              return a.href === b.href;
            }
          });
          var pathname = createMemo(function () {
            return url().pathname;
          });
          var search = createMemo(function () {
            return url().search;
          }, true);
          var hash = createMemo(function () {
            return url().hash;
          });
          var key = function key() {
            return "";
          };
          var queryFn = on(search, function () {
            return extractSearchParams(url());
          });
          return {
            get pathname() {
              return pathname();
            },
            get search() {
              return search();
            },
            get hash() {
              return hash();
            },
            get state() {
              return state();
            },
            get key() {
              return key();
            },
            query: queryWrapper ? queryWrapper(queryFn) : createMemoObject(queryFn)
          };
        }
        var intent;
        function getIntent() {
          return intent;
        }
        function setInPreloadFn(value) {}
        function createRouterContext(integration, branches, getContext) {
          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
          var _integration$signal = _slicedToArray(integration.signal, 2),
            source = _integration$signal[0],
            setSource = _integration$signal[1],
            _integration$utils = integration.utils,
            utils = _integration$utils === void 0 ? {} : _integration$utils;
          var parsePath = utils.parsePath || function (p) {
            return p;
          };
          var renderPath = utils.renderPath || function (p) {
            return p;
          };
          var beforeLeave = utils.beforeLeave || createBeforeLeave();
          var basePath = _resolvePath("", options.base || "");
          if (basePath === undefined) {
            throw new Error("".concat(basePath, " is not a valid base path"));
          } else if (basePath && !source().value) {
            setSource({
              value: basePath,
              replace: true,
              scroll: false
            });
          }
          var _createSignal27 = createSignal(false),
            _createSignal28 = _slicedToArray(_createSignal27, 2),
            isRouting = _createSignal28[0],
            setIsRouting = _createSignal28[1];
          // Keep track of last target, so that last call to transition wins
          var lastTransitionTarget;
          // Transition the location to a new value
          var transition = function transition(newIntent, newTarget) {
            if (newTarget.value === reference() && newTarget.state === state()) return;
            if (lastTransitionTarget === undefined) setIsRouting(true);
            intent = newIntent;
            lastTransitionTarget = newTarget;
            startTransition(function () {
              if (lastTransitionTarget !== newTarget) return;
              setReference(lastTransitionTarget.value);
              setState(lastTransitionTarget.state);
              submissions[1](function (subs) {
                return subs.filter(function (s) {
                  return s.pending;
                });
              });
            }).finally(function () {
              if (lastTransitionTarget !== newTarget) return;
              // Batch, in order for isRouting and final source update to happen together
              batch(function () {
                intent = undefined;
                if (newIntent === "navigate") navigateEnd(lastTransitionTarget);
                setIsRouting(false);
                lastTransitionTarget = undefined;
              });
            });
          };
          var _createSignal29 = createSignal(source().value),
            _createSignal30 = _slicedToArray(_createSignal29, 2),
            reference = _createSignal30[0],
            setReference = _createSignal30[1];
          var _createSignal31 = createSignal(source().state),
            _createSignal32 = _slicedToArray(_createSignal31, 2),
            state = _createSignal32[0],
            setState = _createSignal32[1];
          var location = createLocation(reference, state, utils.queryWrapper);
          var referrers = [];
          var submissions = createSignal([]);
          var matches = createMemo(function () {
            if (typeof options.transformUrl === "function") {
              return getRouteMatches(branches(), options.transformUrl(location.pathname));
            }
            return getRouteMatches(branches(), location.pathname);
          });
          var buildParams = function buildParams() {
            var m = matches();
            var params = {};
            for (var i = 0; i < m.length; i++) {
              Object.assign(params, m[i].params);
            }
            return params;
          };
          var params = utils.paramsWrapper ? utils.paramsWrapper(buildParams, branches) : createMemoObject(buildParams);
          var baseRoute = {
            pattern: basePath,
            path: function path() {
              return basePath;
            },
            outlet: function outlet() {
              return null;
            },
            resolvePath: function resolvePath(to) {
              return _resolvePath(basePath, to);
            }
          };
          // Create a native transition, when source updates
          createRenderEffect(on(source, function (source) {
            return transition("native", source);
          }, {
            defer: true
          }));
          return {
            base: baseRoute,
            location: location,
            params: params,
            isRouting: isRouting,
            renderPath: renderPath,
            parsePath: parsePath,
            navigatorFactory: navigatorFactory,
            matches: matches,
            beforeLeave: beforeLeave,
            preloadRoute: preloadRoute,
            singleFlight: options.singleFlight === undefined ? true : options.singleFlight,
            submissions: submissions
          };
          function navigateFromRoute(route, to, options) {
            // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths
            untrack(function () {
              if (typeof to === "number") {
                if (!to) {
                  // A delta of 0 means stay at the current location, so it is ignored
                } else if (utils.go) {
                  utils.go(to);
                } else {
                  console.warn("Router integration does not support relative routing");
                }
                return;
              }
              var queryOnly = !to || to[0] === "?";
              var _replace$resolve$scro = _objectSpread({
                  replace: false,
                  resolve: !queryOnly,
                  scroll: true
                }, options),
                replace = _replace$resolve$scro.replace,
                resolve = _replace$resolve$scro.resolve,
                scroll = _replace$resolve$scro.scroll,
                nextState = _replace$resolve$scro.state;
              var resolvedTo = resolve ? route.resolvePath(to) : _resolvePath(queryOnly && location.pathname || "", to);
              if (resolvedTo === undefined) {
                throw new Error("Path '".concat(to, "' is not a routable path"));
              } else if (referrers.length >= MAX_REDIRECTS) {
                throw new Error("Too many redirects");
              }
              var current = reference();
              if (resolvedTo !== current || nextState !== state()) {
                if (isServer) ;else if (beforeLeave.confirm(resolvedTo, options)) {
                  referrers.push({
                    value: current,
                    replace: replace,
                    scroll: scroll,
                    state: state()
                  });
                  transition("navigate", {
                    value: resolvedTo,
                    state: nextState
                  });
                }
              }
            });
          }
          function navigatorFactory(route) {
            // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)
            route = route || useContext(RouteContextObj) || baseRoute;
            return function (to, options) {
              return navigateFromRoute(route, to, options);
            };
          }
          function navigateEnd(next) {
            var first = referrers[0];
            if (first) {
              setSource(_objectSpread(_objectSpread({}, next), {}, {
                replace: first.replace,
                scroll: first.scroll
              }));
              referrers.length = 0;
            }
          }
          function preloadRoute(url, preloadData) {
            var matches = getRouteMatches(branches(), url.pathname);
            var prevIntent = intent;
            intent = "preload";
            var _loop11 = function _loop11() {
              var _matches$match = matches[match],
                route = _matches$match.route,
                params = _matches$match.params;
              route.component && route.component.preload && route.component.preload();
              var preload = route.preload;
              preloadData && preload && runWithOwner(getContext(), function () {
                return preload({
                  params: params,
                  location: {
                    pathname: url.pathname,
                    search: url.search,
                    hash: url.hash,
                    query: extractSearchParams(url),
                    state: null,
                    key: ""
                  },
                  intent: "preload"
                });
              });
            };
            for (var match in matches) {
              _loop11();
            }
            intent = prevIntent;
          }
        }
        function createRouteContext(router, parent, _outlet, match) {
          var base = router.base,
            location = router.location,
            params = router.params;
          var _match$route = match().route,
            pattern = _match$route.pattern,
            component = _match$route.component,
            preload = _match$route.preload;
          var path = createMemo(function () {
            return match().path;
          });
          component && component.preload && component.preload();
          var data = preload ? preload({
            params: params,
            location: location,
            intent: intent || "initial"
          }) : undefined;
          var route = {
            parent: parent,
            pattern: pattern,
            path: path,
            outlet: function outlet() {
              return component ? createComponent$1(component, {
                params: params,
                location: location,
                data: data,
                get children() {
                  return _outlet();
                }
              }) : _outlet();
            },
            resolvePath: function resolvePath(to) {
              return _resolvePath(base.path(), to, path());
            }
          };
          return route;
        }
        var createRouterComponent = function createRouterComponent(router) {
          return function (props) {
            var base = props.base;
            var routeDefs = children(function () {
              return props.children;
            });
            var branches = createMemo(function () {
              return createBranches(routeDefs(), props.base || "");
            });
            var context;
            var routerState = createRouterContext(router, branches, function () {
              return context;
            }, {
              base: base,
              singleFlight: props.singleFlight,
              transformUrl: props.transformUrl
            });
            router.create && router.create(routerState);
            return createComponent(RouterContextObj.Provider, {
              value: routerState,
              get children() {
                return createComponent(Root, {
                  routerState: routerState,
                  get root() {
                    return props.root;
                  },
                  get preload() {
                    return props.rootPreload || props.rootLoad;
                  },
                  get children() {
                    return [memo(function () {
                      return (context = getOwner()) && null;
                    }), createComponent(Routes, {
                      routerState: routerState,
                      get branches() {
                        return branches();
                      }
                    })];
                  }
                });
              }
            });
          };
        };
        function Root(props) {
          var location = props.routerState.location;
          var params = props.routerState.params;
          var data = createMemo(function () {
            return props.preload && untrack(function () {
              setInPreloadFn(true);
              props.preload({
                params: params,
                location: location,
                intent: getIntent() || "initial"
              });
              setInPreloadFn(false);
            });
          });
          return createComponent(Show, {
            get when() {
              return props.root;
            },
            keyed: true,
            get fallback() {
              return props.children;
            },
            children: function children(Root2) {
              return createComponent(Root2, {
                params: params,
                location: location,
                get data() {
                  return data();
                },
                get children() {
                  return props.children;
                }
              });
            }
          });
        }
        function Routes(props) {
          var disposers = [];
          var root;
          var routeStates = createMemo(on(props.routerState.matches, function (nextMatches, prevMatches, prev) {
            var equal = prevMatches && nextMatches.length === prevMatches.length;
            var next = [];
            var _loop12 = function _loop12(i) {
              var prevMatch = prevMatches && prevMatches[i];
              var nextMatch = nextMatches[i];
              if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {
                next[i] = prev[i];
              } else {
                equal = false;
                if (disposers[i]) {
                  disposers[i]();
                }
                createRoot(function (dispose) {
                  disposers[i] = dispose;
                  next[i] = createRouteContext(props.routerState, next[i - 1] || props.routerState.base, createOutlet(function () {
                    return routeStates()[i + 1];
                  }), function () {
                    return props.routerState.matches()[i];
                  });
                });
              }
            };
            for (var i = 0, len = nextMatches.length; i < len; i++) {
              _loop12(i);
            }
            disposers.splice(nextMatches.length).forEach(function (dispose) {
              return dispose();
            });
            if (prev && equal) {
              return prev;
            }
            root = next[0];
            return next;
          }));
          return createOutlet(function () {
            return routeStates() && root;
          })();
        }
        var createOutlet = function createOutlet(child) {
          return function () {
            return createComponent(Show, {
              get when() {
                return child();
              },
              keyed: true,
              children: function children(child2) {
                return createComponent(RouteContextObj.Provider, {
                  value: child2,
                  get children() {
                    return child2.outlet();
                  }
                });
              }
            });
          };
        };
        var Route = function Route(props) {
          var childRoutes = children(function () {
            return props.children;
          });
          return mergeProps$1(props, {
            get children() {
              return childRoutes();
            }
          });
        };
        function intercept(_ref39, get, set) {
          var _ref40 = _slicedToArray(_ref39, 2),
            value = _ref40[0],
            setValue = _ref40[1];
          return [value, set ? function (v) {
            return setValue(set(v));
          } : setValue];
        }
        function createRouter(config) {
          var ignore = false;
          var wrap = function wrap(value) {
            return typeof value === "string" ? {
              value: value
            } : value;
          };
          var signal = intercept(createSignal(wrap(config.get()), {
            equals: function equals(a, b) {
              return a.value === b.value && a.state === b.state;
            }
          }), undefined, function (next) {
            !ignore && config.set(next);
            if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = true;
            return next;
          });
          config.init && onCleanup(config.init(function () {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : config.get();
            ignore = true;
            signal[1](wrap(value));
            ignore = false;
          }));
          return createRouterComponent({
            signal: signal,
            create: config.create,
            utils: config.utils
          });
        }
        function Navigate(props) {
          var navigate = useNavigate();
          var location = useLocation();
          var href = props.href,
            state = props.state;
          var path = typeof href === "function" ? href({
            navigate: navigate,
            location: location
          }) : href;
          navigate(path, {
            replace: true,
            state: state
          });
          return null;
        }
        function hashParser(str) {
          var to = str.replace(/^.*?#/, "");
          if (!to.startsWith("/")) {
            var _window$location$hash = window.location.hash.split("#", 2),
              _window$location$hash2 = _slicedToArray(_window$location$hash, 2),
              _window$location$hash3 = _window$location$hash2[1],
              path = _window$location$hash3 === void 0 ? "/" : _window$location$hash3;
            return "".concat(path, "#").concat(to);
          }
          return to;
        }
        function bindEvent(target, type, handler) {
          target.addEventListener(type, handler);
          return function () {
            return target.removeEventListener(type, handler);
          };
        }
        function HashRouter(props) {
          var getSource = function getSource() {
            return window.location.hash.slice(1);
          };
          var beforeLeave = createBeforeLeave();
          return createRouter({
            get: getSource,
            set: function set(_ref41) {
              var value = _ref41.value,
                replace = _ref41.replace,
                state = _ref41.state;
              if (replace) {
                window.history.replaceState(keepDepth(state), "", "#" + value);
              } else {
                window.history.pushState(state, "", "#" + value);
              }
              saveCurrentDepth();
            },
            init: function init(notify) {
              return bindEvent(window, "hashchange", notifyIfNotBlocked(notify, function (delta) {
                return !beforeLeave.confirm(delta && delta < 0 ? delta : getSource());
              }));
            },
            utils: {
              go: function go(delta) {
                return window.history.go(delta);
              },
              renderPath: function renderPath(path) {
                return "#".concat(path);
              },
              parsePath: hashParser,
              beforeLeave: beforeLeave,
              queryWrapper: props.forceProxy || !SUPPORTS_PROXY ? function (getQuery) {
                return createMemoWithoutProxy(getQuery, props.queryParams);
              } : void 0,
              paramsWrapper: props.forceProxy || !SUPPORTS_PROXY ? function (buildParams, branches) {
                return createMemoWithoutProxy(buildParams, collectDynamicParams(branches()));
              } : void 0
            }
          })(props);
        }
        var SUPPORTS_PROXY = typeof Proxy === "function";
        function createMemoWithoutProxy(fn, allKeys) {
          var map = /* @__PURE__ */new Map();
          var owner = getOwner();
          var target = {};
          var handler = function handler(property) {
            if (!map.has(property)) {
              runWithOwner(owner, function () {
                return map.set(property, createMemo(function () {
                  return fn()[property];
                }));
              });
            }
            return map.get(property)();
          };
          var keys = allKeys ? allKeys : Object.keys(fn());
          keys.forEach(function (key) {
            Object.defineProperty(target, key, {
              get: function get() {
                return handler(key);
              },
              enumerable: true,
              configurable: true
            });
          });
          return target;
        }
        var collectDynamicParams = function collectDynamicParams(branches) {
          var dynamicParams = [];
          branches.forEach(function (branch) {
            branch.routes.forEach(function (route) {
              if (route.pattern) {
                var matches = route.pattern.match(/:(\w+)/g);
                if (matches) {
                  matches.forEach(function (param) {
                    var p = param.slice(1);
                    if (!dynamicParams.includes(p)) dynamicParams.push(p);
                  });
                }
              }
            });
          });
          return dynamicParams;
        };
        function idxInArray(idx, arr) {
          return idx >= 0 && idx < arr.length;
        }
        function findFirstFocusableChildIdx(el) {
          var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var delta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
          for (var i = from;; i += delta) {
            var _el$children$i;
            if (!idxInArray(i, el.children)) {
              if (el.wrap) {
                i = (i + el.children.length) % el.children.length;
              } else break;
            }
            if (!((_el$children$i = el.children[i]) !== null && _el$children$i !== void 0 && _el$children$i.skipFocus)) {
              return i;
            }
          }
          return -1;
        }
        function selectChild(el, index) {
          var _el$onSelectedChanged;
          var child = el.children[index];
          if (child == null || child.skipFocus) {
            el.selected = -1;
            return false;
          }
          var lastSelected = el.selected;
          el.selected = index;
          if (!isFocused(child)) {
            child.setFocus();
          }
          (_el$onSelectedChanged = el.onSelectedChanged) === null || _el$onSelectedChanged === void 0 || _el$onSelectedChanged.call(el, index, el, child, lastSelected);
          return true;
        }
        var navigableForwardFocus = function navigableForwardFocus() {
          var navigable = this;
          var selected = navigable.selected;
          selected = idxInArray(selected, this.children) ? selected : 0;
          selected = findFirstFocusableChildIdx(navigable, selected);
          navigable.selected = selected;
          return selectChild(navigable, selected);
        };
        function handleNavigation(direction) {
          return function () {
            return moveSelection(this, direction === "up" || direction === "left" ? -1 : 1);
          };
        }
        var navigableHandleNavigation = function navigableHandleNavigation(e) {
          return moveSelection(this, e.key === "ArrowUp" || e.key === "ArrowLeft" ? -1 : 1);
        };
        function moveSelection(el, delta) {
          var selected = findFirstFocusableChildIdx(el, el.selected + delta, delta);
          if (selected === -1) {
            if (!idxInArray(el.selected, el.children) || el.children[el.selected].skipFocus || isFocused(el.children[el.selected])) {
              return false;
            }
            selected = el.selected;
          }
          var active = el.children[selected];
          if (el.plinko) {
            var lastSelectedChild = el.children[el.selected];
            var num = lastSelectedChild.selected || 0;
            active.selected = num < active.children.length ? num : active.children.length - 1;
          }
          return selectChild(el, selected);
        }
        var InViewPort = 8;
        var isNotShown = function isNotShown(node) {
          return node.lng.renderState !== InViewPort;
        };
        function withScrolling(isRow) {
          var dimension = isRow ? "width" : "height";
          var axis = isRow ? "x" : "y";
          return function (selected, component, selectedElement, lastSelected) {
            var _componentRef$_target, _componentRef$offset2, _selectedElement$axis, _selectedElement$dime, _ref42, _selectedElement$scal, _selectedElement$styl, _componentRef$dimensi;
            var componentRef = component;
            if (typeof selected !== "number") {
              componentRef = selected;
              selected = componentRef.selected || 0;
            }
            if (!componentRef || componentRef.scroll === "none" || selected === lastSelected || !componentRef.children.length) return;
            if (componentRef._initialPosition === void 0) {
              componentRef._initialPosition = componentRef[axis];
            }
            var lng = componentRef.lng;
            var screenSize = isRow ? lng.stage.root.width : lng.stage.root.height;
            var isIncrementing = lastSelected === void 0 || lastSelected - 1 !== selected;
            if (componentRef._screenOffset === void 0) {
              var _componentRef$offset;
              if (componentRef.parent.clipping) {
                var p = componentRef.parent;
                componentRef.endOffset = screenSize - ((isRow ? p.absX : p.absY) || 0) - p[dimension];
              }
              componentRef._screenOffset = (_componentRef$offset = componentRef.offset) !== null && _componentRef$offset !== void 0 ? _componentRef$offset : (isRow ? lng.absX : lng.absY) - componentRef[axis];
            }
            var screenOffset = componentRef._screenOffset;
            var gap = componentRef.gap || 0;
            var scroll = componentRef.scroll || (lastSelected === void 0 ? componentRef.scrollIndex ? "center" : "always" : "auto");
            var targetPosition = (_componentRef$_target = componentRef._targetPosition) !== null && _componentRef$_target !== void 0 ? _componentRef$_target : componentRef[axis];
            var rootPosition = isIncrementing ? Math.min(targetPosition, componentRef[axis]) : Math.max(targetPosition, componentRef[axis]);
            componentRef.offset = (_componentRef$offset2 = componentRef.offset) !== null && _componentRef$offset2 !== void 0 ? _componentRef$offset2 : rootPosition;
            var offset = componentRef.offset;
            selectedElement = selectedElement || componentRef.children[selected];
            if (!selectedElement) {
              return;
            }
            var selectedPosition = (_selectedElement$axis = selectedElement[axis]) !== null && _selectedElement$axis !== void 0 ? _selectedElement$axis : 0;
            var selectedSize = (_selectedElement$dime = selectedElement[dimension]) !== null && _selectedElement$dime !== void 0 ? _selectedElement$dime : 0;
            var selectedScale = (_ref42 = (_selectedElement$scal = selectedElement.scale) !== null && _selectedElement$scal !== void 0 ? _selectedElement$scal : (_selectedElement$styl = selectedElement.style) === null || _selectedElement$styl === void 0 || (_selectedElement$styl = _selectedElement$styl.focus) === null || _selectedElement$styl === void 0 ? void 0 : _selectedElement$styl.scale) !== null && _ref42 !== void 0 ? _ref42 : 1;
            var selectedSizeScaled = selectedSize * selectedScale;
            var containerSize = (_componentRef$dimensi = componentRef[dimension]) !== null && _componentRef$dimensi !== void 0 ? _componentRef$dimensi : 0;
            var maxOffset = Math.min(screenSize - containerSize - screenOffset - (componentRef.endOffset || 2 * gap), offset);
            var nextIndex = isIncrementing ? selected + 1 : selected - 1;
            var nextElement = componentRef.children[nextIndex] || null;
            var nextPosition = rootPosition;
            if (selectedElement.centerScroll) {
              nextPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2;
            } else if (scroll === "always") {
              nextPosition = -selectedPosition + offset;
            } else if (scroll === "center") {
              var centerPosition = -selectedPosition + (screenSize - selectedSizeScaled) / 2 - screenOffset;
              nextPosition = Math.min(Math.max(centerPosition, maxOffset), offset);
            } else if (!nextElement) {
              nextPosition = isIncrementing ? maxOffset : offset;
            } else if (scroll === "auto") {
              if (componentRef.scrollIndex && componentRef.scrollIndex > 0) {
                var totalItems = componentRef.children.length;
                var nearEndIndex = totalItems - componentRef.scrollIndex;
                if (isIncrementing && componentRef.selected >= componentRef.scrollIndex) {
                  nextPosition = rootPosition - selectedSize - gap;
                } else if (!isIncrementing && componentRef.selected < nearEndIndex) {
                  nextPosition = rootPosition + selectedSize + gap;
                }
              } else if (isIncrementing) {
                nextPosition = rootPosition - selectedSize - gap;
              } else {
                nextPosition = rootPosition + selectedSize + gap;
              }
            } else if (isIncrementing && isNotShown(nextElement)) {
              nextPosition = rootPosition - selectedSize - gap;
            } else if (isNotShown(nextElement)) {
              nextPosition = -selectedPosition + offset;
            }
            nextPosition = isIncrementing && scroll !== "always" ? Math.max(nextPosition, maxOffset) : Math.min(nextPosition, offset);
            if (componentRef[axis] !== nextPosition) {
              if (componentRef.onScrolled) {
                var isInitial = nextPosition === componentRef._initialPosition;
                componentRef.onScrolled(componentRef, nextPosition, isInitial);
              }
              componentRef[axis] = nextPosition;
              componentRef._targetPosition = nextPosition;
            }
          };
        }
        var scrollRow = /* @__PURE__ */withScrolling(true);
        var scrollColumn = /* @__PURE__ */withScrolling(false);
        function chainFunctions() {
          for (var _len17 = arguments.length, fns = new Array(_len17), _key22 = 0; _key22 < _len17; _key22++) {
            fns[_key22] = arguments[_key22];
          }
          var onlyFunctions = fns.filter(function (func) {
            return typeof func === "function";
          });
          if (onlyFunctions.length === 0) {
            return void 0;
          }
          if (onlyFunctions.length === 1) {
            return onlyFunctions[0];
          }
          return function () {
            var result;
            for (var _len18 = arguments.length, innerArgs = new Array(_len18), _key23 = 0; _key23 < _len18; _key23++) {
              innerArgs[_key23] = arguments[_key23];
            }
            var _iterator39 = _createForOfIteratorHelper(onlyFunctions),
              _step39;
            try {
              for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                var func = _step39.value;
                result = func.apply(this, innerArgs);
                if (result === true) {
                  return result;
                }
              }
            } catch (err) {
              _iterator39.e(err);
            } finally {
              _iterator39.f();
            }
            return result;
          };
        }
        var chainRefs = exports("n", chainFunctions);
        var ColumnStyles = {
          display: "flex",
          flexDirection: "column",
          gap: 30,
          transition: {
            y: {
              duration: 250,
              easing: "ease-in-out"
            }
          }
        };
        function scrollToIndex$1(index) {
          var _this$children$index;
          this.selected = index;
          scrollColumn(index, this);
          (_this$children$index = this.children[index]) === null || _this$children$index === void 0 || _this$children$index.setFocus();
        }
        var onUp = handleNavigation("up");
        var onDown = handleNavigation("down");
        var Column = exports("C", function (props) {
          return function () {
            var _el$ = createElement("view");
            spread(_el$, mergeProps(props, {
              "onUp": chainFunctions(props.onUp, onUp),
              "onDown": chainFunctions(props.onDown, onDown),
              get selected() {
                return props.selected || 0;
              },
              "scrollToIndex": scrollToIndex$1,
              "forwardFocus": navigableForwardFocus,
              "onLayout": props.selected ? chainFunctions(props.onLayout, scrollColumn) : props.onLayout,
              "onSelectedChanged": chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scrollColumn : void 0),
              "style": combineStyles(props.style, ColumnStyles)
            }), false);
            return _el$;
          }();
        });
        var RowStyles = {
          display: "flex",
          gap: 30,
          transition: {
            x: {
              duration: 250,
              easing: "ease-in-out"
            }
          }
        };
        function scrollToIndex(index) {
          var _this$children$index2;
          this.selected = index;
          scrollRow(index, this);
          (_this$children$index2 = this.children[index]) === null || _this$children$index2 === void 0 || _this$children$index2.setFocus();
        }
        var onLeft = handleNavigation("left");
        var onRight = handleNavigation("right");
        var Row = exports("R", function (props) {
          return function () {
            var _el$ = createElement("view");
            spread(_el$, mergeProps(props, {
              get selected() {
                return props.selected || 0;
              },
              "onLeft": chainFunctions(props.onLeft, onLeft),
              "onRight": chainFunctions(props.onRight, onRight),
              "forwardFocus": navigableForwardFocus,
              "scrollToIndex": scrollToIndex,
              "onLayout": props.selected ? chainFunctions(props.onLayout, scrollRow) : props.onLayout,
              "onSelectedChanged": chainFunctions(props.onSelectedChanged, props.scroll !== "none" ? scrollRow : void 0),
              "style": combineStyles(props.style, RowStyles)
            }), false);
            return _el$;
          }();
        });
        var fpsStyle = {
          color: 255,
          height: 180,
          width: 330,
          x: 1900,
          y: 6,
          mountX: 1,
          alpha: 0.8,
          zIndex: 100
        };
        var fpsLabel = {
          x: 10,
          fontSize: 20,
          textColor: 4143380223
        };
        var fpsValue = {
          fontSize: 22,
          textColor: 4143380223
        };
        var _createSignal33 = createSignal(0),
          _createSignal34 = _slicedToArray(_createSignal33, 2),
          fps = _createSignal34[0],
          setFps = _createSignal34[1];
        var _createSignal35 = createSignal(0),
          _createSignal36 = _slicedToArray(_createSignal35, 2),
          avgFps = _createSignal36[0],
          setAvgFps = _createSignal36[1];
        var _createSignal37 = createSignal(99),
          _createSignal38 = _slicedToArray(_createSignal37, 2),
          minFps = _createSignal38[0],
          setMinFps = _createSignal38[1];
        var _createSignal39 = createSignal(0),
          _createSignal40 = _slicedToArray(_createSignal39, 2),
          maxFps = _createSignal40[0],
          setMaxFps = _createSignal40[1];
        var _createSignal41 = createSignal(""),
          _createSignal42 = _slicedToArray(_createSignal41, 2),
          criticalThresholdSignal = _createSignal42[0],
          setCriticalThresholdSignal = _createSignal42[1];
        var _createSignal43 = createSignal(""),
          _createSignal44 = _slicedToArray(_createSignal43, 2),
          targetThresholdSignal = _createSignal44[0],
          setTargetThresholdSignal = _createSignal44[1];
        var _createSignal45 = createSignal(""),
          _createSignal46 = _slicedToArray(_createSignal45, 2),
          renderableMemUsedSignal = _createSignal46[0],
          setRenderableMemUsedSignal = _createSignal46[1];
        var _createSignal47 = createSignal(""),
          _createSignal48 = _slicedToArray(_createSignal47, 2),
          memUsedSignal = _createSignal48[0],
          setMemUsedSignal = _createSignal48[1];
        var _createSignal49 = createSignal(0),
          _createSignal50 = _slicedToArray(_createSignal49, 2),
          renderableTexturesLoadedSignal = _createSignal50[0],
          setRenderableTexturesLoadedSignal = _createSignal50[1];
        var _createSignal51 = createSignal(0),
          _createSignal52 = _slicedToArray(_createSignal51, 2),
          loadedTexturesSignal = _createSignal52[0],
          setLoadedTexturesSignal = _createSignal52[1];
        var count = 0;
        var totalFps = 0;
        var infoFontSize = 14;
        function bytesToMb(bytes) {
          return (bytes / 1024 / 1024).toFixed(2) + " Mb";
        }
        var calcFps = function calcFps(fps2) {
          if (!fps2) return;
          setFps(fps2);
          setMinFps(function (prev) {
            return Math.min(fps2, prev);
          });
          setMaxFps(function (prev) {
            return Math.max(fps2, prev);
          });
          totalFps += fps2;
          count++;
          setAvgFps(Math.round(totalFps / count));
        };
        function updateMemoryInfo(stage) {
          var memInfo = stage.txMemManager.getMemoryInfo();
          setCriticalThresholdSignal(bytesToMb(memInfo.criticalThreshold));
          setTargetThresholdSignal(bytesToMb(memInfo.targetThreshold));
          setRenderableMemUsedSignal(bytesToMb(memInfo.renderableMemUsed));
          setMemUsedSignal(bytesToMb(memInfo.memUsed));
          setRenderableTexturesLoadedSignal(memInfo.renderableTexturesLoaded);
          setLoadedTexturesSignal(memInfo.loadedTextures);
        }
        var frameCount = 0;
        function setupFPS(root) {
          root.renderer.on("fpsUpdate", function (target, fpsData) {
            var fps2 = typeof fpsData === "number" ? fpsData : fpsData.fps;
            if (fps2 > 5) {
              calcFps(fps2);
              if (frameCount % 10 === 0) {
                updateMemoryInfo(target.stage);
                frameCount = 0;
              }
              frameCount++;
            }
          });
        }
        var FPSCounter = function FPSCounter(props) {
          return function () {
            var _el$ = createElement("view"),
              _el$2 = createElement("view"),
              _el$3 = createElement("text"),
              _el$5 = createElement("text"),
              _el$6 = createElement("view"),
              _el$7 = createElement("text"),
              _el$9 = createElement("text"),
              _el$0 = createElement("view"),
              _el$1 = createElement("text"),
              _el$11 = createElement("text"),
              _el$12 = createElement("view"),
              _el$13 = createElement("text"),
              _el$15 = createElement("text"),
              _el$16 = createElement("view"),
              _el$17 = createElement("view"),
              _el$18 = createElement("text"),
              _el$20 = createElement("text"),
              _el$21 = createElement("view"),
              _el$22 = createElement("text"),
              _el$24 = createElement("text"),
              _el$25 = createElement("view"),
              _el$26 = createElement("text"),
              _el$28 = createElement("text"),
              _el$29 = createElement("view"),
              _el$30 = createElement("text"),
              _el$32 = createElement("text"),
              _el$33 = createElement("view"),
              _el$34 = createElement("text"),
              _el$36 = createElement("text"),
              _el$37 = createElement("view"),
              _el$38 = createElement("text"),
              _el$40 = createElement("text");
            insertNode(_el$, _el$2);
            insertNode(_el$, _el$6);
            insertNode(_el$, _el$0);
            insertNode(_el$, _el$12);
            insertNode(_el$, _el$16);
            spread(_el$, mergeProps(props, {
              "style": fpsStyle
            }), true);
            insertNode(_el$2, _el$3);
            insertNode(_el$2, _el$5);
            setProp(_el$2, "y", 6);
            insertNode(_el$3, createTextNode("FPS:"));
            setProp(_el$3, "style", fpsLabel);
            setProp(_el$5, "style", fpsValue);
            setProp(_el$5, "x", 90);
            insert(_el$5, function () {
              return fps().toString();
            });
            insertNode(_el$6, _el$7);
            insertNode(_el$6, _el$9);
            setProp(_el$6, "y", 6);
            setProp(_el$6, "x", 160);
            insertNode(_el$7, createTextNode("AVG:"));
            setProp(_el$7, "style", fpsLabel);
            setProp(_el$9, "style", fpsValue);
            setProp(_el$9, "x", 100);
            insert(_el$9, function () {
              return avgFps().toString();
            });
            insertNode(_el$0, _el$1);
            insertNode(_el$0, _el$11);
            setProp(_el$0, "x", 0);
            setProp(_el$0, "y", 26);
            insertNode(_el$1, createTextNode("MIN:"));
            setProp(_el$1, "style", fpsLabel);
            setProp(_el$11, "style", fpsValue);
            setProp(_el$11, "x", 90);
            insert(_el$11, function () {
              return minFps().toString();
            });
            insertNode(_el$12, _el$13);
            insertNode(_el$12, _el$15);
            setProp(_el$12, "x", 160);
            setProp(_el$12, "y", 26);
            insertNode(_el$13, createTextNode("MAX:"));
            setProp(_el$13, "style", fpsLabel);
            setProp(_el$15, "style", fpsValue);
            setProp(_el$15, "x", 100);
            insert(_el$15, function () {
              return maxFps().toString();
            });
            insertNode(_el$16, _el$17);
            insertNode(_el$16, _el$21);
            insertNode(_el$16, _el$25);
            insertNode(_el$16, _el$29);
            insertNode(_el$16, _el$33);
            insertNode(_el$16, _el$37);
            setProp(_el$16, "display", "flex");
            setProp(_el$16, "flexDirection", "column");
            setProp(_el$16, "y", 58);
            setProp(_el$16, "gap", 4);
            insertNode(_el$17, _el$18);
            insertNode(_el$17, _el$20);
            setProp(_el$17, "height", infoFontSize);
            insertNode(_el$18, createTextNode("criticalThreshold:"));
            setProp(_el$18, "fontSize", infoFontSize);
            setProp(_el$18, "style", fpsLabel);
            setProp(_el$20, "fontSize", infoFontSize);
            setProp(_el$20, "style", fpsLabel);
            setProp(_el$20, "x", 230);
            insert(_el$20, criticalThresholdSignal);
            insertNode(_el$21, _el$22);
            insertNode(_el$21, _el$24);
            setProp(_el$21, "height", infoFontSize);
            insertNode(_el$22, createTextNode("targetThreshold:"));
            setProp(_el$22, "fontSize", infoFontSize);
            setProp(_el$22, "style", fpsLabel);
            setProp(_el$24, "fontSize", infoFontSize);
            setProp(_el$24, "style", fpsLabel);
            setProp(_el$24, "x", 230);
            insert(_el$24, targetThresholdSignal);
            insertNode(_el$25, _el$26);
            insertNode(_el$25, _el$28);
            setProp(_el$25, "height", infoFontSize);
            insertNode(_el$26, createTextNode("renderableMemUsed:"));
            setProp(_el$26, "fontSize", infoFontSize);
            setProp(_el$26, "style", fpsLabel);
            setProp(_el$28, "fontSize", infoFontSize);
            setProp(_el$28, "style", fpsLabel);
            setProp(_el$28, "x", 230);
            insert(_el$28, renderableMemUsedSignal);
            insertNode(_el$29, _el$30);
            insertNode(_el$29, _el$32);
            setProp(_el$29, "height", infoFontSize);
            insertNode(_el$30, createTextNode("memUsed:"));
            setProp(_el$30, "fontSize", infoFontSize);
            setProp(_el$30, "style", fpsLabel);
            setProp(_el$32, "fontSize", infoFontSize);
            setProp(_el$32, "style", fpsLabel);
            setProp(_el$32, "x", 230);
            insert(_el$32, memUsedSignal);
            insertNode(_el$33, _el$34);
            insertNode(_el$33, _el$36);
            setProp(_el$33, "height", infoFontSize);
            insertNode(_el$34, createTextNode("renderableTexturesLoaded:"));
            setProp(_el$34, "fontSize", infoFontSize);
            setProp(_el$34, "style", fpsLabel);
            setProp(_el$36, "fontSize", infoFontSize);
            setProp(_el$36, "style", fpsLabel);
            setProp(_el$36, "x", 230);
            insert(_el$36, function () {
              return renderableTexturesLoadedSignal().toString();
            });
            insertNode(_el$37, _el$38);
            insertNode(_el$37, _el$40);
            setProp(_el$37, "height", infoFontSize);
            insertNode(_el$38, createTextNode("loadedTextures:"));
            setProp(_el$38, "fontSize", infoFontSize);
            setProp(_el$38, "style", fpsLabel);
            setProp(_el$40, "fontSize", infoFontSize);
            setProp(_el$40, "style", fpsLabel);
            setProp(_el$40, "x", 230);
            insert(_el$40, function () {
              return loadedTexturesSignal().toString();
            });
            return _el$;
          }();
        };
        var SAFETY_MARGIN = 10;
        function MarqueeText(props) {
          var speed = createMemo(function () {
            return props.speed || 200;
          });
          var delay = createMemo(function () {
            var _props$delay2;
            return (_props$delay2 = props.delay) !== null && _props$delay2 !== void 0 ? _props$delay2 : 1e3;
          });
          var scrollGap = createMemo(function () {
            var _props$scrollGap;
            return (_props$scrollGap = props.scrollGap) !== null && _props$scrollGap !== void 0 ? _props$scrollGap : props.clipWidth * 0.5;
          });
          var _createSignal53 = createSignal(0),
            _createSignal54 = _slicedToArray(_createSignal53, 2),
            textWidth = _createSignal54[0],
            setTextWidth = _createSignal54[1];
          var isTextOverflowing = createMemo(function () {
            return textWidth() > props.clipWidth - SAFETY_MARGIN;
          });
          var shouldScroll = createMemo(function () {
            return props.marquee && isTextOverflowing();
          });
          var wasFocusedBefore = createMemo(function (p) {
            return p || props.marquee;
          }, false);
          createEffect(function () {
            if (shouldScroll()) {
              var options = {
                duration: (textWidth() + scrollGap()) / speed() * 1e3,
                delay: delay(),
                loop: true,
                easing: props.easing
              };
              text1.lng.x = 0;
              text2.lng.x = textWidth() + scrollGap();
              var a1 = text1.lng.animate({
                x: -textWidth() - scrollGap()
              }, options).start();
              var a2 = text2.lng.animate({
                x: 0
              }, options).start();
              onCleanup(function () {
                a1.stop();
                a2.stop();
              });
            }
          });
          var events = {
            loaded: function loaded(el) {
              setTextWidth(el.width);
            }
          };
          var text1;
          var text2;
          return [memo(function () {
            return memo(function () {
              return !!wasFocusedBefore();
            })() && [function () {
              var _el$2 = createElement("text");
              var _ref$ = text1;
              typeof _ref$ === "function" ? use(_ref$, _el$2) : text1 = _el$2;
              spread(_el$2, mergeProps(props, {
                get hidden() {
                  return !shouldScroll();
                },
                "rtt": true,
                "maxLines": 1,
                "onEvent": events
              }), false);
              return _el$2;
            }(), function () {
              var _el$3 = createElement("text");
              var _ref$2 = text2;
              typeof _ref$2 === "function" ? use(_ref$2, _el$3) : text2 = _el$3;
              spread(_el$3, mergeProps(props, {
                get hidden() {
                  return !shouldScroll();
                },
                "rtt": true,
                "maxLines": 1
              }), false);
              return _el$3;
            }()];
          }), function () {
            var _el$ = createElement("text");
            spread(_el$, mergeProps(props, {
              "maxLines": 1,
              get hidden() {
                return shouldScroll();
              },
              "contain": "width"
            }), false);
            return _el$;
          }()];
        }
        function Marquee(props) {
          var _createSignal55 = createSignal(props.width || 0),
            _createSignal56 = _slicedToArray(_createSignal55, 2),
            clipWidth = _createSignal56[0],
            setClipWidth = _createSignal56[1];
          var clipHeight = createMemo(function () {
            var _props$textProps, _props$textProps2;
            return props.height || ((_props$textProps = props.textProps) === null || _props$textProps === void 0 ? void 0 : _props$textProps.lineHeight) || (((_props$textProps2 = props.textProps) === null || _props$textProps2 === void 0 ? void 0 : _props$textProps2.fontSize) || 16) * 1.5;
          });
          return function () {
            var _el$4 = createElement("view");
            spread(_el$4, mergeProps(props, {
              get height() {
                return clipHeight();
              },
              "onLayout": chainFunctions(props.onLayout, function (e) {
                return setClipWidth(e.width);
              }),
              get clipping() {
                return props.marquee;
              }
            }), true);
            insert(_el$4, createComponent(MarqueeText, mergeProps(function () {
              return props.textProps;
            }, {
              get marquee() {
                return props.marquee;
              },
              get clipWidth() {
                return clipWidth();
              },
              get speed() {
                return props.speed;
              },
              get delay() {
                return props.delay;
              },
              get scrollGap() {
                return props.scrollGap;
              },
              get easing() {
                return props.easing;
              },
              get children() {
                return props.children;
              }
            })));
            return _el$4;
          }();
        }
        var FocusStackContext = createContext(void 0);
        function FocusStackProvider(props) {
          var _createSignal57 = createSignal([]),
            _createSignal58 = _slicedToArray(_createSignal57, 2),
            _focusStack = _createSignal58[0],
            setFocusStack = _createSignal58[1];
          function storeFocus(element, prevElement) {
            var elm = prevElement || element;
            if (elm) {
              setFocusStack(function (stack) {
                return [].concat(_toConsumableArray(stack), [elm]);
              });
            }
          }
          function restoreFocus() {
            var wasFocused = false;
            setFocusStack(function (stack) {
              var prevElement = stack.pop();
              if (prevElement && typeof prevElement.setFocus === "function") {
                prevElement.setFocus();
                wasFocused = true;
              }
              return _toConsumableArray(stack);
            });
            return wasFocused;
          }
          function clearFocusStack() {
            setFocusStack([]);
          }
          return createComponent(FocusStackContext.Provider, {
            value: {
              storeFocus: storeFocus,
              restoreFocus: restoreFocus,
              clearFocusStack: clearFocusStack
            },
            get children() {
              return props.children;
            }
          });
        }
        function useFocusStack() {
          var autoClear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var context = useContext(FocusStackContext);
          if (!context) {
            throw new Error("useFocusStack must be used within a FocusStackProvider");
          }
          if (autoClear) {
            onCleanup(function () {
              setTimeout(function () {
                return context.clearFocusStack();
              }, 5);
            });
          }
          return context;
        }
        var keepAliveElements = /* @__PURE__ */new Map();
        var storeKeepAlive = function storeKeepAlive(element) {
          if (keepAliveElements.has(element.id)) {
            console.warn("[KeepAlive] Element with id \"".concat(element.id, "\" already in cache. Recreating."));
            return element;
          }
          keepAliveElements.set(element.id, element);
          return element;
        };
        function wrapChildren(props) {
          var onRemove = props.onRemove || function (elm) {
            elm.alpha = 0;
          };
          var onRender = props.onRender || function (elm) {
            elm.alpha = 1;
          };
          var transition = props.transition || {
            alpha: true
          };
          return function () {
            var _el$ = createElement("view");
            setProp(_el$, "preserve", true);
            setProp(_el$, "onRemove", onRemove);
            setProp(_el$, "onRender", onRender);
            setProp(_el$, "forwardFocus", 0);
            setProp(_el$, "transition", transition);
            spread(_el$, props, false);
            return _el$;
          }();
        }
        var KeepAlive = function KeepAlive(props) {
          var _props$shouldDispose;
          var existing = keepAliveElements.get(props.id);
          if (existing && (_props$shouldDispose = props.shouldDispose) !== null && _props$shouldDispose !== void 0 && _props$shouldDispose.call(props, props.id)) {
            existing.dispose();
            keepAliveElements.delete(props.id);
            existing = void 0;
          }
          if (!existing) {
            return createRoot(function (dispose) {
              var children = wrapChildren(props);
              storeKeepAlive({
                id: props.id,
                owner: getOwner(),
                children: children,
                dispose: dispose
              });
              return children;
            });
          } else if (existing && !existing.children) {
            existing.children = runWithOwner(existing.owner, function () {
              return wrapChildren(props);
            });
          }
          return existing.children;
        };
        var KeepAliveRoute = function KeepAliveRoute(props) {
          var key = props.id || props.path;
          var preload = props.preload ? function (preloadProps) {
            var _props$shouldDispose2;
            var existing = keepAliveElements.get(key);
            if (existing && (_props$shouldDispose2 = props.shouldDispose) !== null && _props$shouldDispose2 !== void 0 && _props$shouldDispose2.call(props, key)) {
              existing.dispose();
              keepAliveElements.delete(key);
              existing = void 0;
            }
            if (!existing) {
              return createRoot(function (dispose) {
                storeKeepAlive({
                  id: key,
                  owner: getOwner(),
                  dispose: dispose,
                  children: null
                });
                return props.preload(preloadProps);
              });
            } else if (existing.children) {
              var _existing$children;
              (_existing$children = existing.children) === null || _existing$children === void 0 || _existing$children.setFocus();
            }
          } : void 0;
          return createComponent(Route, mergeProps(props, {
            preload: preload,
            component: function component(childProps) {
              return createComponent(KeepAlive, {
                id: key,
                get onRemove() {
                  return props.onRemove;
                },
                get onRender() {
                  return props.onRender;
                },
                get transition() {
                  return props.transition;
                },
                get children() {
                  return props.component(childProps);
                }
              });
            }
          }));
        };
        function disposeList(list) {
          for (var i = 0; i < list.length; i++) {
            var _list$i;
            (_list$i = list[i]) === null || _list$i === void 0 || _list$i.disposer();
          }
        }
        /**
         * Reactively transforms an array with a callback function - underlying helper for the `<List>` unkeyed control flow.
         *
         * Alternative to `mapArray` or `indexArray` that provides reactive value and index for array elements.
         */
        function listArray(list, mapFn) {
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
          var items = [];
          var mapped = [],
            unusedItems,
            i,
            j,
            item,
            oldValue,
            oldIndex,
            newValue,
            fallback,
            fallbackDisposer;
          onCleanup(function () {
            var _fallbackDisposer;
            (_fallbackDisposer = fallbackDisposer) === null || _fallbackDisposer === void 0 || _fallbackDisposer();
            fallbackDisposer = undefined;
            disposeList(items);
          });
          return function () {
            var newItems = list() || [];
            newItems[$TRACK]; // top level tracking
            return untrack(function () {
              if (newItems.length > 0 && fallbackDisposer) {
                fallbackDisposer();
                fallbackDisposer = undefined;
                fallback = undefined;
              }
              var temp = new Array(newItems.length); // new mapped array
              unusedItems = items.length;
              // 1) no change when values & indexes match
              for (j = unusedItems - 1; j >= 0; --j) {
                item = items[j];
                oldIndex = item.index;
                if (oldIndex < newItems.length && newItems[oldIndex] === item.value) {
                  temp[oldIndex] = mapped[oldIndex];
                  if (--unusedItems !== j) {
                    items[j] = items[unusedItems];
                    items[unusedItems] = item;
                  }
                }
              }
              // #2 prepare values matcher
              var matcher = new Map();
              var matchedItems = new Uint8Array(unusedItems);
              for (j = unusedItems - 1; j >= 0; --j) {
                var _matcher$get$push, _matcher$get;
                oldValue = items[j].value;
                (_matcher$get$push = (_matcher$get = matcher.get(oldValue)) === null || _matcher$get === void 0 ? void 0 : _matcher$get.push(j)) !== null && _matcher$get$push !== void 0 ? _matcher$get$push : matcher.set(oldValue, [j]);
              }
              // 2) change indexes when values match
              for (i = 0; i < newItems.length; ++i) {
                var _matcher$get$pop, _matcher$get2;
                if (i in temp) continue;
                newValue = newItems[i];
                j = (_matcher$get$pop = (_matcher$get2 = matcher.get(newValue)) === null || _matcher$get2 === void 0 ? void 0 : _matcher$get2.pop()) !== null && _matcher$get$pop !== void 0 ? _matcher$get$pop : -1;
                if (j >= 0) {
                  var _item$indexSetter, _item;
                  item = items[j];
                  oldIndex = item.index;
                  temp[i] = mapped[oldIndex];
                  item.index = i;
                  (_item$indexSetter = (_item = item).indexSetter) === null || _item$indexSetter === void 0 || _item$indexSetter.call(_item, i);
                  matchedItems[j] = 1;
                }
              }
              // #2 reduce unusedItems for matched items
              for (j = matchedItems.length - 1; j >= 0; --j) {
                if (matchedItems[j] && --unusedItems !== j) {
                  item = items[j];
                  items[j] = items[unusedItems];
                  items[unusedItems] = item;
                }
              }
              // 3) change values when indexes match
              for (j = unusedItems - 1; j >= 0; --j) {
                item = items[j];
                oldIndex = item.index;
                if (!(oldIndex in temp) && oldIndex < newItems.length) {
                  var _item$valueSetter, _item2;
                  temp[oldIndex] = mapped[oldIndex];
                  newValue = newItems[oldIndex];
                  item.value = newValue;
                  (_item$valueSetter = (_item2 = item).valueSetter) === null || _item$valueSetter === void 0 || _item$valueSetter.call(_item2, newValueGetter);
                  if (--unusedItems !== j) {
                    items[j] = items[unusedItems];
                    items[unusedItems] = item;
                  }
                }
              }
              // 4) change value & index when none matched
              // 5) create new if no unused items left
              for (i = 0; i < newItems.length; ++i) {
                if (i in temp) continue;
                newValue = newItems[i];
                if (unusedItems > 0) {
                  item = items[--unusedItems];
                  temp[i] = mapped[item.index];
                  batch(changeBoth);
                } else {
                  temp[i] = createRoot(mapper);
                }
              }
              // 6) delete any old unused items left
              disposeList(items.splice(0, unusedItems));
              if (newItems.length === 0 && options.fallback) {
                if (!fallbackDisposer) {
                  fallback = [createRoot(function (d) {
                    fallbackDisposer = d;
                    return options.fallback();
                  })];
                }
                return fallback;
              }
              return mapped = temp;
            });
          };
          function newValueGetter() {
            return newValue;
          }
          function changeBoth() {
            var _item$indexSetter2, _item3, _item$valueSetter2, _item4;
            item.index = i;
            (_item$indexSetter2 = (_item3 = item).indexSetter) === null || _item$indexSetter2 === void 0 || _item$indexSetter2.call(_item3, i);
            item.value = newValue;
            (_item$valueSetter2 = (_item4 = item).valueSetter) === null || _item$valueSetter2 === void 0 || _item$valueSetter2.call(_item4, newValueGetter);
          }
          function mapper(disposer) {
            var t = {
              value: newValue,
              index: i,
              disposer: disposer
            };
            items.push(t);
            // signal created when used
            var _sV = function sV() {
                var _createSignal59 = createSignal(t.value);
                var _createSignal60 = _slicedToArray(_createSignal59, 2);
                _sV = _createSignal60[0];
                t.valueSetter = _createSignal60[1];
                return _sV();
              },
              _sI = function sI() {
                var _createSignal61 = createSignal(t.index);
                var _createSignal62 = _slicedToArray(_createSignal61, 2);
                _sI = _createSignal62[0];
                t.indexSetter = _createSignal62[1];
                return _sI();
              };
            return mapFn(function () {
              return _sV();
            }, function () {
              return _sI();
            });
          }
        }
        /**
         * Iteration over a list creating elements from its items.
         * It avoids recreating elements, instead reorders existing elements whenever possible and / or changes reactive value.
         *
         * To be used if you have a list with changing indexes and values.
         * ```typescript
         * <List each={items} fallback={<div>No items</div>}>
         *   {(item, index) => <div data-index={index()}>{item()}</div>}
         * </List>
         * ```
         */
        function List(props) {
          var fallback = "fallback" in props && {
            fallback: function fallback() {
              return props.fallback;
            }
          };
          return createMemo(listArray(function () {
            return props.each;
          }, props.children, fallback || undefined));
        }
        var columnScroll = withScrolling(false);
        var rowStyles = {
          display: "flex",
          flexWrap: "wrap",
          transition: {
            y: true
          }
        };
        function VirtualGrid(props) {
          var _props$selected;
          var bufferSize = function bufferSize() {
            var _props$buffer;
            return (_props$buffer = props.buffer) !== null && _props$buffer !== void 0 ? _props$buffer : 2;
          };
          var _createSignal63 = createSignal((_props$selected = props.selected) !== null && _props$selected !== void 0 ? _props$selected : 0),
            _createSignal64 = _slicedToArray(_createSignal63, 2),
            cursor = _createSignal64[0],
            setCursor = _createSignal64[1];
          var items = createMemo(function () {
            return props.each || [];
          });
          var itemsPerRow = function itemsPerRow() {
            return props.columns;
          };
          var numberOfRows = function numberOfRows() {
            var _props$rows;
            return (_props$rows = props.rows) !== null && _props$rows !== void 0 ? _props$rows : 1;
          };
          var totalVisibleItems = function totalVisibleItems() {
            return itemsPerRow() * numberOfRows();
          };
          var start = createMemo(function () {
            var perRow = itemsPerRow();
            var newRowIndex = Math.floor(cursor() / perRow);
            var rawStart = newRowIndex * perRow - bufferSize() * perRow;
            return Math.max(0, rawStart);
          });
          var end = createMemo(function () {
            var perRow = itemsPerRow();
            var newRowIndex = Math.floor(cursor() / perRow);
            var rawEnd = (newRowIndex + bufferSize()) * perRow + totalVisibleItems();
            return Math.min(items().length, rawEnd);
          });
          var _createSignal65 = createSignal(items().slice(start(), end())),
            _createSignal66 = _slicedToArray(_createSignal65, 2),
            slice = _createSignal66[0],
            setSlice = _createSignal66[1];
          var viewRef;
          function onVerticalNav(dir) {
            return function () {
              var perRow = itemsPerRow();
              var currentRowIndex = Math.floor(cursor() / perRow);
              var maxRows = Math.floor(items().length / perRow);
              if (currentRowIndex === 0 && dir === -1 || currentRowIndex === maxRows && dir === 1) return;
              var selected = this.selected || 0;
              var offset = dir * perRow;
              var newIndex = clamp(selected + offset, 0, items().length - 1);
              var lastIdx = selected;
              this.selected = newIndex;
              var active = this.children[this.selected];
              if (active instanceof ElementNode) {
                active.setFocus();
                chainedOnSelectedChanged.call(this, this.selected, this, active, lastIdx);
                return true;
              }
            };
          }
          var onUp = onVerticalNav(-1);
          var onDown = onVerticalNav(1);
          var onSelectedChanged = function onSelectedChanged(_idx, elm, active, _lastIdx) {
            var _this75 = this;
            var idx = _idx;
            var lastIdx = _lastIdx;
            var perRow = itemsPerRow();
            var newRowIndex = Math.floor(idx / perRow);
            var prevRowIndex = Math.floor((lastIdx || 0) / perRow);
            var prevStart = start();
            setCursor(prevStart + idx);
            if (newRowIndex === prevRowIndex) return;
            setSlice(items().slice(start(), end()));
            var idxCorrection = prevStart - start();
            if (lastIdx) lastIdx += idxCorrection;
            idx += idxCorrection;
            this.selected += idxCorrection;
            if (props.onEndReachedThreshold !== void 0 && cursor() >= items().length - props.onEndReachedThreshold) {
              var _props$onEndReached;
              (_props$onEndReached = props.onEndReached) === null || _props$onEndReached === void 0 || _props$onEndReached.call(props);
            }
            queueMicrotask(function () {
              var prevRowY = _this75.y + active.y;
              _this75.updateLayout();
              _this75.lng.y = prevRowY - active.y;
              columnScroll(idx, elm, active, lastIdx);
            });
          };
          var chainedOnSelectedChanged = chainFunctions(props.onSelectedChanged, onSelectedChanged);
          var cachedSelected;
          var updateSelected = function updateSelected(_ref43) {
            var _ref44 = _slicedToArray(_ref43, 2),
              selected = _ref44[0],
              _items = _ref44[1];
            if (!viewRef || selected == null) return;
            if (cachedSelected !== void 0) {
              selected = cachedSelected;
              cachedSelected = void 0;
            }
            if (selected >= items().length && props.onEndReached) {
              var _props$onEndReached2;
              (_props$onEndReached2 = props.onEndReached) === null || _props$onEndReached2 === void 0 || _props$onEndReached2.call(props);
              cachedSelected = selected;
              return;
            }
            var item = items()[selected];
            var active = viewRef.children.find(function (x) {
              return x.item === item;
            });
            var lastSelected = viewRef.selected;
            if (active instanceof ElementNode) {
              viewRef.selected = viewRef.children.indexOf(active);
              active.setFocus();
              chainedOnSelectedChanged.call(viewRef, viewRef.selected, viewRef, active, lastSelected);
            } else {
              setCursor(selected);
              setSlice(items().slice(start(), end()));
              queueMicrotask(function () {
                viewRef.updateLayout();
                active = viewRef.children.find(function (x) {
                  return x.item === item;
                });
                if (active instanceof ElementNode) {
                  viewRef.selected = viewRef.children.indexOf(active);
                  active.setFocus();
                  chainedOnSelectedChanged.call(viewRef, viewRef.selected, viewRef, active, lastSelected);
                }
              });
            }
          };
          var scrollToIndex = function scrollToIndex(index) {
            untrack(function () {
              return updateSelected([index]);
            });
          };
          createEffect(on([function () {
            return props.selected;
          }, items], updateSelected));
          createEffect(on(items, function () {
            if (!viewRef) return;
            if (cachedSelected !== void 0) {
              updateSelected([cachedSelected]);
              return;
            }
            setSlice(items().slice(start(), end()));
          }, {
            defer: true
          }));
          return function () {
            var _el$ = createElement("view");
            var _ref$ = chainRefs(function (el) {
              viewRef = el;
            }, props.ref);
            typeof _ref$ === "function" && use(_ref$, _el$);
            spread(_el$, mergeProps(props, {
              get scroll() {
                return props.scroll || "always";
              },
              get selected() {
                return props.selected || 0;
              },
              get cursor() {
                return cursor();
              },
              "onLeft": chainFunctions(props.onLeft, navigableHandleNavigation),
              "onRight": chainFunctions(props.onRight, navigableHandleNavigation),
              "onUp": chainFunctions(props.onUp, onUp),
              "onDown": chainFunctions(props.onDown, onDown),
              "forwardFocus": navigableForwardFocus,
              "onCreate": props.selected ? chainFunctions(props.onCreate, columnScroll) : props.onCreate,
              "scrollToIndex": scrollToIndex,
              "onSelectedChanged": chainedOnSelectedChanged,
              "style": combineStyles(props.style, rowStyles)
            }), true);
            insert(_el$, createComponent(List, {
              get each() {
                return slice();
              },
              get children() {
                return props.children;
              }
            }));
            return _el$;
          }();
        }
        function createVirtual(component, props, keyHandlers) {
          var _props$selected2;
          var isRow = component === Row;
          var axis = isRow ? "x" : "y";
          var _createSignal67 = createSignal((_props$selected2 = props.selected) !== null && _props$selected2 !== void 0 ? _props$selected2 : 0),
            _createSignal68 = _slicedToArray(_createSignal67, 2),
            cursor = _createSignal68[0],
            setCursor = _createSignal68[1];
          var bufferSize = createMemo(function () {
            return props.bufferSize || 2;
          });
          var scrollIndex = createMemo(function () {
            return props.scrollIndex || 0;
          });
          var items = createMemo(function () {
            return props.each || [];
          });
          var itemCount = createMemo(function () {
            return items().length;
          });
          var scrollType = createMemo(function () {
            return props.scroll || "auto";
          });
          var selected = function selected() {
            if (props.wrap) {
              return Math.max(bufferSize(), scrollIndex());
            }
            return props.selected || 0;
          };
          var cachedScaledSize;
          var targetPosition;
          var cachedAnimationController;
          var uniformSize = createMemo(function () {
            return props.uniformSize !== false;
          });
          var _createSignal69 = createSignal({
              start: 0,
              slice: [],
              selected: 0,
              delta: 0,
              shiftBy: 0,
              atStart: true
            }),
            _createSignal70 = _slicedToArray(_createSignal69, 2),
            slice = _createSignal70[0],
            setSlice = _createSignal70[1];
          function normalizeDeltaForWindow(delta, windowLen) {
            if (!windowLen) return 0;
            var half = windowLen / 2;
            if (delta > half) return delta - windowLen;
            if (delta < -half) return delta + windowLen;
            return delta;
          }
          function computeSize() {
            var selected2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            if (uniformSize() && cachedScaledSize) {
              return cachedScaledSize;
            } else if (viewRef) {
              var gap = viewRef.gap || 0;
              var dimension = isRow ? "width" : "height";
              var prevSelectedChild = viewRef.children[selected2];
              if (prevSelectedChild instanceof ElementNode) {
                var _prevSelectedChild$st, _ref45, _focusStyle$scale;
                var itemSize = prevSelectedChild[dimension] || 0;
                var focusStyle = (_prevSelectedChild$st = prevSelectedChild.style) === null || _prevSelectedChild$st === void 0 ? void 0 : _prevSelectedChild$st.focus;
                var scale = (_ref45 = (_focusStyle$scale = focusStyle === null || focusStyle === void 0 ? void 0 : focusStyle.scale) !== null && _focusStyle$scale !== void 0 ? _focusStyle$scale : prevSelectedChild.scale) !== null && _ref45 !== void 0 ? _ref45 : 1;
                var scaledSize = itemSize * (props.factorScale ? scale : 1) + gap;
                cachedScaledSize = scaledSize;
                return scaledSize;
              }
            }
            return 0;
          }
          function computeSlice(c, delta, prev) {
            var total = itemCount();
            if (total === 0) return {
              start: 0,
              slice: [],
              selected: 0,
              delta: delta,
              shiftBy: 0,
              atStart: true
            };
            var length = props.displaySize + bufferSize();
            var start = prev.start;
            var selected2 = prev.selected;
            var atStart = prev.atStart;
            var shiftBy = -delta;
            switch (scrollType()) {
              case "always":
                if (props.wrap) {
                  start = mod(c - 1, total);
                  selected2 = 1;
                } else {
                  start = clamp(c - bufferSize(), 0, Math.max(0, total - props.displaySize - bufferSize()));
                  if (delta === 0 && c > 3) {
                    shiftBy = c < 3 ? -c : -2;
                    selected2 = 2;
                  } else {
                    selected2 = c < bufferSize() ? c : c >= total - props.displaySize ? c - (total - props.displaySize) + bufferSize() : bufferSize();
                  }
                }
                break;
              case "auto":
                if (props.wrap) {
                  if (delta === 0) {
                    selected2 = scrollIndex() || 1;
                    start = mod(c - (scrollIndex() || 1), total);
                  } else {
                    start = mod(c - (prev.selected || 1), total);
                  }
                } else {
                  if (delta < 0) {
                    if (prev.start > 0 && prev.selected >= props.displaySize) {
                      start = prev.start;
                      selected2 = prev.selected - 1;
                    } else if (prev.start > 0) {
                      start = prev.start - 1;
                      selected2 = prev.selected;
                    } else if (prev.start === 0 && !prev.atStart) {
                      start = 0;
                      selected2 = prev.selected - 1;
                      atStart = true;
                    } else if (selected2 >= props.displaySize - 1) {
                      start = 0;
                      selected2 = prev.selected - 1;
                    } else {
                      start = 0;
                      selected2 = prev.selected - 1;
                      shiftBy = 0;
                    }
                  } else if (delta > 0) {
                    if (prev.selected < scrollIndex()) {
                      start = prev.start;
                      selected2 = prev.selected + 1;
                      shiftBy = 0;
                    } else if (prev.selected === scrollIndex() || atStart) {
                      start = prev.start;
                      selected2 = prev.selected + 1;
                      atStart = false;
                    } else if (prev.start === 0 && prev.selected === 0) {
                      start = 0;
                      selected2 = 1;
                      atStart = false;
                    } else if (prev.start >= total - props.displaySize) {
                      start = prev.start;
                      selected2 = c - start;
                      shiftBy = 0;
                    } else {
                      start = prev.start + 1;
                      selected2 = Math.max(prev.selected, scrollIndex() + 1);
                    }
                  } else {
                    if (c > 0) {
                      start = Math.min(c - (scrollIndex() || 1), total - props.displaySize - bufferSize());
                      selected2 = Math.max(scrollIndex() || 1, c - start);
                      shiftBy = total - c < 3 ? c - total : -1;
                      atStart = false;
                    } else {
                      start = prev.start;
                      selected2 = prev.selected;
                    }
                  }
                }
                break;
              case "edge":
                var startScrolling = Math.max(1, props.displaySize + (atStart ? -1 : 0));
                if (props.wrap) {
                  if (delta > 0) {
                    if (prev.selected < startScrolling) {
                      selected2 = prev.selected + 1;
                      shiftBy = 0;
                    } else if (prev.selected === startScrolling && atStart) {
                      selected2 = prev.selected + 1;
                      atStart = false;
                    } else {
                      start = mod(prev.start + 1, total);
                      selected2 = prev.selected;
                    }
                  } else if (delta < 0) {
                    if (prev.selected > 1) {
                      selected2 = prev.selected - 1;
                      shiftBy = 0;
                    } else {
                      start = mod(prev.start - 1, total);
                      selected2 = 1;
                    }
                  } else {
                    start = mod(c - 1, total);
                    selected2 = 1;
                    shiftBy = -1;
                    atStart = false;
                  }
                } else {
                  if (delta === 0 && c > 0) {
                    selected2 = c > startScrolling ? startScrolling : c;
                    start = Math.max(0, c - startScrolling + 1);
                    shiftBy = c > startScrolling ? -1 : 0;
                    atStart = c < startScrolling;
                  } else if (delta > 0) {
                    if (prev.selected < startScrolling) {
                      selected2 = prev.selected + 1;
                      shiftBy = 0;
                    } else if (prev.selected === startScrolling && atStart) {
                      selected2 = prev.selected + 1;
                      atStart = false;
                    } else {
                      start = prev.start + 1;
                      selected2 = prev.selected;
                      atStart = false;
                    }
                  } else if (delta < 0) {
                    if (prev.selected > 1) {
                      selected2 = prev.selected - 1;
                      shiftBy = 0;
                    } else if (c > 1) {
                      start = Math.max(0, c - 1);
                      selected2 = 1;
                    } else if (c === 1) {
                      start = 0;
                      selected2 = 1;
                    } else {
                      start = 0;
                      selected2 = 0;
                      shiftBy = atStart ? 0 : shiftBy;
                      atStart = true;
                    }
                  }
                }
                break;
              case "none":
              default:
                start = 0;
                selected2 = c;
                shiftBy = 0;
                break;
            }
            var newSlice = prev.slice;
            if (start !== prev.start || newSlice.length === 0) {
              newSlice = props.wrap ? Array.from({
                length: length
              }, function (_, i) {
                return items()[mod(start + i, total)];
              }) : items().slice(start, start + length);
            }
            var state = {
              start: start,
              slice: newSlice,
              selected: selected2,
              delta: delta,
              shiftBy: shiftBy,
              atStart: atStart
            };
            if (props.debugInfo) {
              console.log("[Virtual]", {
                cursor: c,
                delta: delta,
                start: start,
                selected: selected2,
                shiftBy: shiftBy,
                slice: state.slice
              });
            }
            return state;
          }
          var viewRef;
          function scrollToIndex(index) {
            untrack(function () {
              if (itemCount() === 0) return;
              lastNavTime = performance.now();
              if (originalPosition !== void 0) {
                viewRef.lng[axis] = originalPosition;
                targetPosition = originalPosition;
              }
              updateSelected([clamp(index, 0, itemCount() - 1)]);
            });
          }
          var lastNavTime = 0;
          function getAdaptiveDuration() {
            var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
            var now = performance.now();
            var delta = now - lastNavTime;
            lastNavTime = now;
            if (delta < duration) return delta;
            return duration;
          }
          var originalPosition;
          var onSelectedChanged = function onSelectedChanged(_idx, elm, _active, _lastIdx) {
            var _elm$children$length,
              _elm$children,
              _this76 = this;
            var idx = _idx;
            var lastIdx = _lastIdx || 0;
            var active = _active;
            var noChange = idx === lastIdx;
            var total = itemCount();
            originalPosition = originalPosition !== null && originalPosition !== void 0 ? originalPosition : elm[axis];
            if (props.onSelectedChanged) {
              props.onSelectedChanged.call(this, idx, this, active, lastIdx);
            }
            if (noChange) return;
            var rawDelta = idx - (lastIdx !== null && lastIdx !== void 0 ? lastIdx : 0);
            var windowLen = (_elm$children$length = elm === null || elm === void 0 || (_elm$children = elm.children) === null || _elm$children === void 0 ? void 0 : _elm$children.length) !== null && _elm$children$length !== void 0 ? _elm$children$length : props.displaySize + bufferSize();
            var delta = props.wrap ? normalizeDeltaForWindow(rawDelta, windowLen) : rawDelta;
            setCursor(function (c) {
              var next = c + delta;
              return props.wrap ? mod(next, total) : clamp(next, 0, total - 1);
            });
            var newState = computeSlice(cursor(), delta, slice());
            setSlice(newState);
            elm.selected = newState.selected;
            if (props.onEndReachedThreshold !== void 0 && cursor() >= itemCount() - props.onEndReachedThreshold) {
              var _props$onEndReached3;
              (_props$onEndReached3 = props.onEndReached) === null || _props$onEndReached3 === void 0 || _props$onEndReached3.call(props);
            }
            if (newState.shiftBy === 0) return;
            var prevChildPos = (targetPosition !== null && targetPosition !== void 0 ? targetPosition : this[axis]) + active[axis];
            queueMicrotask(function () {
              elm.updateLayout();
              var childSize = computeSize(slice().selected);
              if (cachedAnimationController && cachedAnimationController.state === "running") {
                cachedAnimationController.stop();
              }
              if (Config.animationsEnabled) {
                var _this76$animationSett;
                _this76.lng[axis] = prevChildPos - active[axis];
                var offset = _this76.lng[axis] + childSize * slice().shiftBy;
                targetPosition = offset;
                cachedAnimationController = _this76.animate(_defineProperty({}, axis, offset), _objectSpread(_objectSpread({}, _this76.animationSettings), {}, {
                  duration: getAdaptiveDuration((_this76$animationSett = _this76.animationSettings) === null || _this76$animationSett === void 0 ? void 0 : _this76$animationSett.duration)
                })).start();
              } else {
                _this76.lng[axis] = _this76.lng[axis] + childSize * slice().shiftBy;
              }
            });
          };
          var updateSelected = function updateSelected(_ref46) {
            var _ref47 = _slicedToArray(_ref46, 2),
              sel = _ref47[0],
              _items = _ref47[1];
            if (!viewRef || sel === void 0 || itemCount() === 0) return;
            var item = items()[sel];
            setCursor(sel);
            var newState = computeSlice(cursor(), 0, slice());
            setSlice(newState);
            queueMicrotask(function () {
              var _viewRef$children$act;
              viewRef.updateLayout();
              var activeIndex = viewRef.children.findIndex(function (x) {
                return x.item === item;
              });
              if (activeIndex === -1) return;
              viewRef.selected = activeIndex;
              (_viewRef$children$act = viewRef.children[activeIndex]) === null || _viewRef$children$act === void 0 || _viewRef$children$act.setFocus();
            });
          };
          var doOnce = false;
          createEffect(on([function () {
            return props.wrap;
          }, items], function () {
            if (!viewRef || itemCount() === 0 || !props.wrap || doOnce) return;
            doOnce = true;
            queueMicrotask(function () {
              var childSize = computeSize(slice().selected);
              viewRef.lng[axis] = (viewRef.lng[axis] || 0) + childSize * -1;
              originalPosition = viewRef.lng[axis];
              targetPosition = viewRef.lng[axis];
            });
          }));
          createEffect(on([function () {
            return props.selected;
          }, items], updateSelected));
          createEffect(on(items, function () {
            if (!viewRef || itemCount() === 0) return;
            if (cursor() >= itemCount()) {
              setCursor(itemCount() - 1);
            }
            var newState = computeSlice(cursor(), 0, slice());
            setSlice(newState);
            viewRef.selected = newState.selected;
          }));
          return function () {
            var _el$ = createElement("view");
            var _ref$ = chainRefs(function (el) {
              viewRef = el;
            }, props.ref);
            typeof _ref$ === "function" && use(_ref$, _el$);
            spread(_el$, mergeProps(props, keyHandlers, {
              get selected() {
                return selected();
              },
              get cursor() {
                return cursor();
              },
              "forwardFocus": navigableForwardFocus,
              "scrollToIndex": scrollToIndex,
              "onSelectedChanged": onSelectedChanged,
              "style": combineStyles(props.style, component === Row ? {
                display: "flex",
                gap: 30,
                transition: {
                  x: {
                    duration: 250,
                    easing: "ease-out"
                  }
                }
              } : {
                display: "flex",
                flexDirection: "column",
                gap: 30,
                transition: {
                  y: {
                    duration: 250,
                    easing: "ease-out"
                  }
                }
              })
            }), true);
            insert(_el$, createComponent(List, {
              get each() {
                return slice().slice;
              },
              get children() {
                return props.children;
              }
            }));
            return _el$;
          }();
        }
        function VirtualRow(props) {
          return createVirtual(Row, props, {
            onLeft: chainFunctions(props.onLeft, handleNavigation("left")),
            onRight: chainFunctions(props.onRight, handleNavigation("right"))
          });
        }
        function createSpriteMap(src, subTextures) {
          var spriteMapTexture = renderer$1.createTexture("ImageTexture", {
            src: src
          });
          return subTextures.reduce(function (acc, t) {
            var x = t.x,
              y = t.y,
              width = t.width,
              height = t.height;
            acc[t.name] = renderer$1.createTexture("SubTexture", {
              texture: spriteMapTexture,
              x: x,
              y: y,
              width: width,
              height: height
            });
            return acc;
          }, {});
        }
        var App = function App(props) {
          useFocusManager({
            Announcer: ["a"],
            Menu: ["m"],
            Escape: ["Escape", 27],
            Backspace: ["Backspace", 8],
            Back: ["b"],
            Left: ["ArrowLeft", 37],
            Right: ["ArrowRight", 39],
            Up: ["ArrowUp", 38],
            Down: ["ArrowDown", 40],
            Enter: ["Enter", 13]
          }, {
            userKeyHoldMap: {
              EnterHold: ["Enter", 13],
              BackHold: ["b", 66]
            },
            holdThreshold: 1e3
          });
          return props.children;
        };
        var theme = exports("t", {
          // === Primary Brand ===
          primary: 0x2C4F7CFF,
          // Solid Blue
          primaryLight: 0x4A7BD0FF,
          textPrimary: 0xE6E8EBFF,
          textSecondary: 0x7F848DFF,
          layout: {
            gutterX: 20,
            marginX: 150,
            screenW: 1920
          },
          typography: {
            display2: {
              fontFamily: "Arial",
              fontSize: 50,
              lineHeight: 60,
              fontWeight: 500,
              verticalAlign: "middle",
              textBaseline: "bottom"
            },
            body1: {
              fontFamily: "Arial",
              fontSize: 25,
              fontWeight: 300,
              lineHeight: 40,
              verticalAlign: "middle",
              textBaseline: "bottom"
            },
            body2: {
              fontFamily: "Arial",
              fontSize: 22,
              fontWeight: 300,
              lineHeight: 32,
              verticalAlign: "middle",
              textBaseline: "bottom"
            }
          },
          color: {
            materialBrand: 13311
          }
        });
        var params = new URLSearchParams(window.location.search);
        var roundPoster = params.get("roundPoster") !== "false";
        var styles$1 = exports("Q", {
          itemsContainer: {
            width: theme.layout.screenW,
            height: 800,
            y: 560,
            x: 0,
            zIndex: 2
          },
          Thumbnail: {
            width: 185,
            height: 278,
            scale: 1,
            zIndex: 2,
            transition: {
              scale: {
                duration: 250,
                easing: "linear"
              },
              border: {
                duration: 250,
                easing: "linear"
              }
            },
            borderRadius: roundPoster ? 16 : 0,
            border: {
              width: 0,
              color: 0
            },
            $focus: {
              scale: 1.1,
              border: {
                color: theme.primaryLight,
                width: 6
              }
            }
          },
          RowTitle: {
            height: 44,
            width: 300,
            marginBottom: -54,
            fontSize: 26,
            color: 0xF0F0F0FF,
            zIndex: 2
          },
          Row: {
            display: "flex",
            justifyContent: "spaceBetween",
            height: 300
          },
          Column: {
            display: "flex",
            flexDirection: "column",
            justifyContent: "flexStart",
            flexBoundary: "contain",
            gap: 64,
            width: theme.layout.screenW - 2 * theme.layout.marginX,
            x: theme.layout.marginX + theme.layout.gutterX,
            y: 48,
            transition: {
              y: {
                duration: 250,
                easing: "ease-in-out"
              }
            },
            zIndex: 2
          },
          peopleBio: _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
            fontFamily: "Roboto",
            fontWeight: "normal",
            contain: "both",
            width: 780,
            height: 340
          })
        });
        var Button$1 = {
          width: 300,
          height: 90,
          color: theme.primary,
          borderRadius: 12,
          $focus: {
            color: theme.primaryLight
          }
        };
        ({
          width: Button$1.width + 8
        });
        var ButtonText = {
          fontSize: 26,
          lineHeight: Button$1.height,
          contain: "width",
          textAlign: "center",
          height: Button$1.height,
          width: Button$1.width,
          color: theme.textPrimary
        };
        var buttonStyles = {
          container: Button$1,
          text: ButtonText
        };
        var MaterialButton = {
          width: 386,
          height: 136
        };
        var MaterialButtonText = exports("U", {
          fontSize: 32,
          contain: "width",
          textAlign: "center",
          mountY: -0.35,
          color: 0xFFFFFFFF,
          height: MaterialButton.height,
          width: MaterialButton.width,
          // lineHeight: MaterialButton.height, // TODO: Add back when lineHeight is supported
          $focus: {
            fontSize: 40
          },
          $disabled: {
            color: 0x909090FF
          }
        });
        function Thumbnail(props) {
          return createComponent(Image$1, mergeProps(props, {
            id: "thumbnail",
            get src() {
              return props.item.src;
            },
            placeholder: "./assets/fallback.png",
            get item() {
              return props.item;
            },
            get announce() {
              return [props.item.title, "PAUSE-1", props.item.overview];
            },
            get style() {
              return styles$1.Thumbnail;
            }
          }));
        }
        function TileRow(props) {
          return createComponent(Row, mergeProps(props, {
            get style() {
              return styles$1.Row;
            },
            get children() {
              return createComponent(Index, {
                get each() {
                  return props.items;
                },
                children: function children(item, index) {
                  return createComponent(Thumbnail, {
                    get item() {
                      return item();
                    },
                    get announceContext() {
                      return "".concat(index + 1, " of ").concat(props.items.length);
                    }
                  });
                }
              });
            }
          }));
        }
        function Button(props) {
          return createComponent(View, mergeProps(props, {
            get announce() {
              return [props.children, "button"];
            },
            forwardStates: true,
            get style() {
              return buttonStyles.container;
            },
            get children() {
              return createComponent(Text, {
                get style() {
                  return buttonStyles.text;
                },
                get children() {
                  return props.children || props.title;
                }
              });
            }
          }));
        }
        function AssetPanel(props) {
          var panelRef, actionRef;
          createEffect(function () {
            if (props.open) {
              panelRef.animate({
                x: 1470
              }, {
                duration: 400,
                easing: "ease-in-out"
              }).start();
              actionRef.setFocus();
            } else if (panelRef.rendered) {
              panelRef.animate({
                x: 1920
              }, {
                duration: 400,
                easing: "ease-in-out"
              }).start();
            }
          });
          return createComponent(View, mergeProps(props, {
            x: 1920,
            ref: function ref(r$) {
              var _ref$ = panelRef;
              typeof _ref$ === "function" ? _ref$(r$) : panelRef = r$;
            },
            color: 0x000000FF,
            width: 450,
            height: 1080,
            zIndex: 5,
            get children() {
              return [createComponent(Text, {
                x: 75,
                y: 50,
                fontSize: 32,
                get children() {
                  var _props$item;
                  return (_props$item = props.item) === null || _props$item === void 0 ? void 0 : _props$item.title;
                }
              }), createComponent(Column, {
                ref: function ref(r$) {
                  var _ref$2 = actionRef;
                  typeof _ref$2 === "function" ? _ref$2(r$) : actionRef = r$;
                },
                get onLeft() {
                  return props.close;
                },
                get onBack() {
                  return props.close;
                },
                x: 75,
                y: 200,
                get children() {
                  return [createComponent(Button, {
                    get onEnter() {
                      return props.close;
                    },
                    children: "Record"
                  }), createComponent(Button, {
                    get onEnter() {
                      return props.close;
                    },
                    children: "Watch"
                  }), createComponent(Button, {
                    get onEnter() {
                      return props.close;
                    },
                    children: "Close"
                  })];
                }
              })];
            }
          }));
        }
        var heroTransition = {
          duration: 300,
          easing: "cubic-bezier(0.20, 1.00, 0.80, 1.00)"
        };
        var titleRowStyles = {
          fontFamily: "Raleway",
          fontSize: 24,
          height: 32,
          lineHeight: 32
        };
        function TitleRow(props) {
          return createComponent(View, {
            get height() {
              return props.height;
            },
            forwardFocus: 1,
            marginTop: 30,
            get children() {
              return [createComponent(Text, {
                skipFocus: true,
                style: titleRowStyles,
                get children() {
                  return props.title;
                }
              }), createComponent(VirtualRow, {
                gap: 20,
                displaySize: 8,
                bufferSize: 3,
                get each() {
                  return props.items;
                },
                y: 50,
                get scroll() {
                  return props.scroll;
                },
                get wrap() {
                  return props.wrap;
                },
                debugInfo: true,
                children: function children(item, index) {
                  return createComponent(Dynamic, {
                    get component() {
                      return typeToComponent[props.row.type];
                    },
                    get index() {
                      return index();
                    },
                    get item() {
                      return item();
                    }
                  });
                }
              })];
            }
          });
        }
        var posterStyles = {
          width: 185,
          height: 278,
          scale: 1,
          zIndex: 2,
          color: 0xB0B0B0FF,
          //borderRadius: 8,
          transition: {
            scale: {
              duration: 200,
              easing: "linear"
            }
          },
          $focus: {
            scale: 1.1,
            color: 0xFFFFFFFF
          }
        };
        function Poster(props) {
          return createComponent(View, mergeProps({
            get src() {
              var _props$item2;
              return (_props$item2 = props.item) === null || _props$item2 === void 0 ? void 0 : _props$item2.src;
            },
            get title() {
              var _props$item3;
              return (_props$item3 = props.item) === null || _props$item3 === void 0 ? void 0 : _props$item3.shortTitle;
            },
            get backdrop() {
              var _props$item4;
              return (_props$item4 = props.item) === null || _props$item4 === void 0 ? void 0 : _props$item4.backdrop;
            }
          }, props, {
            onFail: function onFail(node) {
              return node.src = "failback.png";
            },
            style: posterStyles
          }));
        }
        var posterTitleStyles = {
          fontFamily: "Raleway",
          fontSize: 22,
          lineHeight: 22,
          height: 22,
          x: 10,
          y: 278,
          contain: "width",
          width: 185,
          maxLines: 2,
          alpha: 0,
          $focus: {
            alpha: 1,
            y: 288
          },
          transition: {
            y: heroTransition,
            alpha: heroTransition
          }
        };
        function PosterTitle(props) {
          return createComponent(View, mergeProps({
            get src() {
              var _props$item5;
              return (_props$item5 = props.item) === null || _props$item5 === void 0 ? void 0 : _props$item5.src;
            },
            get backdrop() {
              var _props$item6;
              return (_props$item6 = props.item) === null || _props$item6 === void 0 ? void 0 : _props$item6.backdrop;
            }
          }, props, {
            onFail: function onFail(node) {
              return node.src = "failback.png";
            },
            style: posterStyles,
            forwardStates: true,
            get children() {
              return createComponent(Text, {
                style: posterTitleStyles,
                get children() {
                  var _props$item7;
                  return (_props$item7 = props.item) === null || _props$item7 === void 0 ? void 0 : _props$item7.title;
                }
              });
            }
          }));
        }
        var heroStyles = {
          width: 1280,
          height: 720,
          scale: 1,
          zIndex: 2,
          colorTop: 0xFFFFFFFF,
          colorBottom: 0x000000FF,
          //borderRadius: 8,
          transition: {
            scale: heroTransition
          },
          $focus: {
            scale: 1.05
          }
        };
        var heroTextStyles = {
          fontFamily: "Raleway",
          contain: "width"
        };
        function Hero(props) {
          var _createSignal71 = createSignal(false),
            _createSignal72 = _slicedToArray(_createSignal71, 2),
            hasFocus = _createSignal72[0],
            setHasFocus = _createSignal72[1];
          return createComponent(View, mergeProps(props, {
            get src() {
              return props.item.backdrop;
            },
            style: heroStyles,
            onFocusChanged: setHasFocus,
            forwardStates: true,
            get children() {
              return createComponent(View, {
                transition: {
                  alpha: heroTransition
                },
                get alpha() {
                  return hasFocus() ? 1 : 0;
                },
                get children() {
                  return [createComponent(View, {
                    width: 185,
                    height: 278,
                    x: 54,
                    y: 220,
                    get src() {
                      return props.item.src;
                    }
                  }), createComponent(Text, {
                    y: 520,
                    x: 54,
                    fontSize: 64,
                    width: 1e3,
                    maxLines: 1,
                    style: heroTextStyles,
                    get children() {
                      return props.item.title;
                    }
                  }), createComponent(Text, {
                    y: 620,
                    x: 60,
                    fontSize: 21,
                    width: 1e3,
                    maxLines: 2,
                    lineHeight: 36,
                    color: 0xCCCCCCFF,
                    style: heroTextStyles,
                    get children() {
                      return props.item.overview;
                    }
                  })];
                }
              });
            }
          }));
        }
        var typeToComponent = {
          Poster: Poster,
          Hero: Hero,
          PosterTitle: PosterTitle
        };
        var BlockStyle = {
          alpha: 0.85,
          border: {
            width: 0,
            color: 0x000000FF
          },
          $focus: {
            border: {
              width: 4,
              color: 0xFFFFFFFF
            },
            alpha: 1
          }
        };
        function Block(props) {
          return createComponent(View, mergeProps(props, {
            width: 100,
            height: 100,
            style: BlockStyle,
            get color() {
              return props.color || 0xE0E0E0FF;
            }
          }));
        }
        var _createSignal73 = createSignal(""),
          _createSignal74 = _slicedToArray(_createSignal73, 2),
          globalBackground = _createSignal74[0],
          setGlobalBackground = _createSignal74[1];
        exports("s", setGlobalBackground);
        function createInfiniteScroll(fetcher) {
          var _createSignal75 = createSignal([]),
            _createSignal76 = _slicedToArray(_createSignal75, 2),
            pages = _createSignal76[0],
            setPages = _createSignal76[1];
          var _createSignal77 = createSignal(1),
            _createSignal78 = _slicedToArray(_createSignal77, 2),
            page = _createSignal78[0],
            setPage = _createSignal78[1];
          var _createSignal79 = createSignal(false),
            _createSignal80 = _slicedToArray(_createSignal79, 2),
            end = _createSignal80[0],
            setEnd = _createSignal80[1];
          var _createResource3 = createResource(page, fetcher),
            _createResource4 = _slicedToArray(_createResource3, 1),
            contents = _createResource4[0];
          createComputed(function () {
            var content = contents();
            if (!content) return;
            batch(function () {
              if (content.length === 0) setEnd(true);
              setPages(function (p) {
                return [].concat(_toConsumableArray(p), _toConsumableArray(content));
              });
            });
          });
          return {
            pages: pages,
            page: page,
            setPage: setPage,
            setPages: setPages,
            end: end,
            setEnd: setEnd
          };
        }
        var blockWidth = 900;
        var ContentBlockStyle = {
          display: "flex",
          flexDirection: "column",
          flexBoundary: "fixed",
          width: blockWidth,
          height: 220,
          gap: 16
        };
        var HeadlineStyles = _objectSpread(_objectSpread({}, theme.typography.display2), {}, {
          fontFamily: "Roboto",
          fontWeight: 700,
          maxLines: 1,
          width: blockWidth
        });
        var Headline = function Headline(props) {
          return createComponent(Marquee, mergeProps(props, {
            textProps: HeadlineStyles
          }));
        };
        var DescriptionStyles = _objectSpread(_objectSpread({}, theme.typography.body1), {}, {
          fontFamily: "Roboto",
          fontWeight: 400,
          lineHeight: 32,
          width: blockWidth,
          maxLines: 3,
          contain: "width"
        });
        var BadgeStyle = {
          fontSize: 16,
          lineHeight: 20,
          marginLeft: 13,
          marginRight: 13
        };
        var Description = function Description(props) {
          return createComponent(Text, mergeProps(props, {
            style: DescriptionStyles,
            get children() {
              return props.children;
            }
          }));
        };
        var Badge = function Badge(props) {
          return createComponent(View, mergeProps(props, {
            style: {
              color: "0x00000099",
              borderRadius: 8,
              border: {
                width: 2,
                color: "0xffffffff"
              },
              display: "flex",
              height: 36
            },
            get children() {
              return createComponent(Text, {
                lineHeight: 36,
                style: BadgeStyle,
                get children() {
                  return props.children;
                }
              });
            }
          }));
        };
        var MetaTextStyle = _objectSpread(_objectSpread({}, theme.typography.body2), {}, {
          fontFamily: "Roboto",
          fontWeight: 400
        });
        var Metadata = function Metadata(props) {
          return createComponent(View, {
            style: {
              display: "flex",
              flexDirection: "row",
              gap: 18,
              width: blockWidth,
              height: 48
            },
            get children() {
              return [createComponent(View, {
                y: -4,
                src: "./assets/stars.png",
                width: 188,
                height: 31
              }), createComponent(View, {
                y: -4,
                flexItem: false,
                clipping: true,
                get width() {
                  return 188 * props.voteAverage / 10;
                },
                height: 31,
                get children() {
                  return createComponent(View, {
                    src: "./assets/stars-full.png",
                    width: 188,
                    height: 31
                  });
                }
              }), createComponent(Text, {
                style: MetaTextStyle,
                get children() {
                  return [memo(function () {
                    return props.voteCount;
                  }), " reviews"];
                }
              }), createComponent(Text, {
                style: MetaTextStyle,
                get children() {
                  return props.metaText;
                }
              }), createComponent(For, {
                get each() {
                  return props.badges;
                },
                children: function children(item) {
                  return createComponent(Badge, {
                    y: -5,
                    children: item
                  });
                }
              })];
            }
          });
        };
        var ContentBlock = exports("x", function (props) {
          return createComponent(View, mergeProps({
            id: "contentBlock",
            style: ContentBlockStyle
          }, props, {
            get children() {
              return [createComponent(Headline, {
                get marquee() {
                  return props.marquee;
                },
                get children() {
                  return props.content.title;
                }
              }), createComponent(Description, {
                get children() {
                  return props.content.description;
                }
              }), createComponent(Show, {
                get when() {
                  return props.content.voteCount;
                },
                get children() {
                  return createComponent(Metadata, {
                    get metaText() {
                      return props.content.metaText;
                    },
                    get badges() {
                      return props.content.badges;
                    },
                    get voteCount() {
                      return props.content.voteCount;
                    },
                    get voteAverage() {
                      return props.content.voteAverage;
                    }
                  });
                }
              })];
            }
          }));
        });
        var Browse = function Browse(props) {
          usePreloadRoute();
          var _createSignal81 = createSignal({}),
            _createSignal82 = _slicedToArray(_createSignal81, 2),
            heroContent = _createSignal82[0],
            setHeroContent = _createSignal82[1];
          var navigate = useNavigate();
          var firstRun = true;
          var vgRef;
          onCleanup(function () {
            console.log("cleanup");
          });
          var provider = createMemo(function () {
            return createInfiniteScroll(props.data());
          });
          var delayedBackgrounds = debounce(function (img) {
            return setGlobalBackground(img);
          }, 800);
          var delayedHero = debounce(function (content) {
            return setHeroContent(content || {});
          }, 600);
          function updateContentBlock(_index, _col, elm) {
            if (!elm) return;
            var item = elm.item || {};
            if (firstRun) {
              if (item.backdrop) {
                setGlobalBackground(item.backdrop);
              }
              if (item.heroContent) {
                setHeroContent(item.heroContent);
              }
              firstRun = false;
              return;
            }
            if (item.href) ;
            if (item.backdrop) {
              delayedBackgrounds(item.backdrop);
            }
            if (item.heroContent) {
              delayedHero(item.heroContent);
            }
          }
          function onEndReached() {
            provider().setPage(function (p) {
              return p + 1;
            });
          }
          function onEnter() {
            var _entity$item;
            this.display = "flex";
            var entity = this.children.find(function (c) {
              return c.states.has("focus");
            });
            assertTruthy(entity && ((_entity$item = entity.item) === null || _entity$item === void 0 ? void 0 : _entity$item.href));
            navigate(entity.item.href);
            return true;
          }
          return createComponent(Show, {
            get when() {
              return provider().pages().length;
            },
            get children() {
              return [createComponent(ContentBlock, {
                y: 360,
                x: 162,
                get content() {
                  return heroContent();
                },
                forwardFocus: function forwardFocus() {
                  return vgRef.setFocus();
                }
              }), createComponent(View, {
                clipping: true,
                get style() {
                  return styles$1.itemsContainer;
                },
                get children() {
                  return createComponent(VirtualGrid, {
                    y: 24,
                    x: 160,
                    id: "BrowseGrid",
                    ref: function ref(r$) {
                      var _ref$ = vgRef;
                      typeof _ref$ === "function" ? _ref$(r$) : vgRef = r$;
                    },
                    scroll: "always",
                    get announce() {
                      return "All Trending ".concat(props.params.filter);
                    },
                    onEnter: onEnter,
                    columns: 7,
                    gap: 50,
                    rows: 2,
                    buffer: 2,
                    onSelectedChanged: updateContentBlock,
                    onEndReached: onEndReached,
                    onEndReachedThreshold: 18,
                    width: 1620,
                    autofocus: true,
                    get each() {
                      return provider().pages();
                    },
                    children: function children(item) {
                      return createComponent(Thumbnail, {
                        get item() {
                          return item();
                        }
                      });
                    }
                  });
                }
              })];
            }
          });
        };
        var TMDB = function TMDB(props) {
          var _createSignal83 = createSignal({}),
            _createSignal84 = _slicedToArray(_createSignal83, 2),
            heroContent = _createSignal84[0],
            setHeroContent = _createSignal84[1];
          var _createSignal85 = createSignal(false),
            _createSignal86 = _slicedToArray(_createSignal85, 2),
            openPanel = _createSignal86[0],
            setOpenPanel = _createSignal86[1];
          var _useFocusStack = useFocusStack(),
            storeFocus = _useFocusStack.storeFocus,
            restoreFocus = _useFocusStack.restoreFocus;
          var contentBlock,
            solidLogo,
            firstRun = true;
          var delayedBackgrounds = debounce(setGlobalBackground, 800);
          var delayedHero = debounce(function (content) {
            return setHeroContent(content || {});
          }, 600);
          createEffect(on(activeElement, function (elm) {
            if (!elm) return;
            var item = elm.item || {};
            if (firstRun) {
              item.backdrop && setGlobalBackground(item.backdrop);
              item.heroContent && setHeroContent(item.heroContent);
              firstRun = false;
            } else {
              item.backdrop && delayedBackgrounds(item.backdrop);
              item.heroContent && delayedHero(item.heroContent);
            }
          }, {
            defer: true
          }));
          function onRowChanged(selectedIndex, column, row, lastIndex) {
            if (selectedIndex === lastIndex) return;
            var values = selectedIndex === 0 ? {
              y: 300,
              alpha: 1
            } : {
              y: 200,
              alpha: 0
            };
            contentBlock.animate(values, {
              duration: 300,
              easing: "ease-in-out"
            }).start();
            var values2 = selectedIndex === 0 ? {
              y: 80,
              alpha: 1
            } : {
              y: 0,
              alpha: 0
            };
            solidLogo.animate(values2, {
              duration: 300,
              easing: "ease-in-out"
            }).start();
          }
          return createComponent(View, {
            forwardFocus: 2,
            get children() {
              return [createComponent(View, {
                ref: function ref(r$) {
                  var _ref$ = solidLogo;
                  typeof _ref$ === "function" ? _ref$(r$) : solidLogo = r$;
                },
                width: 300,
                height: 150,
                x: 162,
                y: 80,
                zIndex: 105,
                get children() {
                  return [createComponent(Text, {
                    x: 80,
                    fontSize: 28,
                    color: 4143380121,
                    children: "Built With:"
                  }), createComponent(View, {
                    y: 32,
                    src: "./assets/solidWord.png",
                    width: 280,
                    height: 52
                  }), createComponent(View, {
                    x: 0,
                    y: 110,
                    src: "./assets/tmdb.png",
                    width: 80,
                    height: 41
                  }), createComponent(Text, {
                    x: 90,
                    y: 110,
                    contain: "width",
                    width: 160,
                    fontSize: 12,
                    color: 4143380121,
                    children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
                  })];
                }
              }), createComponent(ContentBlock, {
                ref: function ref(r$) {
                  var _ref$2 = contentBlock;
                  typeof _ref$2 === "function" ? _ref$2(r$) : contentBlock = r$;
                },
                y: 300,
                x: 162,
                get content() {
                  return heroContent();
                }
              }), createComponent(LazyColumn, {
                y: 500,
                upCount: 3,
                get each() {
                  return props.data.rows;
                },
                id: "BrowseColumn",
                onSelectedChanged: onRowChanged,
                onEnter: function onEnter() {
                  return setOpenPanel(true);
                },
                get autofocus() {
                  return props.data.rows[0].items();
                },
                gap: 40,
                transition: {
                  y: {
                    duration: 300,
                    easing: "ease-in-out"
                  }
                },
                get style() {
                  return styles$1.Column;
                },
                children: function children(row) {
                  return row().type === "Hero" ? createComponent(VirtualRow, {
                    gap: 80,
                    displaySize: 3,
                    bufferSize: 1,
                    scroll: "center",
                    centerScroll: true,
                    get each() {
                      return row().items();
                    },
                    y: 50,
                    get height() {
                      return row().height;
                    },
                    children: function children(item) {
                      return createComponent(Hero, {
                        get item() {
                          return item();
                        }
                      });
                    }
                  }) : createComponent(TitleRow, {
                    get row() {
                      return row();
                    },
                    get title() {
                      return row().title;
                    },
                    get height() {
                      return row().height;
                    },
                    get items() {
                      return row().items();
                    }
                  });
                }
              }), createComponent(AssetPanel, {
                onFocus: storeFocus,
                close: function close() {
                  setOpenPanel(false);
                  restoreFocus();
                  return true;
                },
                get open() {
                  return openPanel();
                },
                get item() {
                  return heroContent();
                }
              })];
            }
          });
        };
        var Destroy = function Destroy(props) {
          var _createSignal87 = createSignal(),
            _createSignal88 = _slicedToArray(_createSignal87, 2),
            heroContent = _createSignal88[0],
            setHeroContent = _createSignal88[1];
          var _createSignal89 = createSignal(0),
            _createSignal90 = _slicedToArray(_createSignal89, 2),
            heroIndex = _createSignal90[0],
            setHeroIndex = _createSignal90[1];
          onMount(function () {
            return setGlobalBackground(0x333333FF);
          });
          createEffect(on([props.data.heroRow.items, heroIndex], function (_ref48) {
            var _ref49 = _slicedToArray(_ref48, 2),
              heros = _ref49[0],
              index = _ref49[1];
            if (heros) setHeroContent(heros[index]);
            if (heros && index < heros.length - 1) {
              var img = new Image();
              img.crossOrigin = "anonymous";
              img.src = heros[index + 1].backdrop;
            }
          }));
          function onDown() {
            if (heroIndex() >= 19) return false;
            setHeroIndex(function (p) {
              return p + 1;
            });
          }
          function onUp() {
            if (heroIndex() === 0) return false;
            setHeroIndex(function (p) {
              return p - 1;
            });
            return true;
          }
          function animateOut(node) {
            return node.animate({
              y: 200,
              alpha: 0
            }, {
              duration: 500,
              easing: "ease-in-out"
            }).start().waitUntilStopped();
          }
          function animateIn(node) {
            node.alpha = 0;
            node.y = -100;
            return node.animate({
              y: 0,
              alpha: 1
            }, {
              duration: 500,
              easing: "ease-in-out"
            }).start().waitUntilStopped();
          }
          return createComponent(View, {
            x: 300,
            y: 200,
            onDown: onDown,
            onUp: onUp,
            get children() {
              return [createComponent(View, {
                src: "assets/up.svg",
                width: 350,
                height: 200,
                x: 450,
                y: -200,
                get rotation() {
                  return Math.PI;
                }
              }), createComponent(Show, {
                get when() {
                  return heroContent();
                },
                keyed: true,
                get children() {
                  return createComponent(Hero, {
                    id: "Hero",
                    autofocus: true,
                    onDestroy: animateOut,
                    onCreate: animateIn,
                    get item() {
                      return heroContent();
                    },
                    get title() {
                      return heroContent().title;
                    }
                  });
                }
              })];
            }
          });
        };
        var API_KEY_V4 = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIyZDE4YjEwMTA0YjdiZTlkNjFiMWYwYjVlMGEwNzM2OCIsInN1YiI6IjYwZTVjMTdlNGNhNjc2MDA3NTA4Njc3MSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.D_nqH9kd-bhhWzeVsTDPYhHnsUaNAuyAa6YATmKHqsA";
        var API_BASE = "https://api.themoviedb.org/3";
        var tmdbConfig;
        var baseImageUrl;
        var urlParams$1 = new URLSearchParams(window.location.search);
        var basePosterSize = urlParams$1.get("posterSize") || "w185";
        var defaultFetchParams = {
          headers: {
            "Content-Type": "application/json",
            Authorization: "Bearer " + API_KEY_V4
          }
        };
        function getImageUrl(path) {
          var posterSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : basePosterSize;
          return baseImageUrl + posterSize + path;
        }
        function get(path) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          if (tmdbConfig) {
            return _get(path, params);
          } else {
            return loadConfig().then(function () {
              return _get(path, params);
            });
          }
        }
        function _get(path) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          return fetch(API_BASE + path, _objectSpread(_objectSpread({}, defaultFetchParams), params)).then(function (r) {
            return r.json();
          });
        }
        function loadConfig() {
          return _get("/configuration").then(function (data) {
            var _data$images;
            tmdbConfig = data;
            baseImageUrl = (_data$images = data.images) === null || _data$images === void 0 ? void 0 : _data$images.secure_base_url;
            return data;
          });
        }
        var api = exports("X", {
          get: get,
          loadConfig: loadConfig
        });
        function truncateString(str, maxLength) {
          if (str.length > maxLength) {
            return str.substring(0, maxLength - 3) + "...";
          }
          return str;
        }
        function convertItemsToTiles() {
          var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
          return items.map(function (item, i) {
            return {
              src: getImageUrl(item.poster_path || item.profile_path),
              tileSrc: getImageUrl(item.backdrop_path || item.profile_path, "w300"),
              backdrop: getImageUrl(item.backdrop_path, "w1280"),
              href: "/entity/".concat(item.media_type || "people", "/").concat(item.id),
              shortTitle: truncateString(item.title || item.name, 30),
              title: item.title || item.name,
              overview: item.overview,
              absIndex: i,
              item: item,
              entityInfo: {
                type: item.media_type || "people",
                id: item.id
              },
              heroContent: {
                title: item.title || item.name,
                description: item.overview
              }
            };
          });
        }
        var handleResults = function handleResults(response) {
          return response.then(function (_ref50) {
            var results = _ref50.results;
            var filteredItems = results.filter(function (r) {
              return !r.adult;
            });
            return convertItemsToTiles(filteredItems);
          });
        };
        var fetchPopular = function fetchPopular(type) {
          return handleResults(api.get("/".concat(type, "/popular")));
        };
        var genreListCache;
        var fetchGenreMovies = function fetchGenreMovies(genres) {
          var genreList = genreListCache || (genreListCache = api.get("/genre/movie/list"));
          var targetGenre = Array.isArray(genres) ? genres : [genres];
          return genreList.then(function (_ref51) {
            var genres2 = _ref51.genres;
            var targetGenreIds = [];
            genres2.forEach(function (item) {
              if (targetGenre.includes(item.name)) targetGenreIds.push(item.id);
            });
            return handleResults(api.get("/discover/movie?with_genres=".concat(targetGenreIds.join())));
          });
        };
        function destroyData() {
          var heroRow = {
            title: "Best Adventure and Action movies",
            items: createResource(function () {
              return fetchGenreMovies(["adventure", "action"]);
            })[0],
            type: "Hero",
            height: 800
          };
          return {
            heroRow: heroRow
          };
        }
        function tmdbData() {
          var rows = [];
          var popularMovies = createResource(function () {
            return fetchPopular("movie");
          });
          rows.push({
            title: "Popular Movies",
            items: popularMovies[0],
            setItems: popularMovies[1].mutate,
            type: "Poster",
            height: 328
          });
          rows.push({
            title: "Best Western movies",
            items: createResource(function () {
              return fetchGenreMovies(["Western"]);
            })[0],
            type: "Hero",
            height: 720
          });
          rows.push({
            title: "Best Comedy movies",
            items: createResource(function () {
              return fetchGenreMovies(["Comedy"]);
            })[0],
            type: "PosterTitle",
            height: 400
          });
          rows.push({
            title: "Popular TV shows",
            items: createResource(function () {
              return fetchPopular("tv");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          var heroRow = {
            title: "Best Adventure and Action movies",
            items: createResource(function () {
              return fetchGenreMovies(["adventure", "action"]);
            })[0],
            type: "Hero",
            height: 720
          };
          rows.push(heroRow);
          rows.push({
            title: "Best Animations",
            items: createResource(function () {
              return fetchGenreMovies("Animation");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          rows.push({
            title: "Best TV Movie Movies",
            items: createResource(function () {
              return fetchGenreMovies("TV Movie");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          rows.push({
            title: "Best Science Fiction movies",
            items: createResource(function () {
              return fetchGenreMovies("Science Fiction");
            })[0],
            type: "Hero",
            height: 720
          });
          rows.push({
            title: "Best War Movies",
            items: createResource(function () {
              return fetchGenreMovies("War");
            })[0],
            type: "PosterTitle",
            height: 400
          });
          return {
            rows: rows
          };
        }
        var NotFound = function NotFound() {
          return function () {
            var _el$ = createElement("node");
            setProp(_el$, "style", {
              width: 1920,
              height: 1080,
              color: 868483072
            });
            return _el$;
          }();
        };
        var basePath$1 = "/solid-demo-app/";
        var fonts = [{
          type: "msdf",
          fontFamily: "Roboto",
          descriptors: {
            weight: 700
          },
          atlasDataUrl: basePath$1 + "fonts/Roboto-Bold.msdf.json",
          atlasUrl: basePath$1 + "fonts/Roboto-Bold.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Roboto",
          descriptors: {
            weight: 400
          },
          atlasDataUrl: basePath$1 + "fonts/Roboto-Regular.msdf.json",
          atlasUrl: basePath$1 + "fonts/Roboto-Regular.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Arial",
          descriptors: {
            weight: 500
          },
          atlasDataUrl: basePath$1 + "fonts/Roboto-Regular.msdf.json",
          atlasUrl: basePath$1 + "fonts/Roboto-Regular.msdf.png"
        }, {
          type: "msdf",
          fontFamily: "Raleway",
          descriptors: {
            weight: 800
          },
          atlasDataUrl: basePath$1 + "fonts/Raleway-ExtraBold.msdf.json",
          atlasUrl: basePath$1 + "fonts/Raleway-ExtraBold.msdf.png"
        }, {
          fontFamily: "Roboto",
          fontUrl: basePath$1 + "fonts/Roboto-Regular.ttf"
        }];
        var cache = /* @__PURE__ */new Map();
        function browseProvider(filter) {
          return function (pageIndex) {
            var url = "/trending/".concat(filter, "/week?page=").concat(pageIndex);
            if (cache.has(url)) {
              return cache.get(url);
            }
            var result = api.get(url).then(function (trending) {
              var results = trending.results.filter(function (r) {
                return !r.adult;
              });
              var tiles = convertItemsToTiles(results);
              return tiles;
            });
            cache.set(url, result);
            return result;
          };
        }
        function browsePreload(props) {
          var lastFilter = null;
          return createMemo(function (p) {
            var params = props.params;
            if (p && (!params.filter || lastFilter === params.filter)) {
              return p;
            }
            var provider = browseProvider(params.filter || "all");
            provider(1);
            lastFilter = params.filter || lastFilter;
            return provider;
          });
        }
        function minutesToHMM(minutes) {
          var hours = Math.floor(minutes / 60);
          var remainingMinutes = minutes % 60;
          return hours + "h " + (remainingMinutes < 10 ? "0" : "") + remainingMinutes + "min";
        }
        function formatDate(dateString) {
          var parts = dateString.split("-");
          return parts[1] + "/" + parts[2] + "/" + parts[0];
        }
        function justYear(dateString) {
          var parts = (dateString === null || dateString === void 0 ? void 0 : dateString.split("-")) || [];
          return parts[0] || "";
        }
        function ensureItems(items, minCount) {
          var remainingCount = minCount - items.length;
          if (remainingCount > 0) {
            return items.concat(Array(remainingCount).fill({}));
          }
          return items;
        }
        function getRecommendations(_ref52) {
          var type = _ref52.type,
            id = _ref52.id;
          return api.get("/".concat(type, "/").concat(id, "/recommendations")).then(function (_ref53) {
            var results = _ref53.results;
            if (results.length) {
              return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
            }
            return api.get("/trending/".concat(type, "/week?page=1")).then(function (_ref54) {
              var results = _ref54.results;
              return ensureItems(convertItemsToTiles(results.slice(0, 7)), 7);
            });
          });
        }
        function getCredits(_ref55) {
          var type = _ref55.type,
            id = _ref55.id;
          return api.get("/".concat(type, "/").concat(id, "/credits")).then(function (_ref56) {
            var cast = _ref56.cast;
            return ensureItems(convertItemsToTiles(cast.slice(0, 7)), 7);
          });
        }
        function getInfo(_ref57) {
          var type = _ref57.type,
            id = _ref57.id;
          var rt = type === "movie" ? {
            rtCrit: 86,
            rtFan: 92
          } : {};
          return api.get("/".concat(type, "/").concat(id)).then(function (data) {
            return _objectSpread({
              backgroundImage: getImageUrl(data.backdrop_path, "w1280"),
              heroContent: {
                title: data.title || data.name,
                description: data.overview,
                badges: ["HD", "CC"],
                voteAverage: data.vote_average,
                voteCount: data.vote_count,
                metaText: type === "movie" ? minutesToHMM(data.runtime) + "   " + formatDate(data.release_date) : "".concat(justYear(data.first_air_date), " - ").concat(justYear(data.last_air_date)),
                reviews: rt
              }
            }, data);
          });
        }
        function entityPreload(_ref58) {
          var params = _ref58.params,
            intent = _ref58.intent;
          var _createResource5 = createResource(function () {
              return _objectSpread({}, params);
            }, getInfo),
            _createResource6 = _slicedToArray(_createResource5, 1),
            entity = _createResource6[0];
          if (intent === "preload") {
            return;
          }
          var _createResource7 = createResource(function () {
              return _objectSpread({}, params);
            }, getCredits),
            _createResource8 = _slicedToArray(_createResource7, 1),
            credits = _createResource8[0];
          var _createResource9 = createResource(function () {
              return _objectSpread({}, params);
            }, getRecommendations),
            _createResource0 = _slicedToArray(_createResource9, 1),
            recommendations = _createResource0[0];
          return {
            entity: entity,
            credits: credits,
            recommendations: recommendations
          };
        }
        function Background() {
          var params = new URLSearchParams(window.location.search);
          var disableBG = params.get("disableBG") === "true";
          var bg1, bg2, heroMask;
          var active = 0;
          var alpha = 1;
          var animationSettings = {
            duration: 550,
            easing: "ease-in-out"
          };
          var bgStyles = {
            alpha: alpha,
            color: 4294967295
          };
          onMount(function () {
            if (disableBG) {
              heroMask.src = "";
              heroMask.colorLeft = 0x000000FF;
              heroMask.colorRight = 0x00000000;
              return;
            }
          });
          function changeBackgrounds(img) {
            if (disableBG) {
              heroMask.src = "";
              heroMask.colorLeft = 0x000000FF;
              heroMask.colorRight = 0x00000000;
              return;
            }
            if (typeof img !== "string") {
              bg1.color = img;
              bg1.src = "";
              bg1.alpha = 1;
              active = 1;
              bg2.alpha = 0;
              heroMask.alpha = 0;
              return;
            } else {
              bg1.color = 4294967295;
              heroMask.alpha = 1;
            }
            var currentBg = active === 1 ? bg2 : bg1;
            var nextBg = active === 1 ? bg1 : bg2;
            currentBg.src = img;
            if (active === 0) {
              currentBg.alpha = 1;
            } else {
              currentBg.alpha = 0.01;
              currentBg.animate({
                alpha: 1
              }, animationSettings).start();
            }
            nextBg.animate({
              alpha: 0.01
            }, animationSettings).start();
            active = active === 1 ? 2 : 1;
          }
          createEffect(on(globalBackground, function (img) {
            changeBackgrounds(img);
          }, {
            defer: true
          }));
          return createComponent(View, {
            width: 1920,
            height: 1080,
            zIndex: -5,
            get children() {
              return [createComponent(View, {
                ref: function ref(r$) {
                  var _ref$ = bg1;
                  typeof _ref$ === "function" ? _ref$(r$) : bg1 = r$;
                },
                style: bgStyles
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$2 = bg2;
                  typeof _ref$2 === "function" ? _ref$2(r$) : bg2 = r$;
                },
                style: bgStyles,
                alpha: 0
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$3 = heroMask;
                  typeof _ref$3 === "function" ? _ref$3(r$) : heroMask = r$;
                },
                src: "./assets/hero-mask-inverted.png",
                get color() {
                  return hexColor(theme.color.materialBrand);
                },
                width: 1920,
                height: 1080
              })];
            }
          });
        }
        var styles = {
          Column: {
            flexDirection: "column",
            display: "flex",
            width: 140,
            height: 600,
            y: 360,
            gap: 20,
            zIndex: 101,
            transition: {
              x: {
                duration: 250,
                easing: "ease-in-out"
              }
            },
            x: 24,
            $focus: {
              width: 500
              // x: theme.layout.marginX
            }
          },
          Gradient: {
            zIndex: 99,
            color: 0x000000FF,
            src: "./assets/sidenav.png",
            alpha: 0,
            width: 200,
            height: 1080,
            $focus: {
              alpha: 1,
              width: 1600
            },
            transition: {
              alpha: true,
              width: true
            }
          },
          NavButton: {
            zIndex: 102,
            height: 70,
            width: 100,
            borderRadius: 8,
            color: 0,
            $focus: {
              color: theme.primaryLight
            },
            $active: {
              width: 328,
              height: 70
            }
          }
        };
        var basePath = "/solid-demo-app/";
        var icons = [{
          name: "experiment",
          width: 81,
          height: 100,
          x: 0,
          y: 0
        }, {
          name: "trending",
          width: 99,
          height: 56,
          x: 81,
          y: 0
        }, {
          name: "tv",
          width: 100,
          height: 68,
          x: 181,
          y: 0
        }, {
          name: "movie",
          width: 94,
          height: 100,
          x: 282,
          y: 0
        }];
        var sprite;
        function Icon(props) {
          sprite = sprite || createSpriteMap(basePath + "assets/icons_white.png", icons);
          return createComponent(View, mergeProps(props, {
            get texture() {
              return sprite[props.name];
            },
            get width() {
              return sprite[props.name].props.width;
            },
            get height() {
              return sprite[props.name].props.height;
            },
            get x() {
              return (100 - (sprite[props.name].props.width || 0)) / 2;
            },
            get y() {
              return (100 - (sprite[props.name].props.height || 0)) / 2;
            }
          }));
        }
        var NavButtonTextStyles = {
          fontSize: 38,
          x: 116,
          y: 18,
          height: 50,
          alpha: 0,
          color: theme.textSecondary,
          $focus: {
            color: 0xFFFFFFFF
          },
          $active: {
            alpha: 1
          }
        };
        function NavButton(props) {
          return createComponent(View, mergeProps(props, {
            forwardStates: true,
            get style() {
              return styles.NavButton;
            },
            get children() {
              return [createComponent(View, {
                y: -16,
                get children() {
                  return createComponent(Icon, {
                    get color() {
                      return props.iconColor;
                    },
                    scale: 0.5,
                    get name() {
                      return props.icon;
                    }
                  });
                }
              }), createComponent(Text, {
                style: NavButtonTextStyles,
                get children() {
                  return props.children;
                }
              })];
            }
          }));
        }
        function NavDrawer(props) {
          var backdrop;
          var navigate = useNavigate();
          function onFocus() {
            backdrop.states.add("$focus");
            this.children.forEach(function (c) {
              return c.states.add("$active");
            });
            this.children[this.selected || 0].setFocus();
          }
          function onBlur() {
            backdrop.states.remove("$focus");
            this.selected = 0;
            this.children.forEach(function (c) {
              return c.states.remove("$active");
            });
          }
          function handleNavigate(page) {
            var isOnPage = useMatch(function () {
              return page;
            });
            if (isOnPage()) {
              return props.focusPage();
            }
            navigate(page);
          }
          return [createComponent(View, {
            flexItem: false,
            width: 300,
            height: 150,
            x: 30,
            y: 15,
            zIndex: 105,
            get alpha() {
              return props.showWidgets ? 1 : 0.01;
            },
            get children() {
              return [createComponent(Text, {
                y: 8,
                x: 80,
                fontSize: 28,
                get color() {
                  return theme.textSecondary;
                },
                children: "Built With:"
              }), createComponent(View, {
                y: 10,
                src: "./assets/solidWord.png",
                width: 280,
                height: 52
              }), createComponent(View, {
                x: 0,
                y: 100,
                src: "./assets/tmdb.png",
                width: 80,
                height: 41
              }), createComponent(Text, {
                x: 90,
                y: 104,
                contain: "width",
                width: 160,
                fontSize: 12,
                get color() {
                  return theme.textSecondary;
                },
                children: "This product uses the TMDB API but is not endorsed or certified by TMDB."
              })];
            }
          }), createComponent(Column, mergeProps(props, {
            onFocus: onFocus,
            onBlur: onBlur,
            get style() {
              return styles.Column;
            },
            announce: "Main Menu",
            scroll: "none",
            get children() {
              return [createComponent(NavButton, {
                onEnter: function onEnter() {
                  return handleNavigate("/browse/all");
                },
                get iconColor() {
                  return memo(function () {
                    return !!useMatch(function () {
                      return "/browse/all";
                    })();
                  })() ? 0xFFFFFFFF : theme.textSecondary;
                },
                announce: ["Trending Browse", "button"],
                icon: "trending",
                children: "Trending"
              }), createComponent(NavButton, {
                icon: "movie",
                get iconColor() {
                  return memo(function () {
                    return !!useMatch(function () {
                      return "/browse/movie";
                    })();
                  })() ? 0xFFFFFFFF : theme.textSecondary;
                },
                announce: ["Movies Browse", "button"],
                onEnter: function onEnter() {
                  return handleNavigate("/browse/movie");
                },
                children: "Movies"
              }), createComponent(NavButton, {
                icon: "tv",
                get iconColor() {
                  return memo(function () {
                    return !!useMatch(function () {
                      return "/browse/tv";
                    })();
                  })() ? 0xFFFFFFFF : theme.textSecondary;
                },
                announce: ["TV Browse", "button"],
                onEnter: function onEnter() {
                  return handleNavigate("/browse/tv");
                },
                children: "TV"
              }), createComponent(NavButton, {
                icon: "experiment",
                get iconColor() {
                  return memo(function () {
                    return !!useMatch(function () {
                      return "/examples";
                    })();
                  })() ? 0xFFFFFFFF : theme.textSecondary;
                },
                announce: ["Examples", "button"],
                onEnter: function onEnter() {
                  return handleNavigate("/examples");
                },
                children: "Examples"
              })];
            }
          })), createComponent(View, {
            skipFocus: true,
            ref: function ref(r$) {
              var _ref$ = backdrop;
              typeof _ref$ === "function" ? _ref$(r$) : backdrop = r$;
            },
            get style() {
              return styles.Gradient;
            }
          })];
        }
        var LeftNavWrapper = function LeftNavWrapper(props) {
          var navigate = useNavigate();
          var announcer = useAnnouncer();
          announcer.debug = true;
          announcer.enabled = false;
          var navDrawer, lastFocused;
          setupFPS({
            renderer: renderer$1
          });
          function focusNavDrawer() {
            if (navDrawer.states.has("focus")) {
              return false;
            }
            lastFocused = activeElement();
            return navDrawer.setFocus();
          }
          var _createSignal91 = createSignal(true),
            _createSignal92 = _slicedToArray(_createSignal91, 2),
            showWidgets = _createSignal92[0],
            setShowWidgets = _createSignal92[1];
          var location = useLocation();
          var showOnPaths = ["/browse", "/entity"];
          createEffect(function () {
            var currentPath = location.pathname;
            var matchesPartial = showOnPaths.some(function (path) {
              return currentPath.startsWith(path);
            });
            if (currentPath === "/") {
              matchesPartial = true;
            }
            setShowWidgets(matchesPartial);
          });
          var _createSignal93 = createSignal(),
            _createSignal94 = _slicedToArray(_createSignal93, 2),
            lastKey = _createSignal94[0],
            setLastKey = _createSignal94[1];
          var _createSignal95 = createSignal(),
            _createSignal96 = _slicedToArray(_createSignal95, 2),
            lastError = _createSignal96[0],
            setLastError = _createSignal96[1];
          var keyPressHandler = function keyPressHandler(e) {
            setLastKey("Last key: ".concat(e.key, ", Code: ").concat(e.keyCode));
          };
          document.addEventListener("keydown", keyPressHandler);
          var displayError = function displayError(e) {
            setLastError(function (p) {
              return (p || "") + "\n" + e.message;
            });
          };
          document.addEventListener("onerror", displayError);
          onCleanup(function () {
            document.removeEventListener("onerror", displayError);
            document.removeEventListener("keydown", keyPressHandler);
          });
          var pageContainer;
          return createComponent(View, {
            ref: function ref(r$) {
              var _ref$ = window.APP;
              typeof _ref$ === "function" ? _ref$(r$) : window.APP = r$;
            },
            onAnnouncer: function onAnnouncer() {
              return announcer.enabled = !announcer.enabled;
            },
            onLast: function onLast() {
              return history.back();
            },
            onMenu: function onMenu() {
              return navigate("/");
            },
            onBack: function onBack() {
              return navigate(-1);
            },
            style: {
              width: 1920,
              height: 1080
            },
            onBackspace: focusNavDrawer,
            onLeft: focusNavDrawer,
            onRight: function onRight() {
              return navDrawer.states.has("focus") && (lastFocused || pageContainer).setFocus();
            },
            get children() {
              return [createComponent(Background, {}), createComponent(FPSCounter, {
                mountX: 1,
                x: 1910,
                y: 10,
                get alpha() {
                  return showWidgets() ? 1 : 0.01;
                }
              }), createComponent(View, {
                mountX: 1,
                width: 330,
                height: 28,
                x: 1910,
                y: 190,
                color: 255,
                get hidden() {
                  return !showWidgets();
                },
                get children() {
                  return createComponent(Text, {
                    fontSize: 20,
                    y: 4,
                    x: 4,
                    get children() {
                      return lastKey();
                    }
                  });
                }
              }), createComponent(Text, {
                x: 270,
                y: 20,
                fontSize: 24,
                contain: "width",
                width: 800,
                get children() {
                  return lastError();
                }
              }), createComponent(View, {
                ref: function ref(r$) {
                  var _ref$2 = pageContainer;
                  typeof _ref$2 === "function" ? _ref$2(r$) : pageContainer = r$;
                },
                forwardFocus: 0,
                get children() {
                  return props.children;
                }
              }), createComponent(NavDrawer, {
                ref: function ref(r$) {
                  var _ref$3 = navDrawer;
                  typeof _ref$3 === "function" ? _ref$3(r$) : navDrawer = r$;
                },
                focusPage: function focusPage() {
                  return lastFocused.setFocus();
                },
                get showWidgets() {
                  return showWidgets();
                }
              })];
            }
          });
        };
        var Player = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Player-legacy-DKC74gzI.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var Grid = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Grid-legacy-DSYXMK1z.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var Loops = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Loops-legacy-BwmPfG6z.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var Infinite = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Infinite-legacy-CGHDVbiC.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var TMDBGrid = lazy(function () {
          return __vitePreload(function () {
            return module.import('./TMDBGrid-legacy-DruG0cPq.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var Portal = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Portal-legacy-iL1LA6Ee.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var TextPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Text-legacy-Bys3CkOY.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var TextPosterPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./TextPoster-legacy-UyjYMde0.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var CreatePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Create-legacy-Bi3hMdLv.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var ViewportPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Viewport-legacy-DeWOdpFO.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var PositioningPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Positioning-legacy-Ck-1fVGk.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var LayoutPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Layout-legacy-D0uSHPWx.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FocusBasicsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FocusBasics-legacy-COLuqGq_.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var KeyHandlingPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./KeyHandling-legacy-86HtogWC.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var TransitionsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Transitions-legacy-C6FRbaIb.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var ComponentsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Components-legacy-DC1hMIHA.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FocusHandlingPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FocusHandling-legacy-D2gnWLQd.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var GradientsPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Gradients-legacy-DZBPemWB.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Flex-legacy-D_D4cstz.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexGrowPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexGrow-legacy-IZBXLlpR.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexMenuPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexMenu-legacy-C50JMW13.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexSizePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexSize-legacy-Cp0Vomqw.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexColumnSizePage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexColumnSize-legacy-DkYVQUva.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FlexColumnPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./FlexColumn-legacy-CZ4w-J41.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var ButtonsMaterialPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./ButtonsMaterial-legacy-Bo87po5O.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var SuperFlexPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./SuperFlex-legacy-BKN0YVNC.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var Entity = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Entity-legacy-DCXbYdV6.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var People = lazy(function () {
          return __vitePreload(function () {
            return module.import('./People-legacy-Dcf3MbfP.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var FireboltPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Firebolt-legacy-P6BGB_EU.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var LoginPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Login-legacy-DGG0lzSK.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var VirtualPage = lazy(function () {
          return __vitePreload(function () {
            return module.import('./Virtual-legacy-DiuLGz6-.js');
          }, false              ? __VITE_PRELOAD__ : void 0);
        });
        var numImageWorkers = 4;
        var urlParams = new URLSearchParams(window.location.search);
        var numWorkers = urlParams.get("numImageWorkers");
        var screenSize = urlParams.get("size") || "default";
        var rendererMode = urlParams.get("mode") || "webgl";
        var animationsEnabled = urlParams.get("animate") || "true";
        if (numWorkers) {
          numImageWorkers = parseInt(numWorkers);
        }
        var deviceLogicalPixelRatio = {
          "720": 0.666667,
          "medium": 0.8,
          "1080": 1,
          "4k": 2,
          default: window.innerHeight / 1080
        }[screenSize];
        Config.debug = false;
        Config.animationsEnabled = animationsEnabled === "true";
        Config.simpleAnimationsEnabled = true;
        Config.fontSettings.fontFamily = "Roboto";
        Config.fontSettings.color = theme.textPrimary;
        Config.fontSettings.fontSize = 32;
        Config.rendererOptions = {
          fpsUpdateInterval: 1e3,
          inspector: void 0,
          // textureMemory: {
          //   criticalThreshold: 80e6,
          // },
          numImageWorkers: numImageWorkers,
          // temp fix for renderer bug
          // Set the resolution based on window height
          // 720p = 0.666667, 1080p = 1, 1440p = 1.5, 2160p = 2
          deviceLogicalPixelRatio: deviceLogicalPixelRatio,
          devicePhysicalPixelRatio: 1,
          createImageBitmapSupport: "auto",
          targetFPS: 30
        };
        if (rendererMode === "canvas") {
          Config.rendererOptions.fontEngines = [CanvasTextRenderer];
          Config.rendererOptions.renderEngine = CanvasCoreRenderer;
        } else {
          Config.rendererOptions.fontEngines = [SdfTextRenderer];
          Config.rendererOptions.renderEngine = WebGlCoreRenderer;
        }
        var _createRenderer = createRenderer(),
          render = _createRenderer.render;
        loadFonts(fonts);
        render(function () {
          return createComponent(FocusStackProvider, {
            get children() {
              return createComponent(HashRouter, {
                root: function root(props) {
                  return createComponent(App, props);
                },
                get children() {
                  return [createComponent(Route, {
                    path: "",
                    component: LeftNavWrapper,
                    get children() {
                      return [createComponent(Route, {
                        path: "",
                        component: function component() {
                          return createComponent(Navigate, {
                            href: "/browse/all"
                          });
                        }
                      }), createComponent(Route, {
                        path: "examples",
                        component: Portal,
                        get children() {
                          return [createComponent(Route, {
                            path: "/"
                          }), createComponent(Route, {
                            path: "tmdb",
                            component: TMDB,
                            preload: tmdbData
                          })];
                        }
                      }), createComponent(KeepAliveRoute, {
                        id: "browse",
                        path: "browse/:filter",
                        component: Browse,
                        preload: browsePreload
                      }), createComponent(Route, {
                        path: "loops",
                        component: Loops,
                        preload: tmdbData
                      }), createComponent(Route, {
                        path: "infinite",
                        component: Infinite,
                        preload: tmdbData
                      }), createComponent(Route, {
                        path: "tmdbgrid",
                        component: TMDBGrid,
                        preload: tmdbData
                      }), createComponent(Route, {
                        path: "virtual",
                        component: VirtualPage,
                        preload: tmdbData
                      }), createComponent(Route, {
                        path: "destroy",
                        component: Destroy,
                        preload: destroyData
                      }), createComponent(Route, {
                        path: "grid",
                        component: Grid
                      }), createComponent(Route, {
                        path: "text",
                        component: TextPage
                      }), createComponent(Route, {
                        path: "firebolt",
                        component: FireboltPage
                      }), createComponent(Route, {
                        path: "login",
                        component: LoginPage
                      }), createComponent(Route, {
                        path: "nested",
                        get component() {
                          return lazy(function () {
                            return __vitePreload(function () {
                              return module.import('./Nested-legacy-DzA9Gi7M.js');
                            }, false              ? __VITE_PRELOAD__ : void 0);
                          });
                        }
                      }), createComponent(Route, {
                        path: "textposter",
                        component: TextPosterPage
                      }), createComponent(Route, {
                        path: "positioning",
                        component: PositioningPage
                      }), createComponent(Route, {
                        path: "layout",
                        component: LayoutPage
                      }), createComponent(Route, {
                        path: "focusbasics",
                        component: FocusBasicsPage
                      }), createComponent(Route, {
                        path: "transitions",
                        component: TransitionsPage
                      }), createComponent(Route, {
                        path: "components",
                        component: ComponentsPage
                      }), createComponent(Route, {
                        path: "focushandling",
                        component: FocusHandlingPage
                      }), createComponent(Route, {
                        path: "keyhandling",
                        component: KeyHandlingPage
                      }), createComponent(Route, {
                        path: "gradients",
                        component: GradientsPage
                      }), createComponent(Route, {
                        path: "flex",
                        component: FlexPage
                      }), createComponent(Route, {
                        path: "create",
                        component: CreatePage
                      }), createComponent(Route, {
                        path: "viewport",
                        component: ViewportPage
                      }), createComponent(Route, {
                        path: "flexsize",
                        component: FlexSizePage
                      }), createComponent(Route, {
                        path: "flexmenu",
                        component: FlexMenuPage
                      }), createComponent(Route, {
                        path: "flexcolumnsize",
                        component: FlexColumnSizePage
                      }), createComponent(Route, {
                        path: "flexcolumn",
                        component: FlexColumnPage
                      }), createComponent(Route, {
                        path: "flexgrow",
                        component: FlexGrowPage
                      }), createComponent(Route, {
                        path: "keepalive",
                        get component() {
                          return lazy(function () {
                            return __vitePreload(function () {
                              return module.import('./KeepAlive-legacy-D_x_woEj.js');
                            }, false              ? __VITE_PRELOAD__ : void 0);
                          });
                        }
                      }), createComponent(Route, {
                        path: "suspense",
                        get component() {
                          return lazy(function () {
                            return __vitePreload(function () {
                              return module.import('./suspense-legacy-CPIxHMI6.js');
                            }, false              ? __VITE_PRELOAD__ : void 0);
                          });
                        }
                      }), createComponent(Route, {
                        path: "superflex",
                        component: SuperFlexPage
                      }), createComponent(Route, {
                        path: "buttonsmaterial",
                        component: ButtonsMaterialPage
                      }), createComponent(Route, {
                        path: "entity/people/:id",
                        component: People
                      }), createComponent(Route, {
                        path: "entity/:type/:id",
                        component: Entity,
                        preload: entityPreload
                      }), createComponent(Route, {
                        path: "*all",
                        component: NotFound
                      })];
                    }
                  }), createComponent(Route, {
                    path: "player",
                    get children() {
                      return createComponent(Route, {
                        path: ":id",
                        component: Player
                      });
                    }
                  })];
                }
              });
            }
          });
        });
      }
    };
  });
})();
